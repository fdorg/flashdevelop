// $ANTLR 3.1.1 AS3_ex.g3 2011-12-19 16:18:10

  using System.Collections.Generic;
  using System.Text.RegularExpressions;
  
  using CodeFormatter.Handlers;


using System;
using Antlr.Runtime;
using IList 		= System.Collections.IList;
using ArrayList 	= System.Collections.ArrayList;
using Stack 		= Antlr.Runtime.Collections.StackList;

using IDictionary	= System.Collections.IDictionary;
using Hashtable 	= System.Collections.Hashtable;


using Antlr.Runtime.Tree;

public class AS3_exParser : Parser 
{
    public static readonly string[] tokenNames = new string[] 
	{
        "<invalid>", 
		"<EOR>", 
		"<DOWN>", 
		"<UP>", 
		"AS", 
		"BREAK", 
		"CASE", 
		"CATCH", 
		"CLASS", 
		"CONST", 
		"CONTINUE", 
		"DEFAULT", 
		"DELETE", 
		"DO", 
		"ELSE", 
		"EXTENDS", 
		"FALSE", 
		"FINALLY", 
		"FOR", 
		"FUNCTION", 
		"IF", 
		"IMPLEMENTS", 
		"IMPORT", 
		"IN", 
		"INSTANCEOF", 
		"INTERFACE", 
		"INTERNAL", 
		"IS", 
		"NATIVE", 
		"NEW", 
		"NULL", 
		"PACKAGE", 
		"PRIVATE", 
		"PROTECTED", 
		"PUBLIC", 
		"RETURN", 
		"SUPER", 
		"SWITCH", 
		"THIS", 
		"THROW", 
		"TO", 
		"TRUE", 
		"TRY", 
		"TYPEOF", 
		"USE", 
		"VAR", 
		"VOID", 
		"WHILE", 
		"WITH", 
		"EACH", 
		"GET", 
		"SET", 
		"NAMESPACE", 
		"INCLUDE", 
		"DYNAMIC", 
		"FINAL", 
		"OVERRIDE", 
		"STATIC", 
		"SEMI", 
		"LCURLY", 
		"RCURLY", 
		"LPAREN", 
		"RPAREN", 
		"LBRACK", 
		"RBRACK", 
		"DOT", 
		"COMMA", 
		"LT", 
		"GT", 
		"LTE", 
		"GTE", 
		"EQ", 
		"NEQ", 
		"SAME", 
		"NSAME", 
		"PLUS", 
		"SUB", 
		"STAR", 
		"DIV", 
		"MOD", 
		"INC", 
		"DEC", 
		"SHL", 
		"SHR", 
		"SHU", 
		"AND", 
		"OR", 
		"XOR", 
		"NOT", 
		"INV", 
		"LAND", 
		"LOR", 
		"QUE", 
		"COLON", 
		"ASSIGN", 
		"UNDERSCORE", 
		"DOLLAR", 
		"DIV_ASSIGN", 
		"MOD_ASSIGN", 
		"ADD_ASSIGN", 
		"SUB_ASSIGN", 
		"SHL_ASSIGN", 
		"SHR_ASSIGN", 
		"SHU_ASSIGN", 
		"LAND_ASSIGN", 
		"LOR_ASSIGN", 
		"AND_ASSIGN", 
		"XOR_ASSIGN", 
		"OR_ASSIGN", 
		"ELLIPSIS", 
		"XML_ELLIPSIS", 
		"XML_TEND", 
		"XML_E_TEND", 
		"XML_NS_OP", 
		"XML_AT", 
		"XML_LS_STD", 
		"XML_LS_END", 
		"ALPHABET", 
		"NUMBER", 
		"HEX_DIGIT", 
		"CR", 
		"LF", 
		"UNICODE_ESCAPE", 
		"ESCAPE_SEQUENCE", 
		"EOL", 
		"WHITESPACE", 
		"COMMENT_MULTILINE", 
		"COMMENT_SINGLELINE", 
		"SINGLE_QUOTE_LITERAL", 
		"DOUBLE_QUOTE_LITERAL", 
		"REGULAR_EXPR_BODY", 
		"REGULAR_EXPR_FLAG", 
		"REGULAR_EXPR_LITERAL", 
		"REGULAR_EXPR_FIRST_CHAR", 
		"REGULAR_EXPR_CHAR", 
		"BACKSLASH_SEQUENCE", 
		"IDENT_PART", 
		"HEX_NUMBER_LITERAL", 
		"DEC_NUMBER", 
		"EXPONENT", 
		"DEC_NUMBER_LITERAL", 
		"IDENT_NAME_ASCII_START", 
		"IDENTIFIER", 
		"IDENT_ASCII_START", 
		"XML_COMMENT", 
		"XML_CDATA", 
		"XML_PI", 
		"XML_TEXT"
    };

    public const int PACKAGE = 31;
    public const int FUNCTION = 19;
    public const int SHR = 83;
    public const int LOR = 91;
    public const int INTERNAL = 26;
    public const int EXPONENT = 139;
    public const int LT = 67;
    public const int STAR = 77;
    public const int BACKSLASH_SEQUENCE = 135;
    public const int WHILE = 47;
    public const int MOD = 79;
    public const int SHL = 82;
    public const int CONST = 9;
    public const int MOD_ASSIGN = 98;
    public const int CASE = 6;
    public const int NEW = 29;
    public const int DO = 13;
    public const int IDENT_ASCII_START = 143;
    public const int NOT = 88;
    public const int HEX_NUMBER_LITERAL = 137;
    public const int EOF = -1;
    public const int DIV_ASSIGN = 97;
    public const int BREAK = 5;
    public const int FINAL = 55;
    public const int RPAREN = 62;
    public const int INC = 80;
    public const int IMPORT = 22;
    public const int EOL = 124;
    public const int XML_AT = 114;
    public const int INCLUDE = 53;
    public const int THIS = 38;
    public const int RETURN = 35;
    public const int XML_PI = 146;
    public const int XML_CDATA = 145;
    public const int REGULAR_EXPR_FIRST_CHAR = 133;
    public const int IDENT_NAME_ASCII_START = 141;
    public const int GET = 50;
    public const int VAR = 45;
    public const int VOID = 46;
    public const int SUPER = 36;
    public const int EACH = 49;
    public const int EQ = 71;
    public const int SHU = 84;
    public const int RBRACK = 64;
    public const int ADD_ASSIGN = 99;
    public const int PRIVATE = 32;
    public const int STATIC = 57;
    public const int INV = 89;
    public const int SWITCH = 37;
    public const int NULL = 30;
    public const int LAND_ASSIGN = 104;
    public const int ELSE = 14;
    public const int NUMBER = 118;
    public const int DOUBLE_QUOTE_LITERAL = 129;
    public const int ELLIPSIS = 109;
    public const int NATIVE = 28;
    public const int WHITESPACE = 125;
    public const int UNDERSCORE = 95;
    public const int LCURLY = 59;
    public const int DELETE = 12;
    public const int TRY = 42;
    public const int NAMESPACE = 52;
    public const int REGULAR_EXPR_CHAR = 134;
    public const int TYPEOF = 43;
    public const int XML_LS_END = 116;
    public const int QUE = 92;
    public const int OR = 86;
    public const int IDENT_PART = 136;
    public const int GT = 68;
    public const int USE = 44;
    public const int DEC_NUMBER = 138;
    public const int CATCH = 7;
    public const int FALSE = 16;
    public const int LAND = 90;
    public const int XML_E_TEND = 112;
    public const int THROW = 39;
    public const int DYNAMIC = 54;
    public const int COMMENT_SINGLELINE = 127;
    public const int DOLLAR = 96;
    public const int PROTECTED = 33;
    public const int DEC = 81;
    public const int CLASS = 8;
    public const int LBRACK = 63;
    public const int REGULAR_EXPR_BODY = 130;
    public const int GTE = 70;
    public const int FOR = 18;
    public const int SHU_ASSIGN = 103;
    public const int SUB = 76;
    public const int AND = 85;
    public const int AND_ASSIGN = 106;
    public const int LTE = 69;
    public const int XML_LS_STD = 115;
    public const int LPAREN = 61;
    public const int SHR_ASSIGN = 102;
    public const int IF = 20;
    public const int ESCAPE_SEQUENCE = 123;
    public const int AS = 4;
    public const int XML_COMMENT = 144;
    public const int UNICODE_ESCAPE = 122;
    public const int SHL_ASSIGN = 101;
    public const int DEC_NUMBER_LITERAL = 140;
    public const int IN = 23;
    public const int IMPLEMENTS = 21;
    public const int CONTINUE = 10;
    public const int COMMA = 66;
    public const int IS = 27;
    public const int IDENTIFIER = 142;
    public const int XML_ELLIPSIS = 110;
    public const int XOR_ASSIGN = 107;
    public const int PLUS = 75;
    public const int DOT = 65;
    public const int WITH = 48;
    public const int XOR = 87;
    public const int TO = 40;
    public const int ALPHABET = 117;
    public const int DEFAULT = 11;
    public const int NSAME = 74;
    public const int REGULAR_EXPR_FLAG = 131;
    public const int HEX_DIGIT = 119;
    public const int SET = 51;
    public const int INSTANCEOF = 24;
    public const int XML_TEXT = 147;
    public const int TRUE = 41;
    public const int SEMI = 58;
    public const int SAME = 73;
    public const int COLON = 93;
    public const int OR_ASSIGN = 108;
    public const int NEQ = 72;
    public const int SINGLE_QUOTE_LITERAL = 128;
    public const int FINALLY = 17;
    public const int OVERRIDE = 56;
    public const int XML_NS_OP = 113;
    public const int RCURLY = 60;
    public const int ASSIGN = 94;
    public const int REGULAR_EXPR_LITERAL = 132;
    public const int INTERFACE = 25;
    public const int XML_TEND = 111;
    public const int DIV = 78;
    public const int CR = 120;
    public const int PUBLIC = 34;
    public const int EXTENDS = 15;
    public const int SUB_ASSIGN = 100;
    public const int COMMENT_MULTILINE = 126;
    public const int LOR_ASSIGN = 105;
    public const int LF = 121;

    // delegates
    // delegators



        public AS3_exParser(ITokenStream input)
    		: this(input, new RecognizerSharedState()) {
        }

        public AS3_exParser(ITokenStream input, RecognizerSharedState state)
    		: base(input, state) {
            InitializeCyclicDFAs();
            this.state.ruleMemo = new Hashtable[540+1];
             
             
       }
        
    protected ITreeAdaptor adaptor = new CommonTreeAdaptor();

    public ITreeAdaptor TreeAdaptor
    {
        get { return this.adaptor; }
        set {
    	this.adaptor = value;
    	}
    }

    override public string[] TokenNames {
		get { return AS3_exParser.tokenNames; }
    }

    override public string GrammarFileName {
		get { return "AS3_ex.g3"; }
    }



    	//options
    	private List<Exception> mParseErrors;

    	private ASPrettyPrinter mPrinter;
    	private CommonTokenStream mRawTokens;

    	private List<IfElseBlockTracker> mIfElseBlocks=new List<IfElseBlockTracker>();

    	public AS3_exParser(ASPrettyPrinter printer, CommonTokenStream tokenStream)
    	      : this(tokenStream, new RecognizerSharedState()) {
    		mRawTokens=tokenStream;
    		mPrinter=printer;
    	}

    	public class IfElseBlockTracker
    	{
    		public bool mBlockFlag=false;
    		public bool mBlockFlagSet=false;
    	}

    	public void AddIfElseBlockTracker()
    	{
    		mIfElseBlocks.Add(new IfElseBlockTracker());
    	}

    	public void PopIfElseBlockTracker()
    	{
    		if (mIfElseBlocks.Count>0)
    			mIfElseBlocks.RemoveAt(mIfElseBlocks.Count-1);
    	}

    	public IfElseBlockTracker GetCurrentIfElseTracker()
    	{
    		if (mIfElseBlocks.Count>0)
    			return mIfElseBlocks.ToArray()[mIfElseBlocks.Count-1];

    		return null;
    	}

    	public void SetBlockFlag(bool flag)
    	{
    		IfElseBlockTracker tracker=GetCurrentIfElseTracker();
    		if (tracker!=null)
    		{
    			//don't set if already set
    			if (tracker.mBlockFlagSet)
    				return;

    			tracker.mBlockFlag=flag;
    			tracker.mBlockFlagSet=true;
    		}
    	}

    	public void MarkBlockFlag()
    	{
    		IfElseBlockTracker tracker=GetCurrentIfElseTracker();
    		if (tracker!=null)
    			tracker.mBlockFlagSet=true;
    	}

    	public void ClearBlockFlag()
    	{
    		IfElseBlockTracker tracker=GetCurrentIfElseTracker();
    		if (tracker!=null)
    			tracker.mBlockFlagSet=false;
    	}

    	public bool IsBlockFlag()
    	{
    		IfElseBlockTracker tracker=GetCurrentIfElseTracker();
    		if (tracker!=null)
    			return tracker.mBlockFlag;

    		return false;
    	}

    	public bool FoundNextLT()
    	{
    		int i=1;
    		while (true)
    		{
    			CommonToken token= (CommonToken) input.LT(i);
    			if (token.Text!=null && token.Text.StartsWith("<"))
    				return (i>1);
    			if (token.Type==EOF)
    				return false;
    			i++;   
    		}
    	}

    	public void ChangeTokensUpToNextLT()
    	{
    		int i=1;
    		while (true)
    		{
    			CommonToken t= (CommonToken) input.LT(i);
    			if (t.Text!=null && t.Text.StartsWith("<"))
    				return;
    			if (t.Type==EOF)
    				return;
    			t.Type = XML_TEXT;          

    			i++;   
    		}
    	}

    	private void IndentEmit(CommonToken tokenOperator)
    	{
    		PushExpressionIndent();
    		WrapOptions options=mPrinter.GetExpressionWrapOptions();
    		if ((options.WrapType==WrapOptions.WRAP_BY_COLUMN || options.WrapType==WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS) && options.BeforeSeparator)
    		{
    			InsertMaxColumnCR();
    		}
    		char firstChar=Convert.ToChar(0);
    		if (tokenOperator.Text.Length>0)
    			firstChar=tokenOperator.Text.ToCharArray()[0];
    		if (firstChar!=Convert.ToChar(0))
    		{
    			if (IsIdentifierPart(firstChar))
    				InsertWS(1); //add 1 space around text operators (ex. 'as', 'instanceof')
    			else
    				InsertWS(mPrinter.GetExpressionSpacesAroundSymbolicOperators()); //add configurable symbolic operator value
    		}	
    		Emit(tokenOperator);
    		if ((options.WrapType==WrapOptions.WRAP_BY_COLUMN || options.WrapType==WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS) && !options.BeforeSeparator)
    		{
    			InsertMaxColumnCR();
    		}
    		if (firstChar!=0)
    		{
    			if (IsIdentifierPart(firstChar))
    				InsertWS(1); //add 1 space around text operators (ex. 'as', 'instanceof')
    			else
    				InsertWS(mPrinter.GetExpressionSpacesAroundSymbolicOperators()); //add configurable symbolic operator value
    		}	
    	}
    	
    	public static bool IsIdentifierPart(char ch)
        {
       		return Char.IsLetterOrDigit(ch) || ch == '_';
    	}

    	private bool PushFormatType(WrapOptions options, bool lazy)
    	{
    		if (mPrinter.IsDoFormat())
    		{
    			int formatMode=0;
    			if (options.WrapType==WrapOptions.WRAP_DONT_PROCESS)
    			{
    				formatMode=ASPrettyPrinter.FORMAT_INDENT;
    			}
    			else if (options.WrapType==WrapOptions.WRAP_FORMAT_NO_CRs)
    			{
    				formatMode=ASPrettyPrinter.FORMAT_NOCRs;
    			}
    			else if (options.WrapType==WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS)
    			{
    				formatMode=ASPrettyPrinter.FORMAT_OnlyAddCRs;
    			}
    			else
    			{
    				//if we didn't have a restrictive format, we want to make sure we're using the full format
    				formatMode=ASPrettyPrinter.FORMAT_ALL;
    			}

    			if (formatMode>0)
    			{		
    				mPrinter.SetFirstTokenBeforeFormatIndent();
    				if (lazy)
    					mPrinter.PushLazyFormat(formatMode);
    				else
    					mPrinter.PushFormatMode(formatMode);
    				return true;
    			}

    		} 

    		return false;
    	}

    	private void EmitCRForTag(WrapOptions options)
    	{
    		if (options.WrapType==WrapOptions.WRAP_BY_COLUMN || options.WrapType==WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS)
    		{
    			InsertMaxColumnCR();
    		}
    		else if (options.WrapType==WrapOptions.WRAP_BY_TAG)
    		{
    			InsertCR(false);
    		}

    	}

    	private bool EmitCommaWithSpacingAndCRs(WrapOptions options, CommonToken comma, bool pushedIndent)
    	{
    		if ((options.WrapType==WrapOptions.WRAP_BY_COLUMN || options.WrapType==WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS) && options.BeforeSeparator)
    		{
    			InsertMaxColumnCR();
    		}

    		if (!pushedIndent)
    		{
    			pushedIndent=true;
    			PushExpressionIndent();
    		}

    		InsertWS(mPrinter.GetSpacesBeforeComma());
    		Emit(comma); 
    		if ((options.WrapType==WrapOptions.WRAP_BY_COLUMN || options.WrapType==WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS) && !options.BeforeSeparator)
    		{
    			InsertMaxColumnCR();
    		}
    		InsertWS(mPrinter.GetSpacesAfterComma());
    		return pushedIndent;
    	}

    	public bool FindVirtualHiddenToken(ParserRuleReturnScope retval)
    	{
    		int index = ((CommonToken) retval.Start).TokenIndex;
    		if(index<0){
    			index = input.Count;
    		}
    		for (int ix = index - 1; ix >= 0; ix--){
    			CommonToken lt = (CommonToken) input.Get(ix);
    			int type = lt.Type;
    			if(lt.Channel == Token.DEFAULT_CHANNEL)
    				break;
    			if (type == EOL || type==COMMENT_SINGLELINE || (type == COMMENT_MULTILINE && Regex.Match(lt.Text,"/.*\r\n|\r|\n").Success))
    			{
    				retval.Start=lt;
    				return true;
    			}
    		}
    		return false;

    	}

    	/*public void ReportError(RecognitionException e)
    	{
    		if (mParseErrors==null)
    			mParseErrors=new List<Exception>();
    		mParseErrors.add(e);
    		base.ReportError(e);
    	}*/

    	private void InsertWS(int amt)
    	{
    		mPrinter.InsertWS(amt);
    	}

    	private void InsertLines(int amt)
    	{
    		InsertLines(amt, true);
    	}

    	private void InsertVariableDeclAssignmentWhitespace(CommonToken equalToken, bool before)
    	{
    		if (mPrinter.IsDoFormat() && !mPrinter.IsInParameterDecl() && mPrinter.IsKeepingExcessDeclWhitespace())
    		{
    			int spaceCount=0;
    			if (before)
    			{
    				CommonToken testToken= (CommonToken) mRawTokens.Get(equalToken.TokenIndex-1);
    				if (testToken.Channel==CHANNEL_WHITESPACE)
    				{
    					//if the token before the whitespace is a carriage return, we *don't* want to apply this "preserve whitespace" logic
    					CommonToken prevTok= (CommonToken) mRawTokens.Get(equalToken.TokenIndex-2);
    					if (!(prevTok.Channel==CHANNEL_SLCOMMENT || prevTok.Channel==CHANNEL_EOL))
    					{
    						if (testToken.Text.IndexOf('\t')>=0)
    						{
    							spaceCount=mPrinter.GetColumnForIndex(equalToken, 0)-mPrinter.GetColumnForIndex(testToken, 0);
    						}
    						else
    						{
    							spaceCount=testToken.Text.Length;
    						}
    					}
    				}
    			}
    			else
    			{
    				CommonToken testToken= (CommonToken) mRawTokens.Get(equalToken.TokenIndex+1);
    				if (testToken.Channel==CHANNEL_WHITESPACE)
    				{
    					//if the token after the whitespace is a carriage return, we *don't* want to apply this "preserve whitespace" logic
    					//I think we only care about actual EOL here, not sl comment or ml comment, since there is actual text before the CR,
    					//even if it's not 'code' text.
    					CommonToken nextTok= (CommonToken) mRawTokens.Get(equalToken.TokenIndex+2);
    					if (!(nextTok.Channel==CHANNEL_EOL))
    					{
    						if (testToken.Text.IndexOf('\t')>=0)
    						{
    							spaceCount=mPrinter.GetColumnForIndex(testToken, testToken.Text.Length)-mPrinter.GetColumnForIndex(equalToken, equalToken.Text.Length);
    						}
    						else
    						{
    							spaceCount=testToken.Text.Length;
    						}
    					}
    				}
    			}

    			if (spaceCount>mPrinter.GetSpacesAroundAssignment())
    			{
    				InsertWS(spaceCount);
    				return;
    			}
    		}

    		InsertWS(mPrinter.IsInParameterDecl() ? mPrinter.GetAdvancedSpacesAroundAssignmentInOptionalParameters() : mPrinter.GetSpacesAroundAssignment());
    	}

    	//this method is for inserting blank lines before elements, based on the format settings
    	private void InsertLines(int amt, bool inCodeBlock)
    	{
    		//don't add blank lines if not inside a block
    		if (!mPrinter.IsHardIndent())
    			return;
    		//don't add blank lines if the wrapper is a labeled statement indent
    		if (mPrinter.IsLabeledIndent())
    			return;

    		//don't add blank lines if we are at start of block
    		if (inCodeBlock)
    		{
    			if (!mPrinter.IsCanAddCRsAtBlockStart() && mPrinter.IsAtBlockStart())
    			{
    				return;
    			}
    		}

    		for (int i=0;i<amt;i++)
    		{
    			mPrinter.InsertCR(true);
    		}
    	}

    	private void InsertMaxColumnCR()
    	{
    		mPrinter.InsertCRBeyondMaxCol();
    	}

    	private void InsertStatementCR()
    	{
    		if (!mPrinter.IsLabeledIndent())
    			InsertCR(false);
    	}

    	private void InsertCR(bool doOverride)
    	{
    		mPrinter.InsertCR(doOverride);
    	}

    	private void PushLabeledIndent()
    	{
    		PushExpressionIndent(); //push an expression indent so that it won't further indent the nested statement 
    		mPrinter.MakeLabeledIndent();
    	}

    	private void PushIndent(bool hardIndent)
    	{
    		mPrinter.PushIndent(hardIndent ? ASPrettyPrinter.BRACE_INDENT : ASPrettyPrinter.STATEMENT_INDENT);
    	}

    	private void PushExpressionIndent()
    	{
    		mPrinter.PushIndent(ASPrettyPrinter.EXPRESSION_INDENT);
    	}

    	private bool PushLazyParmIndent(bool alreadyPushed, int indentStyle)
    	{
    		if (!alreadyPushed)
    		{
    			if (indentStyle==WrapOptions.WRAP_STYLE_INDENT_TO_WRAP_ELEMENT)
    				mPrinter.PushLazyIndent(ASPrettyPrinter.EXPRESSION_INDENT_NEXTITEM);
    			else
    				PushLazyIndent();
    		}
    		return true;
    	}

    	private void PushLazyIndent()
    	{
    		mPrinter.PushLazyIndent(ASPrettyPrinter.EXPRESSION_INDENT);
    	}

    	private void PopIndent()
    	{
    		mPrinter.PopIndent();
    	}

    	private void LeftCurlyNewlineHandler(bool checkBraceIndent)
    	{
    		if (mPrinter.IsCRBeforeOpenBrace() || (checkBraceIndent && mPrinter.GetIndentType(0)==ASPrettyPrinter.BRACE_INDENT))
    			InsertCR(false);
    		else
    			InsertWS(1);
    	}

    	private void Emit(CommonToken tok)
    	{
    		mPrinter.Emit(tok);
    	}


    	/*public List<Exception> getParseErrors()
    	{
    		return mParseErrors;
    	}*/
    	

    	public const int CHANNEL_SLCOMMENT=43;
    	public const int CHANNEL_MLCOMMENT=42;
    	public const int CHANNEL_WHITESPACE=41;
    	public const int CHANNEL_EOL=40;

    	private bool PromoteWhitespace()
    	{
    		//find the current lookahead token
    		CommonToken lt = (CommonToken) input.LT(1);
    		int index = lt.TokenIndex;
    		if(index<0){
    			index = input.Count;
    		}

    		//walk backward through tokens to see if the previous token is whitespace.
    		for (int ix = index - 1; ix >= 0; ix--){
    			lt = (CommonToken) input.Get(ix);
    			int channel=lt.Channel;
    			if (channel == CHANNEL_EOL || channel ==  CHANNEL_WHITESPACE){
    				return true;
    			} else if(channel == Token.DEFAULT_CHANNEL){
    				break;
    			}
    		}
    		return false;
    	}


    public class booleanLiteral_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "booleanLiteral"
    // AS3_ex.g3:1242:1: booleanLiteral : (T= TRUE | F= FALSE );
    public AS3_exParser.booleanLiteral_return booleanLiteral() // throws RecognitionException [1]
    {   
        AS3_exParser.booleanLiteral_return retval = new AS3_exParser.booleanLiteral_return();
        retval.Start = input.LT(1);
        int booleanLiteral_StartIndex = input.Index();
        object root_0 = null;

        IToken T = null;
        IToken F = null;

        object T_tree=null;
        object F_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 1) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1242:36: (T= TRUE | F= FALSE )
            int alt1 = 2;
            int LA1_0 = input.LA(1);

            if ( (LA1_0 == TRUE) )
            {
                alt1 = 1;
            }
            else if ( (LA1_0 == FALSE) )
            {
                alt1 = 2;
            }
            else 
            {
                if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                NoViableAltException nvae_d1s0 =
                    new NoViableAltException("", 1, 0, input);

                throw nvae_d1s0;
            }
            switch (alt1) 
            {
                case 1 :
                    // AS3_ex.g3:1242:40: T= TRUE
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	T=(IToken)Match(input,TRUE,FOLLOW_TRUE_in_booleanLiteral3614); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{T_tree = (object)adaptor.Create(T);
                    		adaptor.AddChild(root_0, T_tree);
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  Emit((CommonToken)T);
                    	}

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:1242:74: F= FALSE
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	F=(IToken)Match(input,FALSE,FOLLOW_FALSE_in_booleanLiteral3622); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{F_tree = (object)adaptor.Create(F);
                    		adaptor.AddChild(root_0, F_tree);
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  Emit((CommonToken)F);
                    	}

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 1, booleanLiteral_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "booleanLiteral"

    public class numericLiteral_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "numericLiteral"
    // AS3_ex.g3:1244:1: numericLiteral : (D= DEC_NUMBER_LITERAL | H= HEX_NUMBER_LITERAL );
    public AS3_exParser.numericLiteral_return numericLiteral() // throws RecognitionException [1]
    {   
        AS3_exParser.numericLiteral_return retval = new AS3_exParser.numericLiteral_return();
        retval.Start = input.LT(1);
        int numericLiteral_StartIndex = input.Index();
        object root_0 = null;

        IToken D = null;
        IToken H = null;

        object D_tree=null;
        object H_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 2) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1244:36: (D= DEC_NUMBER_LITERAL | H= HEX_NUMBER_LITERAL )
            int alt2 = 2;
            int LA2_0 = input.LA(1);

            if ( (LA2_0 == DEC_NUMBER_LITERAL) )
            {
                alt2 = 1;
            }
            else if ( (LA2_0 == HEX_NUMBER_LITERAL) )
            {
                alt2 = 2;
            }
            else 
            {
                if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                NoViableAltException nvae_d2s0 =
                    new NoViableAltException("", 2, 0, input);

                throw nvae_d2s0;
            }
            switch (alt2) 
            {
                case 1 :
                    // AS3_ex.g3:1244:40: D= DEC_NUMBER_LITERAL
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	D=(IToken)Match(input,DEC_NUMBER_LITERAL,FOLLOW_DEC_NUMBER_LITERAL_in_numericLiteral3656); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{D_tree = (object)adaptor.Create(D);
                    		adaptor.AddChild(root_0, D_tree);
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  Emit((CommonToken)D);
                    	}

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:1244:88: H= HEX_NUMBER_LITERAL
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	H=(IToken)Match(input,HEX_NUMBER_LITERAL,FOLLOW_HEX_NUMBER_LITERAL_in_numericLiteral3664); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{H_tree = (object)adaptor.Create(H);
                    		adaptor.AddChild(root_0, H_tree);
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  Emit((CommonToken)H);
                    	}

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 2, numericLiteral_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "numericLiteral"

    public class stringLiteral_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "stringLiteral"
    // AS3_ex.g3:1246:1: stringLiteral : (S= SINGLE_QUOTE_LITERAL | D= DOUBLE_QUOTE_LITERAL );
    public AS3_exParser.stringLiteral_return stringLiteral() // throws RecognitionException [1]
    {   
        AS3_exParser.stringLiteral_return retval = new AS3_exParser.stringLiteral_return();
        retval.Start = input.LT(1);
        int stringLiteral_StartIndex = input.Index();
        object root_0 = null;

        IToken S = null;
        IToken D = null;

        object S_tree=null;
        object D_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 3) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1246:36: (S= SINGLE_QUOTE_LITERAL | D= DOUBLE_QUOTE_LITERAL )
            int alt3 = 2;
            int LA3_0 = input.LA(1);

            if ( (LA3_0 == SINGLE_QUOTE_LITERAL) )
            {
                alt3 = 1;
            }
            else if ( (LA3_0 == DOUBLE_QUOTE_LITERAL) )
            {
                alt3 = 2;
            }
            else 
            {
                if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                NoViableAltException nvae_d3s0 =
                    new NoViableAltException("", 3, 0, input);

                throw nvae_d3s0;
            }
            switch (alt3) 
            {
                case 1 :
                    // AS3_ex.g3:1246:40: S= SINGLE_QUOTE_LITERAL
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	S=(IToken)Match(input,SINGLE_QUOTE_LITERAL,FOLLOW_SINGLE_QUOTE_LITERAL_in_stringLiteral3699); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{S_tree = (object)adaptor.Create(S);
                    		adaptor.AddChild(root_0, S_tree);
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  Emit((CommonToken)S);
                    	}

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:1246:89: D= DOUBLE_QUOTE_LITERAL
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	D=(IToken)Match(input,DOUBLE_QUOTE_LITERAL,FOLLOW_DOUBLE_QUOTE_LITERAL_in_stringLiteral3706); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{D_tree = (object)adaptor.Create(D);
                    		adaptor.AddChild(root_0, D_tree);
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  Emit((CommonToken)D);
                    	}

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 3, stringLiteral_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "stringLiteral"

    public class regularExpresionLiteral_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "regularExpresionLiteral"
    // AS3_ex.g3:1248:1: regularExpresionLiteral : R= REGULAR_EXPR_LITERAL ;
    public AS3_exParser.regularExpresionLiteral_return regularExpresionLiteral() // throws RecognitionException [1]
    {   
        AS3_exParser.regularExpresionLiteral_return retval = new AS3_exParser.regularExpresionLiteral_return();
        retval.Start = input.LT(1);
        int regularExpresionLiteral_StartIndex = input.Index();
        object root_0 = null;

        IToken R = null;

        object R_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 4) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1248:36: (R= REGULAR_EXPR_LITERAL )
            // AS3_ex.g3:1248:40: R= REGULAR_EXPR_LITERAL
            {
            	root_0 = (object)adaptor.GetNilNode();

            	R=(IToken)Match(input,REGULAR_EXPR_LITERAL,FOLLOW_REGULAR_EXPR_LITERAL_in_regularExpresionLiteral3731); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{R_tree = (object)adaptor.Create(R);
            		adaptor.AddChild(root_0, R_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)R);
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 4, regularExpresionLiteral_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "regularExpresionLiteral"

    public class identifierLiteral_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "identifierLiteral"
    // AS3_ex.g3:1250:1: identifierLiteral : (I= IDENTIFIER | notQuiteReservedWord );
    public AS3_exParser.identifierLiteral_return identifierLiteral() // throws RecognitionException [1]
    {   
        AS3_exParser.identifierLiteral_return retval = new AS3_exParser.identifierLiteral_return();
        retval.Start = input.LT(1);
        int identifierLiteral_StartIndex = input.Index();
        object root_0 = null;

        IToken I = null;
        AS3_exParser.notQuiteReservedWord_return notQuiteReservedWord1 = null;


        object I_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 5) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1250:36: (I= IDENTIFIER | notQuiteReservedWord )
            int alt4 = 2;
            int LA4_0 = input.LA(1);

            if ( (LA4_0 == IDENTIFIER) )
            {
                alt4 = 1;
            }
            else if ( (LA4_0 == NATIVE || LA4_0 == TO || (LA4_0 >= EACH && LA4_0 <= NAMESPACE) || (LA4_0 >= DYNAMIC && LA4_0 <= STATIC)) )
            {
                alt4 = 2;
            }
            else 
            {
                if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                NoViableAltException nvae_d4s0 =
                    new NoViableAltException("", 4, 0, input);

                throw nvae_d4s0;
            }
            switch (alt4) 
            {
                case 1 :
                    // AS3_ex.g3:1250:83: I= IDENTIFIER
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	I=(IToken)Match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_identifierLiteral3764); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{I_tree = (object)adaptor.Create(I);
                    		adaptor.AddChild(root_0, I_tree);
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  Emit((CommonToken)I);
                    	}

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:1250:122: notQuiteReservedWord
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_notQuiteReservedWord_in_identifierLiteral3769);
                    	notQuiteReservedWord1 = notQuiteReservedWord();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, notQuiteReservedWord1.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 5, identifierLiteral_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "identifierLiteral"

    public class xmlNameLiteral_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "xmlNameLiteral"
    // AS3_ex.g3:1252:1: xmlNameLiteral : (I= IDENTIFIER | allKeywords ) ({...}? => (s= SUB | d= DOT | c= COLON ) {...}? => (I2= IDENTIFIER | allKeywords ) )* ;
    public AS3_exParser.xmlNameLiteral_return xmlNameLiteral() // throws RecognitionException [1]
    {   
        AS3_exParser.xmlNameLiteral_return retval = new AS3_exParser.xmlNameLiteral_return();
        retval.Start = input.LT(1);
        int xmlNameLiteral_StartIndex = input.Index();
        object root_0 = null;

        IToken I = null;
        IToken s = null;
        IToken d = null;
        IToken c = null;
        IToken I2 = null;
        AS3_exParser.allKeywords_return allKeywords2 = null;

        AS3_exParser.allKeywords_return allKeywords3 = null;


        object I_tree=null;
        object s_tree=null;
        object d_tree=null;
        object c_tree=null;
        object I2_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 6) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1252:36: ( (I= IDENTIFIER | allKeywords ) ({...}? => (s= SUB | d= DOT | c= COLON ) {...}? => (I2= IDENTIFIER | allKeywords ) )* )
            // AS3_ex.g3:1252:40: (I= IDENTIFIER | allKeywords ) ({...}? => (s= SUB | d= DOT | c= COLON ) {...}? => (I2= IDENTIFIER | allKeywords ) )*
            {
            	root_0 = (object)adaptor.GetNilNode();

            	// AS3_ex.g3:1252:40: (I= IDENTIFIER | allKeywords )
            	int alt5 = 2;
            	int LA5_0 = input.LA(1);

            	if ( (LA5_0 == IDENTIFIER) )
            	{
            	    alt5 = 1;
            	}
            	else if ( ((LA5_0 >= AS && LA5_0 <= STATIC)) )
            	{
            	    alt5 = 2;
            	}
            	else 
            	{
            	    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            	    NoViableAltException nvae_d5s0 =
            	        new NoViableAltException("", 5, 0, input);

            	    throw nvae_d5s0;
            	}
            	switch (alt5) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:1252:41: I= IDENTIFIER
            	        {
            	        	I=(IToken)Match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_xmlNameLiteral3804); if (state.failed) return retval;
            	        	if ( state.backtracking == 0 )
            	        	{I_tree = (object)adaptor.Create(I);
            	        		adaptor.AddChild(root_0, I_tree);
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  Emit((CommonToken)I);
            	        	}

            	        }
            	        break;
            	    case 2 :
            	        // AS3_ex.g3:1252:80: allKeywords
            	        {
            	        	PushFollow(FOLLOW_allKeywords_in_xmlNameLiteral3809);
            	        	allKeywords2 = allKeywords();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, allKeywords2.Tree);

            	        }
            	        break;

            	}

            	// AS3_ex.g3:1252:93: ({...}? => (s= SUB | d= DOT | c= COLON ) {...}? => (I2= IDENTIFIER | allKeywords ) )*
            	do 
            	{
            	    int alt8 = 2;
            	    alt8 = dfa8.Predict(input);
            	    switch (alt8) 
            		{
            			case 1 :
            			    // AS3_ex.g3:1252:95: {...}? => (s= SUB | d= DOT | c= COLON ) {...}? => (I2= IDENTIFIER | allKeywords )
            			    {
            			    	if ( !((!PromoteWhitespace())) ) 
            			    	{
            			    	    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            			    	    throw new FailedPredicateException(input, "xmlNameLiteral", "!PromoteWhitespace()");
            			    	}
            			    	// AS3_ex.g3:1252:121: (s= SUB | d= DOT | c= COLON )
            			    	int alt6 = 3;
            			    	switch ( input.LA(1) ) 
            			    	{
            			    	case SUB:
            			    		{
            			    	    alt6 = 1;
            			    	    }
            			    	    break;
            			    	case DOT:
            			    		{
            			    	    alt6 = 2;
            			    	    }
            			    	    break;
            			    	case COLON:
            			    		{
            			    	    alt6 = 3;
            			    	    }
            			    	    break;
            			    		default:
            			    		    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            			    		    NoViableAltException nvae_d6s0 =
            			    		        new NoViableAltException("", 6, 0, input);

            			    		    throw nvae_d6s0;
            			    	}

            			    	switch (alt6) 
            			    	{
            			    	    case 1 :
            			    	        // AS3_ex.g3:1252:122: s= SUB
            			    	        {
            			    	        	s=(IToken)Match(input,SUB,FOLLOW_SUB_in_xmlNameLiteral3820); if (state.failed) return retval;
            			    	        	if ( state.backtracking == 0 )
            			    	        	{s_tree = (object)adaptor.Create(s);
            			    	        		adaptor.AddChild(root_0, s_tree);
            			    	        	}
            			    	        	if ( state.backtracking == 0 ) 
            			    	        	{
            			    	        	  Emit((CommonToken)s);
            			    	        	}

            			    	        }
            			    	        break;
            			    	    case 2 :
            			    	        // AS3_ex.g3:1252:155: d= DOT
            			    	        {
            			    	        	d=(IToken)Match(input,DOT,FOLLOW_DOT_in_xmlNameLiteral3828); if (state.failed) return retval;
            			    	        	if ( state.backtracking == 0 )
            			    	        	{d_tree = (object)adaptor.Create(d);
            			    	        		adaptor.AddChild(root_0, d_tree);
            			    	        	}
            			    	        	if ( state.backtracking == 0 ) 
            			    	        	{
            			    	        	  Emit((CommonToken)d);
            			    	        	}

            			    	        }
            			    	        break;
            			    	    case 3 :
            			    	        // AS3_ex.g3:1252:188: c= COLON
            			    	        {
            			    	        	c=(IToken)Match(input,COLON,FOLLOW_COLON_in_xmlNameLiteral3836); if (state.failed) return retval;
            			    	        	if ( state.backtracking == 0 )
            			    	        	{c_tree = (object)adaptor.Create(c);
            			    	        		adaptor.AddChild(root_0, c_tree);
            			    	        	}
            			    	        	if ( state.backtracking == 0 ) 
            			    	        	{
            			    	        	  Emit((CommonToken)c);
            			    	        	}

            			    	        }
            			    	        break;

            			    	}

            			    	if ( !((!PromoteWhitespace())) ) 
            			    	{
            			    	    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            			    	    throw new FailedPredicateException(input, "xmlNameLiteral", "!PromoteWhitespace()");
            			    	}
            			    	// AS3_ex.g3:1252:248: (I2= IDENTIFIER | allKeywords )
            			    	int alt7 = 2;
            			    	int LA7_0 = input.LA(1);

            			    	if ( (LA7_0 == IDENTIFIER) )
            			    	{
            			    	    alt7 = 1;
            			    	}
            			    	else if ( ((LA7_0 >= AS && LA7_0 <= STATIC)) )
            			    	{
            			    	    alt7 = 2;
            			    	}
            			    	else 
            			    	{
            			    	    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            			    	    NoViableAltException nvae_d7s0 =
            			    	        new NoViableAltException("", 7, 0, input);

            			    	    throw nvae_d7s0;
            			    	}
            			    	switch (alt7) 
            			    	{
            			    	    case 1 :
            			    	        // AS3_ex.g3:1252:249: I2= IDENTIFIER
            			    	        {
            			    	        	I2=(IToken)Match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_xmlNameLiteral3847); if (state.failed) return retval;
            			    	        	if ( state.backtracking == 0 )
            			    	        	{I2_tree = (object)adaptor.Create(I2);
            			    	        		adaptor.AddChild(root_0, I2_tree);
            			    	        	}
            			    	        	if ( state.backtracking == 0 ) 
            			    	        	{
            			    	        	  Emit((CommonToken)I2);
            			    	        	}

            			    	        }
            			    	        break;
            			    	    case 2 :
            			    	        // AS3_ex.g3:1252:291: allKeywords
            			    	        {
            			    	        	PushFollow(FOLLOW_allKeywords_in_xmlNameLiteral3853);
            			    	        	allKeywords3 = allKeywords();
            			    	        	state.followingStackPointer--;
            			    	        	if (state.failed) return retval;
            			    	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, allKeywords3.Tree);

            			    	        }
            			    	        break;

            			    	}


            			    }
            			    break;

            			default:
            			    goto loop8;
            	    }
            	} while (true);

            	loop8:
            		;	// Stops C# compiler whining that label 'loop8' has no statements


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 6, xmlNameLiteral_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "xmlNameLiteral"

    public class literal_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "literal"
    // AS3_ex.g3:1255:1: literal : (N= NULL | booleanLiteral | numericLiteral | stringLiteral | regularExpresionLiteral );
    public AS3_exParser.literal_return literal() // throws RecognitionException [1]
    {   
        AS3_exParser.literal_return retval = new AS3_exParser.literal_return();
        retval.Start = input.LT(1);
        int literal_StartIndex = input.Index();
        object root_0 = null;

        IToken N = null;
        AS3_exParser.booleanLiteral_return booleanLiteral4 = null;

        AS3_exParser.numericLiteral_return numericLiteral5 = null;

        AS3_exParser.stringLiteral_return stringLiteral6 = null;

        AS3_exParser.regularExpresionLiteral_return regularExpresionLiteral7 = null;


        object N_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 7) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1255:36: (N= NULL | booleanLiteral | numericLiteral | stringLiteral | regularExpresionLiteral )
            int alt9 = 5;
            switch ( input.LA(1) ) 
            {
            case NULL:
            	{
                alt9 = 1;
                }
                break;
            case FALSE:
            case TRUE:
            	{
                alt9 = 2;
                }
                break;
            case HEX_NUMBER_LITERAL:
            case DEC_NUMBER_LITERAL:
            	{
                alt9 = 3;
                }
                break;
            case SINGLE_QUOTE_LITERAL:
            case DOUBLE_QUOTE_LITERAL:
            	{
                alt9 = 4;
                }
                break;
            case REGULAR_EXPR_LITERAL:
            	{
                alt9 = 5;
                }
                break;
            	default:
            	    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            	    NoViableAltException nvae_d9s0 =
            	        new NoViableAltException("", 9, 0, input);

            	    throw nvae_d9s0;
            }

            switch (alt9) 
            {
                case 1 :
                    // AS3_ex.g3:1255:40: N= NULL
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	N=(IToken)Match(input,NULL,FOLLOW_NULL_in_literal3906); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{N_tree = (object)adaptor.Create(N);
                    		adaptor.AddChild(root_0, N_tree);
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  Emit((CommonToken)N);
                    	}

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:1255:74: booleanLiteral
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_booleanLiteral_in_literal3912);
                    	booleanLiteral4 = booleanLiteral();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, booleanLiteral4.Tree);

                    }
                    break;
                case 3 :
                    // AS3_ex.g3:1255:91: numericLiteral
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_numericLiteral_in_literal3916);
                    	numericLiteral5 = numericLiteral();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, numericLiteral5.Tree);

                    }
                    break;
                case 4 :
                    // AS3_ex.g3:1255:108: stringLiteral
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_stringLiteral_in_literal3920);
                    	stringLiteral6 = stringLiteral();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, stringLiteral6.Tree);

                    }
                    break;
                case 5 :
                    // AS3_ex.g3:1255:124: regularExpresionLiteral
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_regularExpresionLiteral_in_literal3924);
                    	regularExpresionLiteral7 = regularExpresionLiteral();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, regularExpresionLiteral7.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 7, literal_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "literal"

    public class xmlMarkup_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "xmlMarkup"
    // AS3_ex.g3:1258:1: xmlMarkup : ( xmlComment | xmlCDATA | xmlPI );
    public AS3_exParser.xmlMarkup_return xmlMarkup() // throws RecognitionException [1]
    {   
        AS3_exParser.xmlMarkup_return retval = new AS3_exParser.xmlMarkup_return();
        retval.Start = input.LT(1);
        int xmlMarkup_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.xmlComment_return xmlComment8 = null;

        AS3_exParser.xmlCDATA_return xmlCDATA9 = null;

        AS3_exParser.xmlPI_return xmlPI10 = null;



        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 8) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1258:36: ( xmlComment | xmlCDATA | xmlPI )
            int alt10 = 3;
            switch ( input.LA(1) ) 
            {
            case XML_COMMENT:
            	{
                alt10 = 1;
                }
                break;
            case XML_CDATA:
            	{
                alt10 = 2;
                }
                break;
            case XML_PI:
            	{
                alt10 = 3;
                }
                break;
            	default:
            	    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            	    NoViableAltException nvae_d10s0 =
            	        new NoViableAltException("", 10, 0, input);

            	    throw nvae_d10s0;
            }

            switch (alt10) 
            {
                case 1 :
                    // AS3_ex.g3:1258:40: xmlComment
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_xmlComment_in_xmlMarkup3960);
                    	xmlComment8 = xmlComment();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlComment8.Tree);

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:1258:53: xmlCDATA
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_xmlCDATA_in_xmlMarkup3964);
                    	xmlCDATA9 = xmlCDATA();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlCDATA9.Tree);

                    }
                    break;
                case 3 :
                    // AS3_ex.g3:1258:64: xmlPI
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_xmlPI_in_xmlMarkup3968);
                    	xmlPI10 = xmlPI();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlPI10.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 8, xmlMarkup_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "xmlMarkup"

    public class xmlComment_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "xmlComment"
    // AS3_ex.g3:1259:1: xmlComment : x= XML_COMMENT ;
    public AS3_exParser.xmlComment_return xmlComment() // throws RecognitionException [1]
    {   
        AS3_exParser.xmlComment_return retval = new AS3_exParser.xmlComment_return();
        retval.Start = input.LT(1);
        int xmlComment_StartIndex = input.Index();
        object root_0 = null;

        IToken x = null;

        object x_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 9) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1259:36: (x= XML_COMMENT )
            // AS3_ex.g3:1259:40: x= XML_COMMENT
            {
            	root_0 = (object)adaptor.GetNilNode();

            	x=(IToken)Match(input,XML_COMMENT,FOLLOW_XML_COMMENT_in_xmlComment4003); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{x_tree = (object)adaptor.Create(x);
            		adaptor.AddChild(root_0, x_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)x);
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 9, xmlComment_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "xmlComment"

    public class xmlCDATA_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "xmlCDATA"
    // AS3_ex.g3:1260:1: xmlCDATA : x= XML_CDATA ;
    public AS3_exParser.xmlCDATA_return xmlCDATA() // throws RecognitionException [1]
    {   
        AS3_exParser.xmlCDATA_return retval = new AS3_exParser.xmlCDATA_return();
        retval.Start = input.LT(1);
        int xmlCDATA_StartIndex = input.Index();
        object root_0 = null;

        IToken x = null;

        object x_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 10) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1260:36: (x= XML_CDATA )
            // AS3_ex.g3:1260:40: x= XML_CDATA
            {
            	root_0 = (object)adaptor.GetNilNode();

            	x=(IToken)Match(input,XML_CDATA,FOLLOW_XML_CDATA_in_xmlCDATA4045); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{x_tree = (object)adaptor.Create(x);
            		adaptor.AddChild(root_0, x_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)x);
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 10, xmlCDATA_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "xmlCDATA"

    public class xmlPI_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "xmlPI"
    // AS3_ex.g3:1261:1: xmlPI : x= XML_PI ;
    public AS3_exParser.xmlPI_return xmlPI() // throws RecognitionException [1]
    {   
        AS3_exParser.xmlPI_return retval = new AS3_exParser.xmlPI_return();
        retval.Start = input.LT(1);
        int xmlPI_StartIndex = input.Index();
        object root_0 = null;

        IToken x = null;

        object x_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 11) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1261:36: (x= XML_PI )
            // AS3_ex.g3:1261:40: x= XML_PI
            {
            	root_0 = (object)adaptor.GetNilNode();

            	x=(IToken)Match(input,XML_PI,FOLLOW_XML_PI_in_xmlPI4088); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{x_tree = (object)adaptor.Create(x);
            		adaptor.AddChild(root_0, x_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)x);
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 11, xmlPI_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "xmlPI"

    public class xmlExprEval_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "xmlExprEval"
    // AS3_ex.g3:1262:1: xmlExprEval : L= LCURLY expression R= RCURLY ;
    public AS3_exParser.xmlExprEval_return xmlExprEval() // throws RecognitionException [1]
    {   
        AS3_exParser.xmlExprEval_return retval = new AS3_exParser.xmlExprEval_return();
        retval.Start = input.LT(1);
        int xmlExprEval_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        IToken R = null;
        AS3_exParser.expression_return expression11 = null;


        object L_tree=null;
        object R_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 12) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1262:36: (L= LCURLY expression R= RCURLY )
            // AS3_ex.g3:1262:40: L= LCURLY expression R= RCURLY
            {
            	root_0 = (object)adaptor.GetNilNode();

            	L=(IToken)Match(input,LCURLY,FOLLOW_LCURLY_in_xmlExprEval4126); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{L_tree = (object)adaptor.Create(L);
            		adaptor.AddChild(root_0, L_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)L);PushIndent(true);
            	}
            	PushFollow(FOLLOW_expression_in_xmlExprEval4130);
            	expression11 = expression();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, expression11.Tree);
            	R=(IToken)Match(input,RCURLY,FOLLOW_RCURLY_in_xmlExprEval4134); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{R_tree = (object)adaptor.Create(R);
            		adaptor.AddChild(root_0, R_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  PopIndent();Emit((CommonToken)R);
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 12, xmlExprEval_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "xmlExprEval"

    public class xmlTextElement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "xmlTextElement"
    // AS3_ex.g3:1265:1: xmlTextElement : ( allKeywords | lexToken= ( DEC_NUMBER_LITERAL | HEX_NUMBER_LITERAL | SINGLE_QUOTE_LITERAL | DOUBLE_QUOTE_LITERAL | IDENTIFIER | XML_TEXT | DIV | SEMI | RCURLY | LPAREN | RPAREN | LBRACK | RBRACK | DOT | COMMA | GT | LTE | EQ | NEQ | SAME | NSAME | PLUS | SUB | STAR | MOD | INC | DEC | SHL | AND | OR | XOR | NOT | INV | LAND | LOR | QUE | COLON | ASSIGN | DIV_ASSIGN | MOD_ASSIGN | ADD_ASSIGN | SUB_ASSIGN | SHL_ASSIGN | AND_ASSIGN | XOR_ASSIGN | OR_ASSIGN | LOR_ASSIGN | LAND_ASSIGN | ELLIPSIS | XML_ELLIPSIS | XML_NS_OP | XML_AT ) );
    public AS3_exParser.xmlTextElement_return xmlTextElement() // throws RecognitionException [1]
    {   
        AS3_exParser.xmlTextElement_return retval = new AS3_exParser.xmlTextElement_return();
        retval.Start = input.LT(1);
        int xmlTextElement_StartIndex = input.Index();
        object root_0 = null;

        IToken lexToken = null;
        AS3_exParser.allKeywords_return allKeywords12 = null;


        object lexToken_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 13) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1266:5: ( allKeywords | lexToken= ( DEC_NUMBER_LITERAL | HEX_NUMBER_LITERAL | SINGLE_QUOTE_LITERAL | DOUBLE_QUOTE_LITERAL | IDENTIFIER | XML_TEXT | DIV | SEMI | RCURLY | LPAREN | RPAREN | LBRACK | RBRACK | DOT | COMMA | GT | LTE | EQ | NEQ | SAME | NSAME | PLUS | SUB | STAR | MOD | INC | DEC | SHL | AND | OR | XOR | NOT | INV | LAND | LOR | QUE | COLON | ASSIGN | DIV_ASSIGN | MOD_ASSIGN | ADD_ASSIGN | SUB_ASSIGN | SHL_ASSIGN | AND_ASSIGN | XOR_ASSIGN | OR_ASSIGN | LOR_ASSIGN | LAND_ASSIGN | ELLIPSIS | XML_ELLIPSIS | XML_NS_OP | XML_AT ) )
            int alt11 = 2;
            int LA11_0 = input.LA(1);

            if ( ((LA11_0 >= AS && LA11_0 <= STATIC)) )
            {
                alt11 = 1;
            }
            else if ( (LA11_0 == SEMI || (LA11_0 >= RCURLY && LA11_0 <= COMMA) || (LA11_0 >= GT && LA11_0 <= LTE) || (LA11_0 >= EQ && LA11_0 <= SHL) || (LA11_0 >= AND && LA11_0 <= ASSIGN) || (LA11_0 >= DIV_ASSIGN && LA11_0 <= SHL_ASSIGN) || (LA11_0 >= LAND_ASSIGN && LA11_0 <= XML_ELLIPSIS) || (LA11_0 >= XML_NS_OP && LA11_0 <= XML_AT) || (LA11_0 >= SINGLE_QUOTE_LITERAL && LA11_0 <= DOUBLE_QUOTE_LITERAL) || LA11_0 == HEX_NUMBER_LITERAL || LA11_0 == DEC_NUMBER_LITERAL || LA11_0 == IDENTIFIER || LA11_0 == XML_TEXT) )
            {
                alt11 = 2;
            }
            else 
            {
                if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                NoViableAltException nvae_d11s0 =
                    new NoViableAltException("", 11, 0, input);

                throw nvae_d11s0;
            }
            switch (alt11) 
            {
                case 1 :
                    // AS3_ex.g3:1267:3: allKeywords
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_allKeywords_in_xmlTextElement4152);
                    	allKeywords12 = allKeywords();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, allKeywords12.Tree);
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  /*TODO: see if I can change token type*/
                    	}

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:1268:7: lexToken= ( DEC_NUMBER_LITERAL | HEX_NUMBER_LITERAL | SINGLE_QUOTE_LITERAL | DOUBLE_QUOTE_LITERAL | IDENTIFIER | XML_TEXT | DIV | SEMI | RCURLY | LPAREN | RPAREN | LBRACK | RBRACK | DOT | COMMA | GT | LTE | EQ | NEQ | SAME | NSAME | PLUS | SUB | STAR | MOD | INC | DEC | SHL | AND | OR | XOR | NOT | INV | LAND | LOR | QUE | COLON | ASSIGN | DIV_ASSIGN | MOD_ASSIGN | ADD_ASSIGN | SUB_ASSIGN | SHL_ASSIGN | AND_ASSIGN | XOR_ASSIGN | OR_ASSIGN | LOR_ASSIGN | LAND_ASSIGN | ELLIPSIS | XML_ELLIPSIS | XML_NS_OP | XML_AT )
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	lexToken = (IToken)input.LT(1);
                    	if ( input.LA(1) == SEMI || (input.LA(1) >= RCURLY && input.LA(1) <= COMMA) || (input.LA(1) >= GT && input.LA(1) <= LTE) || (input.LA(1) >= EQ && input.LA(1) <= SHL) || (input.LA(1) >= AND && input.LA(1) <= ASSIGN) || (input.LA(1) >= DIV_ASSIGN && input.LA(1) <= SHL_ASSIGN) || (input.LA(1) >= LAND_ASSIGN && input.LA(1) <= XML_ELLIPSIS) || (input.LA(1) >= XML_NS_OP && input.LA(1) <= XML_AT) || (input.LA(1) >= SINGLE_QUOTE_LITERAL && input.LA(1) <= DOUBLE_QUOTE_LITERAL) || input.LA(1) == HEX_NUMBER_LITERAL || input.LA(1) == DEC_NUMBER_LITERAL || input.LA(1) == IDENTIFIER || input.LA(1) == XML_TEXT ) 
                    	{
                    	    input.Consume();
                    	    if ( state.backtracking == 0 ) adaptor.AddChild(root_0, (object)adaptor.Create(lexToken));
                    	    state.errorRecovery = false;state.failed = false;
                    	}
                    	else 
                    	{
                    	    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    	    MismatchedSetException mse = new MismatchedSetException(null,input);
                    	    throw mse;
                    	}

                    	if ( state.backtracking == 0 ) 
                    	{

                    	          lexToken.Type = XML_TEXT; 
                    	          Emit((CommonToken)lexToken);
                    	      
                    	}

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 13, xmlTextElement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "xmlTextElement"

    public class xmlText_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "xmlText"
    // AS3_ex.g3:1339:1: xmlText : (x= XML_TEXT | xmlTextElement )+ ;
    public AS3_exParser.xmlText_return xmlText() // throws RecognitionException [1]
    {   
        AS3_exParser.xmlText_return retval = new AS3_exParser.xmlText_return();
        retval.Start = input.LT(1);
        int xmlText_StartIndex = input.Index();
        object root_0 = null;

        IToken x = null;
        AS3_exParser.xmlTextElement_return xmlTextElement13 = null;


        object x_tree=null;


            

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 14) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1347:5: ( (x= XML_TEXT | xmlTextElement )+ )
            // AS3_ex.g3:1349:2: (x= XML_TEXT | xmlTextElement )+
            {
            	root_0 = (object)adaptor.GetNilNode();

            	if ( state.backtracking == 0 ) 
            	{
            	  mPrinter.SetE4XTextContent(true);
            	}
            	// AS3_ex.g3:1350:5: (x= XML_TEXT | xmlTextElement )+
            	int cnt12 = 0;
            	do 
            	{
            	    int alt12 = 3;
            	    switch ( input.LA(1) ) 
            	    {
            	    case XML_TEXT:
            	    	{
            	        int LA12_2 = input.LA(2);

            	        if ( (synpred68_AS3_ex()) )
            	        {
            	            alt12 = 1;
            	        }
            	        else if ( (synpred69_AS3_ex()) )
            	        {
            	            alt12 = 2;
            	        }


            	        }
            	        break;
            	    case AS:
            	    case BREAK:
            	    case CASE:
            	    case CATCH:
            	    case CLASS:
            	    case CONST:
            	    case CONTINUE:
            	    case DEFAULT:
            	    case DELETE:
            	    case DO:
            	    case ELSE:
            	    case EXTENDS:
            	    case FALSE:
            	    case FINALLY:
            	    case FOR:
            	    case FUNCTION:
            	    case IF:
            	    case IMPLEMENTS:
            	    case IMPORT:
            	    case IN:
            	    case INSTANCEOF:
            	    case INTERFACE:
            	    case INTERNAL:
            	    case IS:
            	    case NEW:
            	    case NULL:
            	    case PACKAGE:
            	    case PRIVATE:
            	    case PROTECTED:
            	    case PUBLIC:
            	    case RETURN:
            	    case SUPER:
            	    case SWITCH:
            	    case THIS:
            	    case THROW:
            	    case TRUE:
            	    case TRY:
            	    case TYPEOF:
            	    case USE:
            	    case VAR:
            	    case VOID:
            	    case WHILE:
            	    case WITH:
            	    case INCLUDE:
            	    	{
            	        int LA12_3 = input.LA(2);

            	        if ( (synpred69_AS3_ex()) )
            	        {
            	            alt12 = 2;
            	        }


            	        }
            	        break;
            	    case NATIVE:
            	    case TO:
            	    case EACH:
            	    case GET:
            	    case SET:
            	    case NAMESPACE:
            	    case DYNAMIC:
            	    case FINAL:
            	    case OVERRIDE:
            	    case STATIC:
            	    	{
            	        int LA12_4 = input.LA(2);

            	        if ( (synpred69_AS3_ex()) )
            	        {
            	            alt12 = 2;
            	        }


            	        }
            	        break;
            	    case SEMI:
            	    case RCURLY:
            	    case LPAREN:
            	    case RPAREN:
            	    case LBRACK:
            	    case RBRACK:
            	    case DOT:
            	    case COMMA:
            	    case GT:
            	    case LTE:
            	    case EQ:
            	    case NEQ:
            	    case SAME:
            	    case NSAME:
            	    case PLUS:
            	    case SUB:
            	    case STAR:
            	    case DIV:
            	    case MOD:
            	    case INC:
            	    case DEC:
            	    case SHL:
            	    case AND:
            	    case OR:
            	    case XOR:
            	    case NOT:
            	    case INV:
            	    case LAND:
            	    case LOR:
            	    case QUE:
            	    case COLON:
            	    case ASSIGN:
            	    case DIV_ASSIGN:
            	    case MOD_ASSIGN:
            	    case ADD_ASSIGN:
            	    case SUB_ASSIGN:
            	    case SHL_ASSIGN:
            	    case LAND_ASSIGN:
            	    case LOR_ASSIGN:
            	    case AND_ASSIGN:
            	    case XOR_ASSIGN:
            	    case OR_ASSIGN:
            	    case ELLIPSIS:
            	    case XML_ELLIPSIS:
            	    case XML_NS_OP:
            	    case XML_AT:
            	    case SINGLE_QUOTE_LITERAL:
            	    case DOUBLE_QUOTE_LITERAL:
            	    case HEX_NUMBER_LITERAL:
            	    case DEC_NUMBER_LITERAL:
            	    case IDENTIFIER:
            	    	{
            	        int LA12_5 = input.LA(2);

            	        if ( (synpred69_AS3_ex()) )
            	        {
            	            alt12 = 2;
            	        }


            	        }
            	        break;

            	    }

            	    switch (alt12) 
            		{
            			case 1 :
            			    // AS3_ex.g3:1350:6: x= XML_TEXT
            			    {
            			    	x=(IToken)Match(input,XML_TEXT,FOLLOW_XML_TEXT_in_xmlText4895); if (state.failed) return retval;
            			    	if ( state.backtracking == 0 )
            			    	{x_tree = (object)adaptor.Create(x);
            			    		adaptor.AddChild(root_0, x_tree);
            			    	}
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  Emit((CommonToken)x);
            			    	}

            			    }
            			    break;
            			case 2 :
            			    // AS3_ex.g3:1350:44: xmlTextElement
            			    {
            			    	PushFollow(FOLLOW_xmlTextElement_in_xmlText4901);
            			    	xmlTextElement13 = xmlTextElement();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlTextElement13.Tree);

            			    }
            			    break;

            			default:
            			    if ( cnt12 >= 1 ) goto loop12;
            			    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            		            EarlyExitException eee =
            		                new EarlyExitException(12, input);
            		            throw eee;
            	    }
            	    cnt12++;
            	} while (true);

            	loop12:
            		;	// Stops C# compiler whinging that label 'loop12' has no statements

            	if ( state.backtracking == 0 ) 
            	{
            	  mPrinter.SetE4XTextContent(false);
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
            if ( state.backtracking == 0 ) 
            {

                  // System.out.println("xmlText.text=("+input.ToString((IToken)retval.Start,input.LT(-1))+")");
                  // System.out.println("xmlText after start currentIndex = "+input.index()+"size = "+input.size());

            }
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 14, xmlText_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "xmlText"

    public class xmlPrimaryExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "xmlPrimaryExpression"
    // AS3_ex.g3:1355:1: xmlPrimaryExpression : ( xmlPropertyIdentifier | xmlInitialiser | xmlListInitialiser );
    public AS3_exParser.xmlPrimaryExpression_return xmlPrimaryExpression() // throws RecognitionException [1]
    {   
        AS3_exParser.xmlPrimaryExpression_return retval = new AS3_exParser.xmlPrimaryExpression_return();
        retval.Start = input.LT(1);
        int xmlPrimaryExpression_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.xmlPropertyIdentifier_return xmlPropertyIdentifier14 = null;

        AS3_exParser.xmlInitialiser_return xmlInitialiser15 = null;

        AS3_exParser.xmlListInitialiser_return xmlListInitialiser16 = null;



        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 15) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1356:5: ( xmlPropertyIdentifier | xmlInitialiser | xmlListInitialiser )
            int alt13 = 3;
            switch ( input.LA(1) ) 
            {
            case AS:
            case BREAK:
            case CASE:
            case CATCH:
            case CLASS:
            case CONST:
            case CONTINUE:
            case DEFAULT:
            case DELETE:
            case DO:
            case ELSE:
            case EXTENDS:
            case FALSE:
            case FINALLY:
            case FOR:
            case FUNCTION:
            case IF:
            case IMPLEMENTS:
            case IMPORT:
            case IN:
            case INSTANCEOF:
            case INTERFACE:
            case INTERNAL:
            case IS:
            case NATIVE:
            case NEW:
            case NULL:
            case PACKAGE:
            case PRIVATE:
            case PROTECTED:
            case PUBLIC:
            case RETURN:
            case SUPER:
            case SWITCH:
            case THIS:
            case THROW:
            case TO:
            case TRUE:
            case TRY:
            case TYPEOF:
            case USE:
            case VAR:
            case VOID:
            case WHILE:
            case WITH:
            case EACH:
            case GET:
            case SET:
            case NAMESPACE:
            case INCLUDE:
            case DYNAMIC:
            case FINAL:
            case OVERRIDE:
            case STATIC:
            case STAR:
            case XML_AT:
            case IDENTIFIER:
            	{
                alt13 = 1;
                }
                break;
            case LT:
            case XML_COMMENT:
            case XML_CDATA:
            case XML_PI:
            	{
                alt13 = 2;
                }
                break;
            case XML_LS_STD:
            	{
                alt13 = 3;
                }
                break;
            	default:
            	    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            	    NoViableAltException nvae_d13s0 =
            	        new NoViableAltException("", 13, 0, input);

            	    throw nvae_d13s0;
            }

            switch (alt13) 
            {
                case 1 :
                    // AS3_ex.g3:1356:9: xmlPropertyIdentifier
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_xmlPropertyIdentifier_in_xmlPrimaryExpression5003);
                    	xmlPropertyIdentifier14 = xmlPropertyIdentifier();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlPropertyIdentifier14.Tree);

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:1357:9: xmlInitialiser
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_xmlInitialiser_in_xmlPrimaryExpression5013);
                    	xmlInitialiser15 = xmlInitialiser();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlInitialiser15.Tree);

                    }
                    break;
                case 3 :
                    // AS3_ex.g3:1358:9: xmlListInitialiser
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_xmlListInitialiser_in_xmlPrimaryExpression5023);
                    	xmlListInitialiser16 = xmlListInitialiser();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlListInitialiser16.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 15, xmlPrimaryExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "xmlPrimaryExpression"

    public class xmlPropertyIdentifier_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "xmlPropertyIdentifier"
    // AS3_ex.g3:1371:1: xmlPropertyIdentifier : ( xmlAttributeIdentifier | xmlQualifiedIdentifier | s= STAR );
    public AS3_exParser.xmlPropertyIdentifier_return xmlPropertyIdentifier() // throws RecognitionException [1]
    {   
        AS3_exParser.xmlPropertyIdentifier_return retval = new AS3_exParser.xmlPropertyIdentifier_return();
        retval.Start = input.LT(1);
        int xmlPropertyIdentifier_StartIndex = input.Index();
        object root_0 = null;

        IToken s = null;
        AS3_exParser.xmlAttributeIdentifier_return xmlAttributeIdentifier17 = null;

        AS3_exParser.xmlQualifiedIdentifier_return xmlQualifiedIdentifier18 = null;


        object s_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 16) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1372:7: ( xmlAttributeIdentifier | xmlQualifiedIdentifier | s= STAR )
            int alt14 = 3;
            alt14 = dfa14.Predict(input);
            switch (alt14) 
            {
                case 1 :
                    // AS3_ex.g3:1372:11: xmlAttributeIdentifier
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_xmlAttributeIdentifier_in_xmlPropertyIdentifier5116);
                    	xmlAttributeIdentifier17 = xmlAttributeIdentifier();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlAttributeIdentifier17.Tree);

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:1373:11: xmlQualifiedIdentifier
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_xmlQualifiedIdentifier_in_xmlPropertyIdentifier5128);
                    	xmlQualifiedIdentifier18 = xmlQualifiedIdentifier();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlQualifiedIdentifier18.Tree);

                    }
                    break;
                case 3 :
                    // AS3_ex.g3:1374:11: s= STAR
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	s=(IToken)Match(input,STAR,FOLLOW_STAR_in_xmlPropertyIdentifier5142); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{s_tree = (object)adaptor.Create(s);
                    		adaptor.AddChild(root_0, s_tree);
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  Emit((CommonToken)s);
                    	}

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 16, xmlPropertyIdentifier_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "xmlPropertyIdentifier"

    public class xmlAttributeIdentifier_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "xmlAttributeIdentifier"
    // AS3_ex.g3:1377:1: xmlAttributeIdentifier : at= XML_AT ( xmlQualifiedIdentifier | xmlPropertySelector | indexSuffix ) ;
    public AS3_exParser.xmlAttributeIdentifier_return xmlAttributeIdentifier() // throws RecognitionException [1]
    {   
        AS3_exParser.xmlAttributeIdentifier_return retval = new AS3_exParser.xmlAttributeIdentifier_return();
        retval.Start = input.LT(1);
        int xmlAttributeIdentifier_StartIndex = input.Index();
        object root_0 = null;

        IToken at = null;
        AS3_exParser.xmlQualifiedIdentifier_return xmlQualifiedIdentifier19 = null;

        AS3_exParser.xmlPropertySelector_return xmlPropertySelector20 = null;

        AS3_exParser.indexSuffix_return indexSuffix21 = null;


        object at_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 17) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1378:5: (at= XML_AT ( xmlQualifiedIdentifier | xmlPropertySelector | indexSuffix ) )
            // AS3_ex.g3:1378:9: at= XML_AT ( xmlQualifiedIdentifier | xmlPropertySelector | indexSuffix )
            {
            	root_0 = (object)adaptor.GetNilNode();

            	at=(IToken)Match(input,XML_AT,FOLLOW_XML_AT_in_xmlAttributeIdentifier5207); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{at_tree = (object)adaptor.Create(at);
            		adaptor.AddChild(root_0, at_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)at);
            	}
            	// AS3_ex.g3:1379:9: ( xmlQualifiedIdentifier | xmlPropertySelector | indexSuffix )
            	int alt15 = 3;
            	switch ( input.LA(1) ) 
            	{
            	case IDENTIFIER:
            		{
            	    int LA15_1 = input.LA(2);

            	    if ( (synpred74_AS3_ex()) )
            	    {
            	        alt15 = 1;
            	    }
            	    else if ( (synpred75_AS3_ex()) )
            	    {
            	        alt15 = 2;
            	    }
            	    else 
            	    {
            	        if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            	        NoViableAltException nvae_d15s1 =
            	            new NoViableAltException("", 15, 1, input);

            	        throw nvae_d15s1;
            	    }
            	    }
            	    break;
            	case AS:
            	case BREAK:
            	case CASE:
            	case CATCH:
            	case CLASS:
            	case CONST:
            	case CONTINUE:
            	case DEFAULT:
            	case DELETE:
            	case DO:
            	case ELSE:
            	case EXTENDS:
            	case FALSE:
            	case FINALLY:
            	case FOR:
            	case FUNCTION:
            	case IF:
            	case IMPLEMENTS:
            	case IMPORT:
            	case IN:
            	case INSTANCEOF:
            	case INTERFACE:
            	case INTERNAL:
            	case IS:
            	case NEW:
            	case NULL:
            	case PACKAGE:
            	case PRIVATE:
            	case PROTECTED:
            	case PUBLIC:
            	case RETURN:
            	case SUPER:
            	case SWITCH:
            	case THIS:
            	case THROW:
            	case TRUE:
            	case TRY:
            	case TYPEOF:
            	case USE:
            	case VAR:
            	case VOID:
            	case WHILE:
            	case WITH:
            	case INCLUDE:
            		{
            	    int LA15_2 = input.LA(2);

            	    if ( (synpred74_AS3_ex()) )
            	    {
            	        alt15 = 1;
            	    }
            	    else if ( (synpred75_AS3_ex()) )
            	    {
            	        alt15 = 2;
            	    }
            	    else 
            	    {
            	        if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            	        NoViableAltException nvae_d15s2 =
            	            new NoViableAltException("", 15, 2, input);

            	        throw nvae_d15s2;
            	    }
            	    }
            	    break;
            	case NATIVE:
            	case TO:
            	case EACH:
            	case GET:
            	case SET:
            	case NAMESPACE:
            	case DYNAMIC:
            	case FINAL:
            	case OVERRIDE:
            	case STATIC:
            		{
            	    int LA15_3 = input.LA(2);

            	    if ( (synpred74_AS3_ex()) )
            	    {
            	        alt15 = 1;
            	    }
            	    else if ( (synpred75_AS3_ex()) )
            	    {
            	        alt15 = 2;
            	    }
            	    else 
            	    {
            	        if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            	        NoViableAltException nvae_d15s3 =
            	            new NoViableAltException("", 15, 3, input);

            	        throw nvae_d15s3;
            	    }
            	    }
            	    break;
            	case STAR:
            		{
            	    int LA15_4 = input.LA(2);

            	    if ( (synpred74_AS3_ex()) )
            	    {
            	        alt15 = 1;
            	    }
            	    else if ( (synpred75_AS3_ex()) )
            	    {
            	        alt15 = 2;
            	    }
            	    else 
            	    {
            	        if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            	        NoViableAltException nvae_d15s4 =
            	            new NoViableAltException("", 15, 4, input);

            	        throw nvae_d15s4;
            	    }
            	    }
            	    break;
            	case LBRACK:
            		{
            	    alt15 = 3;
            	    }
            	    break;
            		default:
            		    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            		    NoViableAltException nvae_d15s0 =
            		        new NoViableAltException("", 15, 0, input);

            		    throw nvae_d15s0;
            	}

            	switch (alt15) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:1380:12: xmlQualifiedIdentifier
            	        {
            	        	PushFollow(FOLLOW_xmlQualifiedIdentifier_in_xmlAttributeIdentifier5233);
            	        	xmlQualifiedIdentifier19 = xmlQualifiedIdentifier();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlQualifiedIdentifier19.Tree);

            	        }
            	        break;
            	    case 2 :
            	        // AS3_ex.g3:1381:14: xmlPropertySelector
            	        {
            	        	PushFollow(FOLLOW_xmlPropertySelector_in_xmlAttributeIdentifier5248);
            	        	xmlPropertySelector20 = xmlPropertySelector();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlPropertySelector20.Tree);

            	        }
            	        break;
            	    case 3 :
            	        // AS3_ex.g3:1382:14: indexSuffix
            	        {
            	        	PushFollow(FOLLOW_indexSuffix_in_xmlAttributeIdentifier5263);
            	        	indexSuffix21 = indexSuffix();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, indexSuffix21.Tree);

            	        }
            	        break;

            	}


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 17, xmlAttributeIdentifier_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "xmlAttributeIdentifier"

    public class xmlPropertySelector_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "xmlPropertySelector"
    // AS3_ex.g3:1386:1: xmlPropertySelector : ( xmlNameLiteral | s= STAR );
    public AS3_exParser.xmlPropertySelector_return xmlPropertySelector() // throws RecognitionException [1]
    {   
        AS3_exParser.xmlPropertySelector_return retval = new AS3_exParser.xmlPropertySelector_return();
        retval.Start = input.LT(1);
        int xmlPropertySelector_StartIndex = input.Index();
        object root_0 = null;

        IToken s = null;
        AS3_exParser.xmlNameLiteral_return xmlNameLiteral22 = null;


        object s_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 18) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1387:5: ( xmlNameLiteral | s= STAR )
            int alt16 = 2;
            int LA16_0 = input.LA(1);

            if ( ((LA16_0 >= AS && LA16_0 <= STATIC) || LA16_0 == IDENTIFIER) )
            {
                alt16 = 1;
            }
            else if ( (LA16_0 == STAR) )
            {
                alt16 = 2;
            }
            else 
            {
                if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                NoViableAltException nvae_d16s0 =
                    new NoViableAltException("", 16, 0, input);

                throw nvae_d16s0;
            }
            switch (alt16) 
            {
                case 1 :
                    // AS3_ex.g3:1387:9: xmlNameLiteral
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_xmlNameLiteral_in_xmlPropertySelector5353);
                    	xmlNameLiteral22 = xmlNameLiteral();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlNameLiteral22.Tree);

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:1388:9: s= STAR
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	s=(IToken)Match(input,STAR,FOLLOW_STAR_in_xmlPropertySelector5366); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{s_tree = (object)adaptor.Create(s);
                    		adaptor.AddChild(root_0, s_tree);
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  Emit((CommonToken)s);
                    	}

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 18, xmlPropertySelector_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "xmlPropertySelector"

    public class xmlQualifiedIdentifier_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "xmlQualifiedIdentifier"
    // AS3_ex.g3:1391:1: xmlQualifiedIdentifier : xmlPropertySelector x= XML_NS_OP ( xmlPropertySelector | indexSuffix ) ;
    public AS3_exParser.xmlQualifiedIdentifier_return xmlQualifiedIdentifier() // throws RecognitionException [1]
    {   
        AS3_exParser.xmlQualifiedIdentifier_return retval = new AS3_exParser.xmlQualifiedIdentifier_return();
        retval.Start = input.LT(1);
        int xmlQualifiedIdentifier_StartIndex = input.Index();
        object root_0 = null;

        IToken x = null;
        AS3_exParser.xmlPropertySelector_return xmlPropertySelector23 = null;

        AS3_exParser.xmlPropertySelector_return xmlPropertySelector24 = null;

        AS3_exParser.indexSuffix_return indexSuffix25 = null;


        object x_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 19) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1392:5: ( xmlPropertySelector x= XML_NS_OP ( xmlPropertySelector | indexSuffix ) )
            // AS3_ex.g3:1392:9: xmlPropertySelector x= XML_NS_OP ( xmlPropertySelector | indexSuffix )
            {
            	root_0 = (object)adaptor.GetNilNode();

            	PushFollow(FOLLOW_xmlPropertySelector_in_xmlQualifiedIdentifier5387);
            	xmlPropertySelector23 = xmlPropertySelector();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlPropertySelector23.Tree);
            	x=(IToken)Match(input,XML_NS_OP,FOLLOW_XML_NS_OP_in_xmlQualifiedIdentifier5392); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{x_tree = (object)adaptor.Create(x);
            		adaptor.AddChild(root_0, x_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)x);
            	}
            	// AS3_ex.g3:1393:5: ( xmlPropertySelector | indexSuffix )
            	int alt17 = 2;
            	int LA17_0 = input.LA(1);

            	if ( ((LA17_0 >= AS && LA17_0 <= STATIC) || LA17_0 == STAR || LA17_0 == IDENTIFIER) )
            	{
            	    alt17 = 1;
            	}
            	else if ( (LA17_0 == LBRACK) )
            	{
            	    alt17 = 2;
            	}
            	else 
            	{
            	    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            	    NoViableAltException nvae_d17s0 =
            	        new NoViableAltException("", 17, 0, input);

            	    throw nvae_d17s0;
            	}
            	switch (alt17) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:1394:9: xmlPropertySelector
            	        {
            	        	PushFollow(FOLLOW_xmlPropertySelector_in_xmlQualifiedIdentifier5427);
            	        	xmlPropertySelector24 = xmlPropertySelector();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlPropertySelector24.Tree);

            	        }
            	        break;
            	    case 2 :
            	        // AS3_ex.g3:1395:11: indexSuffix
            	        {
            	        	PushFollow(FOLLOW_indexSuffix_in_xmlQualifiedIdentifier5439);
            	        	indexSuffix25 = indexSuffix();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, indexSuffix25.Tree);

            	        }
            	        break;

            	}


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 19, xmlQualifiedIdentifier_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "xmlQualifiedIdentifier"

    public class xmlInitialiser_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "xmlInitialiser"
    // AS3_ex.g3:1399:1: xmlInitialiser : ( xmlMarkup | xmlElement );
    public AS3_exParser.xmlInitialiser_return xmlInitialiser() // throws RecognitionException [1]
    {   
        AS3_exParser.xmlInitialiser_return retval = new AS3_exParser.xmlInitialiser_return();
        retval.Start = input.LT(1);
        int xmlInitialiser_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.xmlMarkup_return xmlMarkup26 = null;

        AS3_exParser.xmlElement_return xmlElement27 = null;



        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 20) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1400:5: ( xmlMarkup | xmlElement )
            int alt18 = 2;
            int LA18_0 = input.LA(1);

            if ( ((LA18_0 >= XML_COMMENT && LA18_0 <= XML_PI)) )
            {
                alt18 = 1;
            }
            else if ( (LA18_0 == LT) )
            {
                alt18 = 2;
            }
            else 
            {
                if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                NoViableAltException nvae_d18s0 =
                    new NoViableAltException("", 18, 0, input);

                throw nvae_d18s0;
            }
            switch (alt18) 
            {
                case 1 :
                    // AS3_ex.g3:1400:9: xmlMarkup
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_xmlMarkup_in_xmlInitialiser5464);
                    	xmlMarkup26 = xmlMarkup();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlMarkup26.Tree);

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:1401:9: xmlElement
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_xmlElement_in_xmlInitialiser5474);
                    	xmlElement27 = xmlElement();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlElement27.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 20, xmlInitialiser_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "xmlInitialiser"

    public class xmlElement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "xmlElement"
    // AS3_ex.g3:1404:1: xmlElement : L= LT xmlTagName ( xmlAttributes )? (x= XML_TEND | G= GT ( xmlElementContent )? x= XML_E_TEND xmlTagName G= GT ) ;
    public AS3_exParser.xmlElement_return xmlElement() // throws RecognitionException [1]
    {   
        AS3_exParser.xmlElement_return retval = new AS3_exParser.xmlElement_return();
        retval.Start = input.LT(1);
        int xmlElement_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        IToken x = null;
        IToken G = null;
        AS3_exParser.xmlTagName_return xmlTagName28 = null;

        AS3_exParser.xmlAttributes_return xmlAttributes29 = null;

        AS3_exParser.xmlElementContent_return xmlElementContent30 = null;

        AS3_exParser.xmlTagName_return xmlTagName31 = null;


        object L_tree=null;
        object x_tree=null;
        object G_tree=null;


        	WrapOptions options=mPrinter.GetXMLWrapOptions();
        	bool pushedFormat=false;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 21) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1410:5: (L= LT xmlTagName ( xmlAttributes )? (x= XML_TEND | G= GT ( xmlElementContent )? x= XML_E_TEND xmlTagName G= GT ) )
            // AS3_ex.g3:1411:5: L= LT xmlTagName ( xmlAttributes )? (x= XML_TEND | G= GT ( xmlElementContent )? x= XML_E_TEND xmlTagName G= GT )
            {
            	root_0 = (object)adaptor.GetNilNode();

            	if ( state.backtracking == 0 ) 
            	{
            	  pushedFormat=PushFormatType(options, false);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  EmitCRForTag(options);
            	}
            	L=(IToken)Match(input,LT,FOLLOW_LT_in_xmlElement5518); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{L_tree = (object)adaptor.Create(L);
            		adaptor.AddChild(root_0, L_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)L);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  PushIndent(true);
            	}
            	PushFollow(FOLLOW_xmlTagName_in_xmlElement5523);
            	xmlTagName28 = xmlTagName();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlTagName28.Tree);
            	// AS3_ex.g3:1413:65: ( xmlAttributes )?
            	int alt19 = 2;
            	int LA19_0 = input.LA(1);

            	if ( ((LA19_0 >= AS && LA19_0 <= STATIC) || LA19_0 == IDENTIFIER) )
            	{
            	    alt19 = 1;
            	}
            	switch (alt19) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:0:0: xmlAttributes
            	        {
            	        	PushFollow(FOLLOW_xmlAttributes_in_xmlElement5525);
            	        	xmlAttributes29 = xmlAttributes();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlAttributes29.Tree);

            	        }
            	        break;

            	}

            	// AS3_ex.g3:1414:5: (x= XML_TEND | G= GT ( xmlElementContent )? x= XML_E_TEND xmlTagName G= GT )
            	int alt21 = 2;
            	int LA21_0 = input.LA(1);

            	if ( (LA21_0 == XML_TEND) )
            	{
            	    alt21 = 1;
            	}
            	else if ( (LA21_0 == GT) )
            	{
            	    alt21 = 2;
            	}
            	else 
            	{
            	    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            	    NoViableAltException nvae_d21s0 =
            	        new NoViableAltException("", 21, 0, input);

            	    throw nvae_d21s0;
            	}
            	switch (alt21) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:1415:9: x= XML_TEND
            	        {
            	        	x=(IToken)Match(input,XML_TEND,FOLLOW_XML_TEND_in_xmlElement5545); if (state.failed) return retval;
            	        	if ( state.backtracking == 0 )
            	        	{x_tree = (object)adaptor.Create(x);
            	        		adaptor.AddChild(root_0, x_tree);
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  Emit((CommonToken)x);
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  EmitCRForTag(options);
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  PopIndent();
            	        	}

            	        }
            	        break;
            	    case 2 :
            	        // AS3_ex.g3:1419:9: G= GT ( xmlElementContent )? x= XML_E_TEND xmlTagName G= GT
            	        {
            	        	G=(IToken)Match(input,GT,FOLLOW_GT_in_xmlElement5590); if (state.failed) return retval;
            	        	if ( state.backtracking == 0 )
            	        	{G_tree = (object)adaptor.Create(G);
            	        		adaptor.AddChild(root_0, G_tree);
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  Emit((CommonToken)G);
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  EmitCRForTag(options);
            	        	}
            	        	// AS3_ex.g3:1419:62: ( xmlElementContent )?
            	        	int alt20 = 2;
            	        	int LA20_0 = input.LA(1);

            	        	if ( ((LA20_0 >= AS && LA20_0 <= LTE) || (LA20_0 >= EQ && LA20_0 <= SHL) || (LA20_0 >= AND && LA20_0 <= ASSIGN) || (LA20_0 >= DIV_ASSIGN && LA20_0 <= SHL_ASSIGN) || (LA20_0 >= LAND_ASSIGN && LA20_0 <= XML_ELLIPSIS) || (LA20_0 >= XML_NS_OP && LA20_0 <= XML_AT) || (LA20_0 >= SINGLE_QUOTE_LITERAL && LA20_0 <= DOUBLE_QUOTE_LITERAL) || LA20_0 == HEX_NUMBER_LITERAL || LA20_0 == DEC_NUMBER_LITERAL || LA20_0 == IDENTIFIER || (LA20_0 >= XML_COMMENT && LA20_0 <= XML_TEXT)) )
            	        	{
            	        	    alt20 = 1;
            	        	}
            	        	switch (alt20) 
            	        	{
            	        	    case 1 :
            	        	        // AS3_ex.g3:0:0: xmlElementContent
            	        	        {
            	        	        	PushFollow(FOLLOW_xmlElementContent_in_xmlElement5594);
            	        	        	xmlElementContent30 = xmlElementContent();
            	        	        	state.followingStackPointer--;
            	        	        	if (state.failed) return retval;
            	        	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlElementContent30.Tree);

            	        	        }
            	        	        break;

            	        	}

            	        	x=(IToken)Match(input,XML_E_TEND,FOLLOW_XML_E_TEND_in_xmlElement5608); if (state.failed) return retval;
            	        	if ( state.backtracking == 0 )
            	        	{x_tree = (object)adaptor.Create(x);
            	        		adaptor.AddChild(root_0, x_tree);
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  PopIndent();
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  Emit((CommonToken)x);
            	        	}
            	        	PushFollow(FOLLOW_xmlTagName_in_xmlElement5622);
            	        	xmlTagName31 = xmlTagName();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlTagName31.Tree);
            	        	G=(IToken)Match(input,GT,FOLLOW_GT_in_xmlElement5626); if (state.failed) return retval;
            	        	if ( state.backtracking == 0 )
            	        	{G_tree = (object)adaptor.Create(G);
            	        		adaptor.AddChild(root_0, G_tree);
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  Emit((CommonToken)G);
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  EmitCRForTag(options);
            	        	}

            	        }
            	        break;

            	}

            	if ( state.backtracking == 0 ) 
            	{

            	  	    if (pushedFormat)
            	  	    	mPrinter.PopFormatMode();
            	      
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 21, xmlElement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "xmlElement"

    public class xmlAttributes_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "xmlAttributes"
    // AS3_ex.g3:1429:1: xmlAttributes : ( xmlAttribute )+ ;
    public AS3_exParser.xmlAttributes_return xmlAttributes() // throws RecognitionException [1]
    {   
        AS3_exParser.xmlAttributes_return retval = new AS3_exParser.xmlAttributes_return();
        retval.Start = input.LT(1);
        int xmlAttributes_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.xmlAttribute_return xmlAttribute32 = null;



        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 22) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1430:5: ( ( xmlAttribute )+ )
            // AS3_ex.g3:1430:9: ( xmlAttribute )+
            {
            	root_0 = (object)adaptor.GetNilNode();

            	// AS3_ex.g3:1430:9: ( xmlAttribute )+
            	int cnt22 = 0;
            	do 
            	{
            	    int alt22 = 2;
            	    int LA22_0 = input.LA(1);

            	    if ( ((LA22_0 >= AS && LA22_0 <= STATIC) || LA22_0 == IDENTIFIER) )
            	    {
            	        alt22 = 1;
            	    }


            	    switch (alt22) 
            		{
            			case 1 :
            			    // AS3_ex.g3:0:0: xmlAttribute
            			    {
            			    	PushFollow(FOLLOW_xmlAttribute_in_xmlAttributes5665);
            			    	xmlAttribute32 = xmlAttribute();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlAttribute32.Tree);

            			    }
            			    break;

            			default:
            			    if ( cnt22 >= 1 ) goto loop22;
            			    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            		            EarlyExitException eee =
            		                new EarlyExitException(22, input);
            		            throw eee;
            	    }
            	    cnt22++;
            	} while (true);

            	loop22:
            		;	// Stops C# compiler whinging that label 'loop22' has no statements


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 22, xmlAttributes_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "xmlAttributes"

    public class xmlTagName_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "xmlTagName"
    // AS3_ex.g3:1433:1: xmlTagName : ( xmlExprEval | xmlNameLiteral );
    public AS3_exParser.xmlTagName_return xmlTagName() // throws RecognitionException [1]
    {   
        AS3_exParser.xmlTagName_return retval = new AS3_exParser.xmlTagName_return();
        retval.Start = input.LT(1);
        int xmlTagName_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.xmlExprEval_return xmlExprEval33 = null;

        AS3_exParser.xmlNameLiteral_return xmlNameLiteral34 = null;



        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 23) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1434:5: ( xmlExprEval | xmlNameLiteral )
            int alt23 = 2;
            int LA23_0 = input.LA(1);

            if ( (LA23_0 == LCURLY) )
            {
                alt23 = 1;
            }
            else if ( ((LA23_0 >= AS && LA23_0 <= STATIC) || LA23_0 == IDENTIFIER) )
            {
                alt23 = 2;
            }
            else 
            {
                if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                NoViableAltException nvae_d23s0 =
                    new NoViableAltException("", 23, 0, input);

                throw nvae_d23s0;
            }
            switch (alt23) 
            {
                case 1 :
                    // AS3_ex.g3:1434:9: xmlExprEval
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_xmlExprEval_in_xmlTagName5695);
                    	xmlExprEval33 = xmlExprEval();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlExprEval33.Tree);

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:1435:4: xmlNameLiteral
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_xmlNameLiteral_in_xmlTagName5700);
                    	xmlNameLiteral34 = xmlNameLiteral();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlNameLiteral34.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 23, xmlTagName_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "xmlTagName"

    public class xmlAttribute_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "xmlAttribute"
    // AS3_ex.g3:1438:1: xmlAttribute : {...}? xmlNameLiteral A= ASSIGN ( xmlExprEval | stringLiteral ) ;
    public AS3_exParser.xmlAttribute_return xmlAttribute() // throws RecognitionException [1]
    {   
        AS3_exParser.xmlAttribute_return retval = new AS3_exParser.xmlAttribute_return();
        retval.Start = input.LT(1);
        int xmlAttribute_StartIndex = input.Index();
        object root_0 = null;

        IToken A = null;
        AS3_exParser.xmlNameLiteral_return xmlNameLiteral35 = null;

        AS3_exParser.xmlExprEval_return xmlExprEval36 = null;

        AS3_exParser.stringLiteral_return stringLiteral37 = null;


        object A_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 24) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1439:5: ({...}? xmlNameLiteral A= ASSIGN ( xmlExprEval | stringLiteral ) )
            // AS3_ex.g3:1439:8: {...}? xmlNameLiteral A= ASSIGN ( xmlExprEval | stringLiteral )
            {
            	root_0 = (object)adaptor.GetNilNode();

            	if ( !((PromoteWhitespace())) ) 
            	{
            	    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            	    throw new FailedPredicateException(input, "xmlAttribute", "PromoteWhitespace()");
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  InsertWS(1);
            	}
            	PushFollow(FOLLOW_xmlNameLiteral_in_xmlAttribute5723);
            	xmlNameLiteral35 = xmlNameLiteral();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlNameLiteral35.Tree);
            	A=(IToken)Match(input,ASSIGN,FOLLOW_ASSIGN_in_xmlAttribute5727); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{A_tree = (object)adaptor.Create(A);
            		adaptor.AddChild(root_0, A_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)A);
            	}
            	// AS3_ex.g3:1440:5: ( xmlExprEval | stringLiteral )
            	int alt24 = 2;
            	int LA24_0 = input.LA(1);

            	if ( (LA24_0 == LCURLY) )
            	{
            	    alt24 = 1;
            	}
            	else if ( ((LA24_0 >= SINGLE_QUOTE_LITERAL && LA24_0 <= DOUBLE_QUOTE_LITERAL)) )
            	{
            	    alt24 = 2;
            	}
            	else 
            	{
            	    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            	    NoViableAltException nvae_d24s0 =
            	        new NoViableAltException("", 24, 0, input);

            	    throw nvae_d24s0;
            	}
            	switch (alt24) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:1441:9: xmlExprEval
            	        {
            	        	PushFollow(FOLLOW_xmlExprEval_in_xmlAttribute5746);
            	        	xmlExprEval36 = xmlExprEval();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlExprEval36.Tree);

            	        }
            	        break;
            	    case 2 :
            	        // AS3_ex.g3:1442:11: stringLiteral
            	        {
            	        	PushFollow(FOLLOW_stringLiteral_in_xmlAttribute5758);
            	        	stringLiteral37 = stringLiteral();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, stringLiteral37.Tree);

            	        }
            	        break;

            	}


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 24, xmlAttribute_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "xmlAttribute"

    public class xmlElementContent_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "xmlElementContent"
    // AS3_ex.g3:1446:1: xmlElementContent : ( xmlElementContentHelper )+ ;
    public AS3_exParser.xmlElementContent_return xmlElementContent() // throws RecognitionException [1]
    {   
        AS3_exParser.xmlElementContent_return retval = new AS3_exParser.xmlElementContent_return();
        retval.Start = input.LT(1);
        int xmlElementContent_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.xmlElementContentHelper_return xmlElementContentHelper38 = null;



        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 25) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1447:5: ( ( xmlElementContentHelper )+ )
            // AS3_ex.g3:1447:8: ( xmlElementContentHelper )+
            {
            	root_0 = (object)adaptor.GetNilNode();

            	// AS3_ex.g3:1447:8: ( xmlElementContentHelper )+
            	int cnt25 = 0;
            	do 
            	{
            	    int alt25 = 2;
            	    int LA25_0 = input.LA(1);

            	    if ( ((LA25_0 >= AS && LA25_0 <= LTE) || (LA25_0 >= EQ && LA25_0 <= SHL) || (LA25_0 >= AND && LA25_0 <= ASSIGN) || (LA25_0 >= DIV_ASSIGN && LA25_0 <= SHL_ASSIGN) || (LA25_0 >= LAND_ASSIGN && LA25_0 <= XML_ELLIPSIS) || (LA25_0 >= XML_NS_OP && LA25_0 <= XML_AT) || (LA25_0 >= SINGLE_QUOTE_LITERAL && LA25_0 <= DOUBLE_QUOTE_LITERAL) || LA25_0 == HEX_NUMBER_LITERAL || LA25_0 == DEC_NUMBER_LITERAL || LA25_0 == IDENTIFIER || (LA25_0 >= XML_COMMENT && LA25_0 <= XML_TEXT)) )
            	    {
            	        alt25 = 1;
            	    }


            	    switch (alt25) 
            		{
            			case 1 :
            			    // AS3_ex.g3:0:0: xmlElementContentHelper
            			    {
            			    	PushFollow(FOLLOW_xmlElementContentHelper_in_xmlElementContent5789);
            			    	xmlElementContentHelper38 = xmlElementContentHelper();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlElementContentHelper38.Tree);

            			    }
            			    break;

            			default:
            			    if ( cnt25 >= 1 ) goto loop25;
            			    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            		            EarlyExitException eee =
            		                new EarlyExitException(25, input);
            		            throw eee;
            	    }
            	    cnt25++;
            	} while (true);

            	loop25:
            		;	// Stops C# compiler whinging that label 'loop25' has no statements


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 25, xmlElementContent_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "xmlElementContent"

    public class xmlElementContentHelper_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "xmlElementContentHelper"
    // AS3_ex.g3:1450:1: xmlElementContentHelper : ( xmlExprEval | xmlMarkup | xmlElement | xmlText );
    public AS3_exParser.xmlElementContentHelper_return xmlElementContentHelper() // throws RecognitionException [1]
    {   
        AS3_exParser.xmlElementContentHelper_return retval = new AS3_exParser.xmlElementContentHelper_return();
        retval.Start = input.LT(1);
        int xmlElementContentHelper_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.xmlExprEval_return xmlExprEval39 = null;

        AS3_exParser.xmlMarkup_return xmlMarkup40 = null;

        AS3_exParser.xmlElement_return xmlElement41 = null;

        AS3_exParser.xmlText_return xmlText42 = null;



        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 26) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1451:5: ( xmlExprEval | xmlMarkup | xmlElement | xmlText )
            int alt26 = 4;
            switch ( input.LA(1) ) 
            {
            case LCURLY:
            	{
                alt26 = 1;
                }
                break;
            case XML_COMMENT:
            case XML_CDATA:
            case XML_PI:
            	{
                alt26 = 2;
                }
                break;
            case LT:
            	{
                alt26 = 3;
                }
                break;
            case AS:
            case BREAK:
            case CASE:
            case CATCH:
            case CLASS:
            case CONST:
            case CONTINUE:
            case DEFAULT:
            case DELETE:
            case DO:
            case ELSE:
            case EXTENDS:
            case FALSE:
            case FINALLY:
            case FOR:
            case FUNCTION:
            case IF:
            case IMPLEMENTS:
            case IMPORT:
            case IN:
            case INSTANCEOF:
            case INTERFACE:
            case INTERNAL:
            case IS:
            case NATIVE:
            case NEW:
            case NULL:
            case PACKAGE:
            case PRIVATE:
            case PROTECTED:
            case PUBLIC:
            case RETURN:
            case SUPER:
            case SWITCH:
            case THIS:
            case THROW:
            case TO:
            case TRUE:
            case TRY:
            case TYPEOF:
            case USE:
            case VAR:
            case VOID:
            case WHILE:
            case WITH:
            case EACH:
            case GET:
            case SET:
            case NAMESPACE:
            case INCLUDE:
            case DYNAMIC:
            case FINAL:
            case OVERRIDE:
            case STATIC:
            case SEMI:
            case RCURLY:
            case LPAREN:
            case RPAREN:
            case LBRACK:
            case RBRACK:
            case DOT:
            case COMMA:
            case GT:
            case LTE:
            case EQ:
            case NEQ:
            case SAME:
            case NSAME:
            case PLUS:
            case SUB:
            case STAR:
            case DIV:
            case MOD:
            case INC:
            case DEC:
            case SHL:
            case AND:
            case OR:
            case XOR:
            case NOT:
            case INV:
            case LAND:
            case LOR:
            case QUE:
            case COLON:
            case ASSIGN:
            case DIV_ASSIGN:
            case MOD_ASSIGN:
            case ADD_ASSIGN:
            case SUB_ASSIGN:
            case SHL_ASSIGN:
            case LAND_ASSIGN:
            case LOR_ASSIGN:
            case AND_ASSIGN:
            case XOR_ASSIGN:
            case OR_ASSIGN:
            case ELLIPSIS:
            case XML_ELLIPSIS:
            case XML_NS_OP:
            case XML_AT:
            case SINGLE_QUOTE_LITERAL:
            case DOUBLE_QUOTE_LITERAL:
            case HEX_NUMBER_LITERAL:
            case DEC_NUMBER_LITERAL:
            case IDENTIFIER:
            case XML_TEXT:
            	{
                alt26 = 4;
                }
                break;
            	default:
            	    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            	    NoViableAltException nvae_d26s0 =
            	        new NoViableAltException("", 26, 0, input);

            	    throw nvae_d26s0;
            }

            switch (alt26) 
            {
                case 1 :
                    // AS3_ex.g3:1451:7: xmlExprEval
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_xmlExprEval_in_xmlElementContentHelper5807);
                    	xmlExprEval39 = xmlExprEval();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlExprEval39.Tree);

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:1452:7: xmlMarkup
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_xmlMarkup_in_xmlElementContentHelper5816);
                    	xmlMarkup40 = xmlMarkup();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlMarkup40.Tree);

                    }
                    break;
                case 3 :
                    // AS3_ex.g3:1453:7: xmlElement
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_xmlElement_in_xmlElementContentHelper5825);
                    	xmlElement41 = xmlElement();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlElement41.Tree);

                    }
                    break;
                case 4 :
                    // AS3_ex.g3:1454:7: xmlText
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	if ( state.backtracking == 0 ) 
                    	{
                    	  mPrinter.PushFormatMode(ASPrettyPrinter.FORMAT_INDENT);
                    	}
                    	PushFollow(FOLLOW_xmlText_in_xmlElementContentHelper5835);
                    	xmlText42 = xmlText();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlText42.Tree);
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  mPrinter.PopFormatMode();
                    	}

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 26, xmlElementContentHelper_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "xmlElementContentHelper"

    public class xmlListInitialiser_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "xmlListInitialiser"
    // AS3_ex.g3:1457:1: xmlListInitialiser : x= XML_LS_STD ( xmlElementContent )? x= XML_LS_END ;
    public AS3_exParser.xmlListInitialiser_return xmlListInitialiser() // throws RecognitionException [1]
    {   
        AS3_exParser.xmlListInitialiser_return retval = new AS3_exParser.xmlListInitialiser_return();
        retval.Start = input.LT(1);
        int xmlListInitialiser_StartIndex = input.Index();
        object root_0 = null;

        IToken x = null;
        AS3_exParser.xmlElementContent_return xmlElementContent43 = null;


        object x_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 27) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1458:5: (x= XML_LS_STD ( xmlElementContent )? x= XML_LS_END )
            // AS3_ex.g3:1458:9: x= XML_LS_STD ( xmlElementContent )? x= XML_LS_END
            {
            	root_0 = (object)adaptor.GetNilNode();

            	if ( state.backtracking == 0 ) 
            	{
            	  InsertCR(false);
            	}
            	x=(IToken)Match(input,XML_LS_STD,FOLLOW_XML_LS_STD_in_xmlListInitialiser5856); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{x_tree = (object)adaptor.Create(x);
            		adaptor.AddChild(root_0, x_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)x);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  InsertCR(false);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  PushIndent(true);
            	}
            	// AS3_ex.g3:1460:5: ( xmlElementContent )?
            	int alt27 = 2;
            	int LA27_0 = input.LA(1);

            	if ( ((LA27_0 >= AS && LA27_0 <= LTE) || (LA27_0 >= EQ && LA27_0 <= SHL) || (LA27_0 >= AND && LA27_0 <= ASSIGN) || (LA27_0 >= DIV_ASSIGN && LA27_0 <= SHL_ASSIGN) || (LA27_0 >= LAND_ASSIGN && LA27_0 <= XML_ELLIPSIS) || (LA27_0 >= XML_NS_OP && LA27_0 <= XML_AT) || (LA27_0 >= SINGLE_QUOTE_LITERAL && LA27_0 <= DOUBLE_QUOTE_LITERAL) || LA27_0 == HEX_NUMBER_LITERAL || LA27_0 == DEC_NUMBER_LITERAL || LA27_0 == IDENTIFIER || (LA27_0 >= XML_COMMENT && LA27_0 <= XML_TEXT)) )
            	{
            	    alt27 = 1;
            	}
            	switch (alt27) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:0:0: xmlElementContent
            	        {
            	        	PushFollow(FOLLOW_xmlElementContent_in_xmlListInitialiser5871);
            	        	xmlElementContent43 = xmlElementContent();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlElementContent43.Tree);

            	        }
            	        break;

            	}

            	if ( state.backtracking == 0 ) 
            	{
            	  InsertCR(false);
            	}
            	x=(IToken)Match(input,XML_LS_END,FOLLOW_XML_LS_END_in_xmlListInitialiser5883); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{x_tree = (object)adaptor.Create(x);
            		adaptor.AddChild(root_0, x_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  PopIndent();
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)x);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  InsertCR(false);
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 27, xmlListInitialiser_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "xmlListInitialiser"

    public class semic_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "semic"
    // AS3_ex.g3:1465:1: semic : (S= SEMI | E= EOF | R= RCURLY );
    public AS3_exParser.semic_return semic() // throws RecognitionException [1]
    {   
        AS3_exParser.semic_return retval = new AS3_exParser.semic_return();
        retval.Start = input.LT(1);
        int semic_StartIndex = input.Index();
        object root_0 = null;

        IToken S = null;
        IToken E = null;
        IToken R = null;

        object S_tree=null;
        object E_tree=null;
        object R_tree=null;


            // Mark current position so we can unconsume a RBRACE.
            int marker = input.Mark();
            // Promote EOL if appropriate
            bool onBrace=false;
            if ( ((CommonToken) retval.Start).Text!=null && ((CommonToken) retval.Start).Text.Equals("}"))
            {
            	onBrace=true;
        		if (state.backtracking>0)
        		{
        			retval.Stop=retval.Start;
        		    return retval; //we don't want to consume the '}' during the prediction phase
        		}    	
            }
            	
            if (FindVirtualHiddenToken(retval))
            {
               retval.Stop=retval.Start;
               return retval;
            }
               
         //   promoteEOL(retval);

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 28) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1490:5: (S= SEMI | E= EOF | R= RCURLY )
            int alt28 = 3;
            switch ( input.LA(1) ) 
            {
            case SEMI:
            	{
                alt28 = 1;
                }
                break;
            case EOF:
            	{
                alt28 = 2;
                }
                break;
            case RCURLY:
            	{
                alt28 = 3;
                }
                break;
            	default:
            	    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            	    NoViableAltException nvae_d28s0 =
            	        new NoViableAltException("", 28, 0, input);

            	    throw nvae_d28s0;
            }

            switch (alt28) 
            {
                case 1 :
                    // AS3_ex.g3:1490:9: S= SEMI
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	S=(IToken)Match(input,SEMI,FOLLOW_SEMI_in_semic5914); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{S_tree = (object)adaptor.Create(S);
                    		adaptor.AddChild(root_0, S_tree);
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  Emit((CommonToken)S);
                    	}

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:1491:9: E= EOF
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	E=(IToken)Match(input,EOF,FOLLOW_EOF_in_semic5928); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{E_tree = (object)adaptor.Create(E);
                    		adaptor.AddChild(root_0, E_tree);
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  Emit((CommonToken)E);
                    	}

                    }
                    break;
                case 3 :
                    // AS3_ex.g3:1492:9: R= RCURLY
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	R=(IToken)Match(input,RCURLY,FOLLOW_RCURLY_in_semic5942); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{R_tree = (object)adaptor.Create(R);
                    		adaptor.AddChild(root_0, R_tree);
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{
                    	   input.Rewind(marker); 
                    	                      if (onBrace)
                    	                           retval.Start=input.LT(-1);
                    	                   
                    	}

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 28, semic_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "semic"

    public class fileContents_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "fileContents"
    // AS3_ex.g3:1501:1: fileContents : ( ( ( packageDeclaration )? ( packageElement )* ) | EOF );
    public AS3_exParser.fileContents_return fileContents() // throws RecognitionException [1]
    {   
        AS3_exParser.fileContents_return retval = new AS3_exParser.fileContents_return();
        retval.Start = input.LT(1);
        int fileContents_StartIndex = input.Index();
        object root_0 = null;

        IToken EOF46 = null;
        AS3_exParser.packageDeclaration_return packageDeclaration44 = null;

        AS3_exParser.packageElement_return packageElement45 = null;


        object EOF46_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 29) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1502:2: ( ( ( packageDeclaration )? ( packageElement )* ) | EOF )
            int alt31 = 2;
            int LA31_0 = input.LA(1);

            if ( ((LA31_0 >= AS && LA31_0 <= LCURLY) || LA31_0 == LPAREN || LA31_0 == LBRACK || LA31_0 == LT || (LA31_0 >= PLUS && LA31_0 <= STAR) || (LA31_0 >= INC && LA31_0 <= DEC) || (LA31_0 >= NOT && LA31_0 <= INV) || (LA31_0 >= XML_AT && LA31_0 <= XML_LS_STD) || (LA31_0 >= SINGLE_QUOTE_LITERAL && LA31_0 <= DOUBLE_QUOTE_LITERAL) || LA31_0 == REGULAR_EXPR_LITERAL || LA31_0 == HEX_NUMBER_LITERAL || LA31_0 == DEC_NUMBER_LITERAL || LA31_0 == IDENTIFIER || (LA31_0 >= XML_COMMENT && LA31_0 <= XML_PI)) )
            {
                alt31 = 1;
            }
            else if ( (LA31_0 == EOF) )
            {
                int LA31_2 = input.LA(2);

                if ( (LA31_2 == EOF) )
                {
                    alt31 = 2;
                }
                else 
                {
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    NoViableAltException nvae_d31s2 =
                        new NoViableAltException("", 31, 2, input);

                    throw nvae_d31s2;
                }
            }
            else 
            {
                if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                NoViableAltException nvae_d31s0 =
                    new NoViableAltException("", 31, 0, input);

                throw nvae_d31s0;
            }
            switch (alt31) 
            {
                case 1 :
                    // AS3_ex.g3:1502:4: ( ( packageDeclaration )? ( packageElement )* )
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	// AS3_ex.g3:1502:4: ( ( packageDeclaration )? ( packageElement )* )
                    	// AS3_ex.g3:1502:5: ( packageDeclaration )? ( packageElement )*
                    	{
                    		// AS3_ex.g3:1502:5: ( packageDeclaration )?
                    		int alt29 = 2;
                    		int LA29_0 = input.LA(1);

                    		if ( (LA29_0 == PACKAGE) )
                    		{
                    		    int LA29_1 = input.LA(2);

                    		    if ( (LA29_1 == DEFAULT || LA29_1 == INTERNAL || LA29_1 == NATIVE || LA29_1 == TO || LA29_1 == VOID || (LA29_1 >= EACH && LA29_1 <= NAMESPACE) || (LA29_1 >= DYNAMIC && LA29_1 <= STATIC) || LA29_1 == LCURLY || LA29_1 == STAR || LA29_1 == IDENTIFIER) )
                    		    {
                    		        alt29 = 1;
                    		    }
                    		}
                    		switch (alt29) 
                    		{
                    		    case 1 :
                    		        // AS3_ex.g3:0:0: packageDeclaration
                    		        {
                    		        	PushFollow(FOLLOW_packageDeclaration_in_fileContents5962);
                    		        	packageDeclaration44 = packageDeclaration();
                    		        	state.followingStackPointer--;
                    		        	if (state.failed) return retval;
                    		        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, packageDeclaration44.Tree);

                    		        }
                    		        break;

                    		}

                    		// AS3_ex.g3:1502:25: ( packageElement )*
                    		do 
                    		{
                    		    int alt30 = 2;
                    		    int LA30_0 = input.LA(1);

                    		    if ( ((LA30_0 >= AS && LA30_0 <= LCURLY) || LA30_0 == LPAREN || LA30_0 == LBRACK || LA30_0 == LT || (LA30_0 >= PLUS && LA30_0 <= STAR) || (LA30_0 >= INC && LA30_0 <= DEC) || (LA30_0 >= NOT && LA30_0 <= INV) || (LA30_0 >= XML_AT && LA30_0 <= XML_LS_STD) || (LA30_0 >= SINGLE_QUOTE_LITERAL && LA30_0 <= DOUBLE_QUOTE_LITERAL) || LA30_0 == REGULAR_EXPR_LITERAL || LA30_0 == HEX_NUMBER_LITERAL || LA30_0 == DEC_NUMBER_LITERAL || LA30_0 == IDENTIFIER || (LA30_0 >= XML_COMMENT && LA30_0 <= XML_PI)) )
                    		    {
                    		        alt30 = 1;
                    		    }


                    		    switch (alt30) 
                    			{
                    				case 1 :
                    				    // AS3_ex.g3:0:0: packageElement
                    				    {
                    				    	PushFollow(FOLLOW_packageElement_in_fileContents5965);
                    				    	packageElement45 = packageElement();
                    				    	state.followingStackPointer--;
                    				    	if (state.failed) return retval;
                    				    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, packageElement45.Tree);

                    				    }
                    				    break;

                    				default:
                    				    goto loop30;
                    		    }
                    		} while (true);

                    		loop30:
                    			;	// Stops C# compiler whining that label 'loop30' has no statements


                    	}


                    }
                    break;
                case 2 :
                    // AS3_ex.g3:1502:44: EOF
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	EOF46=(IToken)Match(input,EOF,FOLLOW_EOF_in_fileContents5971); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{EOF46_tree = (object)adaptor.Create(EOF46);
                    		adaptor.AddChild(root_0, EOF46_tree);
                    	}

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 29, fileContents_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "fileContents"

    public class packageDeclaration_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "packageDeclaration"
    // AS3_ex.g3:1507:1: packageDeclaration : p= PACKAGE ( type )? l= LCURLY ( packageElement )* r= RCURLY ;
    public AS3_exParser.packageDeclaration_return packageDeclaration() // throws RecognitionException [1]
    {   
        AS3_exParser.packageDeclaration_return retval = new AS3_exParser.packageDeclaration_return();
        retval.Start = input.LT(1);
        int packageDeclaration_StartIndex = input.Index();
        object root_0 = null;

        IToken p = null;
        IToken l = null;
        IToken r = null;
        AS3_exParser.type_return type47 = null;

        AS3_exParser.packageElement_return packageElement48 = null;


        object p_tree=null;
        object l_tree=null;
        object r_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 30) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1508:2: (p= PACKAGE ( type )? l= LCURLY ( packageElement )* r= RCURLY )
            // AS3_ex.g3:1508:6: p= PACKAGE ( type )? l= LCURLY ( packageElement )* r= RCURLY
            {
            	root_0 = (object)adaptor.GetNilNode();

            	p=(IToken)Match(input,PACKAGE,FOLLOW_PACKAGE_in_packageDeclaration5988); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{p_tree = (object)adaptor.Create(p);
            		adaptor.AddChild(root_0, p_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  {InsertCR(false);}Emit((CommonToken)p);PushExpressionIndent();
            	}
            	// AS3_ex.g3:1508:82: ( type )?
            	int alt32 = 2;
            	int LA32_0 = input.LA(1);

            	if ( (LA32_0 == DEFAULT || LA32_0 == INTERNAL || LA32_0 == NATIVE || LA32_0 == TO || LA32_0 == VOID || (LA32_0 >= EACH && LA32_0 <= NAMESPACE) || (LA32_0 >= DYNAMIC && LA32_0 <= STATIC) || LA32_0 == STAR || LA32_0 == IDENTIFIER) )
            	{
            	    alt32 = 1;
            	}
            	switch (alt32) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:1508:83: type
            	        {
            	        	PushFollow(FOLLOW_type_in_packageDeclaration5993);
            	        	type47 = type();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, type47.Tree);

            	        }
            	        break;

            	}

            	if ( state.backtracking == 0 ) 
            	{
            	  PopIndent();
            	}
            	l=(IToken)Match(input,LCURLY,FOLLOW_LCURLY_in_packageDeclaration6007); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{l_tree = (object)adaptor.Create(l);
            		adaptor.AddChild(root_0, l_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{

            	  	       LeftCurlyNewlineHandler(false);
            	  	       Emit((CommonToken)l);
            	  	       if (mPrinter.IsIndentAtPackageLevel())
            	  	          PushIndent(true);
            	  	    
            	}
            	// AS3_ex.g3:1516:6: ( packageElement )*
            	do 
            	{
            	    int alt33 = 2;
            	    int LA33_0 = input.LA(1);

            	    if ( ((LA33_0 >= AS && LA33_0 <= LCURLY) || LA33_0 == LPAREN || LA33_0 == LBRACK || LA33_0 == LT || (LA33_0 >= PLUS && LA33_0 <= STAR) || (LA33_0 >= INC && LA33_0 <= DEC) || (LA33_0 >= NOT && LA33_0 <= INV) || (LA33_0 >= XML_AT && LA33_0 <= XML_LS_STD) || (LA33_0 >= SINGLE_QUOTE_LITERAL && LA33_0 <= DOUBLE_QUOTE_LITERAL) || LA33_0 == REGULAR_EXPR_LITERAL || LA33_0 == HEX_NUMBER_LITERAL || LA33_0 == DEC_NUMBER_LITERAL || LA33_0 == IDENTIFIER || (LA33_0 >= XML_COMMENT && LA33_0 <= XML_PI)) )
            	    {
            	        alt33 = 1;
            	    }


            	    switch (alt33) 
            		{
            			case 1 :
            			    // AS3_ex.g3:0:0: packageElement
            			    {
            			    	PushFollow(FOLLOW_packageElement_in_packageDeclaration6023);
            			    	packageElement48 = packageElement();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, packageElement48.Tree);

            			    }
            			    break;

            			default:
            			    goto loop33;
            	    }
            	} while (true);

            	loop33:
            		;	// Stops C# compiler whining that label 'loop33' has no statements

            	if ( state.backtracking == 0 ) 
            	{

            	  	    	if (mPrinter.IsIndentAtPackageLevel())
            	  	            PopIndent();
            	  	    
            	}
            	r=(IToken)Match(input,RCURLY,FOLLOW_RCURLY_in_packageDeclaration6042); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{r_tree = (object)adaptor.Create(r);
            		adaptor.AddChild(root_0, r_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  InsertCR(false);Emit((CommonToken)r);
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 30, packageDeclaration_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "packageDeclaration"

    public class mxmlEmbedded_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "mxmlEmbedded"
    // AS3_ex.g3:1527:1: mxmlEmbedded : ( ( propertyDeclaration | functionDeclaration | statement | directive | interfaceFunctionDeclaration )* | EOF );
    public AS3_exParser.mxmlEmbedded_return mxmlEmbedded() // throws RecognitionException [1]
    {   
        AS3_exParser.mxmlEmbedded_return retval = new AS3_exParser.mxmlEmbedded_return();
        retval.Start = input.LT(1);
        int mxmlEmbedded_StartIndex = input.Index();
        object root_0 = null;

        IToken EOF54 = null;
        AS3_exParser.propertyDeclaration_return propertyDeclaration49 = null;

        AS3_exParser.functionDeclaration_return functionDeclaration50 = null;

        AS3_exParser.statement_return statement51 = null;

        AS3_exParser.directive_return directive52 = null;

        AS3_exParser.interfaceFunctionDeclaration_return interfaceFunctionDeclaration53 = null;


        object EOF54_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 31) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1528:2: ( ( propertyDeclaration | functionDeclaration | statement | directive | interfaceFunctionDeclaration )* | EOF )
            int alt35 = 2;
            int LA35_0 = input.LA(1);

            if ( ((LA35_0 >= AS && LA35_0 <= LCURLY) || LA35_0 == LPAREN || LA35_0 == LBRACK || LA35_0 == LT || (LA35_0 >= PLUS && LA35_0 <= STAR) || (LA35_0 >= INC && LA35_0 <= DEC) || (LA35_0 >= NOT && LA35_0 <= INV) || (LA35_0 >= XML_AT && LA35_0 <= XML_LS_STD) || (LA35_0 >= SINGLE_QUOTE_LITERAL && LA35_0 <= DOUBLE_QUOTE_LITERAL) || LA35_0 == REGULAR_EXPR_LITERAL || LA35_0 == HEX_NUMBER_LITERAL || LA35_0 == DEC_NUMBER_LITERAL || LA35_0 == IDENTIFIER || (LA35_0 >= XML_COMMENT && LA35_0 <= XML_PI)) )
            {
                alt35 = 1;
            }
            else if ( (LA35_0 == EOF) )
            {
                int LA35_2 = input.LA(2);

                if ( (LA35_2 == EOF) )
                {
                    alt35 = 2;
                }
                else 
                {
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    NoViableAltException nvae_d35s2 =
                        new NoViableAltException("", 35, 2, input);

                    throw nvae_d35s2;
                }
            }
            else 
            {
                if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                NoViableAltException nvae_d35s0 =
                    new NoViableAltException("", 35, 0, input);

                throw nvae_d35s0;
            }
            switch (alt35) 
            {
                case 1 :
                    // AS3_ex.g3:1529:6: ( propertyDeclaration | functionDeclaration | statement | directive | interfaceFunctionDeclaration )*
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	// AS3_ex.g3:1529:6: ( propertyDeclaration | functionDeclaration | statement | directive | interfaceFunctionDeclaration )*
                    	do 
                    	{
                    	    int alt34 = 6;
                    	    alt34 = dfa34.Predict(input);
                    	    switch (alt34) 
                    		{
                    			case 1 :
                    			    // AS3_ex.g3:1529:7: propertyDeclaration
                    			    {
                    			    	PushFollow(FOLLOW_propertyDeclaration_in_mxmlEmbedded6067);
                    			    	propertyDeclaration49 = propertyDeclaration();
                    			    	state.followingStackPointer--;
                    			    	if (state.failed) return retval;
                    			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, propertyDeclaration49.Tree);

                    			    }
                    			    break;
                    			case 2 :
                    			    // AS3_ex.g3:1529:29: functionDeclaration
                    			    {
                    			    	PushFollow(FOLLOW_functionDeclaration_in_mxmlEmbedded6071);
                    			    	functionDeclaration50 = functionDeclaration();
                    			    	state.followingStackPointer--;
                    			    	if (state.failed) return retval;
                    			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, functionDeclaration50.Tree);

                    			    }
                    			    break;
                    			case 3 :
                    			    // AS3_ex.g3:1529:51: statement
                    			    {
                    			    	PushFollow(FOLLOW_statement_in_mxmlEmbedded6075);
                    			    	statement51 = statement();
                    			    	state.followingStackPointer--;
                    			    	if (state.failed) return retval;
                    			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, statement51.Tree);

                    			    }
                    			    break;
                    			case 4 :
                    			    // AS3_ex.g3:1529:63: directive
                    			    {
                    			    	PushFollow(FOLLOW_directive_in_mxmlEmbedded6079);
                    			    	directive52 = directive();
                    			    	state.followingStackPointer--;
                    			    	if (state.failed) return retval;
                    			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, directive52.Tree);

                    			    }
                    			    break;
                    			case 5 :
                    			    // AS3_ex.g3:1529:75: interfaceFunctionDeclaration
                    			    {
                    			    	PushFollow(FOLLOW_interfaceFunctionDeclaration_in_mxmlEmbedded6083);
                    			    	interfaceFunctionDeclaration53 = interfaceFunctionDeclaration();
                    			    	state.followingStackPointer--;
                    			    	if (state.failed) return retval;
                    			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, interfaceFunctionDeclaration53.Tree);

                    			    }
                    			    break;

                    			default:
                    			    goto loop34;
                    	    }
                    	} while (true);

                    	loop34:
                    		;	// Stops C# compiler whining that label 'loop34' has no statements


                    }
                    break;
                case 2 :
                    // AS3_ex.g3:1529:108: EOF
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	EOF54=(IToken)Match(input,EOF,FOLLOW_EOF_in_mxmlEmbedded6089); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{EOF54_tree = (object)adaptor.Create(EOF54);
                    		adaptor.AddChild(root_0, EOF54_tree);
                    	}

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 31, mxmlEmbedded_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "mxmlEmbedded"

    public class packageElement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "packageElement"
    // AS3_ex.g3:1532:1: packageElement : ( classOrInterfaceDecl | propertyDeclaration | functionDeclaration | interfaceFunctionDeclaration | statement | directive );
    public AS3_exParser.packageElement_return packageElement() // throws RecognitionException [1]
    {   
        AS3_exParser.packageElement_return retval = new AS3_exParser.packageElement_return();
        retval.Start = input.LT(1);
        int packageElement_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.classOrInterfaceDecl_return classOrInterfaceDecl55 = null;

        AS3_exParser.propertyDeclaration_return propertyDeclaration56 = null;

        AS3_exParser.functionDeclaration_return functionDeclaration57 = null;

        AS3_exParser.interfaceFunctionDeclaration_return interfaceFunctionDeclaration58 = null;

        AS3_exParser.statement_return statement59 = null;

        AS3_exParser.directive_return directive60 = null;



        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 32) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1533:5: ( classOrInterfaceDecl | propertyDeclaration | functionDeclaration | interfaceFunctionDeclaration | statement | directive )
            int alt36 = 6;
            alt36 = dfa36.Predict(input);
            switch (alt36) 
            {
                case 1 :
                    // AS3_ex.g3:1533:9: classOrInterfaceDecl
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_classOrInterfaceDecl_in_packageElement6109);
                    	classOrInterfaceDecl55 = classOrInterfaceDecl();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, classOrInterfaceDecl55.Tree);

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:1533:32: propertyDeclaration
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_propertyDeclaration_in_packageElement6113);
                    	propertyDeclaration56 = propertyDeclaration();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, propertyDeclaration56.Tree);

                    }
                    break;
                case 3 :
                    // AS3_ex.g3:1533:54: functionDeclaration
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_functionDeclaration_in_packageElement6117);
                    	functionDeclaration57 = functionDeclaration();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, functionDeclaration57.Tree);

                    }
                    break;
                case 4 :
                    // AS3_ex.g3:1533:76: interfaceFunctionDeclaration
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_interfaceFunctionDeclaration_in_packageElement6121);
                    	interfaceFunctionDeclaration58 = interfaceFunctionDeclaration();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, interfaceFunctionDeclaration58.Tree);

                    }
                    break;
                case 5 :
                    // AS3_ex.g3:1533:107: statement
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_statement_in_packageElement6125);
                    	statement59 = statement();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, statement59.Tree);

                    }
                    break;
                case 6 :
                    // AS3_ex.g3:1533:119: directive
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_directive_in_packageElement6129);
                    	directive60 = directive();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, directive60.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 32, packageElement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "packageElement"

    public class importDeclaration_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "importDeclaration"
    // AS3_ex.g3:1536:1: importDeclaration : i= IMPORT type (D= DOT S= STAR )? semic ;
    public AS3_exParser.importDeclaration_return importDeclaration() // throws RecognitionException [1]
    {   
        AS3_exParser.importDeclaration_return retval = new AS3_exParser.importDeclaration_return();
        retval.Start = input.LT(1);
        int importDeclaration_StartIndex = input.Index();
        object root_0 = null;

        IToken i = null;
        IToken D = null;
        IToken S = null;
        AS3_exParser.type_return type61 = null;

        AS3_exParser.semic_return semic62 = null;


        object i_tree=null;
        object D_tree=null;
        object S_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 33) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1537:2: (i= IMPORT type (D= DOT S= STAR )? semic )
            // AS3_ex.g3:1537:6: i= IMPORT type (D= DOT S= STAR )? semic
            {
            	root_0 = (object)adaptor.GetNilNode();

            	if ( state.backtracking == 0 ) 
            	{
            	  InsertCR(false);
            	}
            	i=(IToken)Match(input,IMPORT,FOLLOW_IMPORT_in_importDeclaration6149); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{i_tree = (object)adaptor.Create(i);
            		adaptor.AddChild(root_0, i_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)i);
            	}
            	PushFollow(FOLLOW_type_in_importDeclaration6153);
            	type61 = type();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, type61.Tree);
            	// AS3_ex.g3:1537:64: (D= DOT S= STAR )?
            	int alt37 = 2;
            	int LA37_0 = input.LA(1);

            	if ( (LA37_0 == DOT) )
            	{
            	    alt37 = 1;
            	}
            	switch (alt37) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:1537:65: D= DOT S= STAR
            	        {
            	        	D=(IToken)Match(input,DOT,FOLLOW_DOT_in_importDeclaration6158); if (state.failed) return retval;
            	        	if ( state.backtracking == 0 )
            	        	{D_tree = (object)adaptor.Create(D);
            	        		adaptor.AddChild(root_0, D_tree);
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  Emit((CommonToken)D);
            	        	}
            	        	S=(IToken)Match(input,STAR,FOLLOW_STAR_in_importDeclaration6164); if (state.failed) return retval;
            	        	if ( state.backtracking == 0 )
            	        	{S_tree = (object)adaptor.Create(S);
            	        		adaptor.AddChild(root_0, S_tree);
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  Emit((CommonToken)S);
            	        	}

            	        }
            	        break;

            	}

            	PushFollow(FOLLOW_semic_in_importDeclaration6170);
            	semic62 = semic();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, semic62.Tree);

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 33, importDeclaration_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "importDeclaration"

    public class classOrInterfaceDecl_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "classOrInterfaceDecl"
    // AS3_ex.g3:1540:1: classOrInterfaceDecl : ( conditionalDirAndBindingDecls )? ( memberModifiers )? ( interfaceDeclaration | classDeclaration ) ;
    public AS3_exParser.classOrInterfaceDecl_return classOrInterfaceDecl() // throws RecognitionException [1]
    {   
        AS3_exParser.classOrInterfaceDecl_return retval = new AS3_exParser.classOrInterfaceDecl_return();
        retval.Start = input.LT(1);
        int classOrInterfaceDecl_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.conditionalDirAndBindingDecls_return conditionalDirAndBindingDecls63 = null;

        AS3_exParser.memberModifiers_return memberModifiers64 = null;

        AS3_exParser.interfaceDeclaration_return interfaceDeclaration65 = null;

        AS3_exParser.classDeclaration_return classDeclaration66 = null;



        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 34) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1541:2: ( ( conditionalDirAndBindingDecls )? ( memberModifiers )? ( interfaceDeclaration | classDeclaration ) )
            // AS3_ex.g3:1541:6: ( conditionalDirAndBindingDecls )? ( memberModifiers )? ( interfaceDeclaration | classDeclaration )
            {
            	root_0 = (object)adaptor.GetNilNode();

            	// AS3_ex.g3:1541:6: ( conditionalDirAndBindingDecls )?
            	int alt38 = 2;
            	switch ( input.LA(1) ) 
            	{
            	    case IDENTIFIER:
            	    	{
            	        int LA38_1 = input.LA(2);

            	        if ( (LA38_1 == XML_NS_OP) )
            	        {
            	            alt38 = 1;
            	        }
            	        }
            	        break;
            	    case NATIVE:
            	    case DYNAMIC:
            	    case FINAL:
            	    case OVERRIDE:
            	    case STATIC:
            	    	{
            	        int LA38_2 = input.LA(2);

            	        if ( (LA38_2 == XML_NS_OP) )
            	        {
            	            alt38 = 1;
            	        }
            	        }
            	        break;
            	    case TO:
            	    case EACH:
            	    case GET:
            	    case SET:
            	    case NAMESPACE:
            	    	{
            	        alt38 = 1;
            	        }
            	        break;
            	}

            	switch (alt38) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:1541:7: conditionalDirAndBindingDecls
            	        {
            	        	PushFollow(FOLLOW_conditionalDirAndBindingDecls_in_classOrInterfaceDecl6185);
            	        	conditionalDirAndBindingDecls63 = conditionalDirAndBindingDecls();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, conditionalDirAndBindingDecls63.Tree);

            	        }
            	        break;

            	}

            	if ( state.backtracking == 0 ) 
            	{
            	  PushLazyIndent();
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  InsertCR(false);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  InsertLines(mPrinter.GetBlankLinesBeforeClass(), false);
            	}
            	// AS3_ex.g3:1541:135: ( memberModifiers )?
            	int alt39 = 2;
            	int LA39_0 = input.LA(1);

            	if ( (LA39_0 == INTERNAL || LA39_0 == NATIVE || (LA39_0 >= PRIVATE && LA39_0 <= PUBLIC) || (LA39_0 >= DYNAMIC && LA39_0 <= STATIC) || LA39_0 == IDENTIFIER) )
            	{
            	    alt39 = 1;
            	}
            	switch (alt39) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:0:0: memberModifiers
            	        {
            	        	PushFollow(FOLLOW_memberModifiers_in_classOrInterfaceDecl6193);
            	        	memberModifiers64 = memberModifiers();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, memberModifiers64.Tree);

            	        }
            	        break;

            	}

            	// AS3_ex.g3:1541:152: ( interfaceDeclaration | classDeclaration )
            	int alt40 = 2;
            	int LA40_0 = input.LA(1);

            	if ( (LA40_0 == INTERFACE) )
            	{
            	    alt40 = 1;
            	}
            	else if ( (LA40_0 == CLASS) )
            	{
            	    alt40 = 2;
            	}
            	else 
            	{
            	    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            	    NoViableAltException nvae_d40s0 =
            	        new NoViableAltException("", 40, 0, input);

            	    throw nvae_d40s0;
            	}
            	switch (alt40) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:1541:153: interfaceDeclaration
            	        {
            	        	PushFollow(FOLLOW_interfaceDeclaration_in_classOrInterfaceDecl6197);
            	        	interfaceDeclaration65 = interfaceDeclaration();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, interfaceDeclaration65.Tree);

            	        }
            	        break;
            	    case 2 :
            	        // AS3_ex.g3:1541:176: classDeclaration
            	        {
            	        	PushFollow(FOLLOW_classDeclaration_in_classOrInterfaceDecl6201);
            	        	classDeclaration66 = classDeclaration();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, classDeclaration66.Tree);

            	        }
            	        break;

            	}


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 34, classOrInterfaceDecl_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "classOrInterfaceDecl"

    public class directive_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "directive"
    // AS3_ex.g3:1544:1: directive : ( bindingDecl | includeDirective | useNamespaceDirective | importDeclaration | defaultXMLNamespaceDirective ) ;
    public AS3_exParser.directive_return directive() // throws RecognitionException [1]
    {   
        AS3_exParser.directive_return retval = new AS3_exParser.directive_return();
        retval.Start = input.LT(1);
        int directive_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.bindingDecl_return bindingDecl67 = null;

        AS3_exParser.includeDirective_return includeDirective68 = null;

        AS3_exParser.useNamespaceDirective_return useNamespaceDirective69 = null;

        AS3_exParser.importDeclaration_return importDeclaration70 = null;

        AS3_exParser.defaultXMLNamespaceDirective_return defaultXMLNamespaceDirective71 = null;



        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 35) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1545:2: ( ( bindingDecl | includeDirective | useNamespaceDirective | importDeclaration | defaultXMLNamespaceDirective ) )
            // AS3_ex.g3:1545:4: ( bindingDecl | includeDirective | useNamespaceDirective | importDeclaration | defaultXMLNamespaceDirective )
            {
            	root_0 = (object)adaptor.GetNilNode();

            	if ( state.backtracking == 0 ) 
            	{
            	  PushLazyIndent();
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  InsertCR(false);
            	}
            	// AS3_ex.g3:1545:41: ( bindingDecl | includeDirective | useNamespaceDirective | importDeclaration | defaultXMLNamespaceDirective )
            	int alt41 = 5;
            	switch ( input.LA(1) ) 
            	{
            	case LBRACK:
            		{
            	    alt41 = 1;
            	    }
            	    break;
            	case INCLUDE:
            		{
            	    alt41 = 2;
            	    }
            	    break;
            	case USE:
            		{
            	    alt41 = 3;
            	    }
            	    break;
            	case IMPORT:
            		{
            	    alt41 = 4;
            	    }
            	    break;
            	case DEFAULT:
            		{
            	    alt41 = 5;
            	    }
            	    break;
            		default:
            		    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            		    NoViableAltException nvae_d41s0 =
            		        new NoViableAltException("", 41, 0, input);

            		    throw nvae_d41s0;
            	}

            	switch (alt41) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:1545:42: bindingDecl
            	        {
            	        	PushFollow(FOLLOW_bindingDecl_in_directive6217);
            	        	bindingDecl67 = bindingDecl();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, bindingDecl67.Tree);

            	        }
            	        break;
            	    case 2 :
            	        // AS3_ex.g3:1545:56: includeDirective
            	        {
            	        	PushFollow(FOLLOW_includeDirective_in_directive6221);
            	        	includeDirective68 = includeDirective();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, includeDirective68.Tree);

            	        }
            	        break;
            	    case 3 :
            	        // AS3_ex.g3:1545:75: useNamespaceDirective
            	        {
            	        	PushFollow(FOLLOW_useNamespaceDirective_in_directive6225);
            	        	useNamespaceDirective69 = useNamespaceDirective();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, useNamespaceDirective69.Tree);

            	        }
            	        break;
            	    case 4 :
            	        // AS3_ex.g3:1545:99: importDeclaration
            	        {
            	        	PushFollow(FOLLOW_importDeclaration_in_directive6229);
            	        	importDeclaration70 = importDeclaration();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, importDeclaration70.Tree);

            	        }
            	        break;
            	    case 5 :
            	        // AS3_ex.g3:1545:144: defaultXMLNamespaceDirective
            	        {
            	        	PushFollow(FOLLOW_defaultXMLNamespaceDirective_in_directive6235);
            	        	defaultXMLNamespaceDirective71 = defaultXMLNamespaceDirective();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, defaultXMLNamespaceDirective71.Tree);

            	        }
            	        break;

            	}

            	if ( state.backtracking == 0 ) 
            	{
            	  PopIndent();
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 35, directive_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "directive"

    public class conditionalDirAndBindingDecls_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "conditionalDirAndBindingDecls"
    // AS3_ex.g3:1548:1: conditionalDirAndBindingDecls : conditionalCompilerOption ( bindingDecl )* ;
    public AS3_exParser.conditionalDirAndBindingDecls_return conditionalDirAndBindingDecls() // throws RecognitionException [1]
    {   
        AS3_exParser.conditionalDirAndBindingDecls_return retval = new AS3_exParser.conditionalDirAndBindingDecls_return();
        retval.Start = input.LT(1);
        int conditionalDirAndBindingDecls_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.conditionalCompilerOption_return conditionalCompilerOption72 = null;

        AS3_exParser.bindingDecl_return bindingDecl73 = null;



        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 36) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1549:2: ( conditionalCompilerOption ( bindingDecl )* )
            // AS3_ex.g3:1549:4: conditionalCompilerOption ( bindingDecl )*
            {
            	root_0 = (object)adaptor.GetNilNode();

            	if ( state.backtracking == 0 ) 
            	{
            	  InsertCR(false);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  mPrinter.MarkBindablePos(true);
            	}
            	PushFollow(FOLLOW_conditionalCompilerOption_in_conditionalDirAndBindingDecls6261);
            	conditionalCompilerOption72 = conditionalCompilerOption();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, conditionalCompilerOption72.Tree);
            	if ( state.backtracking == 0 ) 
            	{
            	  mPrinter.SetBindableMode();
            	}
            	// AS3_ex.g3:1553:4: ( bindingDecl )*
            	do 
            	{
            	    int alt42 = 2;
            	    int LA42_0 = input.LA(1);

            	    if ( (LA42_0 == LBRACK) )
            	    {
            	        alt42 = 1;
            	    }


            	    switch (alt42) 
            		{
            			case 1 :
            			    // AS3_ex.g3:1553:5: bindingDecl
            			    {
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  InsertCR(false);
            			    	}
            			    	PushFollow(FOLLOW_bindingDecl_in_conditionalDirAndBindingDecls6278);
            			    	bindingDecl73 = bindingDecl();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, bindingDecl73.Tree);

            			    }
            			    break;

            			default:
            			    goto loop42;
            	    }
            	} while (true);

            	loop42:
            		;	// Stops C# compiler whining that label 'loop42' has no statements


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 36, conditionalDirAndBindingDecls_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "conditionalDirAndBindingDecls"

    public class xmlKeyword_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "xmlKeyword"
    // AS3_ex.g3:1556:1: xmlKeyword : {...}?I= IDENTIFIER ;
    public AS3_exParser.xmlKeyword_return xmlKeyword() // throws RecognitionException [1]
    {   
        AS3_exParser.xmlKeyword_return retval = new AS3_exParser.xmlKeyword_return();
        retval.Start = input.LT(1);
        int xmlKeyword_StartIndex = input.Index();
        object root_0 = null;

        IToken I = null;

        object I_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 37) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1557:2: ({...}?I= IDENTIFIER )
            // AS3_ex.g3:1557:4: {...}?I= IDENTIFIER
            {
            	root_0 = (object)adaptor.GetNilNode();

            	if ( !((input.LT(1).Text.ToLower().Equals("xml"))) ) 
            	{
            	    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            	    throw new FailedPredicateException(input, "xmlKeyword", "input.LT(1).Text.ToLower().Equals(\"xml\")");
            	}
            	I=(IToken)Match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_xmlKeyword6296); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{I_tree = (object)adaptor.Create(I);
            		adaptor.AddChild(root_0, I_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)I);
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 37, xmlKeyword_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "xmlKeyword"

    public class conditionalCompilerOption_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "conditionalCompilerOption"
    // AS3_ex.g3:1560:1: conditionalCompilerOption : identifierLiteral x= XML_NS_OP identifierLiteral ;
    public AS3_exParser.conditionalCompilerOption_return conditionalCompilerOption() // throws RecognitionException [1]
    {   
        AS3_exParser.conditionalCompilerOption_return retval = new AS3_exParser.conditionalCompilerOption_return();
        retval.Start = input.LT(1);
        int conditionalCompilerOption_StartIndex = input.Index();
        object root_0 = null;

        IToken x = null;
        AS3_exParser.identifierLiteral_return identifierLiteral74 = null;

        AS3_exParser.identifierLiteral_return identifierLiteral75 = null;


        object x_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 38) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1561:2: ( identifierLiteral x= XML_NS_OP identifierLiteral )
            // AS3_ex.g3:1562:2: identifierLiteral x= XML_NS_OP identifierLiteral
            {
            	root_0 = (object)adaptor.GetNilNode();

            	PushFollow(FOLLOW_identifierLiteral_in_conditionalCompilerOption6312);
            	identifierLiteral74 = identifierLiteral();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, identifierLiteral74.Tree);
            	x=(IToken)Match(input,XML_NS_OP,FOLLOW_XML_NS_OP_in_conditionalCompilerOption6316); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{x_tree = (object)adaptor.Create(x);
            		adaptor.AddChild(root_0, x_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)x);
            	}
            	PushFollow(FOLLOW_identifierLiteral_in_conditionalCompilerOption6320);
            	identifierLiteral75 = identifierLiteral();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, identifierLiteral75.Tree);

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 38, conditionalCompilerOption_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "conditionalCompilerOption"

    public class defaultXMLNamespaceDirective_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "defaultXMLNamespaceDirective"
    // AS3_ex.g3:1565:1: defaultXMLNamespaceDirective : D= DEFAULT xmlKeyword N= NAMESPACE A= ASSIGN I= IDENTIFIER semic ;
    public AS3_exParser.defaultXMLNamespaceDirective_return defaultXMLNamespaceDirective() // throws RecognitionException [1]
    {   
        AS3_exParser.defaultXMLNamespaceDirective_return retval = new AS3_exParser.defaultXMLNamespaceDirective_return();
        retval.Start = input.LT(1);
        int defaultXMLNamespaceDirective_StartIndex = input.Index();
        object root_0 = null;

        IToken D = null;
        IToken N = null;
        IToken A = null;
        IToken I = null;
        AS3_exParser.xmlKeyword_return xmlKeyword76 = null;

        AS3_exParser.semic_return semic77 = null;


        object D_tree=null;
        object N_tree=null;
        object A_tree=null;
        object I_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 39) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1566:2: (D= DEFAULT xmlKeyword N= NAMESPACE A= ASSIGN I= IDENTIFIER semic )
            // AS3_ex.g3:1566:4: D= DEFAULT xmlKeyword N= NAMESPACE A= ASSIGN I= IDENTIFIER semic
            {
            	root_0 = (object)adaptor.GetNilNode();

            	D=(IToken)Match(input,DEFAULT,FOLLOW_DEFAULT_in_defaultXMLNamespaceDirective6334); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{D_tree = (object)adaptor.Create(D);
            		adaptor.AddChild(root_0, D_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)D);
            	}
            	PushFollow(FOLLOW_xmlKeyword_in_defaultXMLNamespaceDirective6338);
            	xmlKeyword76 = xmlKeyword();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlKeyword76.Tree);
            	N=(IToken)Match(input,NAMESPACE,FOLLOW_NAMESPACE_in_defaultXMLNamespaceDirective6346); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{N_tree = (object)adaptor.Create(N);
            		adaptor.AddChild(root_0, N_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)N);
            	}
            	A=(IToken)Match(input,ASSIGN,FOLLOW_ASSIGN_in_defaultXMLNamespaceDirective6354); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{A_tree = (object)adaptor.Create(A);
            		adaptor.AddChild(root_0, A_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)A);
            	}
            	I=(IToken)Match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_defaultXMLNamespaceDirective6360); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{I_tree = (object)adaptor.Create(I);
            		adaptor.AddChild(root_0, I_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)I);
            	}
            	PushFollow(FOLLOW_semic_in_defaultXMLNamespaceDirective6364);
            	semic77 = semic();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, semic77.Tree);

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 39, defaultXMLNamespaceDirective_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "defaultXMLNamespaceDirective"

    public class bindingDecl_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "bindingDecl"
    // AS3_ex.g3:1572:1: bindingDecl : L= LBRACK I= IDENTIFIER (L= LPAREN ( bindingDeclArg (C= COMMA bindingDeclArg )* )? R= RPAREN )? R= RBRACK (s= SEMI )? ;
    public AS3_exParser.bindingDecl_return bindingDecl() // throws RecognitionException [1]
    {   
        AS3_exParser.bindingDecl_return retval = new AS3_exParser.bindingDecl_return();
        retval.Start = input.LT(1);
        int bindingDecl_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        IToken I = null;
        IToken C = null;
        IToken R = null;
        IToken s = null;
        AS3_exParser.bindingDeclArg_return bindingDeclArg78 = null;

        AS3_exParser.bindingDeclArg_return bindingDeclArg79 = null;


        object L_tree=null;
        object I_tree=null;
        object C_tree=null;
        object R_tree=null;
        object s_tree=null;

        bool bindable=false;
        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 40) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1574:2: (L= LBRACK I= IDENTIFIER (L= LPAREN ( bindingDeclArg (C= COMMA bindingDeclArg )* )? R= RPAREN )? R= RBRACK (s= SEMI )? )
            // AS3_ex.g3:1574:4: L= LBRACK I= IDENTIFIER (L= LPAREN ( bindingDeclArg (C= COMMA bindingDeclArg )* )? R= RPAREN )? R= RBRACK (s= SEMI )?
            {
            	root_0 = (object)adaptor.GetNilNode();

            	L=(IToken)Match(input,LBRACK,FOLLOW_LBRACK_in_bindingDecl6384); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{L_tree = (object)adaptor.Create(L);
            		adaptor.AddChild(root_0, L_tree);
            	}
            	I=(IToken)Match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_bindingDecl6394); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{I_tree = (object)adaptor.Create(I);
            		adaptor.AddChild(root_0, I_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{

            	  		  		bindable=mPrinter.IsDirectiveForNextElement(I.Text);
            	  		  		if (bindable)
            	  		  			mPrinter.MarkBindablePos(false); //call this to mark position *before* we send any of the tokens to the printer
            	  		  		Emit((CommonToken)L); 
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)I);
            	  		  	
            	}
            	// AS3_ex.g3:1583:5: (L= LPAREN ( bindingDeclArg (C= COMMA bindingDeclArg )* )? R= RPAREN )?
            	int alt45 = 2;
            	int LA45_0 = input.LA(1);

            	if ( (LA45_0 == LPAREN) )
            	{
            	    alt45 = 1;
            	}
            	switch (alt45) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:1583:6: L= LPAREN ( bindingDeclArg (C= COMMA bindingDeclArg )* )? R= RPAREN
            	        {
            	        	L=(IToken)Match(input,LPAREN,FOLLOW_LPAREN_in_bindingDecl6420); if (state.failed) return retval;
            	        	if ( state.backtracking == 0 )
            	        	{L_tree = (object)adaptor.Create(L);
            	        		adaptor.AddChild(root_0, L_tree);
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  Emit((CommonToken)L);InsertWS(mPrinter.GetAdvancedSpacesInsideParens());
            	        	}
            	        	// AS3_ex.g3:1584:8: ( bindingDeclArg (C= COMMA bindingDeclArg )* )?
            	        	int alt44 = 2;
            	        	int LA44_0 = input.LA(1);

            	        	if ( ((LA44_0 >= AS && LA44_0 <= STATIC) || LA44_0 == STAR || LA44_0 == XML_AT || (LA44_0 >= SINGLE_QUOTE_LITERAL && LA44_0 <= DOUBLE_QUOTE_LITERAL) || LA44_0 == HEX_NUMBER_LITERAL || LA44_0 == DEC_NUMBER_LITERAL || LA44_0 == IDENTIFIER) )
            	        	{
            	        	    alt44 = 1;
            	        	}
            	        	switch (alt44) 
            	        	{
            	        	    case 1 :
            	        	        // AS3_ex.g3:1584:9: bindingDeclArg (C= COMMA bindingDeclArg )*
            	        	        {
            	        	        	PushFollow(FOLLOW_bindingDeclArg_in_bindingDecl6433);
            	        	        	bindingDeclArg78 = bindingDeclArg();
            	        	        	state.followingStackPointer--;
            	        	        	if (state.failed) return retval;
            	        	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, bindingDeclArg78.Tree);
            	        	        	// AS3_ex.g3:1584:24: (C= COMMA bindingDeclArg )*
            	        	        	do 
            	        	        	{
            	        	        	    int alt43 = 2;
            	        	        	    int LA43_0 = input.LA(1);

            	        	        	    if ( (LA43_0 == COMMA) )
            	        	        	    {
            	        	        	        alt43 = 1;
            	        	        	    }


            	        	        	    switch (alt43) 
            	        	        		{
            	        	        			case 1 :
            	        	        			    // AS3_ex.g3:1584:25: C= COMMA bindingDeclArg
            	        	        			    {
            	        	        			    	C=(IToken)Match(input,COMMA,FOLLOW_COMMA_in_bindingDecl6438); if (state.failed) return retval;
            	        	        			    	if ( state.backtracking == 0 )
            	        	        			    	{C_tree = (object)adaptor.Create(C);
            	        	        			    		adaptor.AddChild(root_0, C_tree);
            	        	        			    	}
            	        	        			    	if ( state.backtracking == 0 ) 
            	        	        			    	{
            	        	        			    	  Emit((CommonToken)C);
            	        	        			    	}
            	        	        			    	PushFollow(FOLLOW_bindingDeclArg_in_bindingDecl6442);
            	        	        			    	bindingDeclArg79 = bindingDeclArg();
            	        	        			    	state.followingStackPointer--;
            	        	        			    	if (state.failed) return retval;
            	        	        			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, bindingDeclArg79.Tree);

            	        	        			    }
            	        	        			    break;

            	        	        			default:
            	        	        			    goto loop43;
            	        	        	    }
            	        	        	} while (true);

            	        	        	loop43:
            	        	        		;	// Stops C# compiler whining that label 'loop43' has no statements


            	        	        }
            	        	        break;

            	        	}

            	        	R=(IToken)Match(input,RPAREN,FOLLOW_RPAREN_in_bindingDecl6456); if (state.failed) return retval;
            	        	if ( state.backtracking == 0 )
            	        	{R_tree = (object)adaptor.Create(R);
            	        		adaptor.AddChild(root_0, R_tree);
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  InsertWS(mPrinter.GetAdvancedSpacesInsideParens());Emit((CommonToken)R);
            	        	}

            	        }
            	        break;

            	}

            	R=(IToken)Match(input,RBRACK,FOLLOW_RBRACK_in_bindingDecl6478); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{R_tree = (object)adaptor.Create(R);
            		adaptor.AddChild(root_0, R_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)R);
            	}
            	// AS3_ex.g3:1587:38: (s= SEMI )?
            	int alt46 = 2;
            	int LA46_0 = input.LA(1);

            	if ( (LA46_0 == SEMI) )
            	{
            	    int LA46_1 = input.LA(2);

            	    if ( (synpred120_AS3_ex()) )
            	    {
            	        alt46 = 1;
            	    }
            	}
            	switch (alt46) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:1587:39: s= SEMI
            	        {
            	        	s=(IToken)Match(input,SEMI,FOLLOW_SEMI_in_bindingDecl6484); if (state.failed) return retval;
            	        	if ( state.backtracking == 0 )
            	        	{s_tree = (object)adaptor.Create(s);
            	        		adaptor.AddChild(root_0, s_tree);
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  Emit((CommonToken)s);
            	        	}

            	        }
            	        break;

            	}

            	if ( state.backtracking == 0 ) 
            	{

            	  	   	if (bindable)
            	  	   	{
            	  	   		mPrinter.SetBindableMode();
            	  	   	}
            	  	   
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 40, bindingDecl_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "bindingDecl"

    public class includeDirective_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "includeDirective"
    // AS3_ex.g3:1596:1: includeDirective : I= INCLUDE stringLiteral semic ;
    public AS3_exParser.includeDirective_return includeDirective() // throws RecognitionException [1]
    {   
        AS3_exParser.includeDirective_return retval = new AS3_exParser.includeDirective_return();
        retval.Start = input.LT(1);
        int includeDirective_StartIndex = input.Index();
        object root_0 = null;

        IToken I = null;
        AS3_exParser.stringLiteral_return stringLiteral80 = null;

        AS3_exParser.semic_return semic81 = null;


        object I_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 41) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1597:2: (I= INCLUDE stringLiteral semic )
            // AS3_ex.g3:1597:4: I= INCLUDE stringLiteral semic
            {
            	root_0 = (object)adaptor.GetNilNode();

            	I=(IToken)Match(input,INCLUDE,FOLLOW_INCLUDE_in_includeDirective6509); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{I_tree = (object)adaptor.Create(I);
            		adaptor.AddChild(root_0, I_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)I);
            	}
            	PushFollow(FOLLOW_stringLiteral_in_includeDirective6512);
            	stringLiteral80 = stringLiteral();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, stringLiteral80.Tree);
            	PushFollow(FOLLOW_semic_in_includeDirective6514);
            	semic81 = semic();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, semic81.Tree);

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 41, includeDirective_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "includeDirective"

    public class bindingDeclArg_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "bindingDeclArg"
    // AS3_ex.g3:1600:1: bindingDeclArg : (I= IDENTIFIER E= ASSIGN )? ( stringLiteral | numericLiteral | eitherIdentifier ) ;
    public AS3_exParser.bindingDeclArg_return bindingDeclArg() // throws RecognitionException [1]
    {   
        AS3_exParser.bindingDeclArg_return retval = new AS3_exParser.bindingDeclArg_return();
        retval.Start = input.LT(1);
        int bindingDeclArg_StartIndex = input.Index();
        object root_0 = null;

        IToken I = null;
        IToken E = null;
        AS3_exParser.stringLiteral_return stringLiteral82 = null;

        AS3_exParser.numericLiteral_return numericLiteral83 = null;

        AS3_exParser.eitherIdentifier_return eitherIdentifier84 = null;


        object I_tree=null;
        object E_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 42) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1601:2: ( (I= IDENTIFIER E= ASSIGN )? ( stringLiteral | numericLiteral | eitherIdentifier ) )
            // AS3_ex.g3:1608:5: (I= IDENTIFIER E= ASSIGN )? ( stringLiteral | numericLiteral | eitherIdentifier )
            {
            	root_0 = (object)adaptor.GetNilNode();

            	// AS3_ex.g3:1608:5: (I= IDENTIFIER E= ASSIGN )?
            	int alt47 = 2;
            	int LA47_0 = input.LA(1);

            	if ( (LA47_0 == IDENTIFIER) )
            	{
            	    int LA47_1 = input.LA(2);

            	    if ( (LA47_1 == ASSIGN) )
            	    {
            	        alt47 = 1;
            	    }
            	}
            	switch (alt47) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:1608:6: I= IDENTIFIER E= ASSIGN
            	        {
            	        	I=(IToken)Match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_bindingDeclArg6545); if (state.failed) return retval;
            	        	if ( state.backtracking == 0 )
            	        	{I_tree = (object)adaptor.Create(I);
            	        		adaptor.AddChild(root_0, I_tree);
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  Emit((CommonToken)I);
            	        	}
            	        	E=(IToken)Match(input,ASSIGN,FOLLOW_ASSIGN_in_bindingDeclArg6551); if (state.failed) return retval;
            	        	if ( state.backtracking == 0 )
            	        	{E_tree = (object)adaptor.Create(E);
            	        		adaptor.AddChild(root_0, E_tree);
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  Emit((CommonToken)E);
            	        	}

            	        }
            	        break;

            	}

            	// AS3_ex.g3:1609:2: ( stringLiteral | numericLiteral | eitherIdentifier )
            	int alt48 = 3;
            	switch ( input.LA(1) ) 
            	{
            	case SINGLE_QUOTE_LITERAL:
            	case DOUBLE_QUOTE_LITERAL:
            		{
            	    alt48 = 1;
            	    }
            	    break;
            	case HEX_NUMBER_LITERAL:
            	case DEC_NUMBER_LITERAL:
            		{
            	    alt48 = 2;
            	    }
            	    break;
            	case AS:
            	case BREAK:
            	case CASE:
            	case CATCH:
            	case CLASS:
            	case CONST:
            	case CONTINUE:
            	case DEFAULT:
            	case DELETE:
            	case DO:
            	case ELSE:
            	case EXTENDS:
            	case FALSE:
            	case FINALLY:
            	case FOR:
            	case FUNCTION:
            	case IF:
            	case IMPLEMENTS:
            	case IMPORT:
            	case IN:
            	case INSTANCEOF:
            	case INTERFACE:
            	case INTERNAL:
            	case IS:
            	case NATIVE:
            	case NEW:
            	case NULL:
            	case PACKAGE:
            	case PRIVATE:
            	case PROTECTED:
            	case PUBLIC:
            	case RETURN:
            	case SUPER:
            	case SWITCH:
            	case THIS:
            	case THROW:
            	case TO:
            	case TRUE:
            	case TRY:
            	case TYPEOF:
            	case USE:
            	case VAR:
            	case VOID:
            	case WHILE:
            	case WITH:
            	case EACH:
            	case GET:
            	case SET:
            	case NAMESPACE:
            	case INCLUDE:
            	case DYNAMIC:
            	case FINAL:
            	case OVERRIDE:
            	case STATIC:
            	case STAR:
            	case XML_AT:
            	case IDENTIFIER:
            		{
            	    alt48 = 3;
            	    }
            	    break;
            		default:
            		    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            		    NoViableAltException nvae_d48s0 =
            		        new NoViableAltException("", 48, 0, input);

            		    throw nvae_d48s0;
            	}

            	switch (alt48) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:1610:3: stringLiteral
            	        {
            	        	PushFollow(FOLLOW_stringLiteral_in_bindingDeclArg6564);
            	        	stringLiteral82 = stringLiteral();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, stringLiteral82.Tree);

            	        }
            	        break;
            	    case 2 :
            	        // AS3_ex.g3:1610:19: numericLiteral
            	        {
            	        	PushFollow(FOLLOW_numericLiteral_in_bindingDeclArg6568);
            	        	numericLiteral83 = numericLiteral();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, numericLiteral83.Tree);

            	        }
            	        break;
            	    case 3 :
            	        // AS3_ex.g3:1610:36: eitherIdentifier
            	        {
            	        	PushFollow(FOLLOW_eitherIdentifier_in_bindingDeclArg6572);
            	        	eitherIdentifier84 = eitherIdentifier();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, eitherIdentifier84.Tree);

            	        }
            	        break;

            	}


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 42, bindingDeclArg_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "bindingDeclArg"

    public class interfaceDeclaration_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "interfaceDeclaration"
    // AS3_ex.g3:1617:1: interfaceDeclaration : i= INTERFACE type (e= EXTENDS typeList )? interfaceBody ;
    public AS3_exParser.interfaceDeclaration_return interfaceDeclaration() // throws RecognitionException [1]
    {   
        AS3_exParser.interfaceDeclaration_return retval = new AS3_exParser.interfaceDeclaration_return();
        retval.Start = input.LT(1);
        int interfaceDeclaration_StartIndex = input.Index();
        object root_0 = null;

        IToken i = null;
        IToken e = null;
        AS3_exParser.type_return type85 = null;

        AS3_exParser.typeList_return typeList86 = null;

        AS3_exParser.interfaceBody_return interfaceBody87 = null;


        object i_tree=null;
        object e_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 43) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1618:2: (i= INTERFACE type (e= EXTENDS typeList )? interfaceBody )
            // AS3_ex.g3:1618:6: i= INTERFACE type (e= EXTENDS typeList )? interfaceBody
            {
            	root_0 = (object)adaptor.GetNilNode();

            	i=(IToken)Match(input,INTERFACE,FOLLOW_INTERFACE_in_interfaceDeclaration6594); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{i_tree = (object)adaptor.Create(i);
            		adaptor.AddChild(root_0, i_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)i);
            	}
            	PushFollow(FOLLOW_type_in_interfaceDeclaration6598);
            	type85 = type();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, type85.Tree);
            	// AS3_ex.g3:1618:48: (e= EXTENDS typeList )?
            	int alt49 = 2;
            	int LA49_0 = input.LA(1);

            	if ( (LA49_0 == EXTENDS) )
            	{
            	    alt49 = 1;
            	}
            	switch (alt49) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:1618:49: e= EXTENDS typeList
            	        {
            	        	e=(IToken)Match(input,EXTENDS,FOLLOW_EXTENDS_in_interfaceDeclaration6603); if (state.failed) return retval;
            	        	if ( state.backtracking == 0 )
            	        	{e_tree = (object)adaptor.Create(e);
            	        		adaptor.AddChild(root_0, e_tree);
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  Emit((CommonToken)e);
            	        	}
            	        	PushFollow(FOLLOW_typeList_in_interfaceDeclaration6607);
            	        	typeList86 = typeList();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, typeList86.Tree);

            	        }
            	        break;

            	}

            	if ( state.backtracking == 0 ) 
            	{
            	  PopIndent();
            	}
            	PushFollow(FOLLOW_interfaceBody_in_interfaceDeclaration6621);
            	interfaceBody87 = interfaceBody();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, interfaceBody87.Tree);

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 43, interfaceDeclaration_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "interfaceDeclaration"

    public class interfaceBody_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "interfaceBody"
    // AS3_ex.g3:1622:1: interfaceBody : l= LCURLY ( interfaceElement )* r= RCURLY ;
    public AS3_exParser.interfaceBody_return interfaceBody() // throws RecognitionException [1]
    {   
        AS3_exParser.interfaceBody_return retval = new AS3_exParser.interfaceBody_return();
        retval.Start = input.LT(1);
        int interfaceBody_StartIndex = input.Index();
        object root_0 = null;

        IToken l = null;
        IToken r = null;
        AS3_exParser.interfaceElement_return interfaceElement88 = null;


        object l_tree=null;
        object r_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 44) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1623:2: (l= LCURLY ( interfaceElement )* r= RCURLY )
            // AS3_ex.g3:1623:6: l= LCURLY ( interfaceElement )* r= RCURLY
            {
            	root_0 = (object)adaptor.GetNilNode();

            	l=(IToken)Match(input,LCURLY,FOLLOW_LCURLY_in_interfaceBody6637); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{l_tree = (object)adaptor.Create(l);
            		adaptor.AddChild(root_0, l_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{

            	  	    	LeftCurlyNewlineHandler(false);
            	  	    	Emit((CommonToken)l);PushIndent(true);
            	  	    
            	}
            	// AS3_ex.g3:1628:6: ( interfaceElement )*
            	do 
            	{
            	    int alt50 = 2;
            	    int LA50_0 = input.LA(1);

            	    if ( ((LA50_0 >= AS && LA50_0 <= LCURLY) || LA50_0 == LPAREN || LA50_0 == LBRACK || LA50_0 == LT || (LA50_0 >= PLUS && LA50_0 <= STAR) || (LA50_0 >= INC && LA50_0 <= DEC) || (LA50_0 >= NOT && LA50_0 <= INV) || (LA50_0 >= XML_AT && LA50_0 <= XML_LS_STD) || (LA50_0 >= SINGLE_QUOTE_LITERAL && LA50_0 <= DOUBLE_QUOTE_LITERAL) || LA50_0 == REGULAR_EXPR_LITERAL || LA50_0 == HEX_NUMBER_LITERAL || LA50_0 == DEC_NUMBER_LITERAL || LA50_0 == IDENTIFIER || (LA50_0 >= XML_COMMENT && LA50_0 <= XML_PI)) )
            	    {
            	        alt50 = 1;
            	    }


            	    switch (alt50) 
            		{
            			case 1 :
            			    // AS3_ex.g3:0:0: interfaceElement
            			    {
            			    	PushFollow(FOLLOW_interfaceElement_in_interfaceBody6653);
            			    	interfaceElement88 = interfaceElement();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, interfaceElement88.Tree);

            			    }
            			    break;

            			default:
            			    goto loop50;
            	    }
            	} while (true);

            	loop50:
            		;	// Stops C# compiler whining that label 'loop50' has no statements

            	if ( state.backtracking == 0 ) 
            	{
            	  PopIndent();
            	}
            	r=(IToken)Match(input,RCURLY,FOLLOW_RCURLY_in_interfaceBody6672); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{r_tree = (object)adaptor.Create(r);
            		adaptor.AddChild(root_0, r_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  InsertCR(false);Emit((CommonToken)r);
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 44, interfaceBody_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "interfaceBody"

    public class classDeclaration_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "classDeclaration"
    // AS3_ex.g3:1633:1: classDeclaration : c= CLASS type (E= EXTENDS type )? (I= IMPLEMENTS typeList )? classBody ;
    public AS3_exParser.classDeclaration_return classDeclaration() // throws RecognitionException [1]
    {   
        AS3_exParser.classDeclaration_return retval = new AS3_exParser.classDeclaration_return();
        retval.Start = input.LT(1);
        int classDeclaration_StartIndex = input.Index();
        object root_0 = null;

        IToken c = null;
        IToken E = null;
        IToken I = null;
        AS3_exParser.type_return type89 = null;

        AS3_exParser.type_return type90 = null;

        AS3_exParser.typeList_return typeList91 = null;

        AS3_exParser.classBody_return classBody92 = null;


        object c_tree=null;
        object E_tree=null;
        object I_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 45) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1634:2: (c= CLASS type (E= EXTENDS type )? (I= IMPLEMENTS typeList )? classBody )
            // AS3_ex.g3:1634:6: c= CLASS type (E= EXTENDS type )? (I= IMPLEMENTS typeList )? classBody
            {
            	root_0 = (object)adaptor.GetNilNode();

            	c=(IToken)Match(input,CLASS,FOLLOW_CLASS_in_classDeclaration6690); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{c_tree = (object)adaptor.Create(c);
            		adaptor.AddChild(root_0, c_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)c);
            	}
            	PushFollow(FOLLOW_type_in_classDeclaration6694);
            	type89 = type();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, type89.Tree);
            	// AS3_ex.g3:1634:44: (E= EXTENDS type )?
            	int alt51 = 2;
            	int LA51_0 = input.LA(1);

            	if ( (LA51_0 == EXTENDS) )
            	{
            	    alt51 = 1;
            	}
            	switch (alt51) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:1634:46: E= EXTENDS type
            	        {
            	        	E=(IToken)Match(input,EXTENDS,FOLLOW_EXTENDS_in_classDeclaration6700); if (state.failed) return retval;
            	        	if ( state.backtracking == 0 )
            	        	{E_tree = (object)adaptor.Create(E);
            	        		adaptor.AddChild(root_0, E_tree);
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  Emit((CommonToken)E);
            	        	}
            	        	PushFollow(FOLLOW_type_in_classDeclaration6704);
            	        	type90 = type();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, type90.Tree);

            	        }
            	        break;

            	}

            	// AS3_ex.g3:1634:88: (I= IMPLEMENTS typeList )?
            	int alt52 = 2;
            	int LA52_0 = input.LA(1);

            	if ( (LA52_0 == IMPLEMENTS) )
            	{
            	    alt52 = 1;
            	}
            	switch (alt52) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:1634:90: I= IMPLEMENTS typeList
            	        {
            	        	I=(IToken)Match(input,IMPLEMENTS,FOLLOW_IMPLEMENTS_in_classDeclaration6712); if (state.failed) return retval;
            	        	if ( state.backtracking == 0 )
            	        	{I_tree = (object)adaptor.Create(I);
            	        		adaptor.AddChild(root_0, I_tree);
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  Emit((CommonToken)I);
            	        	}
            	        	PushFollow(FOLLOW_typeList_in_classDeclaration6716);
            	        	typeList91 = typeList();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, typeList91.Tree);

            	        }
            	        break;

            	}

            	if ( state.backtracking == 0 ) 
            	{
            	  PopIndent();
            	}
            	PushFollow(FOLLOW_classBody_in_classDeclaration6730);
            	classBody92 = classBody();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, classBody92.Tree);

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 45, classDeclaration_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "classDeclaration"

    public class classBody_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "classBody"
    // AS3_ex.g3:1640:1: classBody : L= LCURLY ( classBodyElement )* R= RCURLY ;
    public AS3_exParser.classBody_return classBody() // throws RecognitionException [1]
    {   
        AS3_exParser.classBody_return retval = new AS3_exParser.classBody_return();
        retval.Start = input.LT(1);
        int classBody_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        IToken R = null;
        AS3_exParser.classBodyElement_return classBodyElement93 = null;


        object L_tree=null;
        object R_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 46) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1641:2: (L= LCURLY ( classBodyElement )* R= RCURLY )
            // AS3_ex.g3:1641:6: L= LCURLY ( classBodyElement )* R= RCURLY
            {
            	root_0 = (object)adaptor.GetNilNode();

            	L=(IToken)Match(input,LCURLY,FOLLOW_LCURLY_in_classBody6759); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{L_tree = (object)adaptor.Create(L);
            		adaptor.AddChild(root_0, L_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{

            	  			LeftCurlyNewlineHandler(false);
            	  			Emit((CommonToken)L);PushIndent(true);
            	  		
            	}
            	// AS3_ex.g3:1646:3: ( classBodyElement )*
            	do 
            	{
            	    int alt53 = 2;
            	    int LA53_0 = input.LA(1);

            	    if ( ((LA53_0 >= AS && LA53_0 <= LCURLY) || LA53_0 == LPAREN || LA53_0 == LBRACK || LA53_0 == LT || (LA53_0 >= PLUS && LA53_0 <= STAR) || (LA53_0 >= INC && LA53_0 <= DEC) || (LA53_0 >= NOT && LA53_0 <= INV) || (LA53_0 >= XML_AT && LA53_0 <= XML_LS_STD) || (LA53_0 >= SINGLE_QUOTE_LITERAL && LA53_0 <= DOUBLE_QUOTE_LITERAL) || LA53_0 == REGULAR_EXPR_LITERAL || LA53_0 == HEX_NUMBER_LITERAL || LA53_0 == DEC_NUMBER_LITERAL || LA53_0 == IDENTIFIER || (LA53_0 >= XML_COMMENT && LA53_0 <= XML_PI)) )
            	    {
            	        alt53 = 1;
            	    }


            	    switch (alt53) 
            		{
            			case 1 :
            			    // AS3_ex.g3:0:0: classBodyElement
            			    {
            			    	PushFollow(FOLLOW_classBodyElement_in_classBody6769);
            			    	classBodyElement93 = classBodyElement();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, classBodyElement93.Tree);

            			    }
            			    break;

            			default:
            			    goto loop53;
            	    }
            	} while (true);

            	loop53:
            		;	// Stops C# compiler whining that label 'loop53' has no statements

            	if ( state.backtracking == 0 ) 
            	{
            	  PopIndent();
            	}
            	R=(IToken)Match(input,RCURLY,FOLLOW_RCURLY_in_classBody6782); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{R_tree = (object)adaptor.Create(R);
            		adaptor.AddChild(root_0, R_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  InsertCR(false);Emit((CommonToken)R);
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 46, classBody_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "classBody"

    public class classBodyElement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "classBodyElement"
    // AS3_ex.g3:1655:1: classBodyElement : ( propertyDeclaration | functionDeclaration | statement | directive );
    public AS3_exParser.classBodyElement_return classBodyElement() // throws RecognitionException [1]
    {   
        AS3_exParser.classBodyElement_return retval = new AS3_exParser.classBodyElement_return();
        retval.Start = input.LT(1);
        int classBodyElement_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.propertyDeclaration_return propertyDeclaration94 = null;

        AS3_exParser.functionDeclaration_return functionDeclaration95 = null;

        AS3_exParser.statement_return statement96 = null;

        AS3_exParser.directive_return directive97 = null;



        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 47) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1656:5: ( propertyDeclaration | functionDeclaration | statement | directive )
            int alt54 = 4;
            alt54 = dfa54.Predict(input);
            switch (alt54) 
            {
                case 1 :
                    // AS3_ex.g3:1656:9: propertyDeclaration
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_propertyDeclaration_in_classBodyElement6806);
                    	propertyDeclaration94 = propertyDeclaration();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, propertyDeclaration94.Tree);

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:1656:31: functionDeclaration
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_functionDeclaration_in_classBodyElement6810);
                    	functionDeclaration95 = functionDeclaration();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, functionDeclaration95.Tree);

                    }
                    break;
                case 3 :
                    // AS3_ex.g3:1656:53: statement
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_statement_in_classBodyElement6814);
                    	statement96 = statement();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, statement96.Tree);

                    }
                    break;
                case 4 :
                    // AS3_ex.g3:1656:65: directive
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_directive_in_classBodyElement6818);
                    	directive97 = directive();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, directive97.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 47, classBodyElement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "classBodyElement"

    public class interfaceElement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "interfaceElement"
    // AS3_ex.g3:1659:1: interfaceElement : ( propertyDeclaration | interfaceFunctionDeclaration | statement | directive );
    public AS3_exParser.interfaceElement_return interfaceElement() // throws RecognitionException [1]
    {   
        AS3_exParser.interfaceElement_return retval = new AS3_exParser.interfaceElement_return();
        retval.Start = input.LT(1);
        int interfaceElement_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.propertyDeclaration_return propertyDeclaration98 = null;

        AS3_exParser.interfaceFunctionDeclaration_return interfaceFunctionDeclaration99 = null;

        AS3_exParser.statement_return statement100 = null;

        AS3_exParser.directive_return directive101 = null;



        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 48) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1660:5: ( propertyDeclaration | interfaceFunctionDeclaration | statement | directive )
            int alt55 = 4;
            alt55 = dfa55.Predict(input);
            switch (alt55) 
            {
                case 1 :
                    // AS3_ex.g3:1660:9: propertyDeclaration
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_propertyDeclaration_in_interfaceElement6835);
                    	propertyDeclaration98 = propertyDeclaration();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, propertyDeclaration98.Tree);

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:1660:31: interfaceFunctionDeclaration
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_interfaceFunctionDeclaration_in_interfaceElement6839);
                    	interfaceFunctionDeclaration99 = interfaceFunctionDeclaration();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, interfaceFunctionDeclaration99.Tree);

                    }
                    break;
                case 3 :
                    // AS3_ex.g3:1660:62: statement
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_statement_in_interfaceElement6843);
                    	statement100 = statement();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, statement100.Tree);

                    }
                    break;
                case 4 :
                    // AS3_ex.g3:1660:73: directive
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_directive_in_interfaceElement6846);
                    	directive101 = directive();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, directive101.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 48, interfaceElement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "interfaceElement"

    public class interfaceFunctionDeclaration_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "interfaceFunctionDeclaration"
    // AS3_ex.g3:1669:1: interfaceFunctionDeclaration : ( conditionalDirAndBindingDecls )? ( memberModifiers )? F= FUNCTION (S= SET | G= GET )? (I= IDENTIFIER | notQuiteReservedWord ) formalParameterList (C= COLON type )? semic ;
    public AS3_exParser.interfaceFunctionDeclaration_return interfaceFunctionDeclaration() // throws RecognitionException [1]
    {   
        AS3_exParser.interfaceFunctionDeclaration_return retval = new AS3_exParser.interfaceFunctionDeclaration_return();
        retval.Start = input.LT(1);
        int interfaceFunctionDeclaration_StartIndex = input.Index();
        object root_0 = null;

        IToken F = null;
        IToken S = null;
        IToken G = null;
        IToken I = null;
        IToken C = null;
        AS3_exParser.conditionalDirAndBindingDecls_return conditionalDirAndBindingDecls102 = null;

        AS3_exParser.memberModifiers_return memberModifiers103 = null;

        AS3_exParser.notQuiteReservedWord_return notQuiteReservedWord104 = null;

        AS3_exParser.formalParameterList_return formalParameterList105 = null;

        AS3_exParser.type_return type106 = null;

        AS3_exParser.semic_return semic107 = null;


        object F_tree=null;
        object S_tree=null;
        object G_tree=null;
        object I_tree=null;
        object C_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 49) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1670:5: ( ( conditionalDirAndBindingDecls )? ( memberModifiers )? F= FUNCTION (S= SET | G= GET )? (I= IDENTIFIER | notQuiteReservedWord ) formalParameterList (C= COLON type )? semic )
            // AS3_ex.g3:1670:10: ( conditionalDirAndBindingDecls )? ( memberModifiers )? F= FUNCTION (S= SET | G= GET )? (I= IDENTIFIER | notQuiteReservedWord ) formalParameterList (C= COLON type )? semic
            {
            	root_0 = (object)adaptor.GetNilNode();

            	// AS3_ex.g3:1670:10: ( conditionalDirAndBindingDecls )?
            	int alt56 = 2;
            	switch ( input.LA(1) ) 
            	{
            	    case IDENTIFIER:
            	    	{
            	        int LA56_1 = input.LA(2);

            	        if ( (LA56_1 == XML_NS_OP) )
            	        {
            	            alt56 = 1;
            	        }
            	        }
            	        break;
            	    case NATIVE:
            	    case DYNAMIC:
            	    case FINAL:
            	    case OVERRIDE:
            	    case STATIC:
            	    	{
            	        int LA56_2 = input.LA(2);

            	        if ( (LA56_2 == XML_NS_OP) )
            	        {
            	            alt56 = 1;
            	        }
            	        }
            	        break;
            	    case TO:
            	    case EACH:
            	    case GET:
            	    case SET:
            	    case NAMESPACE:
            	    	{
            	        alt56 = 1;
            	        }
            	        break;
            	}

            	switch (alt56) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:1670:11: conditionalDirAndBindingDecls
            	        {
            	        	PushFollow(FOLLOW_conditionalDirAndBindingDecls_in_interfaceFunctionDeclaration6876);
            	        	conditionalDirAndBindingDecls102 = conditionalDirAndBindingDecls();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, conditionalDirAndBindingDecls102.Tree);

            	        }
            	        break;

            	}

            	if ( state.backtracking == 0 ) 
            	{
            	  InsertCR(false);
            	}
            	// AS3_ex.g3:1670:62: ( memberModifiers )?
            	int alt57 = 2;
            	int LA57_0 = input.LA(1);

            	if ( (LA57_0 == INTERNAL || LA57_0 == NATIVE || (LA57_0 >= PRIVATE && LA57_0 <= PUBLIC) || (LA57_0 >= DYNAMIC && LA57_0 <= STATIC) || LA57_0 == IDENTIFIER) )
            	{
            	    alt57 = 1;
            	}
            	switch (alt57) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:0:0: memberModifiers
            	        {
            	        	PushFollow(FOLLOW_memberModifiers_in_interfaceFunctionDeclaration6882);
            	        	memberModifiers103 = memberModifiers();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, memberModifiers103.Tree);

            	        }
            	        break;

            	}

            	F=(IToken)Match(input,FUNCTION,FOLLOW_FUNCTION_in_interfaceFunctionDeclaration6887); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{F_tree = (object)adaptor.Create(F);
            		adaptor.AddChild(root_0, F_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)F);
            	}
            	// AS3_ex.g3:1672:5: (S= SET | G= GET )?
            	int alt58 = 3;
            	int LA58_0 = input.LA(1);

            	if ( (LA58_0 == SET) )
            	{
            	    int LA58_1 = input.LA(2);

            	    if ( (LA58_1 == NATIVE || LA58_1 == TO || (LA58_1 >= EACH && LA58_1 <= NAMESPACE) || (LA58_1 >= DYNAMIC && LA58_1 <= STATIC) || LA58_1 == IDENTIFIER) )
            	    {
            	        alt58 = 1;
            	    }
            	}
            	else if ( (LA58_0 == GET) )
            	{
            	    int LA58_2 = input.LA(2);

            	    if ( (LA58_2 == NATIVE || LA58_2 == TO || (LA58_2 >= EACH && LA58_2 <= NAMESPACE) || (LA58_2 >= DYNAMIC && LA58_2 <= STATIC) || LA58_2 == IDENTIFIER) )
            	    {
            	        alt58 = 2;
            	    }
            	}
            	switch (alt58) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:1672:6: S= SET
            	        {
            	        	S=(IToken)Match(input,SET,FOLLOW_SET_in_interfaceFunctionDeclaration6906); if (state.failed) return retval;
            	        	if ( state.backtracking == 0 )
            	        	{S_tree = (object)adaptor.Create(S);
            	        		adaptor.AddChild(root_0, S_tree);
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  Emit((CommonToken)S);
            	        	}

            	        }
            	        break;
            	    case 2 :
            	        // AS3_ex.g3:1672:38: G= GET
            	        {
            	        	G=(IToken)Match(input,GET,FOLLOW_GET_in_interfaceFunctionDeclaration6913); if (state.failed) return retval;
            	        	if ( state.backtracking == 0 )
            	        	{G_tree = (object)adaptor.Create(G);
            	        		adaptor.AddChild(root_0, G_tree);
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  Emit((CommonToken)G);
            	        	}

            	        }
            	        break;

            	}

            	// AS3_ex.g3:1673:5: (I= IDENTIFIER | notQuiteReservedWord )
            	int alt59 = 2;
            	int LA59_0 = input.LA(1);

            	if ( (LA59_0 == IDENTIFIER) )
            	{
            	    alt59 = 1;
            	}
            	else if ( (LA59_0 == NATIVE || LA59_0 == TO || (LA59_0 >= EACH && LA59_0 <= NAMESPACE) || (LA59_0 >= DYNAMIC && LA59_0 <= STATIC)) )
            	{
            	    alt59 = 2;
            	}
            	else 
            	{
            	    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            	    NoViableAltException nvae_d59s0 =
            	        new NoViableAltException("", 59, 0, input);

            	    throw nvae_d59s0;
            	}
            	switch (alt59) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:1673:6: I= IDENTIFIER
            	        {
            	        	I=(IToken)Match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_interfaceFunctionDeclaration6927); if (state.failed) return retval;
            	        	if ( state.backtracking == 0 )
            	        	{I_tree = (object)adaptor.Create(I);
            	        		adaptor.AddChild(root_0, I_tree);
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  Emit((CommonToken)I);
            	        	}

            	        }
            	        break;
            	    case 2 :
            	        // AS3_ex.g3:1673:46: notQuiteReservedWord
            	        {
            	        	PushFollow(FOLLOW_notQuiteReservedWord_in_interfaceFunctionDeclaration6933);
            	        	notQuiteReservedWord104 = notQuiteReservedWord();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, notQuiteReservedWord104.Tree);

            	        }
            	        break;

            	}

            	PushFollow(FOLLOW_formalParameterList_in_interfaceFunctionDeclaration6936);
            	formalParameterList105 = formalParameterList();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, formalParameterList105.Tree);
            	// AS3_ex.g3:1673:88: (C= COLON type )?
            	int alt60 = 2;
            	int LA60_0 = input.LA(1);

            	if ( (LA60_0 == COLON) )
            	{
            	    alt60 = 1;
            	}
            	switch (alt60) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:1673:89: C= COLON type
            	        {
            	        	C=(IToken)Match(input,COLON,FOLLOW_COLON_in_interfaceFunctionDeclaration6941); if (state.failed) return retval;
            	        	if ( state.backtracking == 0 )
            	        	{C_tree = (object)adaptor.Create(C);
            	        		adaptor.AddChild(root_0, C_tree);
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  InsertWS(mPrinter.GetAdvancedSpacesBeforeColons()); Emit((CommonToken)C);InsertWS(mPrinter.GetAdvancedSpacesAfterColons());
            	        	}
            	        	PushFollow(FOLLOW_type_in_interfaceFunctionDeclaration6945);
            	        	type106 = type();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, type106.Tree);

            	        }
            	        break;

            	}

            	PushFollow(FOLLOW_semic_in_interfaceFunctionDeclaration6949);
            	semic107 = semic();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, semic107.Tree);

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 49, interfaceFunctionDeclaration_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "interfaceFunctionDeclaration"

    public class propertyDeclaration_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "propertyDeclaration"
    // AS3_ex.g3:1680:1: propertyDeclaration : ( conditionalDirAndBindingDecls )? ( memberModifiers )? ( variableStatement | constantVarStatement | namespaceDirective ) ;
    public AS3_exParser.propertyDeclaration_return propertyDeclaration() // throws RecognitionException [1]
    {   
        AS3_exParser.propertyDeclaration_return retval = new AS3_exParser.propertyDeclaration_return();
        retval.Start = input.LT(1);
        int propertyDeclaration_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.conditionalDirAndBindingDecls_return conditionalDirAndBindingDecls108 = null;

        AS3_exParser.memberModifiers_return memberModifiers109 = null;

        AS3_exParser.variableStatement_return variableStatement110 = null;

        AS3_exParser.constantVarStatement_return constantVarStatement111 = null;

        AS3_exParser.namespaceDirective_return namespaceDirective112 = null;



        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 50) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1681:2: ( ( conditionalDirAndBindingDecls )? ( memberModifiers )? ( variableStatement | constantVarStatement | namespaceDirective ) )
            // AS3_ex.g3:1681:7: ( conditionalDirAndBindingDecls )? ( memberModifiers )? ( variableStatement | constantVarStatement | namespaceDirective )
            {
            	root_0 = (object)adaptor.GetNilNode();

            	if ( state.backtracking == 0 ) 
            	{
            	  InsertLines(mPrinter.GetBlankLinesBeforeProperties());
            	}
            	// AS3_ex.g3:1681:64: ( conditionalDirAndBindingDecls )?
            	int alt61 = 2;
            	switch ( input.LA(1) ) 
            	{
            	    case IDENTIFIER:
            	    	{
            	        int LA61_1 = input.LA(2);

            	        if ( (LA61_1 == XML_NS_OP) )
            	        {
            	            alt61 = 1;
            	        }
            	        }
            	        break;
            	    case NATIVE:
            	    case DYNAMIC:
            	    case FINAL:
            	    case OVERRIDE:
            	    case STATIC:
            	    	{
            	        int LA61_2 = input.LA(2);

            	        if ( (LA61_2 == XML_NS_OP) )
            	        {
            	            alt61 = 1;
            	        }
            	        }
            	        break;
            	    case NAMESPACE:
            	    	{
            	        int LA61_3 = input.LA(2);

            	        if ( (LA61_3 == XML_NS_OP) )
            	        {
            	            alt61 = 1;
            	        }
            	        }
            	        break;
            	    case TO:
            	    case EACH:
            	    case GET:
            	    case SET:
            	    	{
            	        alt61 = 1;
            	        }
            	        break;
            	}

            	switch (alt61) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:1681:65: conditionalDirAndBindingDecls
            	        {
            	        	PushFollow(FOLLOW_conditionalDirAndBindingDecls_in_propertyDeclaration6973);
            	        	conditionalDirAndBindingDecls108 = conditionalDirAndBindingDecls();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, conditionalDirAndBindingDecls108.Tree);

            	        }
            	        break;

            	}

            	if ( state.backtracking == 0 ) 
            	{
            	  InsertCR(false);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  PushLazyIndent();
            	}
            	// AS3_ex.g3:1681:135: ( memberModifiers )?
            	int alt62 = 2;
            	int LA62_0 = input.LA(1);

            	if ( (LA62_0 == IDENTIFIER) )
            	{
            	    int LA62_1 = input.LA(2);

            	    if ( (synpred142_AS3_ex()) )
            	    {
            	        alt62 = 1;
            	    }
            	}
            	else if ( (LA62_0 == INTERNAL || LA62_0 == NATIVE || (LA62_0 >= PRIVATE && LA62_0 <= PUBLIC) || (LA62_0 >= DYNAMIC && LA62_0 <= STATIC)) )
            	{
            	    alt62 = 1;
            	}
            	switch (alt62) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:0:0: memberModifiers
            	        {
            	        	PushFollow(FOLLOW_memberModifiers_in_propertyDeclaration6980);
            	        	memberModifiers109 = memberModifiers();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, memberModifiers109.Tree);

            	        }
            	        break;

            	}

            	// AS3_ex.g3:1681:152: ( variableStatement | constantVarStatement | namespaceDirective )
            	int alt63 = 3;
            	switch ( input.LA(1) ) 
            	{
            	case VAR:
            	case IDENTIFIER:
            		{
            	    alt63 = 1;
            	    }
            	    break;
            	case CONST:
            		{
            	    alt63 = 2;
            	    }
            	    break;
            	case NAMESPACE:
            		{
            	    alt63 = 3;
            	    }
            	    break;
            		default:
            		    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            		    NoViableAltException nvae_d63s0 =
            		        new NoViableAltException("", 63, 0, input);

            		    throw nvae_d63s0;
            	}

            	switch (alt63) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:1681:153: variableStatement
            	        {
            	        	PushFollow(FOLLOW_variableStatement_in_propertyDeclaration6984);
            	        	variableStatement110 = variableStatement();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, variableStatement110.Tree);

            	        }
            	        break;
            	    case 2 :
            	        // AS3_ex.g3:1681:173: constantVarStatement
            	        {
            	        	PushFollow(FOLLOW_constantVarStatement_in_propertyDeclaration6988);
            	        	constantVarStatement111 = constantVarStatement();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, constantVarStatement111.Tree);

            	        }
            	        break;
            	    case 3 :
            	        // AS3_ex.g3:1681:196: namespaceDirective
            	        {
            	        	PushFollow(FOLLOW_namespaceDirective_in_propertyDeclaration6992);
            	        	namespaceDirective112 = namespaceDirective();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, namespaceDirective112.Tree);

            	        }
            	        break;

            	}

            	if ( state.backtracking == 0 ) 
            	{
            	  PopIndent();
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 50, propertyDeclaration_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "propertyDeclaration"

    public class functionDeclaration_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "functionDeclaration"
    // AS3_ex.g3:1688:1: functionDeclaration : ( conditionalDirAndBindingDecls )? ( memberModifiers )? F= FUNCTION (funcType= ( SET | GET ) )? (I= IDENTIFIER | notQuiteReservedWord ) formalParameterList (C= COLON type )? functionBody ;
    public AS3_exParser.functionDeclaration_return functionDeclaration() // throws RecognitionException [1]
    {   
        AS3_exParser.functionDeclaration_return retval = new AS3_exParser.functionDeclaration_return();
        retval.Start = input.LT(1);
        int functionDeclaration_StartIndex = input.Index();
        object root_0 = null;

        IToken F = null;
        IToken funcType = null;
        IToken I = null;
        IToken C = null;
        AS3_exParser.conditionalDirAndBindingDecls_return conditionalDirAndBindingDecls113 = null;

        AS3_exParser.memberModifiers_return memberModifiers114 = null;

        AS3_exParser.notQuiteReservedWord_return notQuiteReservedWord115 = null;

        AS3_exParser.formalParameterList_return formalParameterList116 = null;

        AS3_exParser.type_return type117 = null;

        AS3_exParser.functionBody_return functionBody118 = null;


        object F_tree=null;
        object funcType_tree=null;
        object I_tree=null;
        object C_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 51) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1689:5: ( ( conditionalDirAndBindingDecls )? ( memberModifiers )? F= FUNCTION (funcType= ( SET | GET ) )? (I= IDENTIFIER | notQuiteReservedWord ) formalParameterList (C= COLON type )? functionBody )
            // AS3_ex.g3:1689:10: ( conditionalDirAndBindingDecls )? ( memberModifiers )? F= FUNCTION (funcType= ( SET | GET ) )? (I= IDENTIFIER | notQuiteReservedWord ) formalParameterList (C= COLON type )? functionBody
            {
            	root_0 = (object)adaptor.GetNilNode();

            	// AS3_ex.g3:1689:10: ( conditionalDirAndBindingDecls )?
            	int alt64 = 2;
            	switch ( input.LA(1) ) 
            	{
            	    case IDENTIFIER:
            	    	{
            	        int LA64_1 = input.LA(2);

            	        if ( (LA64_1 == XML_NS_OP) )
            	        {
            	            alt64 = 1;
            	        }
            	        }
            	        break;
            	    case NATIVE:
            	    case DYNAMIC:
            	    case FINAL:
            	    case OVERRIDE:
            	    case STATIC:
            	    	{
            	        int LA64_2 = input.LA(2);

            	        if ( (LA64_2 == XML_NS_OP) )
            	        {
            	            alt64 = 1;
            	        }
            	        }
            	        break;
            	    case TO:
            	    case EACH:
            	    case GET:
            	    case SET:
            	    case NAMESPACE:
            	    	{
            	        alt64 = 1;
            	        }
            	        break;
            	}

            	switch (alt64) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:1689:11: conditionalDirAndBindingDecls
            	        {
            	        	PushFollow(FOLLOW_conditionalDirAndBindingDecls_in_functionDeclaration7017);
            	        	conditionalDirAndBindingDecls113 = conditionalDirAndBindingDecls();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, conditionalDirAndBindingDecls113.Tree);

            	        }
            	        break;

            	}

            	if ( state.backtracking == 0 ) 
            	{
            	  PushLazyIndent();
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  InsertCR(false);InsertLines(mPrinter.GetBlankLinesBeforeFunction());
            	}
            	// AS3_ex.g3:1689:133: ( memberModifiers )?
            	int alt65 = 2;
            	int LA65_0 = input.LA(1);

            	if ( (LA65_0 == INTERNAL || LA65_0 == NATIVE || (LA65_0 >= PRIVATE && LA65_0 <= PUBLIC) || (LA65_0 >= DYNAMIC && LA65_0 <= STATIC) || LA65_0 == IDENTIFIER) )
            	{
            	    alt65 = 1;
            	}
            	switch (alt65) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:0:0: memberModifiers
            	        {
            	        	PushFollow(FOLLOW_memberModifiers_in_functionDeclaration7024);
            	        	memberModifiers114 = memberModifiers();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, memberModifiers114.Tree);

            	        }
            	        break;

            	}

            	F=(IToken)Match(input,FUNCTION,FOLLOW_FUNCTION_in_functionDeclaration7029); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{F_tree = (object)adaptor.Create(F);
            		adaptor.AddChild(root_0, F_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)F);
            	}
            	// AS3_ex.g3:1690:5: (funcType= ( SET | GET ) )?
            	int alt66 = 2;
            	int LA66_0 = input.LA(1);

            	if ( ((LA66_0 >= GET && LA66_0 <= SET)) )
            	{
            	    int LA66_1 = input.LA(2);

            	    if ( (LA66_1 == NATIVE || LA66_1 == TO || (LA66_1 >= EACH && LA66_1 <= NAMESPACE) || (LA66_1 >= DYNAMIC && LA66_1 <= STATIC) || LA66_1 == IDENTIFIER) )
            	    {
            	        alt66 = 1;
            	    }
            	}
            	switch (alt66) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:1690:6: funcType= ( SET | GET )
            	        {
            	        	funcType = (IToken)input.LT(1);
            	        	if ( (input.LA(1) >= GET && input.LA(1) <= SET) ) 
            	        	{
            	        	    input.Consume();
            	        	    if ( state.backtracking == 0 ) adaptor.AddChild(root_0, (object)adaptor.Create(funcType));
            	        	    state.errorRecovery = false;state.failed = false;
            	        	}
            	        	else 
            	        	{
            	        	    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            	        	    MismatchedSetException mse = new MismatchedSetException(null,input);
            	        	    throw mse;
            	        	}

            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  Emit((CommonToken)funcType);
            	        	}

            	        }
            	        break;

            	}

            	// AS3_ex.g3:1691:5: (I= IDENTIFIER | notQuiteReservedWord )
            	int alt67 = 2;
            	int LA67_0 = input.LA(1);

            	if ( (LA67_0 == IDENTIFIER) )
            	{
            	    alt67 = 1;
            	}
            	else if ( (LA67_0 == NATIVE || LA67_0 == TO || (LA67_0 >= EACH && LA67_0 <= NAMESPACE) || (LA67_0 >= DYNAMIC && LA67_0 <= STATIC)) )
            	{
            	    alt67 = 2;
            	}
            	else 
            	{
            	    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            	    NoViableAltException nvae_d67s0 =
            	        new NoViableAltException("", 67, 0, input);

            	    throw nvae_d67s0;
            	}
            	switch (alt67) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:1691:6: I= IDENTIFIER
            	        {
            	        	I=(IToken)Match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_functionDeclaration7058); if (state.failed) return retval;
            	        	if ( state.backtracking == 0 )
            	        	{I_tree = (object)adaptor.Create(I);
            	        		adaptor.AddChild(root_0, I_tree);
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  Emit((CommonToken)I);
            	        	}

            	        }
            	        break;
            	    case 2 :
            	        // AS3_ex.g3:1691:46: notQuiteReservedWord
            	        {
            	        	PushFollow(FOLLOW_notQuiteReservedWord_in_functionDeclaration7064);
            	        	notQuiteReservedWord115 = notQuiteReservedWord();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, notQuiteReservedWord115.Tree);

            	        }
            	        break;

            	}

            	PushFollow(FOLLOW_formalParameterList_in_functionDeclaration7067);
            	formalParameterList116 = formalParameterList();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, formalParameterList116.Tree);
            	// AS3_ex.g3:1691:88: (C= COLON type )?
            	int alt68 = 2;
            	int LA68_0 = input.LA(1);

            	if ( (LA68_0 == COLON) )
            	{
            	    alt68 = 1;
            	}
            	switch (alt68) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:1691:89: C= COLON type
            	        {
            	        	C=(IToken)Match(input,COLON,FOLLOW_COLON_in_functionDeclaration7072); if (state.failed) return retval;
            	        	if ( state.backtracking == 0 )
            	        	{C_tree = (object)adaptor.Create(C);
            	        		adaptor.AddChild(root_0, C_tree);
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  InsertWS(mPrinter.GetAdvancedSpacesBeforeColons());Emit((CommonToken)C);InsertWS(mPrinter.GetAdvancedSpacesAfterColons());
            	        	}
            	        	PushFollow(FOLLOW_type_in_functionDeclaration7076);
            	        	type117 = type();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, type117.Tree);

            	        }
            	        break;

            	}

            	if ( state.backtracking == 0 ) 
            	{
            	  PopIndent();
            	}
            	PushFollow(FOLLOW_functionBody_in_functionDeclaration7082);
            	functionBody118 = functionBody();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, functionBody118.Tree);

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 51, functionDeclaration_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "functionDeclaration"

    public class functionExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "functionExpression"
    // AS3_ex.g3:1694:1: functionExpression : F= FUNCTION (I= IDENTIFIER )? formalParameterList (C= COLON type )? functionBody ;
    public AS3_exParser.functionExpression_return functionExpression() // throws RecognitionException [1]
    {   
        AS3_exParser.functionExpression_return retval = new AS3_exParser.functionExpression_return();
        retval.Start = input.LT(1);
        int functionExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken F = null;
        IToken I = null;
        IToken C = null;
        AS3_exParser.formalParameterList_return formalParameterList119 = null;

        AS3_exParser.type_return type120 = null;

        AS3_exParser.functionBody_return functionBody121 = null;


        object F_tree=null;
        object I_tree=null;
        object C_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 52) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1697:5: (F= FUNCTION (I= IDENTIFIER )? formalParameterList (C= COLON type )? functionBody )
            // AS3_ex.g3:1697:9: F= FUNCTION (I= IDENTIFIER )? formalParameterList (C= COLON type )? functionBody
            {
            	root_0 = (object)adaptor.GetNilNode();

            	F=(IToken)Match(input,FUNCTION,FOLLOW_FUNCTION_in_functionExpression7110); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{F_tree = (object)adaptor.Create(F);
            		adaptor.AddChild(root_0, F_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)F);
            	}
            	// AS3_ex.g3:1697:45: (I= IDENTIFIER )?
            	int alt69 = 2;
            	int LA69_0 = input.LA(1);

            	if ( (LA69_0 == IDENTIFIER) )
            	{
            	    alt69 = 1;
            	}
            	switch (alt69) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:1697:46: I= IDENTIFIER
            	        {
            	        	I=(IToken)Match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_functionExpression7117); if (state.failed) return retval;
            	        	if ( state.backtracking == 0 )
            	        	{I_tree = (object)adaptor.Create(I);
            	        		adaptor.AddChild(root_0, I_tree);
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  Emit((CommonToken)I);
            	        	}

            	        }
            	        break;

            	}

            	PushFollow(FOLLOW_formalParameterList_in_functionExpression7122);
            	formalParameterList119 = formalParameterList();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, formalParameterList119.Tree);
            	// AS3_ex.g3:1697:105: (C= COLON type )?
            	int alt70 = 2;
            	int LA70_0 = input.LA(1);

            	if ( (LA70_0 == COLON) )
            	{
            	    alt70 = 1;
            	}
            	switch (alt70) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:1697:106: C= COLON type
            	        {
            	        	C=(IToken)Match(input,COLON,FOLLOW_COLON_in_functionExpression7127); if (state.failed) return retval;
            	        	if ( state.backtracking == 0 )
            	        	{C_tree = (object)adaptor.Create(C);
            	        		adaptor.AddChild(root_0, C_tree);
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  InsertWS(mPrinter.GetAdvancedSpacesBeforeColons());Emit((CommonToken)C);InsertWS(mPrinter.GetAdvancedSpacesAfterColons());
            	        	}
            	        	PushFollow(FOLLOW_type_in_functionExpression7131);
            	        	type120 = type();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, type120.Tree);

            	        }
            	        break;

            	}

            	if ( state.backtracking == 0 ) 
            	{
            	  PopIndent();
            	}
            	PushFollow(FOLLOW_functionBody_in_functionExpression7137);
            	functionBody121 = functionBody();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, functionBody121.Tree);
            	if ( state.backtracking == 0 ) 
            	{
            	  PushExpressionIndent();
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 52, functionExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "functionExpression"

    public class formalParameterList_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "formalParameterList"
    // AS3_ex.g3:1701:1: formalParameterList : L= LPAREN ( ( variableDeclaration (C= COMMA variableDeclaration )* (C= COMMA formalEllipsisParameter )? ) | formalEllipsisParameter )? R= RPAREN ;
    public AS3_exParser.formalParameterList_return formalParameterList() // throws RecognitionException [1]
    {   
        AS3_exParser.formalParameterList_return retval = new AS3_exParser.formalParameterList_return();
        retval.Start = input.LT(1);
        int formalParameterList_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        IToken C = null;
        IToken R = null;
        AS3_exParser.variableDeclaration_return variableDeclaration122 = null;

        AS3_exParser.variableDeclaration_return variableDeclaration123 = null;

        AS3_exParser.formalEllipsisParameter_return formalEllipsisParameter124 = null;

        AS3_exParser.formalEllipsisParameter_return formalEllipsisParameter125 = null;


        object L_tree=null;
        object C_tree=null;
        object R_tree=null;


        	WrapOptions options=mPrinter.GetMethodDeclWrapOptions();
        	bool pushedFormat=false;
        	bool pushedIndent=false;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 53) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1708:5: (L= LPAREN ( ( variableDeclaration (C= COMMA variableDeclaration )* (C= COMMA formalEllipsisParameter )? ) | formalEllipsisParameter )? R= RPAREN )
            // AS3_ex.g3:1709:3: L= LPAREN ( ( variableDeclaration (C= COMMA variableDeclaration )* (C= COMMA formalEllipsisParameter )? ) | formalEllipsisParameter )? R= RPAREN
            {
            	root_0 = (object)adaptor.GetNilNode();

            	if ( state.backtracking == 0 ) 
            	{

            	  			pushedFormat=PushFormatType(options, false);
            	  			mPrinter.SetInParameterDecl(true);
            	  		
            	}
            	L=(IToken)Match(input,LPAREN,FOLLOW_LPAREN_in_formalParameterList7180); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{L_tree = (object)adaptor.Create(L);
            		adaptor.AddChild(root_0, L_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)L);InsertWS(mPrinter.GetAdvancedSpacesInsideParens());
            	}
            	// AS3_ex.g3:1714:9: ( ( variableDeclaration (C= COMMA variableDeclaration )* (C= COMMA formalEllipsisParameter )? ) | formalEllipsisParameter )?
            	int alt73 = 3;
            	int LA73_0 = input.LA(1);

            	if ( (LA73_0 == NATIVE || LA73_0 == TO || (LA73_0 >= EACH && LA73_0 <= NAMESPACE) || (LA73_0 >= DYNAMIC && LA73_0 <= STATIC) || LA73_0 == IDENTIFIER) )
            	{
            	    alt73 = 1;
            	}
            	else if ( (LA73_0 == ELLIPSIS) )
            	{
            	    alt73 = 2;
            	}
            	switch (alt73) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:1714:11: ( variableDeclaration (C= COMMA variableDeclaration )* (C= COMMA formalEllipsisParameter )? )
            	        {
            	        	// AS3_ex.g3:1714:11: ( variableDeclaration (C= COMMA variableDeclaration )* (C= COMMA formalEllipsisParameter )? )
            	        	// AS3_ex.g3:1714:13: variableDeclaration (C= COMMA variableDeclaration )* (C= COMMA formalEllipsisParameter )?
            	        	{
            	        		if ( state.backtracking == 0 ) 
            	        		{
            	        		  pushedIndent=PushLazyParmIndent(pushedIndent, options.IndentStyle);
            	        		}
            	        		PushFollow(FOLLOW_variableDeclaration_in_formalParameterList7199);
            	        		variableDeclaration122 = variableDeclaration();
            	        		state.followingStackPointer--;
            	        		if (state.failed) return retval;
            	        		if ( state.backtracking == 0 ) adaptor.AddChild(root_0, variableDeclaration122.Tree);
            	        		// AS3_ex.g3:1715:13: (C= COMMA variableDeclaration )*
            	        		do 
            	        		{
            	        		    int alt71 = 2;
            	        		    int LA71_0 = input.LA(1);

            	        		    if ( (LA71_0 == COMMA) )
            	        		    {
            	        		        int LA71_1 = input.LA(2);

            	        		        if ( (LA71_1 == NATIVE || LA71_1 == TO || (LA71_1 >= EACH && LA71_1 <= NAMESPACE) || (LA71_1 >= DYNAMIC && LA71_1 <= STATIC) || LA71_1 == IDENTIFIER) )
            	        		        {
            	        		            alt71 = 1;
            	        		        }


            	        		    }


            	        		    switch (alt71) 
            	        			{
            	        				case 1 :
            	        				    // AS3_ex.g3:1716:16: C= COMMA variableDeclaration
            	        				    {
            	        				    	C=(IToken)Match(input,COMMA,FOLLOW_COMMA_in_formalParameterList7234); if (state.failed) return retval;
            	        				    	if ( state.backtracking == 0 )
            	        				    	{C_tree = (object)adaptor.Create(C);
            	        				    		adaptor.AddChild(root_0, C_tree);
            	        				    	}
            	        				    	if ( state.backtracking == 0 ) 
            	        				    	{
            	        				    	  pushedIndent=EmitCommaWithSpacingAndCRs(options, (CommonToken) C, pushedIndent);
            	        				    	}
            	        				    	PushFollow(FOLLOW_variableDeclaration_in_formalParameterList7269);
            	        				    	variableDeclaration123 = variableDeclaration();
            	        				    	state.followingStackPointer--;
            	        				    	if (state.failed) return retval;
            	        				    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, variableDeclaration123.Tree);

            	        				    }
            	        				    break;

            	        				default:
            	        				    goto loop71;
            	        		    }
            	        		} while (true);

            	        		loop71:
            	        			;	// Stops C# compiler whining that label 'loop71' has no statements

            	        		// AS3_ex.g3:1720:13: (C= COMMA formalEllipsisParameter )?
            	        		int alt72 = 2;
            	        		int LA72_0 = input.LA(1);

            	        		if ( (LA72_0 == COMMA) )
            	        		{
            	        		    alt72 = 1;
            	        		}
            	        		switch (alt72) 
            	        		{
            	        		    case 1 :
            	        		        // AS3_ex.g3:1720:15: C= COMMA formalEllipsisParameter
            	        		        {
            	        		        	if ( state.backtracking == 0 ) 
            	        		        	{
            	        		        	  InsertWS(mPrinter.GetSpacesBeforeComma());
            	        		        	}
            	        		        	C=(IToken)Match(input,COMMA,FOLLOW_COMMA_in_formalParameterList7306); if (state.failed) return retval;
            	        		        	if ( state.backtracking == 0 )
            	        		        	{C_tree = (object)adaptor.Create(C);
            	        		        		adaptor.AddChild(root_0, C_tree);
            	        		        	}
            	        		        	if ( state.backtracking == 0 ) 
            	        		        	{
            	        		        	  Emit((CommonToken)C);
            	        		        	}
            	        		        	if ( state.backtracking == 0 ) 
            	        		        	{
            	        		        	  InsertWS(mPrinter.GetSpacesAfterComma());
            	        		        	}
            	        		        	PushFollow(FOLLOW_formalEllipsisParameter_in_formalParameterList7312);
            	        		        	formalEllipsisParameter124 = formalEllipsisParameter();
            	        		        	state.followingStackPointer--;
            	        		        	if (state.failed) return retval;
            	        		        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, formalEllipsisParameter124.Tree);

            	        		        }
            	        		        break;

            	        		}


            	        	}


            	        }
            	        break;
            	    case 2 :
            	        // AS3_ex.g3:1722:14: formalEllipsisParameter
            	        {
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  pushedIndent=PushLazyParmIndent(pushedIndent, options.IndentStyle);
            	        	}
            	        	PushFollow(FOLLOW_formalEllipsisParameter_in_formalParameterList7344);
            	        	formalEllipsisParameter125 = formalEllipsisParameter();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, formalEllipsisParameter125.Tree);

            	        }
            	        break;

            	}

            	R=(IToken)Match(input,RPAREN,FOLLOW_RPAREN_in_formalParameterList7368); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{R_tree = (object)adaptor.Create(R);
            		adaptor.AddChild(root_0, R_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  InsertWS(mPrinter.GetAdvancedSpacesInsideParens());Emit((CommonToken)R);
            	}
            	if ( state.backtracking == 0 ) 
            	{

            	          	 mPrinter.SetInParameterDecl(false);
            	  	        if (pushedIndent)
            	      	    	PopIndent();
            	      	    if (pushedFormat)
            	      	    	mPrinter.PopFormatMode();
            	          
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 53, formalParameterList_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "formalParameterList"

    public class formalEllipsisParameter_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "formalEllipsisParameter"
    // AS3_ex.g3:1735:1: formalEllipsisParameter : E= ELLIPSIS variableIdentifierDecl ;
    public AS3_exParser.formalEllipsisParameter_return formalEllipsisParameter() // throws RecognitionException [1]
    {   
        AS3_exParser.formalEllipsisParameter_return retval = new AS3_exParser.formalEllipsisParameter_return();
        retval.Start = input.LT(1);
        int formalEllipsisParameter_StartIndex = input.Index();
        object root_0 = null;

        IToken E = null;
        AS3_exParser.variableIdentifierDecl_return variableIdentifierDecl126 = null;


        object E_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 54) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1736:5: (E= ELLIPSIS variableIdentifierDecl )
            // AS3_ex.g3:1736:9: E= ELLIPSIS variableIdentifierDecl
            {
            	root_0 = (object)adaptor.GetNilNode();

            	E=(IToken)Match(input,ELLIPSIS,FOLLOW_ELLIPSIS_in_formalEllipsisParameter7415); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{E_tree = (object)adaptor.Create(E);
            		adaptor.AddChild(root_0, E_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)E);InsertWS(1);
            	}
            	PushFollow(FOLLOW_variableIdentifierDecl_in_formalEllipsisParameter7420);
            	variableIdentifierDecl126 = variableIdentifierDecl();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, variableIdentifierDecl126.Tree);

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 54, formalEllipsisParameter_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "formalEllipsisParameter"

    public class functionBody_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "functionBody"
    // AS3_ex.g3:1739:1: functionBody : L= LCURLY ( statement | functionDeclaration )* R= RCURLY ;
    public AS3_exParser.functionBody_return functionBody() // throws RecognitionException [1]
    {   
        AS3_exParser.functionBody_return retval = new AS3_exParser.functionBody_return();
        retval.Start = input.LT(1);
        int functionBody_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        IToken R = null;
        AS3_exParser.statement_return statement127 = null;

        AS3_exParser.functionDeclaration_return functionDeclaration128 = null;


        object L_tree=null;
        object R_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 55) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1740:5: (L= LCURLY ( statement | functionDeclaration )* R= RCURLY )
            // AS3_ex.g3:1740:9: L= LCURLY ( statement | functionDeclaration )* R= RCURLY
            {
            	root_0 = (object)adaptor.GetNilNode();

            	L=(IToken)Match(input,LCURLY,FOLLOW_LCURLY_in_functionBody7444); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{L_tree = (object)adaptor.Create(L);
            		adaptor.AddChild(root_0, L_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{

            	      		LeftCurlyNewlineHandler(false);
            	      		Emit((CommonToken)L);PushIndent(true);
            	      	
            	}
            	// AS3_ex.g3:1745:7: ( statement | functionDeclaration )*
            	do 
            	{
            	    int alt74 = 3;
            	    alt74 = dfa74.Predict(input);
            	    switch (alt74) 
            		{
            			case 1 :
            			    // AS3_ex.g3:1745:8: statement
            			    {
            			    	PushFollow(FOLLOW_statement_in_functionBody7462);
            			    	statement127 = statement();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, statement127.Tree);

            			    }
            			    break;
            			case 2 :
            			    // AS3_ex.g3:1745:18: functionDeclaration
            			    {
            			    	PushFollow(FOLLOW_functionDeclaration_in_functionBody7464);
            			    	functionDeclaration128 = functionDeclaration();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, functionDeclaration128.Tree);

            			    }
            			    break;

            			default:
            			    goto loop74;
            	    }
            	} while (true);

            	loop74:
            		;	// Stops C# compiler whining that label 'loop74' has no statements

            	if ( state.backtracking == 0 ) 
            	{
            	  PopIndent();
            	}
            	R=(IToken)Match(input,RCURLY,FOLLOW_RCURLY_in_functionBody7478); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{R_tree = (object)adaptor.Create(R);
            		adaptor.AddChild(root_0, R_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  InsertCR(false);Emit((CommonToken)R);
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 55, functionBody_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "functionBody"

    public class memberModifiers_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "memberModifiers"
    // AS3_ex.g3:1753:1: memberModifiers : ( memberModifier )+ ;
    public AS3_exParser.memberModifiers_return memberModifiers() // throws RecognitionException [1]
    {   
        AS3_exParser.memberModifiers_return retval = new AS3_exParser.memberModifiers_return();
        retval.Start = input.LT(1);
        int memberModifiers_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.memberModifier_return memberModifier129 = null;



        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 56) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1754:5: ( ( memberModifier )+ )
            // AS3_ex.g3:1754:9: ( memberModifier )+
            {
            	root_0 = (object)adaptor.GetNilNode();

            	// AS3_ex.g3:1754:9: ( memberModifier )+
            	int cnt75 = 0;
            	do 
            	{
            	    int alt75 = 2;
            	    int LA75_0 = input.LA(1);

            	    if ( (LA75_0 == IDENTIFIER) )
            	    {
            	        int LA75_2 = input.LA(2);

            	        if ( (synpred159_AS3_ex()) )
            	        {
            	            alt75 = 1;
            	        }


            	    }
            	    else if ( (LA75_0 == INTERNAL || LA75_0 == NATIVE || (LA75_0 >= PRIVATE && LA75_0 <= PUBLIC) || (LA75_0 >= DYNAMIC && LA75_0 <= STATIC)) )
            	    {
            	        alt75 = 1;
            	    }


            	    switch (alt75) 
            		{
            			case 1 :
            			    // AS3_ex.g3:0:0: memberModifier
            			    {
            			    	PushFollow(FOLLOW_memberModifier_in_memberModifiers7506);
            			    	memberModifier129 = memberModifier();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, memberModifier129.Tree);

            			    }
            			    break;

            			default:
            			    if ( cnt75 >= 1 ) goto loop75;
            			    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            		            EarlyExitException eee =
            		                new EarlyExitException(75, input);
            		            throw eee;
            	    }
            	    cnt75++;
            	} while (true);

            	loop75:
            		;	// Stops C# compiler whinging that label 'loop75' has no statements


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 56, memberModifiers_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "memberModifiers"

    public class memberModifier_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "memberModifier"
    // AS3_ex.g3:1761:1: memberModifier : x= ( DYNAMIC | FINAL | INTERNAL | NATIVE | OVERRIDE | PRIVATE | PROTECTED | PUBLIC | STATIC | IDENTIFIER ) ;
    public AS3_exParser.memberModifier_return memberModifier() // throws RecognitionException [1]
    {   
        AS3_exParser.memberModifier_return retval = new AS3_exParser.memberModifier_return();
        retval.Start = input.LT(1);
        int memberModifier_StartIndex = input.Index();
        object root_0 = null;

        IToken x = null;

        object x_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 57) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1762:5: (x= ( DYNAMIC | FINAL | INTERNAL | NATIVE | OVERRIDE | PRIVATE | PROTECTED | PUBLIC | STATIC | IDENTIFIER ) )
            // AS3_ex.g3:1762:9: x= ( DYNAMIC | FINAL | INTERNAL | NATIVE | OVERRIDE | PRIVATE | PROTECTED | PUBLIC | STATIC | IDENTIFIER )
            {
            	root_0 = (object)adaptor.GetNilNode();

            	x = (IToken)input.LT(1);
            	if ( input.LA(1) == INTERNAL || input.LA(1) == NATIVE || (input.LA(1) >= PRIVATE && input.LA(1) <= PUBLIC) || (input.LA(1) >= DYNAMIC && input.LA(1) <= STATIC) || input.LA(1) == IDENTIFIER ) 
            	{
            	    input.Consume();
            	    if ( state.backtracking == 0 ) adaptor.AddChild(root_0, (object)adaptor.Create(x));
            	    state.errorRecovery = false;state.failed = false;
            	}
            	else 
            	{
            	    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            	    MismatchedSetException mse = new MismatchedSetException(null,input);
            	    throw mse;
            	}

            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)x);
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 57, memberModifier_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "memberModifier"

    public class statement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "statement"
    // AS3_ex.g3:1783:1: statement : ( blockStatement | directive | namespaceDirective | expression semic | constantVarStatement | tryStatement | labelledStatement | switchStatement | withStatement | returnStatement | breakStatement | continueStatement | forStatement | forInStatement | forEachInStatement | doWhileStatement | whileStatement | ifStatement | emptyStatement | variableStatement | throwStatement );
    public AS3_exParser.statement_return statement() // throws RecognitionException [1]
    {   
        AS3_exParser.statement_return retval = new AS3_exParser.statement_return();
        retval.Start = input.LT(1);
        int statement_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.blockStatement_return blockStatement130 = null;

        AS3_exParser.directive_return directive131 = null;

        AS3_exParser.namespaceDirective_return namespaceDirective132 = null;

        AS3_exParser.expression_return expression133 = null;

        AS3_exParser.semic_return semic134 = null;

        AS3_exParser.constantVarStatement_return constantVarStatement135 = null;

        AS3_exParser.tryStatement_return tryStatement136 = null;

        AS3_exParser.labelledStatement_return labelledStatement137 = null;

        AS3_exParser.switchStatement_return switchStatement138 = null;

        AS3_exParser.withStatement_return withStatement139 = null;

        AS3_exParser.returnStatement_return returnStatement140 = null;

        AS3_exParser.breakStatement_return breakStatement141 = null;

        AS3_exParser.continueStatement_return continueStatement142 = null;

        AS3_exParser.forStatement_return forStatement143 = null;

        AS3_exParser.forInStatement_return forInStatement144 = null;

        AS3_exParser.forEachInStatement_return forEachInStatement145 = null;

        AS3_exParser.doWhileStatement_return doWhileStatement146 = null;

        AS3_exParser.whileStatement_return whileStatement147 = null;

        AS3_exParser.ifStatement_return ifStatement148 = null;

        AS3_exParser.emptyStatement_return emptyStatement149 = null;

        AS3_exParser.variableStatement_return variableStatement150 = null;

        AS3_exParser.throwStatement_return throwStatement151 = null;



        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 58) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1784:5: ( blockStatement | directive | namespaceDirective | expression semic | constantVarStatement | tryStatement | labelledStatement | switchStatement | withStatement | returnStatement | breakStatement | continueStatement | forStatement | forInStatement | forEachInStatement | doWhileStatement | whileStatement | ifStatement | emptyStatement | variableStatement | throwStatement )
            int alt76 = 21;
            alt76 = dfa76.Predict(input);
            switch (alt76) 
            {
                case 1 :
                    // AS3_ex.g3:1785:6: blockStatement
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	if ( state.backtracking == 0 ) 
                    	{
                    	  SetBlockFlag(true);
                    	}
                    	PushFollow(FOLLOW_blockStatement_in_statement7673);
                    	blockStatement130 = blockStatement();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, blockStatement130.Tree);

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:1786:9: directive
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	if ( state.backtracking == 0 ) 
                    	{
                    	  InsertStatementCR();
                    	}
                    	PushFollow(FOLLOW_directive_in_statement7684);
                    	directive131 = directive();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, directive131.Tree);

                    }
                    break;
                case 3 :
                    // AS3_ex.g3:1787:9: namespaceDirective
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	if ( state.backtracking == 0 ) 
                    	{
                    	  InsertStatementCR();
                    	}
                    	PushFollow(FOLLOW_namespaceDirective_in_statement7695);
                    	namespaceDirective132 = namespaceDirective();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, namespaceDirective132.Tree);

                    }
                    break;
                case 4 :
                    // AS3_ex.g3:1788:9: expression semic
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	if ( state.backtracking == 0 ) 
                    	{
                    	  InsertStatementCR();
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  PushLazyIndent();
                    	}
                    	PushFollow(FOLLOW_expression_in_statement7708);
                    	expression133 = expression();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, expression133.Tree);
                    	PushFollow(FOLLOW_semic_in_statement7710);
                    	semic134 = semic();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, semic134.Tree);
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  PopIndent();
                    	}

                    }
                    break;
                case 5 :
                    // AS3_ex.g3:1789:9: constantVarStatement
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	if ( state.backtracking == 0 ) 
                    	{
                    	  InsertStatementCR();
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  PushLazyIndent();
                    	}
                    	PushFollow(FOLLOW_constantVarStatement_in_statement7725);
                    	constantVarStatement135 = constantVarStatement();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, constantVarStatement135.Tree);
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  PopIndent();
                    	}

                    }
                    break;
                case 6 :
                    // AS3_ex.g3:1790:9: tryStatement
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	if ( state.backtracking == 0 ) 
                    	{
                    	  MarkBlockFlag();InsertLines(mPrinter.GetBlankLinesBeforeControlStatement());
                    	}
                    	PushFollow(FOLLOW_tryStatement_in_statement7738);
                    	tryStatement136 = tryStatement();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, tryStatement136.Tree);

                    }
                    break;
                case 7 :
                    // AS3_ex.g3:1791:9: labelledStatement
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	if ( state.backtracking == 0 ) 
                    	{
                    	  InsertLines(mPrinter.GetBlankLinesBeforeControlStatement());
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  InsertStatementCR();
                    	}
                    	PushFollow(FOLLOW_labelledStatement_in_statement7750);
                    	labelledStatement137 = labelledStatement();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, labelledStatement137.Tree);

                    }
                    break;
                case 8 :
                    // AS3_ex.g3:1792:9: switchStatement
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	if ( state.backtracking == 0 ) 
                    	{
                    	  MarkBlockFlag();
                    	}
                    	PushFollow(FOLLOW_switchStatement_in_statement7763);
                    	switchStatement138 = switchStatement();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, switchStatement138.Tree);

                    }
                    break;
                case 9 :
                    // AS3_ex.g3:1793:9: withStatement
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	if ( state.backtracking == 0 ) 
                    	{
                    	  MarkBlockFlag();InsertLines(mPrinter.GetBlankLinesBeforeControlStatement());
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  InsertStatementCR();
                    	}
                    	PushFollow(FOLLOW_withStatement_in_statement7775);
                    	withStatement139 = withStatement();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, withStatement139.Tree);

                    }
                    break;
                case 10 :
                    // AS3_ex.g3:1794:9: returnStatement
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	if ( state.backtracking == 0 ) 
                    	{
                    	  InsertStatementCR();
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  PushLazyIndent();
                    	}
                    	PushFollow(FOLLOW_returnStatement_in_statement7789);
                    	returnStatement140 = returnStatement();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, returnStatement140.Tree);
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  PopIndent();
                    	}

                    }
                    break;
                case 11 :
                    // AS3_ex.g3:1795:9: breakStatement
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	if ( state.backtracking == 0 ) 
                    	{
                    	  InsertStatementCR();
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  PushLazyIndent();
                    	}
                    	PushFollow(FOLLOW_breakStatement_in_statement7805);
                    	breakStatement141 = breakStatement();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, breakStatement141.Tree);
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  PopIndent();
                    	}

                    }
                    break;
                case 12 :
                    // AS3_ex.g3:1796:9: continueStatement
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	if ( state.backtracking == 0 ) 
                    	{
                    	  InsertStatementCR();
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  PushLazyIndent();
                    	}
                    	PushFollow(FOLLOW_continueStatement_in_statement7821);
                    	continueStatement142 = continueStatement();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, continueStatement142.Tree);
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  PopIndent();
                    	}

                    }
                    break;
                case 13 :
                    // AS3_ex.g3:1797:9: forStatement
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	if ( state.backtracking == 0 ) 
                    	{
                    	  MarkBlockFlag();InsertLines(mPrinter.GetBlankLinesBeforeControlStatement());
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  InsertStatementCR();
                    	}
                    	PushFollow(FOLLOW_forStatement_in_statement7835);
                    	forStatement143 = forStatement();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, forStatement143.Tree);

                    }
                    break;
                case 14 :
                    // AS3_ex.g3:1798:9: forInStatement
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	if ( state.backtracking == 0 ) 
                    	{
                    	  MarkBlockFlag();InsertLines(mPrinter.GetBlankLinesBeforeControlStatement());
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  InsertStatementCR();
                    	}
                    	PushFollow(FOLLOW_forInStatement_in_statement7847);
                    	forInStatement144 = forInStatement();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, forInStatement144.Tree);

                    }
                    break;
                case 15 :
                    // AS3_ex.g3:1799:9: forEachInStatement
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	if ( state.backtracking == 0 ) 
                    	{
                    	  MarkBlockFlag();InsertLines(mPrinter.GetBlankLinesBeforeControlStatement());
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  InsertStatementCR();
                    	}
                    	PushFollow(FOLLOW_forEachInStatement_in_statement7859);
                    	forEachInStatement145 = forEachInStatement();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, forEachInStatement145.Tree);

                    }
                    break;
                case 16 :
                    // AS3_ex.g3:1800:9: doWhileStatement
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	if ( state.backtracking == 0 ) 
                    	{
                    	  MarkBlockFlag();InsertLines(mPrinter.GetBlankLinesBeforeControlStatement());
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  InsertStatementCR();
                    	}
                    	PushFollow(FOLLOW_doWhileStatement_in_statement7871);
                    	doWhileStatement146 = doWhileStatement();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, doWhileStatement146.Tree);

                    }
                    break;
                case 17 :
                    // AS3_ex.g3:1801:9: whileStatement
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	if ( state.backtracking == 0 ) 
                    	{
                    	  MarkBlockFlag();InsertLines(mPrinter.GetBlankLinesBeforeControlStatement());
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  InsertStatementCR();
                    	}
                    	PushFollow(FOLLOW_whileStatement_in_statement7883);
                    	whileStatement147 = whileStatement();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, whileStatement147.Tree);

                    }
                    break;
                case 18 :
                    // AS3_ex.g3:1802:9: ifStatement
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	if ( state.backtracking == 0 ) 
                    	{
                    	  InsertLines(mPrinter.GetBlankLinesBeforeControlStatement());
                    	}
                    	PushFollow(FOLLOW_ifStatement_in_statement7894);
                    	ifStatement148 = ifStatement();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, ifStatement148.Tree);

                    }
                    break;
                case 19 :
                    // AS3_ex.g3:1803:9: emptyStatement
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	if ( state.backtracking == 0 ) 
                    	{
                    	  if (mPrinter.IsEmptyStatementsOnNewLine())InsertStatementCR();
                    	}
                    	PushFollow(FOLLOW_emptyStatement_in_statement7905);
                    	emptyStatement149 = emptyStatement();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, emptyStatement149.Tree);

                    }
                    break;
                case 20 :
                    // AS3_ex.g3:1804:9: variableStatement
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	if ( state.backtracking == 0 ) 
                    	{
                    	  InsertStatementCR();
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  PushLazyIndent();
                    	}
                    	PushFollow(FOLLOW_variableStatement_in_statement7919);
                    	variableStatement150 = variableStatement();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, variableStatement150.Tree);
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  PopIndent();
                    	}

                    }
                    break;
                case 21 :
                    // AS3_ex.g3:1805:9: throwStatement
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	if ( state.backtracking == 0 ) 
                    	{
                    	  InsertStatementCR();
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  PushLazyIndent();
                    	}
                    	PushFollow(FOLLOW_throwStatement_in_statement7935);
                    	throwStatement151 = throwStatement();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, throwStatement151.Tree);
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  PopIndent();
                    	}

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 58, statement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "statement"

    public class blockStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "blockStatement"
    // AS3_ex.g3:1813:1: blockStatement : (conditionalToken= conditionalCompilerOption )? L= LCURLY ( statement )* R= RCURLY ;
    public AS3_exParser.blockStatement_return blockStatement() // throws RecognitionException [1]
    {   
        AS3_exParser.blockStatement_return retval = new AS3_exParser.blockStatement_return();
        retval.Start = input.LT(1);
        int blockStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        IToken R = null;
        AS3_exParser.conditionalCompilerOption_return conditionalToken = null;

        AS3_exParser.statement_return statement152 = null;


        object L_tree=null;
        object R_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 59) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1814:5: ( (conditionalToken= conditionalCompilerOption )? L= LCURLY ( statement )* R= RCURLY )
            // AS3_ex.g3:1814:9: (conditionalToken= conditionalCompilerOption )? L= LCURLY ( statement )* R= RCURLY
            {
            	root_0 = (object)adaptor.GetNilNode();

            	// AS3_ex.g3:1814:9: (conditionalToken= conditionalCompilerOption )?
            	int alt77 = 2;
            	int LA77_0 = input.LA(1);

            	if ( (LA77_0 == NATIVE || LA77_0 == TO || (LA77_0 >= EACH && LA77_0 <= NAMESPACE) || (LA77_0 >= DYNAMIC && LA77_0 <= STATIC) || LA77_0 == IDENTIFIER) )
            	{
            	    alt77 = 1;
            	}
            	switch (alt77) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:1814:10: conditionalToken= conditionalCompilerOption
            	        {
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  InsertCR(false);
            	        	}
            	        	PushFollow(FOLLOW_conditionalCompilerOption_in_blockStatement7966);
            	        	conditionalToken = conditionalCompilerOption();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, conditionalToken.Tree);

            	        }
            	        break;

            	}

            	L=(IToken)Match(input,LCURLY,FOLLOW_LCURLY_in_blockStatement7972); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{L_tree = (object)adaptor.Create(L);
            		adaptor.AddChild(root_0, L_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{

            	      		LeftCurlyNewlineHandler(conditionalToken==null); //if we have a conditional setting, then we want to have the option of keeping the brace on the same line
            	      		Emit((CommonToken)L);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  PushIndent(true);
            	      	
            	}
            	// AS3_ex.g3:1819:6: ( statement )*
            	do 
            	{
            	    int alt78 = 2;
            	    int LA78_0 = input.LA(1);

            	    if ( ((LA78_0 >= AS && LA78_0 <= NATIVE) || (LA78_0 >= NEW && LA78_0 <= TO) || (LA78_0 >= TRUE && LA78_0 <= LCURLY) || LA78_0 == LPAREN || LA78_0 == LBRACK || LA78_0 == LT || (LA78_0 >= PLUS && LA78_0 <= STAR) || (LA78_0 >= INC && LA78_0 <= DEC) || (LA78_0 >= NOT && LA78_0 <= INV) || (LA78_0 >= XML_AT && LA78_0 <= XML_LS_STD) || (LA78_0 >= SINGLE_QUOTE_LITERAL && LA78_0 <= DOUBLE_QUOTE_LITERAL) || LA78_0 == REGULAR_EXPR_LITERAL || LA78_0 == HEX_NUMBER_LITERAL || LA78_0 == DEC_NUMBER_LITERAL || LA78_0 == IDENTIFIER || (LA78_0 >= XML_COMMENT && LA78_0 <= XML_PI)) )
            	    {
            	        alt78 = 1;
            	    }


            	    switch (alt78) 
            		{
            			case 1 :
            			    // AS3_ex.g3:0:0: statement
            			    {
            			    	PushFollow(FOLLOW_statement_in_blockStatement7989);
            			    	statement152 = statement();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, statement152.Tree);

            			    }
            			    break;

            			default:
            			    goto loop78;
            	    }
            	} while (true);

            	loop78:
            		;	// Stops C# compiler whining that label 'loop78' has no statements

            	if ( state.backtracking == 0 ) 
            	{
            	  PopIndent();
            	}
            	R=(IToken)Match(input,RCURLY,FOLLOW_RCURLY_in_blockStatement8002); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{R_tree = (object)adaptor.Create(R);
            		adaptor.AddChild(root_0, R_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  InsertCR(false);Emit((CommonToken)R);
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 59, blockStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "blockStatement"

    public class throwStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "throwStatement"
    // AS3_ex.g3:1825:1: throwStatement : T= THROW expression semic ;
    public AS3_exParser.throwStatement_return throwStatement() // throws RecognitionException [1]
    {   
        AS3_exParser.throwStatement_return retval = new AS3_exParser.throwStatement_return();
        retval.Start = input.LT(1);
        int throwStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken T = null;
        AS3_exParser.expression_return expression153 = null;

        AS3_exParser.semic_return semic154 = null;


        object T_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 60) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1826:2: (T= THROW expression semic )
            // AS3_ex.g3:1826:5: T= THROW expression semic
            {
            	root_0 = (object)adaptor.GetNilNode();

            	T=(IToken)Match(input,THROW,FOLLOW_THROW_in_throwStatement8023); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{T_tree = (object)adaptor.Create(T);
            		adaptor.AddChild(root_0, T_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)T);
            	}
            	PushFollow(FOLLOW_expression_in_throwStatement8027);
            	expression153 = expression();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, expression153.Tree);
            	PushFollow(FOLLOW_semic_in_throwStatement8029);
            	semic154 = semic();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, semic154.Tree);

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 60, throwStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "throwStatement"

    public class constantVarStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "constantVarStatement"
    // AS3_ex.g3:1831:1: constantVarStatement : C= CONST variableDeclarationList (S= SEMI )? ;
    public AS3_exParser.constantVarStatement_return constantVarStatement() // throws RecognitionException [1]
    {   
        AS3_exParser.constantVarStatement_return retval = new AS3_exParser.constantVarStatement_return();
        retval.Start = input.LT(1);
        int constantVarStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken C = null;
        IToken S = null;
        AS3_exParser.variableDeclarationList_return variableDeclarationList155 = null;


        object C_tree=null;
        object S_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 61) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1832:5: (C= CONST variableDeclarationList (S= SEMI )? )
            // AS3_ex.g3:1832:9: C= CONST variableDeclarationList (S= SEMI )?
            {
            	root_0 = (object)adaptor.GetNilNode();

            	C=(IToken)Match(input,CONST,FOLLOW_CONST_in_constantVarStatement8049); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{C_tree = (object)adaptor.Create(C);
            		adaptor.AddChild(root_0, C_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)C);
            	}
            	PushFollow(FOLLOW_variableDeclarationList_in_constantVarStatement8054);
            	variableDeclarationList155 = variableDeclarationList();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, variableDeclarationList155.Tree);
            	// AS3_ex.g3:1832:67: (S= SEMI )?
            	int alt79 = 2;
            	int LA79_0 = input.LA(1);

            	if ( (LA79_0 == SEMI) )
            	{
            	    int LA79_1 = input.LA(2);

            	    if ( (synpred191_AS3_ex()) )
            	    {
            	        alt79 = 1;
            	    }
            	}
            	switch (alt79) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:1832:68: S= SEMI
            	        {
            	        	S=(IToken)Match(input,SEMI,FOLLOW_SEMI_in_constantVarStatement8059); if (state.failed) return retval;
            	        	if ( state.backtracking == 0 )
            	        	{S_tree = (object)adaptor.Create(S);
            	        		adaptor.AddChild(root_0, S_tree);
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  Emit((CommonToken)S);
            	        	}

            	        }
            	        break;

            	}


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 61, constantVarStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "constantVarStatement"

    public class useNamespaceDirective_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "useNamespaceDirective"
    // AS3_ex.g3:1837:1: useNamespaceDirective : U= USE N= NAMESPACE qualifiedIdentifier (C= COMMA qualifiedIdentifier )* semic ;
    public AS3_exParser.useNamespaceDirective_return useNamespaceDirective() // throws RecognitionException [1]
    {   
        AS3_exParser.useNamespaceDirective_return retval = new AS3_exParser.useNamespaceDirective_return();
        retval.Start = input.LT(1);
        int useNamespaceDirective_StartIndex = input.Index();
        object root_0 = null;

        IToken U = null;
        IToken N = null;
        IToken C = null;
        AS3_exParser.qualifiedIdentifier_return qualifiedIdentifier156 = null;

        AS3_exParser.qualifiedIdentifier_return qualifiedIdentifier157 = null;

        AS3_exParser.semic_return semic158 = null;


        object U_tree=null;
        object N_tree=null;
        object C_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 62) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1838:2: (U= USE N= NAMESPACE qualifiedIdentifier (C= COMMA qualifiedIdentifier )* semic )
            // AS3_ex.g3:1839:2: U= USE N= NAMESPACE qualifiedIdentifier (C= COMMA qualifiedIdentifier )* semic
            {
            	root_0 = (object)adaptor.GetNilNode();

            	U=(IToken)Match(input,USE,FOLLOW_USE_in_useNamespaceDirective8161); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{U_tree = (object)adaptor.Create(U);
            		adaptor.AddChild(root_0, U_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)U);
            	}
            	N=(IToken)Match(input,NAMESPACE,FOLLOW_NAMESPACE_in_useNamespaceDirective8170); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{N_tree = (object)adaptor.Create(N);
            		adaptor.AddChild(root_0, N_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)N);
            	}
            	PushFollow(FOLLOW_qualifiedIdentifier_in_useNamespaceDirective8177);
            	qualifiedIdentifier156 = qualifiedIdentifier();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, qualifiedIdentifier156.Tree);
            	// AS3_ex.g3:1841:22: (C= COMMA qualifiedIdentifier )*
            	do 
            	{
            	    int alt80 = 2;
            	    int LA80_0 = input.LA(1);

            	    if ( (LA80_0 == COMMA) )
            	    {
            	        alt80 = 1;
            	    }


            	    switch (alt80) 
            		{
            			case 1 :
            			    // AS3_ex.g3:1841:23: C= COMMA qualifiedIdentifier
            			    {
            			    	C=(IToken)Match(input,COMMA,FOLLOW_COMMA_in_useNamespaceDirective8182); if (state.failed) return retval;
            			    	if ( state.backtracking == 0 )
            			    	{C_tree = (object)adaptor.Create(C);
            			    		adaptor.AddChild(root_0, C_tree);
            			    	}
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  Emit((CommonToken)C);
            			    	}
            			    	PushFollow(FOLLOW_qualifiedIdentifier_in_useNamespaceDirective8186);
            			    	qualifiedIdentifier157 = qualifiedIdentifier();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, qualifiedIdentifier157.Tree);

            			    }
            			    break;

            			default:
            			    goto loop80;
            	    }
            	} while (true);

            	loop80:
            		;	// Stops C# compiler whining that label 'loop80' has no statements

            	PushFollow(FOLLOW_semic_in_useNamespaceDirective8190);
            	semic158 = semic();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, semic158.Tree);

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 62, useNamespaceDirective_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "useNamespaceDirective"

    public class namespaceDirective_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "namespaceDirective"
    // AS3_ex.g3:1847:1: namespaceDirective : N= NAMESPACE qualifiedIdentifier (A= ASSIGN stringLiteral )? semic ;
    public AS3_exParser.namespaceDirective_return namespaceDirective() // throws RecognitionException [1]
    {   
        AS3_exParser.namespaceDirective_return retval = new AS3_exParser.namespaceDirective_return();
        retval.Start = input.LT(1);
        int namespaceDirective_StartIndex = input.Index();
        object root_0 = null;

        IToken N = null;
        IToken A = null;
        AS3_exParser.qualifiedIdentifier_return qualifiedIdentifier159 = null;

        AS3_exParser.stringLiteral_return stringLiteral160 = null;

        AS3_exParser.semic_return semic161 = null;


        object N_tree=null;
        object A_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 63) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1848:5: (N= NAMESPACE qualifiedIdentifier (A= ASSIGN stringLiteral )? semic )
            // AS3_ex.g3:1849:5: N= NAMESPACE qualifiedIdentifier (A= ASSIGN stringLiteral )? semic
            {
            	root_0 = (object)adaptor.GetNilNode();

            	N=(IToken)Match(input,NAMESPACE,FOLLOW_NAMESPACE_in_namespaceDirective8220); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{N_tree = (object)adaptor.Create(N);
            		adaptor.AddChild(root_0, N_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)N);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  PushExpressionIndent();
            	}
            	PushFollow(FOLLOW_qualifiedIdentifier_in_namespaceDirective8231);
            	qualifiedIdentifier159 = qualifiedIdentifier();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, qualifiedIdentifier159.Tree);
            	// AS3_ex.g3:1850:25: (A= ASSIGN stringLiteral )?
            	int alt81 = 2;
            	int LA81_0 = input.LA(1);

            	if ( (LA81_0 == ASSIGN) )
            	{
            	    alt81 = 1;
            	}
            	switch (alt81) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:1850:27: A= ASSIGN stringLiteral
            	        {
            	        	A=(IToken)Match(input,ASSIGN,FOLLOW_ASSIGN_in_namespaceDirective8237); if (state.failed) return retval;
            	        	if ( state.backtracking == 0 )
            	        	{A_tree = (object)adaptor.Create(A);
            	        		adaptor.AddChild(root_0, A_tree);
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  InsertWS(mPrinter.GetSpacesAroundAssignment());Emit((CommonToken)A);InsertWS(mPrinter.GetSpacesAroundAssignment());
            	        	}
            	        	PushFollow(FOLLOW_stringLiteral_in_namespaceDirective8242);
            	        	stringLiteral160 = stringLiteral();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, stringLiteral160.Tree);

            	        }
            	        break;

            	}

            	PushFollow(FOLLOW_semic_in_namespaceDirective8247);
            	semic161 = semic();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, semic161.Tree);
            	if ( state.backtracking == 0 ) 
            	{
            	  PopIndent();
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 63, namespaceDirective_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "namespaceDirective"

    public class tryStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "tryStatement"
    // AS3_ex.g3:1858:1: tryStatement : T= TRY blockStatement ( ( catchClause )+ finallyClause | ( catchClause )+ | finallyClause ) ;
    public AS3_exParser.tryStatement_return tryStatement() // throws RecognitionException [1]
    {   
        AS3_exParser.tryStatement_return retval = new AS3_exParser.tryStatement_return();
        retval.Start = input.LT(1);
        int tryStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken T = null;
        AS3_exParser.blockStatement_return blockStatement162 = null;

        AS3_exParser.catchClause_return catchClause163 = null;

        AS3_exParser.finallyClause_return finallyClause164 = null;

        AS3_exParser.catchClause_return catchClause165 = null;

        AS3_exParser.finallyClause_return finallyClause166 = null;


        object T_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 64) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1859:5: (T= TRY blockStatement ( ( catchClause )+ finallyClause | ( catchClause )+ | finallyClause ) )
            // AS3_ex.g3:1859:7: T= TRY blockStatement ( ( catchClause )+ finallyClause | ( catchClause )+ | finallyClause )
            {
            	root_0 = (object)adaptor.GetNilNode();

            	if ( state.backtracking == 0 ) 
            	{
            	  InsertStatementCR();
            	}
            	T=(IToken)Match(input,TRY,FOLLOW_TRY_in_tryStatement8275); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{T_tree = (object)adaptor.Create(T);
            		adaptor.AddChild(root_0, T_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)T);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  PushIndent(false);
            	}
            	PushFollow(FOLLOW_blockStatement_in_tryStatement8281);
            	blockStatement162 = blockStatement();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, blockStatement162.Tree);
            	if ( state.backtracking == 0 ) 
            	{
            	  PopIndent();
            	}
            	// AS3_ex.g3:1860:9: ( ( catchClause )+ finallyClause | ( catchClause )+ | finallyClause )
            	int alt84 = 3;
            	int LA84_0 = input.LA(1);

            	if ( (LA84_0 == CATCH) )
            	{
            	    int LA84_1 = input.LA(2);

            	    if ( (synpred195_AS3_ex()) )
            	    {
            	        alt84 = 1;
            	    }
            	    else if ( (synpred197_AS3_ex()) )
            	    {
            	        alt84 = 2;
            	    }
            	    else 
            	    {
            	        if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            	        NoViableAltException nvae_d84s1 =
            	            new NoViableAltException("", 84, 1, input);

            	        throw nvae_d84s1;
            	    }
            	}
            	else if ( (LA84_0 == FINALLY) )
            	{
            	    alt84 = 3;
            	}
            	else 
            	{
            	    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            	    NoViableAltException nvae_d84s0 =
            	        new NoViableAltException("", 84, 0, input);

            	    throw nvae_d84s0;
            	}
            	switch (alt84) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:1860:11: ( catchClause )+ finallyClause
            	        {
            	        	// AS3_ex.g3:1860:11: ( catchClause )+
            	        	int cnt82 = 0;
            	        	do 
            	        	{
            	        	    int alt82 = 2;
            	        	    int LA82_0 = input.LA(1);

            	        	    if ( (LA82_0 == CATCH) )
            	        	    {
            	        	        alt82 = 1;
            	        	    }


            	        	    switch (alt82) 
            	        		{
            	        			case 1 :
            	        			    // AS3_ex.g3:0:0: catchClause
            	        			    {
            	        			    	PushFollow(FOLLOW_catchClause_in_tryStatement8295);
            	        			    	catchClause163 = catchClause();
            	        			    	state.followingStackPointer--;
            	        			    	if (state.failed) return retval;
            	        			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, catchClause163.Tree);

            	        			    }
            	        			    break;

            	        			default:
            	        			    if ( cnt82 >= 1 ) goto loop82;
            	        			    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            	        		            EarlyExitException eee =
            	        		                new EarlyExitException(82, input);
            	        		            throw eee;
            	        	    }
            	        	    cnt82++;
            	        	} while (true);

            	        	loop82:
            	        		;	// Stops C# compiler whinging that label 'loop82' has no statements

            	        	PushFollow(FOLLOW_finallyClause_in_tryStatement8298);
            	        	finallyClause164 = finallyClause();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, finallyClause164.Tree);

            	        }
            	        break;
            	    case 2 :
            	        // AS3_ex.g3:1861:11: ( catchClause )+
            	        {
            	        	// AS3_ex.g3:1861:11: ( catchClause )+
            	        	int cnt83 = 0;
            	        	do 
            	        	{
            	        	    int alt83 = 2;
            	        	    int LA83_0 = input.LA(1);

            	        	    if ( (LA83_0 == CATCH) )
            	        	    {
            	        	        int LA83_2 = input.LA(2);

            	        	        if ( (LA83_2 == LPAREN) )
            	        	        {
            	        	            alt83 = 1;
            	        	        }


            	        	    }


            	        	    switch (alt83) 
            	        		{
            	        			case 1 :
            	        			    // AS3_ex.g3:0:0: catchClause
            	        			    {
            	        			    	PushFollow(FOLLOW_catchClause_in_tryStatement8310);
            	        			    	catchClause165 = catchClause();
            	        			    	state.followingStackPointer--;
            	        			    	if (state.failed) return retval;
            	        			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, catchClause165.Tree);

            	        			    }
            	        			    break;

            	        			default:
            	        			    if ( cnt83 >= 1 ) goto loop83;
            	        			    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            	        		            EarlyExitException eee =
            	        		                new EarlyExitException(83, input);
            	        		            throw eee;
            	        	    }
            	        	    cnt83++;
            	        	} while (true);

            	        	loop83:
            	        		;	// Stops C# compiler whinging that label 'loop83' has no statements


            	        }
            	        break;
            	    case 3 :
            	        // AS3_ex.g3:1862:11: finallyClause
            	        {
            	        	PushFollow(FOLLOW_finallyClause_in_tryStatement8323);
            	        	finallyClause166 = finallyClause();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, finallyClause166.Tree);

            	        }
            	        break;

            	}


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 64, tryStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "tryStatement"

    public class catchClause_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "catchClause"
    // AS3_ex.g3:1866:1: catchClause : C= CATCH L= LPAREN variableIdentifierDecl R= RPAREN blockStatement ;
    public AS3_exParser.catchClause_return catchClause() // throws RecognitionException [1]
    {   
        AS3_exParser.catchClause_return retval = new AS3_exParser.catchClause_return();
        retval.Start = input.LT(1);
        int catchClause_StartIndex = input.Index();
        object root_0 = null;

        IToken C = null;
        IToken L = null;
        IToken R = null;
        AS3_exParser.variableIdentifierDecl_return variableIdentifierDecl167 = null;

        AS3_exParser.blockStatement_return blockStatement168 = null;


        object C_tree=null;
        object L_tree=null;
        object R_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 65) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1867:5: (C= CATCH L= LPAREN variableIdentifierDecl R= RPAREN blockStatement )
            // AS3_ex.g3:1867:7: C= CATCH L= LPAREN variableIdentifierDecl R= RPAREN blockStatement
            {
            	root_0 = (object)adaptor.GetNilNode();

            	if ( state.backtracking == 0 ) 
            	{
            	  if (mPrinter.IsCRBeforeCatch()) InsertCR(false);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  InsertWS(1);
            	}
            	C=(IToken)Match(input,CATCH,FOLLOW_CATCH_in_catchClause8355); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{C_tree = (object)adaptor.Create(C);
            		adaptor.AddChild(root_0, C_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)C);InsertWS(mPrinter.GetSpacesBetweenControlKeywordsAndParens());
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  PushIndent(false);
            	}
            	L=(IToken)Match(input,LPAREN,FOLLOW_LPAREN_in_catchClause8362); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{L_tree = (object)adaptor.Create(L);
            		adaptor.AddChild(root_0, L_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)L);InsertWS(mPrinter.GetAdvancedSpacesInsideParens());
            	}
            	PushFollow(FOLLOW_variableIdentifierDecl_in_catchClause8366);
            	variableIdentifierDecl167 = variableIdentifierDecl();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, variableIdentifierDecl167.Tree);
            	R=(IToken)Match(input,RPAREN,FOLLOW_RPAREN_in_catchClause8370); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{R_tree = (object)adaptor.Create(R);
            		adaptor.AddChild(root_0, R_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  InsertWS(mPrinter.GetAdvancedSpacesInsideParens());Emit((CommonToken)R);
            	}
            	PushFollow(FOLLOW_blockStatement_in_catchClause8374);
            	blockStatement168 = blockStatement();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, blockStatement168.Tree);
            	if ( state.backtracking == 0 ) 
            	{
            	  PopIndent();
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 65, catchClause_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "catchClause"

    public class finallyClause_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "finallyClause"
    // AS3_ex.g3:1870:1: finallyClause : F= FINALLY blockStatement ;
    public AS3_exParser.finallyClause_return finallyClause() // throws RecognitionException [1]
    {   
        AS3_exParser.finallyClause_return retval = new AS3_exParser.finallyClause_return();
        retval.Start = input.LT(1);
        int finallyClause_StartIndex = input.Index();
        object root_0 = null;

        IToken F = null;
        AS3_exParser.blockStatement_return blockStatement169 = null;


        object F_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 66) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1871:5: (F= FINALLY blockStatement )
            // AS3_ex.g3:1871:7: F= FINALLY blockStatement
            {
            	root_0 = (object)adaptor.GetNilNode();

            	if ( state.backtracking == 0 ) 
            	{
            	  if (mPrinter.IsCRBeforeCatch()) InsertCR(false);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  InsertWS(1);
            	}
            	F=(IToken)Match(input,FINALLY,FOLLOW_FINALLY_in_finallyClause8398); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{F_tree = (object)adaptor.Create(F);
            		adaptor.AddChild(root_0, F_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)F);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  PushIndent(false);
            	}
            	PushFollow(FOLLOW_blockStatement_in_finallyClause8403);
            	blockStatement169 = blockStatement();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, blockStatement169.Tree);
            	if ( state.backtracking == 0 ) 
            	{
            	  PopIndent();
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 66, finallyClause_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "finallyClause"

    public class labelledStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "labelledStatement"
    // AS3_ex.g3:1878:1: labelledStatement : I= IDENTIFIER C= COLON statement ;
    public AS3_exParser.labelledStatement_return labelledStatement() // throws RecognitionException [1]
    {   
        AS3_exParser.labelledStatement_return retval = new AS3_exParser.labelledStatement_return();
        retval.Start = input.LT(1);
        int labelledStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken I = null;
        IToken C = null;
        AS3_exParser.statement_return statement170 = null;


        object I_tree=null;
        object C_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 67) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1879:5: (I= IDENTIFIER C= COLON statement )
            // AS3_ex.g3:1879:8: I= IDENTIFIER C= COLON statement
            {
            	root_0 = (object)adaptor.GetNilNode();

            	I=(IToken)Match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_labelledStatement8429); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{I_tree = (object)adaptor.Create(I);
            		adaptor.AddChild(root_0, I_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)I);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  PushLabeledIndent();
            	}
            	C=(IToken)Match(input,COLON,FOLLOW_COLON_in_labelledStatement8442); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{C_tree = (object)adaptor.Create(C);
            		adaptor.AddChild(root_0, C_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{

            	      		Emit((CommonToken)C);
            	      		InsertWS(mPrinter.GetSpacesAfterLabel());
            	      	
            	}
            	PushFollow(FOLLOW_statement_in_labelledStatement8458);
            	statement170 = statement();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, statement170.Tree);
            	if ( state.backtracking == 0 ) 
            	{
            	  PopIndent();
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 67, labelledStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "labelledStatement"

    public class switchStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "switchStatement"
    // AS3_ex.g3:1893:1: switchStatement : S= SWITCH parExpression L= LCURLY ( switchBlockStatementGroup )* R= RCURLY ;
    public AS3_exParser.switchStatement_return switchStatement() // throws RecognitionException [1]
    {   
        AS3_exParser.switchStatement_return retval = new AS3_exParser.switchStatement_return();
        retval.Start = input.LT(1);
        int switchStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken S = null;
        IToken L = null;
        IToken R = null;
        AS3_exParser.parExpression_return parExpression171 = null;

        AS3_exParser.switchBlockStatementGroup_return switchBlockStatementGroup172 = null;


        object S_tree=null;
        object L_tree=null;
        object R_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 68) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1894:5: (S= SWITCH parExpression L= LCURLY ( switchBlockStatementGroup )* R= RCURLY )
            // AS3_ex.g3:1894:8: S= SWITCH parExpression L= LCURLY ( switchBlockStatementGroup )* R= RCURLY
            {
            	root_0 = (object)adaptor.GetNilNode();

            	if ( state.backtracking == 0 ) 
            	{
            	  InsertLines(mPrinter.GetBlankLinesBeforeControlStatement());
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  InsertStatementCR();
            	}
            	S=(IToken)Match(input,SWITCH,FOLLOW_SWITCH_in_switchStatement8493); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{S_tree = (object)adaptor.Create(S);
            		adaptor.AddChild(root_0, S_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)S);InsertWS(mPrinter.GetSpacesBetweenControlKeywordsAndParens());
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  PushExpressionIndent();
            	}
            	PushFollow(FOLLOW_parExpression_in_switchStatement8498);
            	parExpression171 = parExpression();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, parExpression171.Tree);
            	if ( state.backtracking == 0 ) 
            	{
            	  PopIndent();
            	}
            	L=(IToken)Match(input,LCURLY,FOLLOW_LCURLY_in_switchStatement8510); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{L_tree = (object)adaptor.Create(L);
            		adaptor.AddChild(root_0, L_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{

            	      		LeftCurlyNewlineHandler(false);
            	      		Emit((CommonToken)L);PushIndent(true);
            	      	
            	}
            	// AS3_ex.g3:1900:6: ( switchBlockStatementGroup )*
            	do 
            	{
            	    int alt85 = 2;
            	    int LA85_0 = input.LA(1);

            	    if ( (LA85_0 == CASE || LA85_0 == DEFAULT) )
            	    {
            	        alt85 = 1;
            	    }


            	    switch (alt85) 
            		{
            			case 1 :
            			    // AS3_ex.g3:0:0: switchBlockStatementGroup
            			    {
            			    	PushFollow(FOLLOW_switchBlockStatementGroup_in_switchStatement8526);
            			    	switchBlockStatementGroup172 = switchBlockStatementGroup();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, switchBlockStatementGroup172.Tree);

            			    }
            			    break;

            			default:
            			    goto loop85;
            	    }
            	} while (true);

            	loop85:
            		;	// Stops C# compiler whining that label 'loop85' has no statements

            	if ( state.backtracking == 0 ) 
            	{
            	  PopIndent();
            	}
            	R=(IToken)Match(input,RCURLY,FOLLOW_RCURLY_in_switchStatement8539); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{R_tree = (object)adaptor.Create(R);
            		adaptor.AddChild(root_0, R_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  InsertCR(false);Emit((CommonToken)R);
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 68, switchStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "switchStatement"

    public class switchBlockStatementGroup_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "switchBlockStatementGroup"
    // AS3_ex.g3:1908:1: switchBlockStatementGroup : switchLabel ( statement )* ( breakStatement )? ;
    public AS3_exParser.switchBlockStatementGroup_return switchBlockStatementGroup() // throws RecognitionException [1]
    {   
        AS3_exParser.switchBlockStatementGroup_return retval = new AS3_exParser.switchBlockStatementGroup_return();
        retval.Start = input.LT(1);
        int switchBlockStatementGroup_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.switchLabel_return switchLabel173 = null;

        AS3_exParser.statement_return statement174 = null;

        AS3_exParser.breakStatement_return breakStatement175 = null;



        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 69) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1909:5: ( switchLabel ( statement )* ( breakStatement )? )
            // AS3_ex.g3:1909:9: switchLabel ( statement )* ( breakStatement )?
            {
            	root_0 = (object)adaptor.GetNilNode();

            	if ( state.backtracking == 0 ) 
            	{
            	  InsertCR(false);
            	}
            	PushFollow(FOLLOW_switchLabel_in_switchBlockStatementGroup8572);
            	switchLabel173 = switchLabel();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, switchLabel173.Tree);
            	if ( state.backtracking == 0 ) 
            	{
            	  PushIndent(false);
            	}
            	// AS3_ex.g3:1909:61: ( statement )*
            	do 
            	{
            	    int alt86 = 2;
            	    alt86 = dfa86.Predict(input);
            	    switch (alt86) 
            		{
            			case 1 :
            			    // AS3_ex.g3:0:0: statement
            			    {
            			    	PushFollow(FOLLOW_statement_in_switchBlockStatementGroup8576);
            			    	statement174 = statement();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, statement174.Tree);

            			    }
            			    break;

            			default:
            			    goto loop86;
            	    }
            	} while (true);

            	loop86:
            		;	// Stops C# compiler whining that label 'loop86' has no statements

            	if ( state.backtracking == 0 ) 
            	{
            	  PopIndent();
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  InsertCR(false);
            	}
            	// AS3_ex.g3:1909:105: ( breakStatement )?
            	int alt87 = 2;
            	int LA87_0 = input.LA(1);

            	if ( (LA87_0 == BREAK) )
            	{
            	    alt87 = 1;
            	}
            	switch (alt87) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:0:0: breakStatement
            	        {
            	        	PushFollow(FOLLOW_breakStatement_in_switchBlockStatementGroup8582);
            	        	breakStatement175 = breakStatement();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, breakStatement175.Tree);

            	        }
            	        break;

            	}


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 69, switchBlockStatementGroup_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "switchBlockStatementGroup"

    public class switchLabel_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "switchLabel"
    // AS3_ex.g3:1912:1: switchLabel : (C= CASE expression C= COLON | D= DEFAULT C= COLON );
    public AS3_exParser.switchLabel_return switchLabel() // throws RecognitionException [1]
    {   
        AS3_exParser.switchLabel_return retval = new AS3_exParser.switchLabel_return();
        retval.Start = input.LT(1);
        int switchLabel_StartIndex = input.Index();
        object root_0 = null;

        IToken C = null;
        IToken D = null;
        AS3_exParser.expression_return expression176 = null;


        object C_tree=null;
        object D_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 70) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1913:5: (C= CASE expression C= COLON | D= DEFAULT C= COLON )
            int alt88 = 2;
            int LA88_0 = input.LA(1);

            if ( (LA88_0 == CASE) )
            {
                alt88 = 1;
            }
            else if ( (LA88_0 == DEFAULT) )
            {
                alt88 = 2;
            }
            else 
            {
                if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                NoViableAltException nvae_d88s0 =
                    new NoViableAltException("", 88, 0, input);

                throw nvae_d88s0;
            }
            switch (alt88) 
            {
                case 1 :
                    // AS3_ex.g3:1913:9: C= CASE expression C= COLON
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	C=(IToken)Match(input,CASE,FOLLOW_CASE_in_switchLabel8608); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{C_tree = (object)adaptor.Create(C);
                    		adaptor.AddChild(root_0, C_tree);
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  Emit((CommonToken)C);
                    	}
                    	PushFollow(FOLLOW_expression_in_switchLabel8612);
                    	expression176 = expression();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, expression176.Tree);
                    	C=(IToken)Match(input,COLON,FOLLOW_COLON_in_switchLabel8616); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{C_tree = (object)adaptor.Create(C);
                    		adaptor.AddChild(root_0, C_tree);
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{

                    	      	Emit((CommonToken)C);
                    	      	InsertWS(mPrinter.GetSpacesAfterLabel());
                    	      	
                    	}

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:1918:9: D= DEFAULT C= COLON
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	D=(IToken)Match(input,DEFAULT,FOLLOW_DEFAULT_in_switchLabel8637); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{D_tree = (object)adaptor.Create(D);
                    		adaptor.AddChild(root_0, D_tree);
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  Emit((CommonToken)D);
                    	}
                    	C=(IToken)Match(input,COLON,FOLLOW_COLON_in_switchLabel8643); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{C_tree = (object)adaptor.Create(C);
                    		adaptor.AddChild(root_0, C_tree);
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{

                    	      			Emit((CommonToken)C);
                    	      			InsertWS(mPrinter.GetSpacesAfterLabel());
                    	      		
                    	}

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 70, switchLabel_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "switchLabel"

    public class withStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "withStatement"
    // AS3_ex.g3:1929:1: withStatement : W= WITH L= LPAREN expression R= RPAREN statement ;
    public AS3_exParser.withStatement_return withStatement() // throws RecognitionException [1]
    {   
        AS3_exParser.withStatement_return retval = new AS3_exParser.withStatement_return();
        retval.Start = input.LT(1);
        int withStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken W = null;
        IToken L = null;
        IToken R = null;
        AS3_exParser.expression_return expression177 = null;

        AS3_exParser.statement_return statement178 = null;


        object W_tree=null;
        object L_tree=null;
        object R_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 71) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1930:5: (W= WITH L= LPAREN expression R= RPAREN statement )
            // AS3_ex.g3:1930:9: W= WITH L= LPAREN expression R= RPAREN statement
            {
            	root_0 = (object)adaptor.GetNilNode();

            	W=(IToken)Match(input,WITH,FOLLOW_WITH_in_withStatement8677); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{W_tree = (object)adaptor.Create(W);
            		adaptor.AddChild(root_0, W_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)W);InsertWS(mPrinter.GetSpacesBetweenControlKeywordsAndParens());
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  PushExpressionIndent();
            	}
            	L=(IToken)Match(input,LPAREN,FOLLOW_LPAREN_in_withStatement8685); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{L_tree = (object)adaptor.Create(L);
            		adaptor.AddChild(root_0, L_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)L);InsertWS(mPrinter.GetAdvancedSpacesInsideParens());
            	}
            	PushFollow(FOLLOW_expression_in_withStatement8690);
            	expression177 = expression();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, expression177.Tree);
            	R=(IToken)Match(input,RPAREN,FOLLOW_RPAREN_in_withStatement8695); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{R_tree = (object)adaptor.Create(R);
            		adaptor.AddChild(root_0, R_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  InsertWS(mPrinter.GetAdvancedSpacesInsideParens());Emit((CommonToken)R);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  PopIndent();
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  PushIndent(false);
            	}
            	PushFollow(FOLLOW_statement_in_withStatement8703);
            	statement178 = statement();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, statement178.Tree);
            	if ( state.backtracking == 0 ) 
            	{
            	  PopIndent();
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 71, withStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "withStatement"

    public class returnStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "returnStatement"
    // AS3_ex.g3:1937:1: returnStatement : R= RETURN ( expression )? semic ;
    public AS3_exParser.returnStatement_return returnStatement() // throws RecognitionException [1]
    {   
        AS3_exParser.returnStatement_return retval = new AS3_exParser.returnStatement_return();
        retval.Start = input.LT(1);
        int returnStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken R = null;
        AS3_exParser.expression_return expression179 = null;

        AS3_exParser.semic_return semic180 = null;


        object R_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 72) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1938:5: (R= RETURN ( expression )? semic )
            // AS3_ex.g3:1938:9: R= RETURN ( expression )? semic
            {
            	root_0 = (object)adaptor.GetNilNode();

            	R=(IToken)Match(input,RETURN,FOLLOW_RETURN_in_returnStatement8730); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{R_tree = (object)adaptor.Create(R);
            		adaptor.AddChild(root_0, R_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)R);
            	}
            	// AS3_ex.g3:1938:43: ( expression )?
            	int alt89 = 2;
            	int LA89_0 = input.LA(1);

            	if ( ((LA89_0 >= AS && LA89_0 <= STATIC) || LA89_0 == VOID || LA89_0 == LCURLY || LA89_0 == LPAREN || LA89_0 == LBRACK || LA89_0 == LT || (LA89_0 >= PLUS && LA89_0 <= STAR) || (LA89_0 >= INC && LA89_0 <= DEC) || (LA89_0 >= NOT && LA89_0 <= INV) || (LA89_0 >= XML_AT && LA89_0 <= XML_LS_STD) || (LA89_0 >= SINGLE_QUOTE_LITERAL && LA89_0 <= DOUBLE_QUOTE_LITERAL) || LA89_0 == REGULAR_EXPR_LITERAL || LA89_0 == HEX_NUMBER_LITERAL || LA89_0 == DEC_NUMBER_LITERAL || LA89_0 == IDENTIFIER || (LA89_0 >= XML_COMMENT && LA89_0 <= XML_PI)) )
            	{
            	    alt89 = 1;
            	}
            	switch (alt89) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:1938:45: expression
            	        {
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  InsertWS(mPrinter.GetSpacesBetweenControlKeywordsAndParens());
            	        	}
            	        	PushFollow(FOLLOW_expression_in_returnStatement8738);
            	        	expression179 = expression();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, expression179.Tree);

            	        }
            	        break;

            	}

            	PushFollow(FOLLOW_semic_in_returnStatement8742);
            	semic180 = semic();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, semic180.Tree);

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 72, returnStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "returnStatement"

    public class breakStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "breakStatement"
    // AS3_ex.g3:1946:1: breakStatement : B= BREAK (I= IDENTIFIER )? semic ;
    public AS3_exParser.breakStatement_return breakStatement() // throws RecognitionException [1]
    {   
        AS3_exParser.breakStatement_return retval = new AS3_exParser.breakStatement_return();
        retval.Start = input.LT(1);
        int breakStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken B = null;
        IToken I = null;
        AS3_exParser.semic_return semic181 = null;


        object B_tree=null;
        object I_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 73) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1947:5: (B= BREAK (I= IDENTIFIER )? semic )
            // AS3_ex.g3:1947:9: B= BREAK (I= IDENTIFIER )? semic
            {
            	root_0 = (object)adaptor.GetNilNode();

            	B=(IToken)Match(input,BREAK,FOLLOW_BREAK_in_breakStatement8769); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{B_tree = (object)adaptor.Create(B);
            		adaptor.AddChild(root_0, B_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)B);
            	}
            	// AS3_ex.g3:1947:45: (I= IDENTIFIER )?
            	int alt90 = 2;
            	int LA90_0 = input.LA(1);

            	if ( (LA90_0 == IDENTIFIER) )
            	{
            	    alt90 = 1;
            	}
            	switch (alt90) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:1947:46: I= IDENTIFIER
            	        {
            	        	I=(IToken)Match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_breakStatement8779); if (state.failed) return retval;
            	        	if ( state.backtracking == 0 )
            	        	{I_tree = (object)adaptor.Create(I);
            	        		adaptor.AddChild(root_0, I_tree);
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  Emit((CommonToken)I);
            	        	}

            	        }
            	        break;

            	}

            	PushFollow(FOLLOW_semic_in_breakStatement8784);
            	semic181 = semic();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, semic181.Tree);

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 73, breakStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "breakStatement"

    public class continueStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "continueStatement"
    // AS3_ex.g3:1955:1: continueStatement : C= CONTINUE (I= IDENTIFIER )? semic ;
    public AS3_exParser.continueStatement_return continueStatement() // throws RecognitionException [1]
    {   
        AS3_exParser.continueStatement_return retval = new AS3_exParser.continueStatement_return();
        retval.Start = input.LT(1);
        int continueStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken C = null;
        IToken I = null;
        AS3_exParser.semic_return semic182 = null;


        object C_tree=null;
        object I_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 74) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1956:5: (C= CONTINUE (I= IDENTIFIER )? semic )
            // AS3_ex.g3:1956:9: C= CONTINUE (I= IDENTIFIER )? semic
            {
            	root_0 = (object)adaptor.GetNilNode();

            	C=(IToken)Match(input,CONTINUE,FOLLOW_CONTINUE_in_continueStatement8810); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{C_tree = (object)adaptor.Create(C);
            		adaptor.AddChild(root_0, C_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)C);
            	}
            	// AS3_ex.g3:1956:45: (I= IDENTIFIER )?
            	int alt91 = 2;
            	int LA91_0 = input.LA(1);

            	if ( (LA91_0 == IDENTIFIER) )
            	{
            	    alt91 = 1;
            	}
            	switch (alt91) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:1956:46: I= IDENTIFIER
            	        {
            	        	I=(IToken)Match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_continueStatement8817); if (state.failed) return retval;
            	        	if ( state.backtracking == 0 )
            	        	{I_tree = (object)adaptor.Create(I);
            	        		adaptor.AddChild(root_0, I_tree);
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  Emit((CommonToken)I);
            	        	}

            	        }
            	        break;

            	}

            	PushFollow(FOLLOW_semic_in_continueStatement8822);
            	semic182 = semic();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, semic182.Tree);

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 74, continueStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "continueStatement"

    public class forStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "forStatement"
    // AS3_ex.g3:1964:1: forStatement : F= FOR L= LPAREN forControl R= RPAREN statement ;
    public AS3_exParser.forStatement_return forStatement() // throws RecognitionException [1]
    {   
        AS3_exParser.forStatement_return retval = new AS3_exParser.forStatement_return();
        retval.Start = input.LT(1);
        int forStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken F = null;
        IToken L = null;
        IToken R = null;
        AS3_exParser.forControl_return forControl183 = null;

        AS3_exParser.statement_return statement184 = null;


        object F_tree=null;
        object L_tree=null;
        object R_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 75) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1965:5: (F= FOR L= LPAREN forControl R= RPAREN statement )
            // AS3_ex.g3:1965:9: F= FOR L= LPAREN forControl R= RPAREN statement
            {
            	root_0 = (object)adaptor.GetNilNode();

            	F=(IToken)Match(input,FOR,FOLLOW_FOR_in_forStatement8848); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{F_tree = (object)adaptor.Create(F);
            		adaptor.AddChild(root_0, F_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)F);InsertWS(mPrinter.GetSpacesBetweenControlKeywordsAndParens());
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  PushExpressionIndent();
            	}
            	L=(IToken)Match(input,LPAREN,FOLLOW_LPAREN_in_forStatement8856); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{L_tree = (object)adaptor.Create(L);
            		adaptor.AddChild(root_0, L_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)L);InsertWS(mPrinter.GetAdvancedSpacesInsideParens());
            	}
            	PushFollow(FOLLOW_forControl_in_forStatement8860);
            	forControl183 = forControl();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, forControl183.Tree);
            	R=(IToken)Match(input,RPAREN,FOLLOW_RPAREN_in_forStatement8864); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{R_tree = (object)adaptor.Create(R);
            		adaptor.AddChild(root_0, R_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  InsertWS(mPrinter.GetAdvancedSpacesInsideParens());Emit((CommonToken)R);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  PopIndent();
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  PushIndent(false);
            	}
            	PushFollow(FOLLOW_statement_in_forStatement8870);
            	statement184 = statement();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, statement184.Tree);
            	if ( state.backtracking == 0 ) 
            	{
            	  PopIndent();
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 75, forStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "forStatement"

    public class forInStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "forInStatement"
    // AS3_ex.g3:1968:1: forInStatement : F= FOR L= LPAREN forInControl R= RPAREN statement ;
    public AS3_exParser.forInStatement_return forInStatement() // throws RecognitionException [1]
    {   
        AS3_exParser.forInStatement_return retval = new AS3_exParser.forInStatement_return();
        retval.Start = input.LT(1);
        int forInStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken F = null;
        IToken L = null;
        IToken R = null;
        AS3_exParser.forInControl_return forInControl185 = null;

        AS3_exParser.statement_return statement186 = null;


        object F_tree=null;
        object L_tree=null;
        object R_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 76) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1969:5: (F= FOR L= LPAREN forInControl R= RPAREN statement )
            // AS3_ex.g3:1969:9: F= FOR L= LPAREN forInControl R= RPAREN statement
            {
            	root_0 = (object)adaptor.GetNilNode();

            	F=(IToken)Match(input,FOR,FOLLOW_FOR_in_forInStatement8897); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{F_tree = (object)adaptor.Create(F);
            		adaptor.AddChild(root_0, F_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)F);InsertWS(mPrinter.GetSpacesBetweenControlKeywordsAndParens());
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  PushExpressionIndent();
            	}
            	L=(IToken)Match(input,LPAREN,FOLLOW_LPAREN_in_forInStatement8905); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{L_tree = (object)adaptor.Create(L);
            		adaptor.AddChild(root_0, L_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)L);InsertWS(mPrinter.GetAdvancedSpacesInsideParens());
            	}
            	PushFollow(FOLLOW_forInControl_in_forInStatement8909);
            	forInControl185 = forInControl();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, forInControl185.Tree);
            	R=(IToken)Match(input,RPAREN,FOLLOW_RPAREN_in_forInStatement8913); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{R_tree = (object)adaptor.Create(R);
            		adaptor.AddChild(root_0, R_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  InsertWS(mPrinter.GetAdvancedSpacesInsideParens());Emit((CommonToken)R);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  PopIndent();
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  PushIndent(false);
            	}
            	PushFollow(FOLLOW_statement_in_forInStatement8921);
            	statement186 = statement();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, statement186.Tree);
            	if ( state.backtracking == 0 ) 
            	{
            	  PopIndent();
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 76, forInStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "forInStatement"

    public class forEachInStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "forEachInStatement"
    // AS3_ex.g3:1972:1: forEachInStatement : F= FOR E= EACH L= LPAREN forInControl R= RPAREN statement ;
    public AS3_exParser.forEachInStatement_return forEachInStatement() // throws RecognitionException [1]
    {   
        AS3_exParser.forEachInStatement_return retval = new AS3_exParser.forEachInStatement_return();
        retval.Start = input.LT(1);
        int forEachInStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken F = null;
        IToken E = null;
        IToken L = null;
        IToken R = null;
        AS3_exParser.forInControl_return forInControl187 = null;

        AS3_exParser.statement_return statement188 = null;


        object F_tree=null;
        object E_tree=null;
        object L_tree=null;
        object R_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 77) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1973:5: (F= FOR E= EACH L= LPAREN forInControl R= RPAREN statement )
            // AS3_ex.g3:1973:9: F= FOR E= EACH L= LPAREN forInControl R= RPAREN statement
            {
            	root_0 = (object)adaptor.GetNilNode();

            	F=(IToken)Match(input,FOR,FOLLOW_FOR_in_forEachInStatement8950); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{F_tree = (object)adaptor.Create(F);
            		adaptor.AddChild(root_0, F_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)F);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  PushExpressionIndent();
            	}
            	E=(IToken)Match(input,EACH,FOLLOW_EACH_in_forEachInStatement8968); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{E_tree = (object)adaptor.Create(E);
            		adaptor.AddChild(root_0, E_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)E);InsertWS(mPrinter.GetSpacesBetweenControlKeywordsAndParens());
            	}
            	L=(IToken)Match(input,LPAREN,FOLLOW_LPAREN_in_forEachInStatement8979); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{L_tree = (object)adaptor.Create(L);
            		adaptor.AddChild(root_0, L_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)L);InsertWS(mPrinter.GetAdvancedSpacesInsideParens());
            	}
            	PushFollow(FOLLOW_forInControl_in_forEachInStatement8983);
            	forInControl187 = forInControl();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, forInControl187.Tree);
            	R=(IToken)Match(input,RPAREN,FOLLOW_RPAREN_in_forEachInStatement8987); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{R_tree = (object)adaptor.Create(R);
            		adaptor.AddChild(root_0, R_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  InsertWS(mPrinter.GetAdvancedSpacesInsideParens());Emit((CommonToken)R);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  PopIndent();
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  PushIndent(false);
            	}
            	PushFollow(FOLLOW_statement_in_forEachInStatement8993);
            	statement188 = statement();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, statement188.Tree);
            	if ( state.backtracking == 0 ) 
            	{
            	  PopIndent();
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 77, forEachInStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "forEachInStatement"

    public class forControl_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "forControl"
    // AS3_ex.g3:1978:1: forControl options {k=3; } : ( forInit )? semic ( expression )? semic ( forUpdate )? ;
    public AS3_exParser.forControl_return forControl() // throws RecognitionException [1]
    {   
        AS3_exParser.forControl_return retval = new AS3_exParser.forControl_return();
        retval.Start = input.LT(1);
        int forControl_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.forInit_return forInit189 = null;

        AS3_exParser.semic_return semic190 = null;

        AS3_exParser.expression_return expression191 = null;

        AS3_exParser.semic_return semic192 = null;

        AS3_exParser.forUpdate_return forUpdate193 = null;



        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 78) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1980:5: ( ( forInit )? semic ( expression )? semic ( forUpdate )? )
            // AS3_ex.g3:1980:9: ( forInit )? semic ( expression )? semic ( forUpdate )?
            {
            	root_0 = (object)adaptor.GetNilNode();

            	// AS3_ex.g3:1980:9: ( forInit )?
            	int alt92 = 2;
            	int LA92_0 = input.LA(1);

            	if ( ((LA92_0 >= AS && LA92_0 <= STATIC) || LA92_0 == LCURLY || LA92_0 == LPAREN || LA92_0 == LBRACK || LA92_0 == LT || (LA92_0 >= PLUS && LA92_0 <= STAR) || (LA92_0 >= INC && LA92_0 <= DEC) || (LA92_0 >= NOT && LA92_0 <= INV) || (LA92_0 >= XML_AT && LA92_0 <= XML_LS_STD) || (LA92_0 >= SINGLE_QUOTE_LITERAL && LA92_0 <= DOUBLE_QUOTE_LITERAL) || LA92_0 == REGULAR_EXPR_LITERAL || LA92_0 == HEX_NUMBER_LITERAL || LA92_0 == DEC_NUMBER_LITERAL || LA92_0 == IDENTIFIER || (LA92_0 >= XML_COMMENT && LA92_0 <= XML_PI)) )
            	{
            	    alt92 = 1;
            	}
            	switch (alt92) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:0:0: forInit
            	        {
            	        	PushFollow(FOLLOW_forInit_in_forControl9023);
            	        	forInit189 = forInit();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, forInit189.Tree);

            	        }
            	        break;

            	}

            	if ( state.backtracking == 0 ) 
            	{
            	  InsertWS(mPrinter.GetSpacesBeforeComma());
            	}
            	PushFollow(FOLLOW_semic_in_forControl9028);
            	semic190 = semic();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, semic190.Tree);
            	if ( state.backtracking == 0 ) 
            	{
            	  InsertWS(mPrinter.GetSpacesAfterComma());
            	}
            	// AS3_ex.g3:1980:114: ( expression )?
            	int alt93 = 2;
            	int LA93_0 = input.LA(1);

            	if ( ((LA93_0 >= AS && LA93_0 <= STATIC) || LA93_0 == VOID || LA93_0 == LCURLY || LA93_0 == LPAREN || LA93_0 == LBRACK || LA93_0 == LT || (LA93_0 >= PLUS && LA93_0 <= STAR) || (LA93_0 >= INC && LA93_0 <= DEC) || (LA93_0 >= NOT && LA93_0 <= INV) || (LA93_0 >= XML_AT && LA93_0 <= XML_LS_STD) || (LA93_0 >= SINGLE_QUOTE_LITERAL && LA93_0 <= DOUBLE_QUOTE_LITERAL) || LA93_0 == REGULAR_EXPR_LITERAL || LA93_0 == HEX_NUMBER_LITERAL || LA93_0 == DEC_NUMBER_LITERAL || LA93_0 == IDENTIFIER || (LA93_0 >= XML_COMMENT && LA93_0 <= XML_PI)) )
            	{
            	    alt93 = 1;
            	}
            	switch (alt93) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:0:0: expression
            	        {
            	        	PushFollow(FOLLOW_expression_in_forControl9033);
            	        	expression191 = expression();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, expression191.Tree);

            	        }
            	        break;

            	}

            	if ( state.backtracking == 0 ) 
            	{
            	  InsertWS(mPrinter.GetSpacesBeforeComma());
            	}
            	PushFollow(FOLLOW_semic_in_forControl9037);
            	semic192 = semic();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, semic192.Tree);
            	if ( state.backtracking == 0 ) 
            	{
            	  InsertWS(mPrinter.GetSpacesAfterComma());
            	}
            	// AS3_ex.g3:1980:220: ( forUpdate )?
            	int alt94 = 2;
            	int LA94_0 = input.LA(1);

            	if ( ((LA94_0 >= AS && LA94_0 <= STATIC) || LA94_0 == VOID || LA94_0 == LCURLY || LA94_0 == LPAREN || LA94_0 == LBRACK || LA94_0 == LT || (LA94_0 >= PLUS && LA94_0 <= STAR) || (LA94_0 >= INC && LA94_0 <= DEC) || (LA94_0 >= NOT && LA94_0 <= INV) || (LA94_0 >= XML_AT && LA94_0 <= XML_LS_STD) || (LA94_0 >= SINGLE_QUOTE_LITERAL && LA94_0 <= DOUBLE_QUOTE_LITERAL) || LA94_0 == REGULAR_EXPR_LITERAL || LA94_0 == HEX_NUMBER_LITERAL || LA94_0 == DEC_NUMBER_LITERAL || LA94_0 == IDENTIFIER || (LA94_0 >= XML_COMMENT && LA94_0 <= XML_PI)) )
            	{
            	    alt94 = 1;
            	}
            	switch (alt94) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:0:0: forUpdate
            	        {
            	        	PushFollow(FOLLOW_forUpdate_in_forControl9041);
            	        	forUpdate193 = forUpdate();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, forUpdate193.Tree);

            	        }
            	        break;

            	}


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 78, forControl_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "forControl"

    public class forInControl_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "forInControl"
    // AS3_ex.g3:1983:1: forInControl options {k=3; } : forInDecl I= IN expression ;
    public AS3_exParser.forInControl_return forInControl() // throws RecognitionException [1]
    {   
        AS3_exParser.forInControl_return retval = new AS3_exParser.forInControl_return();
        retval.Start = input.LT(1);
        int forInControl_StartIndex = input.Index();
        object root_0 = null;

        IToken I = null;
        AS3_exParser.forInDecl_return forInDecl194 = null;

        AS3_exParser.expression_return expression195 = null;


        object I_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 79) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1985:5: ( forInDecl I= IN expression )
            // AS3_ex.g3:1985:9: forInDecl I= IN expression
            {
            	root_0 = (object)adaptor.GetNilNode();

            	PushFollow(FOLLOW_forInDecl_in_forInControl9069);
            	forInDecl194 = forInDecl();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, forInDecl194.Tree);
            	I=(IToken)Match(input,IN,FOLLOW_IN_in_forInControl9073); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{I_tree = (object)adaptor.Create(I);
            		adaptor.AddChild(root_0, I_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)I);
            	}
            	PushFollow(FOLLOW_expression_in_forInControl9077);
            	expression195 = expression();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, expression195.Tree);

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 79, forInControl_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "forInControl"

    public class forInDecl_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "forInDecl"
    // AS3_ex.g3:1988:1: forInDecl : ( leftHandSideExpression | V= VAR variableDeclarationNoIn );
    public AS3_exParser.forInDecl_return forInDecl() // throws RecognitionException [1]
    {   
        AS3_exParser.forInDecl_return retval = new AS3_exParser.forInDecl_return();
        retval.Start = input.LT(1);
        int forInDecl_StartIndex = input.Index();
        object root_0 = null;

        IToken V = null;
        AS3_exParser.leftHandSideExpression_return leftHandSideExpression196 = null;

        AS3_exParser.variableDeclarationNoIn_return variableDeclarationNoIn197 = null;


        object V_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 80) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1989:5: ( leftHandSideExpression | V= VAR variableDeclarationNoIn )
            int alt95 = 2;
            int LA95_0 = input.LA(1);

            if ( ((LA95_0 >= AS && LA95_0 <= USE) || (LA95_0 >= VOID && LA95_0 <= STATIC) || LA95_0 == LCURLY || LA95_0 == LPAREN || LA95_0 == LBRACK || LA95_0 == LT || LA95_0 == STAR || (LA95_0 >= XML_AT && LA95_0 <= XML_LS_STD) || (LA95_0 >= SINGLE_QUOTE_LITERAL && LA95_0 <= DOUBLE_QUOTE_LITERAL) || LA95_0 == REGULAR_EXPR_LITERAL || LA95_0 == HEX_NUMBER_LITERAL || LA95_0 == DEC_NUMBER_LITERAL || LA95_0 == IDENTIFIER || (LA95_0 >= XML_COMMENT && LA95_0 <= XML_PI)) )
            {
                alt95 = 1;
            }
            else if ( (LA95_0 == VAR) )
            {
                int LA95_2 = input.LA(2);

                if ( (LA95_2 == NATIVE || LA95_2 == TO || (LA95_2 >= EACH && LA95_2 <= NAMESPACE) || (LA95_2 >= DYNAMIC && LA95_2 <= STATIC) || LA95_2 == IDENTIFIER) )
                {
                    alt95 = 2;
                }
                else if ( (LA95_2 == DOT || LA95_2 == SUB || LA95_2 == COLON || LA95_2 == XML_NS_OP) )
                {
                    alt95 = 1;
                }
                else 
                {
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    NoViableAltException nvae_d95s2 =
                        new NoViableAltException("", 95, 2, input);

                    throw nvae_d95s2;
                }
            }
            else 
            {
                if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                NoViableAltException nvae_d95s0 =
                    new NoViableAltException("", 95, 0, input);

                throw nvae_d95s0;
            }
            switch (alt95) 
            {
                case 1 :
                    // AS3_ex.g3:1989:9: leftHandSideExpression
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_leftHandSideExpression_in_forInDecl9096);
                    	leftHandSideExpression196 = leftHandSideExpression();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, leftHandSideExpression196.Tree);

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:1990:9: V= VAR variableDeclarationNoIn
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	V=(IToken)Match(input,VAR,FOLLOW_VAR_in_forInDecl9108); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{V_tree = (object)adaptor.Create(V);
                    		adaptor.AddChild(root_0, V_tree);
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  Emit((CommonToken)V);
                    	}
                    	PushFollow(FOLLOW_variableDeclarationNoIn_in_forInDecl9112);
                    	variableDeclarationNoIn197 = variableDeclarationNoIn();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, variableDeclarationNoIn197.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 80, forInDecl_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "forInDecl"

    public class forInit_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "forInit"
    // AS3_ex.g3:1993:1: forInit : ( variableDeclarationNoInList | expressionNoIn );
    public AS3_exParser.forInit_return forInit() // throws RecognitionException [1]
    {   
        AS3_exParser.forInit_return retval = new AS3_exParser.forInit_return();
        retval.Start = input.LT(1);
        int forInit_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.variableDeclarationNoInList_return variableDeclarationNoInList198 = null;

        AS3_exParser.expressionNoIn_return expressionNoIn199 = null;



        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 81) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1994:5: ( variableDeclarationNoInList | expressionNoIn )
            int alt96 = 2;
            switch ( input.LA(1) ) 
            {
            case VAR:
            	{
                int LA96_1 = input.LA(2);

                if ( (LA96_1 == DOT || LA96_1 == SUB || LA96_1 == COLON || LA96_1 == XML_NS_OP) )
                {
                    alt96 = 2;
                }
                else if ( (LA96_1 == NATIVE || LA96_1 == TO || (LA96_1 >= EACH && LA96_1 <= NAMESPACE) || (LA96_1 >= DYNAMIC && LA96_1 <= STATIC) || LA96_1 == IDENTIFIER) )
                {
                    alt96 = 1;
                }
                else 
                {
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    NoViableAltException nvae_d96s1 =
                        new NoViableAltException("", 96, 1, input);

                    throw nvae_d96s1;
                }
                }
                break;
            case IDENTIFIER:
            	{
                int LA96_2 = input.LA(2);

                if ( (synpred209_AS3_ex()) )
                {
                    alt96 = 1;
                }
                else if ( (true) )
                {
                    alt96 = 2;
                }
                else 
                {
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    NoViableAltException nvae_d96s2 =
                        new NoViableAltException("", 96, 2, input);

                    throw nvae_d96s2;
                }
                }
                break;
            case NATIVE:
            case TO:
            case EACH:
            case GET:
            case SET:
            case NAMESPACE:
            case DYNAMIC:
            case FINAL:
            case OVERRIDE:
            case STATIC:
            	{
                int LA96_3 = input.LA(2);

                if ( (synpred209_AS3_ex()) )
                {
                    alt96 = 1;
                }
                else if ( (true) )
                {
                    alt96 = 2;
                }
                else 
                {
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    NoViableAltException nvae_d96s3 =
                        new NoViableAltException("", 96, 3, input);

                    throw nvae_d96s3;
                }
                }
                break;
            case AS:
            case BREAK:
            case CASE:
            case CATCH:
            case CLASS:
            case CONST:
            case CONTINUE:
            case DEFAULT:
            case DELETE:
            case DO:
            case ELSE:
            case EXTENDS:
            case FALSE:
            case FINALLY:
            case FOR:
            case FUNCTION:
            case IF:
            case IMPLEMENTS:
            case IMPORT:
            case IN:
            case INSTANCEOF:
            case INTERFACE:
            case INTERNAL:
            case IS:
            case NEW:
            case NULL:
            case PACKAGE:
            case PRIVATE:
            case PROTECTED:
            case PUBLIC:
            case RETURN:
            case SUPER:
            case SWITCH:
            case THIS:
            case THROW:
            case TRUE:
            case TRY:
            case TYPEOF:
            case USE:
            case VOID:
            case WHILE:
            case WITH:
            case INCLUDE:
            case LCURLY:
            case LPAREN:
            case LBRACK:
            case LT:
            case PLUS:
            case SUB:
            case STAR:
            case INC:
            case DEC:
            case NOT:
            case INV:
            case XML_AT:
            case XML_LS_STD:
            case SINGLE_QUOTE_LITERAL:
            case DOUBLE_QUOTE_LITERAL:
            case REGULAR_EXPR_LITERAL:
            case HEX_NUMBER_LITERAL:
            case DEC_NUMBER_LITERAL:
            case XML_COMMENT:
            case XML_CDATA:
            case XML_PI:
            	{
                alt96 = 2;
                }
                break;
            	default:
            	    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            	    NoViableAltException nvae_d96s0 =
            	        new NoViableAltException("", 96, 0, input);

            	    throw nvae_d96s0;
            }

            switch (alt96) 
            {
                case 1 :
                    // AS3_ex.g3:1994:9: variableDeclarationNoInList
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_variableDeclarationNoInList_in_forInit9131);
                    	variableDeclarationNoInList198 = variableDeclarationNoInList();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, variableDeclarationNoInList198.Tree);

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:1995:9: expressionNoIn
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_expressionNoIn_in_forInit9141);
                    	expressionNoIn199 = expressionNoIn();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, expressionNoIn199.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 81, forInit_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "forInit"

    public class forUpdate_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "forUpdate"
    // AS3_ex.g3:1998:1: forUpdate : expression ;
    public AS3_exParser.forUpdate_return forUpdate() // throws RecognitionException [1]
    {   
        AS3_exParser.forUpdate_return retval = new AS3_exParser.forUpdate_return();
        retval.Start = input.LT(1);
        int forUpdate_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.expression_return expression200 = null;



        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 82) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:1999:5: ( expression )
            // AS3_ex.g3:1999:9: expression
            {
            	root_0 = (object)adaptor.GetNilNode();

            	PushFollow(FOLLOW_expression_in_forUpdate9160);
            	expression200 = expression();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, expression200.Tree);

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 82, forUpdate_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "forUpdate"

    public class doWhileStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "doWhileStatement"
    // AS3_ex.g3:2007:1: doWhileStatement : D= DO statement W= WHILE parExpression semic (S= SEMI )? ;
    public AS3_exParser.doWhileStatement_return doWhileStatement() // throws RecognitionException [1]
    {   
        AS3_exParser.doWhileStatement_return retval = new AS3_exParser.doWhileStatement_return();
        retval.Start = input.LT(1);
        int doWhileStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken D = null;
        IToken W = null;
        IToken S = null;
        AS3_exParser.statement_return statement201 = null;

        AS3_exParser.parExpression_return parExpression202 = null;

        AS3_exParser.semic_return semic203 = null;


        object D_tree=null;
        object W_tree=null;
        object S_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 83) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2008:5: (D= DO statement W= WHILE parExpression semic (S= SEMI )? )
            // AS3_ex.g3:2008:9: D= DO statement W= WHILE parExpression semic (S= SEMI )?
            {
            	root_0 = (object)adaptor.GetNilNode();

            	D=(IToken)Match(input,DO,FOLLOW_DO_in_doWhileStatement9186); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{D_tree = (object)adaptor.Create(D);
            		adaptor.AddChild(root_0, D_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)D);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  PushIndent(false);
            	}
            	PushFollow(FOLLOW_statement_in_doWhileStatement9192);
            	statement201 = statement();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, statement201.Tree);
            	if ( state.backtracking == 0 ) 
            	{
            	  PopIndent();
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  InsertWS(1);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  PushExpressionIndent();
            	}
            	W=(IToken)Match(input,WHILE,FOLLOW_WHILE_in_doWhileStatement9201); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{W_tree = (object)adaptor.Create(W);
            		adaptor.AddChild(root_0, W_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)W);InsertWS(mPrinter.GetSpacesBetweenControlKeywordsAndParens());
            	}
            	PushFollow(FOLLOW_parExpression_in_doWhileStatement9205);
            	parExpression202 = parExpression();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, parExpression202.Tree);
            	PushFollow(FOLLOW_semic_in_doWhileStatement9207);
            	semic203 = semic();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, semic203.Tree);
            	// AS3_ex.g3:2008:240: (S= SEMI )?
            	int alt97 = 2;
            	int LA97_0 = input.LA(1);

            	if ( (LA97_0 == SEMI) )
            	{
            	    int LA97_1 = input.LA(2);

            	    if ( (synpred210_AS3_ex()) )
            	    {
            	        alt97 = 1;
            	    }
            	}
            	switch (alt97) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:2008:241: S= SEMI
            	        {
            	        	S=(IToken)Match(input,SEMI,FOLLOW_SEMI_in_doWhileStatement9212); if (state.failed) return retval;
            	        	if ( state.backtracking == 0 )
            	        	{S_tree = (object)adaptor.Create(S);
            	        		adaptor.AddChild(root_0, S_tree);
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  Emit((CommonToken)S);
            	        	}

            	        }
            	        break;

            	}

            	if ( state.backtracking == 0 ) 
            	{
            	  PopIndent();
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 83, doWhileStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "doWhileStatement"

    public class whileStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "whileStatement"
    // AS3_ex.g3:2015:1: whileStatement : W= WHILE parExpression statement ;
    public AS3_exParser.whileStatement_return whileStatement() // throws RecognitionException [1]
    {   
        AS3_exParser.whileStatement_return retval = new AS3_exParser.whileStatement_return();
        retval.Start = input.LT(1);
        int whileStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken W = null;
        AS3_exParser.parExpression_return parExpression204 = null;

        AS3_exParser.statement_return statement205 = null;


        object W_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 84) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2016:5: (W= WHILE parExpression statement )
            // AS3_ex.g3:2016:9: W= WHILE parExpression statement
            {
            	root_0 = (object)adaptor.GetNilNode();

            	W=(IToken)Match(input,WHILE,FOLLOW_WHILE_in_whileStatement9242); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{W_tree = (object)adaptor.Create(W);
            		adaptor.AddChild(root_0, W_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)W);InsertWS(mPrinter.GetSpacesBetweenControlKeywordsAndParens());
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  PushExpressionIndent();
            	}
            	PushFollow(FOLLOW_parExpression_in_whileStatement9247);
            	parExpression204 = parExpression();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, parExpression204.Tree);
            	if ( state.backtracking == 0 ) 
            	{
            	  PopIndent();
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  PushIndent(false);
            	}
            	PushFollow(FOLLOW_statement_in_whileStatement9253);
            	statement205 = statement();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, statement205.Tree);
            	if ( state.backtracking == 0 ) 
            	{
            	  PopIndent();
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 84, whileStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "whileStatement"

    public class ifStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "ifStatement"
    // AS3_ex.g3:2025:1: ifStatement : I= IF parExpression statement ( options {k=1; } : E= ELSE statement )? ;
    public AS3_exParser.ifStatement_return ifStatement() // throws RecognitionException [1]
    {   
        AS3_exParser.ifStatement_return retval = new AS3_exParser.ifStatement_return();
        retval.Start = input.LT(1);
        int ifStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken I = null;
        IToken E = null;
        AS3_exParser.parExpression_return parExpression206 = null;

        AS3_exParser.statement_return statement207 = null;

        AS3_exParser.statement_return statement208 = null;


        object I_tree=null;
        object E_tree=null;


           CommonToken tok=null;
           bool ifOnSameLine=false;
           bool wasBlock=false;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 85) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2032:5: (I= IF parExpression statement ( options {k=1; } : E= ELSE statement )? )
            // AS3_ex.g3:2033:9: I= IF parExpression statement ( options {k=1; } : E= ELSE statement )?
            {
            	root_0 = (object)adaptor.GetNilNode();

            	if ( state.backtracking == 0 ) 
            	{

            	             tok=mPrinter.GetLastToken(); 
            	             //if the previous token was not an else, then insert a CR.  Also if it is an 'else' but the setting says to put the 'if' on a new line
            	             if (!mPrinter.IsKeepElseIfOnSameLine() || (tok==null) || !tok.Text.Equals("else"))
            	             {
            	             		InsertStatementCR();
            	             }

            	             if (tok!=null && tok.Text.Equals("else"))
            	             {
            	             		mPrinter.SetElseIfState();
            	             }
            	          
            	}
            	I=(IToken)Match(input,IF,FOLLOW_IF_in_ifStatement9316); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{I_tree = (object)adaptor.Create(I);
            		adaptor.AddChild(root_0, I_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{

            	                Emit((CommonToken)I);
            	                ifOnSameLine=mPrinter.GetElseIfNeedToLoseIndent();
            	                if (ifOnSameLine)
            	                    PopIndent();
            	                InsertWS(mPrinter.GetSpacesBetweenControlKeywordsAndParens());
            	           
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  PushExpressionIndent();
            	}
            	PushFollow(FOLLOW_parExpression_in_ifStatement9351);
            	parExpression206 = parExpression();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, parExpression206.Tree);
            	if ( state.backtracking == 0 ) 
            	{
            	  PopIndent();
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  PushIndent(false);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  AddIfElseBlockTracker();SetBlockFlag(false);ClearBlockFlag();
            	}
            	PushFollow(FOLLOW_statement_in_ifStatement9396);
            	statement207 = statement();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, statement207.Tree);
            	if ( state.backtracking == 0 ) 
            	{
            	  wasBlock=IsBlockFlag();PopIfElseBlockTracker();
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  PopIndent();
            	}
            	// AS3_ex.g3:2063:10: ( options {k=1; } : E= ELSE statement )?
            	int alt98 = 2;
            	int LA98_0 = input.LA(1);

            	if ( (LA98_0 == ELSE) )
            	{
            	    int LA98_2 = input.LA(2);

            	    if ( (synpred211_AS3_ex()) )
            	    {
            	        alt98 = 1;
            	    }
            	}
            	switch (alt98) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:2063:26: E= ELSE statement
            	        {
            	        	E=(IToken)Match(input,ELSE,FOLLOW_ELSE_in_ifStatement9451); if (state.failed) return retval;
            	        	if ( state.backtracking == 0 )
            	        	{E_tree = (object)adaptor.Create(E);
            	        		adaptor.AddChild(root_0, E_tree);
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{

            	        	  	          CommonToken tempTok= (CommonToken) mPrinter.GetLastToken();
            	        	  	          if (mPrinter.IsCRBeforeElse() || !wasBlock)//tempTok==null || !tempTok.Text.Equals("}")) 
            	        	  	              InsertCR(false);
            	        	  	         
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  InsertWS(1);
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  Emit((CommonToken)E);
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  PushIndent(false);
            	        	}
            	        	PushFollow(FOLLOW_statement_in_ifStatement9492);
            	        	statement208 = statement();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, statement208.Tree);
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  PopIndent();
            	        	}

            	        }
            	        break;

            	}

            	if ( state.backtracking == 0 ) 
            	{
            	  if (ifOnSameLine)
            	              	PushIndent(false);
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 85, ifStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "ifStatement"

    public class emptyStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "emptyStatement"
    // AS3_ex.g3:2081:1: emptyStatement : S= SEMI ;
    public AS3_exParser.emptyStatement_return emptyStatement() // throws RecognitionException [1]
    {   
        AS3_exParser.emptyStatement_return retval = new AS3_exParser.emptyStatement_return();
        retval.Start = input.LT(1);
        int emptyStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken S = null;

        object S_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 86) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2082:5: (S= SEMI )
            // AS3_ex.g3:2082:11: S= SEMI
            {
            	root_0 = (object)adaptor.GetNilNode();

            	S=(IToken)Match(input,SEMI,FOLLOW_SEMI_in_emptyStatement9550); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{S_tree = (object)adaptor.Create(S);
            		adaptor.AddChild(root_0, S_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)S);
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 86, emptyStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "emptyStatement"

    public class variableStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "variableStatement"
    // AS3_ex.g3:2090:1: variableStatement : (I= IDENTIFIER )? V= VAR variableDeclaration (C= COMMA variableDeclaration )* semic ;
    public AS3_exParser.variableStatement_return variableStatement() // throws RecognitionException [1]
    {   
        AS3_exParser.variableStatement_return retval = new AS3_exParser.variableStatement_return();
        retval.Start = input.LT(1);
        int variableStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken I = null;
        IToken V = null;
        IToken C = null;
        AS3_exParser.variableDeclaration_return variableDeclaration209 = null;

        AS3_exParser.variableDeclaration_return variableDeclaration210 = null;

        AS3_exParser.semic_return semic211 = null;


        object I_tree=null;
        object V_tree=null;
        object C_tree=null;


        	WrapOptions options=mPrinter.GetExpressionWrapOptions();
        	bool pushedFormat=false;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 87) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2095:5: ( (I= IDENTIFIER )? V= VAR variableDeclaration (C= COMMA variableDeclaration )* semic )
            // AS3_ex.g3:2096:6: (I= IDENTIFIER )? V= VAR variableDeclaration (C= COMMA variableDeclaration )* semic
            {
            	root_0 = (object)adaptor.GetNilNode();

            	if ( state.backtracking == 0 ) 
            	{
            	  pushedFormat=PushFormatType(options, false);
            	}
            	// AS3_ex.g3:2097:9: (I= IDENTIFIER )?
            	int alt99 = 2;
            	int LA99_0 = input.LA(1);

            	if ( (LA99_0 == IDENTIFIER) )
            	{
            	    alt99 = 1;
            	}
            	switch (alt99) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:2097:10: I= IDENTIFIER
            	        {
            	        	I=(IToken)Match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_variableStatement9597); if (state.failed) return retval;
            	        	if ( state.backtracking == 0 )
            	        	{I_tree = (object)adaptor.Create(I);
            	        		adaptor.AddChild(root_0, I_tree);
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  Emit((CommonToken)I);
            	        	}

            	        }
            	        break;

            	}

            	V=(IToken)Match(input,VAR,FOLLOW_VAR_in_variableStatement9605); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{V_tree = (object)adaptor.Create(V);
            		adaptor.AddChild(root_0, V_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)V);
            	}
            	PushFollow(FOLLOW_variableDeclaration_in_variableStatement9609);
            	variableDeclaration209 = variableDeclaration();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, variableDeclaration209.Tree);
            	// AS3_ex.g3:2097:101: (C= COMMA variableDeclaration )*
            	do 
            	{
            	    int alt100 = 2;
            	    int LA100_0 = input.LA(1);

            	    if ( (LA100_0 == COMMA) )
            	    {
            	        alt100 = 1;
            	    }


            	    switch (alt100) 
            		{
            			case 1 :
            			    // AS3_ex.g3:2097:103: C= COMMA variableDeclaration
            			    {
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  InsertWS(mPrinter.GetSpacesBeforeComma());
            			    	}
            			    	C=(IToken)Match(input,COMMA,FOLLOW_COMMA_in_variableStatement9616); if (state.failed) return retval;
            			    	if ( state.backtracking == 0 )
            			    	{C_tree = (object)adaptor.Create(C);
            			    		adaptor.AddChild(root_0, C_tree);
            			    	}
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  Emit((CommonToken)C);
            			    	}
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  InsertWS(mPrinter.GetSpacesAfterComma());
            			    	}
            			    	PushFollow(FOLLOW_variableDeclaration_in_variableStatement9621);
            			    	variableDeclaration210 = variableDeclaration();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, variableDeclaration210.Tree);

            			    }
            			    break;

            			default:
            			    goto loop100;
            	    }
            	} while (true);

            	loop100:
            		;	// Stops C# compiler whining that label 'loop100' has no statements

            	PushFollow(FOLLOW_semic_in_variableStatement9626);
            	semic211 = semic();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, semic211.Tree);
            	if ( state.backtracking == 0 ) 
            	{

            	  	   	    if (pushedFormat)
            	  	   	    	mPrinter.PopFormatMode();
            	      	
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 87, variableStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "variableStatement"

    public class variableDeclarationList_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "variableDeclarationList"
    // AS3_ex.g3:2105:1: variableDeclarationList : variableDeclaration (C= COMMA variableDeclaration )* ;
    public AS3_exParser.variableDeclarationList_return variableDeclarationList() // throws RecognitionException [1]
    {   
        AS3_exParser.variableDeclarationList_return retval = new AS3_exParser.variableDeclarationList_return();
        retval.Start = input.LT(1);
        int variableDeclarationList_StartIndex = input.Index();
        object root_0 = null;

        IToken C = null;
        AS3_exParser.variableDeclaration_return variableDeclaration212 = null;

        AS3_exParser.variableDeclaration_return variableDeclaration213 = null;


        object C_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 88) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2106:5: ( variableDeclaration (C= COMMA variableDeclaration )* )
            // AS3_ex.g3:2106:11: variableDeclaration (C= COMMA variableDeclaration )*
            {
            	root_0 = (object)adaptor.GetNilNode();

            	PushFollow(FOLLOW_variableDeclaration_in_variableDeclarationList9668);
            	variableDeclaration212 = variableDeclaration();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, variableDeclaration212.Tree);
            	// AS3_ex.g3:2106:31: (C= COMMA variableDeclaration )*
            	do 
            	{
            	    int alt101 = 2;
            	    int LA101_0 = input.LA(1);

            	    if ( (LA101_0 == COMMA) )
            	    {
            	        alt101 = 1;
            	    }


            	    switch (alt101) 
            		{
            			case 1 :
            			    // AS3_ex.g3:2106:33: C= COMMA variableDeclaration
            			    {
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  InsertWS(mPrinter.GetSpacesBeforeComma());
            			    	}
            			    	C=(IToken)Match(input,COMMA,FOLLOW_COMMA_in_variableDeclarationList9676); if (state.failed) return retval;
            			    	if ( state.backtracking == 0 )
            			    	{C_tree = (object)adaptor.Create(C);
            			    		adaptor.AddChild(root_0, C_tree);
            			    	}
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  Emit((CommonToken)C);
            			    	}
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  InsertWS(mPrinter.GetSpacesAfterComma());
            			    	}
            			    	PushFollow(FOLLOW_variableDeclaration_in_variableDeclarationList9681);
            			    	variableDeclaration213 = variableDeclaration();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, variableDeclaration213.Tree);

            			    }
            			    break;

            			default:
            			    goto loop101;
            	    }
            	} while (true);

            	loop101:
            		;	// Stops C# compiler whining that label 'loop101' has no statements


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 88, variableDeclarationList_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "variableDeclarationList"

    public class variableDeclarationNoInList_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "variableDeclarationNoInList"
    // AS3_ex.g3:2109:1: variableDeclarationNoInList : (V= VAR )? variableDeclarationNoIn (C= COMMA variableDeclarationNoIn )* ;
    public AS3_exParser.variableDeclarationNoInList_return variableDeclarationNoInList() // throws RecognitionException [1]
    {   
        AS3_exParser.variableDeclarationNoInList_return retval = new AS3_exParser.variableDeclarationNoInList_return();
        retval.Start = input.LT(1);
        int variableDeclarationNoInList_StartIndex = input.Index();
        object root_0 = null;

        IToken V = null;
        IToken C = null;
        AS3_exParser.variableDeclarationNoIn_return variableDeclarationNoIn214 = null;

        AS3_exParser.variableDeclarationNoIn_return variableDeclarationNoIn215 = null;


        object V_tree=null;
        object C_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 89) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2110:5: ( (V= VAR )? variableDeclarationNoIn (C= COMMA variableDeclarationNoIn )* )
            // AS3_ex.g3:2110:10: (V= VAR )? variableDeclarationNoIn (C= COMMA variableDeclarationNoIn )*
            {
            	root_0 = (object)adaptor.GetNilNode();

            	// AS3_ex.g3:2110:10: (V= VAR )?
            	int alt102 = 2;
            	int LA102_0 = input.LA(1);

            	if ( (LA102_0 == VAR) )
            	{
            	    alt102 = 1;
            	}
            	switch (alt102) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:2110:11: V= VAR
            	        {
            	        	V=(IToken)Match(input,VAR,FOLLOW_VAR_in_variableDeclarationNoInList9710); if (state.failed) return retval;
            	        	if ( state.backtracking == 0 )
            	        	{V_tree = (object)adaptor.Create(V);
            	        		adaptor.AddChild(root_0, V_tree);
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  Emit((CommonToken)V);
            	        	}

            	        }
            	        break;

            	}

            	PushFollow(FOLLOW_variableDeclarationNoIn_in_variableDeclarationNoInList9716);
            	variableDeclarationNoIn214 = variableDeclarationNoIn();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, variableDeclarationNoIn214.Tree);
            	// AS3_ex.g3:2110:68: (C= COMMA variableDeclarationNoIn )*
            	do 
            	{
            	    int alt103 = 2;
            	    int LA103_0 = input.LA(1);

            	    if ( (LA103_0 == COMMA) )
            	    {
            	        alt103 = 1;
            	    }


            	    switch (alt103) 
            		{
            			case 1 :
            			    // AS3_ex.g3:2110:70: C= COMMA variableDeclarationNoIn
            			    {
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  InsertWS(mPrinter.GetSpacesBeforeComma());
            			    	}
            			    	C=(IToken)Match(input,COMMA,FOLLOW_COMMA_in_variableDeclarationNoInList9724); if (state.failed) return retval;
            			    	if ( state.backtracking == 0 )
            			    	{C_tree = (object)adaptor.Create(C);
            			    		adaptor.AddChild(root_0, C_tree);
            			    	}
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  Emit((CommonToken)C);
            			    	}
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  InsertWS(mPrinter.GetSpacesAfterComma());
            			    	}
            			    	PushFollow(FOLLOW_variableDeclarationNoIn_in_variableDeclarationNoInList9729);
            			    	variableDeclarationNoIn215 = variableDeclarationNoIn();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, variableDeclarationNoIn215.Tree);

            			    }
            			    break;

            			default:
            			    goto loop103;
            	    }
            	} while (true);

            	loop103:
            		;	// Stops C# compiler whining that label 'loop103' has no statements


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 89, variableDeclarationNoInList_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "variableDeclarationNoInList"

    public class variableDeclaration_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "variableDeclaration"
    // AS3_ex.g3:2113:1: variableDeclaration : variableIdentifierDecl (A= ASSIGN assignmentExpression )? ;
    public AS3_exParser.variableDeclaration_return variableDeclaration() // throws RecognitionException [1]
    {   
        AS3_exParser.variableDeclaration_return retval = new AS3_exParser.variableDeclaration_return();
        retval.Start = input.LT(1);
        int variableDeclaration_StartIndex = input.Index();
        object root_0 = null;

        IToken A = null;
        AS3_exParser.variableIdentifierDecl_return variableIdentifierDecl216 = null;

        AS3_exParser.assignmentExpression_return assignmentExpression217 = null;


        object A_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 90) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2114:5: ( variableIdentifierDecl (A= ASSIGN assignmentExpression )? )
            // AS3_ex.g3:2114:9: variableIdentifierDecl (A= ASSIGN assignmentExpression )?
            {
            	root_0 = (object)adaptor.GetNilNode();

            	PushFollow(FOLLOW_variableIdentifierDecl_in_variableDeclaration9754);
            	variableIdentifierDecl216 = variableIdentifierDecl();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, variableIdentifierDecl216.Tree);
            	// AS3_ex.g3:2114:32: (A= ASSIGN assignmentExpression )?
            	int alt104 = 2;
            	int LA104_0 = input.LA(1);

            	if ( (LA104_0 == ASSIGN) )
            	{
            	    alt104 = 1;
            	}
            	switch (alt104) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:2114:34: A= ASSIGN assignmentExpression
            	        {
            	        	A=(IToken)Match(input,ASSIGN,FOLLOW_ASSIGN_in_variableDeclaration9760); if (state.failed) return retval;
            	        	if ( state.backtracking == 0 )
            	        	{A_tree = (object)adaptor.Create(A);
            	        		adaptor.AddChild(root_0, A_tree);
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{

            	        	      		InsertVariableDeclAssignmentWhitespace((CommonToken) A, true);
            	        	      		//InsertWS(mPrinter.isInParameterDecl() ? mPrinter.getAdvancedSpacesAroundAssignmentInOptionalParameters() : mPrinter.getSpacesAroundAssignment());
            	        	      		Emit((CommonToken)A);
            	        	      		InsertVariableDeclAssignmentWhitespace((CommonToken) A, false);
            	        	      		//InsertWS(mPrinter.isInParameterDecl() ? mPrinter.getAdvancedSpacesAroundAssignmentInOptionalParameters() : mPrinter.getSpacesAroundAssignment());
            	        	      	
            	        	}
            	        	PushFollow(FOLLOW_assignmentExpression_in_variableDeclaration9776);
            	        	assignmentExpression217 = assignmentExpression();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, assignmentExpression217.Tree);

            	        }
            	        break;

            	}


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 90, variableDeclaration_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "variableDeclaration"

    public class variableDeclarationNoIn_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "variableDeclarationNoIn"
    // AS3_ex.g3:2125:1: variableDeclarationNoIn : variableIdentifierDecl (A= ASSIGN assignmentExpressionNoIn )? ;
    public AS3_exParser.variableDeclarationNoIn_return variableDeclarationNoIn() // throws RecognitionException [1]
    {   
        AS3_exParser.variableDeclarationNoIn_return retval = new AS3_exParser.variableDeclarationNoIn_return();
        retval.Start = input.LT(1);
        int variableDeclarationNoIn_StartIndex = input.Index();
        object root_0 = null;

        IToken A = null;
        AS3_exParser.variableIdentifierDecl_return variableIdentifierDecl218 = null;

        AS3_exParser.assignmentExpressionNoIn_return assignmentExpressionNoIn219 = null;


        object A_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 91) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2126:5: ( variableIdentifierDecl (A= ASSIGN assignmentExpressionNoIn )? )
            // AS3_ex.g3:2126:10: variableIdentifierDecl (A= ASSIGN assignmentExpressionNoIn )?
            {
            	root_0 = (object)adaptor.GetNilNode();

            	PushFollow(FOLLOW_variableIdentifierDecl_in_variableDeclarationNoIn9799);
            	variableIdentifierDecl218 = variableIdentifierDecl();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, variableIdentifierDecl218.Tree);
            	// AS3_ex.g3:2126:33: (A= ASSIGN assignmentExpressionNoIn )?
            	int alt105 = 2;
            	int LA105_0 = input.LA(1);

            	if ( (LA105_0 == ASSIGN) )
            	{
            	    alt105 = 1;
            	}
            	switch (alt105) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:2126:35: A= ASSIGN assignmentExpressionNoIn
            	        {
            	        	A=(IToken)Match(input,ASSIGN,FOLLOW_ASSIGN_in_variableDeclarationNoIn9805); if (state.failed) return retval;
            	        	if ( state.backtracking == 0 )
            	        	{A_tree = (object)adaptor.Create(A);
            	        		adaptor.AddChild(root_0, A_tree);
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{

            	        	            InsertVariableDeclAssignmentWhitespace((CommonToken) A, true);
            	        	            //InsertWS(mPrinter.getSpacesAroundAssignment());
            	        	            Emit((CommonToken)A);
            	        	            InsertVariableDeclAssignmentWhitespace((CommonToken) A, false);
            	        	            //InsertWS(mPrinter.getSpacesAroundAssignment());
            	        	           
            	        	}
            	        	PushFollow(FOLLOW_assignmentExpressionNoIn_in_variableDeclarationNoIn9829);
            	        	assignmentExpressionNoIn219 = assignmentExpressionNoIn();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, assignmentExpressionNoIn219.Tree);

            	        }
            	        break;

            	}


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 91, variableDeclarationNoIn_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "variableDeclarationNoIn"

    public class variableIdentifierDecl_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "variableIdentifierDecl"
    // AS3_ex.g3:2137:1: variableIdentifierDecl : identifierLiteral (C= COLON type )? ;
    public AS3_exParser.variableIdentifierDecl_return variableIdentifierDecl() // throws RecognitionException [1]
    {   
        AS3_exParser.variableIdentifierDecl_return retval = new AS3_exParser.variableIdentifierDecl_return();
        retval.Start = input.LT(1);
        int variableIdentifierDecl_StartIndex = input.Index();
        object root_0 = null;

        IToken C = null;
        AS3_exParser.identifierLiteral_return identifierLiteral220 = null;

        AS3_exParser.type_return type221 = null;


        object C_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 92) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2138:5: ( identifierLiteral (C= COLON type )? )
            // AS3_ex.g3:2138:10: identifierLiteral (C= COLON type )?
            {
            	root_0 = (object)adaptor.GetNilNode();

            	PushFollow(FOLLOW_identifierLiteral_in_variableIdentifierDecl9856);
            	identifierLiteral220 = identifierLiteral();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, identifierLiteral220.Tree);
            	// AS3_ex.g3:2138:28: (C= COLON type )?
            	int alt106 = 2;
            	int LA106_0 = input.LA(1);

            	if ( (LA106_0 == COLON) )
            	{
            	    alt106 = 1;
            	}
            	switch (alt106) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:2138:30: C= COLON type
            	        {
            	        	C=(IToken)Match(input,COLON,FOLLOW_COLON_in_variableIdentifierDecl9862); if (state.failed) return retval;
            	        	if ( state.backtracking == 0 )
            	        	{C_tree = (object)adaptor.Create(C);
            	        		adaptor.AddChild(root_0, C_tree);
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  InsertWS(mPrinter.GetAdvancedSpacesBeforeColons());Emit((CommonToken)C);InsertWS(mPrinter.GetAdvancedSpacesAfterColons());
            	        	}
            	        	PushFollow(FOLLOW_type_in_variableIdentifierDecl9866);
            	        	type221 = type();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, type221.Tree);

            	        }
            	        break;

            	}


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 92, variableIdentifierDecl_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "variableIdentifierDecl"

    public class type_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "type"
    // AS3_ex.g3:2144:1: type : ( qualifiedName | S= STAR | V= VOID );
    public AS3_exParser.type_return type() // throws RecognitionException [1]
    {   
        AS3_exParser.type_return retval = new AS3_exParser.type_return();
        retval.Start = input.LT(1);
        int type_StartIndex = input.Index();
        object root_0 = null;

        IToken S = null;
        IToken V = null;
        AS3_exParser.qualifiedName_return qualifiedName222 = null;


        object S_tree=null;
        object V_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 93) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2144:5: ( qualifiedName | S= STAR | V= VOID )
            int alt107 = 3;
            switch ( input.LA(1) ) 
            {
            case DEFAULT:
            case INTERNAL:
            case NATIVE:
            case TO:
            case EACH:
            case GET:
            case SET:
            case NAMESPACE:
            case DYNAMIC:
            case FINAL:
            case OVERRIDE:
            case STATIC:
            case IDENTIFIER:
            	{
                alt107 = 1;
                }
                break;
            case STAR:
            	{
                alt107 = 2;
                }
                break;
            case VOID:
            	{
                alt107 = 3;
                }
                break;
            	default:
            	    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            	    NoViableAltException nvae_d107s0 =
            	        new NoViableAltException("", 107, 0, input);

            	    throw nvae_d107s0;
            }

            switch (alt107) 
            {
                case 1 :
                    // AS3_ex.g3:2144:9: qualifiedName
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_qualifiedName_in_type9890);
                    	qualifiedName222 = qualifiedName();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, qualifiedName222.Tree);

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:2144:25: S= STAR
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	S=(IToken)Match(input,STAR,FOLLOW_STAR_in_type9896); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{S_tree = (object)adaptor.Create(S);
                    		adaptor.AddChild(root_0, S_tree);
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  Emit((CommonToken)S);
                    	}

                    }
                    break;
                case 3 :
                    // AS3_ex.g3:2144:59: V= VOID
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	V=(IToken)Match(input,VOID,FOLLOW_VOID_in_type9904); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{V_tree = (object)adaptor.Create(V);
                    		adaptor.AddChild(root_0, V_tree);
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  Emit((CommonToken)V);
                    	}

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 93, type_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "type"

    public class typeList_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "typeList"
    // AS3_ex.g3:2146:1: typeList : type (C= COMMA type )* ;
    public AS3_exParser.typeList_return typeList() // throws RecognitionException [1]
    {   
        AS3_exParser.typeList_return retval = new AS3_exParser.typeList_return();
        retval.Start = input.LT(1);
        int typeList_StartIndex = input.Index();
        object root_0 = null;

        IToken C = null;
        AS3_exParser.type_return type223 = null;

        AS3_exParser.type_return type224 = null;


        object C_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 94) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2147:5: ( type (C= COMMA type )* )
            // AS3_ex.g3:2147:9: type (C= COMMA type )*
            {
            	root_0 = (object)adaptor.GetNilNode();

            	PushFollow(FOLLOW_type_in_typeList9921);
            	type223 = type();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, type223.Tree);
            	// AS3_ex.g3:2147:14: (C= COMMA type )*
            	do 
            	{
            	    int alt108 = 2;
            	    int LA108_0 = input.LA(1);

            	    if ( (LA108_0 == COMMA) )
            	    {
            	        alt108 = 1;
            	    }


            	    switch (alt108) 
            		{
            			case 1 :
            			    // AS3_ex.g3:2147:15: C= COMMA type
            			    {
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  InsertWS(mPrinter.GetSpacesBeforeComma());
            			    	}
            			    	C=(IToken)Match(input,COMMA,FOLLOW_COMMA_in_typeList9927); if (state.failed) return retval;
            			    	if ( state.backtracking == 0 )
            			    	{C_tree = (object)adaptor.Create(C);
            			    		adaptor.AddChild(root_0, C_tree);
            			    	}
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  Emit((CommonToken)C);
            			    	}
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  InsertWS(mPrinter.GetSpacesAfterComma());
            			    	}
            			    	PushFollow(FOLLOW_type_in_typeList9932);
            			    	type224 = type();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, type224.Tree);

            			    }
            			    break;

            			default:
            			    goto loop108;
            	    }
            	} while (true);

            	loop108:
            		;	// Stops C# compiler whining that label 'loop108' has no statements


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 94, typeList_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "typeList"

    public class standardQualifiedName_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "standardQualifiedName"
    // AS3_ex.g3:2151:1: standardQualifiedName : typeSpecifier (D= DOT typeSpecifier )* ;
    public AS3_exParser.standardQualifiedName_return standardQualifiedName() // throws RecognitionException [1]
    {   
        AS3_exParser.standardQualifiedName_return retval = new AS3_exParser.standardQualifiedName_return();
        retval.Start = input.LT(1);
        int standardQualifiedName_StartIndex = input.Index();
        object root_0 = null;

        IToken D = null;
        AS3_exParser.typeSpecifier_return typeSpecifier225 = null;

        AS3_exParser.typeSpecifier_return typeSpecifier226 = null;


        object D_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 95) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2152:2: ( typeSpecifier (D= DOT typeSpecifier )* )
            // AS3_ex.g3:2153:2: typeSpecifier (D= DOT typeSpecifier )*
            {
            	root_0 = (object)adaptor.GetNilNode();

            	PushFollow(FOLLOW_typeSpecifier_in_standardQualifiedName9956);
            	typeSpecifier225 = typeSpecifier();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, typeSpecifier225.Tree);
            	// AS3_ex.g3:2153:16: (D= DOT typeSpecifier )*
            	do 
            	{
            	    int alt109 = 2;
            	    int LA109_0 = input.LA(1);

            	    if ( (LA109_0 == DOT) )
            	    {
            	        int LA109_1 = input.LA(2);

            	        if ( (LA109_1 == DEFAULT || LA109_1 == INTERNAL || LA109_1 == NATIVE || LA109_1 == TO || (LA109_1 >= EACH && LA109_1 <= NAMESPACE) || (LA109_1 >= DYNAMIC && LA109_1 <= STATIC) || LA109_1 == IDENTIFIER) )
            	        {
            	            alt109 = 1;
            	        }


            	    }


            	    switch (alt109) 
            		{
            			case 1 :
            			    // AS3_ex.g3:2153:17: D= DOT typeSpecifier
            			    {
            			    	D=(IToken)Match(input,DOT,FOLLOW_DOT_in_standardQualifiedName9961); if (state.failed) return retval;
            			    	if ( state.backtracking == 0 )
            			    	{D_tree = (object)adaptor.Create(D);
            			    		adaptor.AddChild(root_0, D_tree);
            			    	}
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  Emit((CommonToken)D);
            			    	}
            			    	PushFollow(FOLLOW_typeSpecifier_in_standardQualifiedName9965);
            			    	typeSpecifier226 = typeSpecifier();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, typeSpecifier226.Tree);

            			    }
            			    break;

            			default:
            			    goto loop109;
            	    }
            	} while (true);

            	loop109:
            		;	// Stops C# compiler whining that label 'loop109' has no statements


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 95, standardQualifiedName_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "standardQualifiedName"

    public class qualifiedName_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "qualifiedName"
    // AS3_ex.g3:2157:1: qualifiedName : standardQualifiedName ( typePostfixSyntax )? ;
    public AS3_exParser.qualifiedName_return qualifiedName() // throws RecognitionException [1]
    {   
        AS3_exParser.qualifiedName_return retval = new AS3_exParser.qualifiedName_return();
        retval.Start = input.LT(1);
        int qualifiedName_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.standardQualifiedName_return standardQualifiedName227 = null;

        AS3_exParser.typePostfixSyntax_return typePostfixSyntax228 = null;



        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 96) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2158:5: ( standardQualifiedName ( typePostfixSyntax )? )
            // AS3_ex.g3:2159:6: standardQualifiedName ( typePostfixSyntax )?
            {
            	root_0 = (object)adaptor.GetNilNode();

            	PushFollow(FOLLOW_standardQualifiedName_in_qualifiedName9993);
            	standardQualifiedName227 = standardQualifiedName();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, standardQualifiedName227.Tree);
            	// AS3_ex.g3:2159:28: ( typePostfixSyntax )?
            	int alt110 = 2;
            	int LA110_0 = input.LA(1);

            	if ( (LA110_0 == DOT) )
            	{
            	    int LA110_1 = input.LA(2);

            	    if ( (LA110_1 == LT) )
            	    {
            	        alt110 = 1;
            	    }
            	}
            	switch (alt110) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:2159:29: typePostfixSyntax
            	        {
            	        	PushFollow(FOLLOW_typePostfixSyntax_in_qualifiedName9996);
            	        	typePostfixSyntax228 = typePostfixSyntax();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, typePostfixSyntax228.Tree);

            	        }
            	        break;

            	}


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 96, qualifiedName_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "qualifiedName"

    public class typePostfixSyntax_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "typePostfixSyntax"
    // AS3_ex.g3:2162:1: typePostfixSyntax : D= DOT L= LT standardQualifiedName ( typePostfixSyntax )? G= GT ;
    public AS3_exParser.typePostfixSyntax_return typePostfixSyntax() // throws RecognitionException [1]
    {   
        AS3_exParser.typePostfixSyntax_return retval = new AS3_exParser.typePostfixSyntax_return();
        retval.Start = input.LT(1);
        int typePostfixSyntax_StartIndex = input.Index();
        object root_0 = null;

        IToken D = null;
        IToken L = null;
        IToken G = null;
        AS3_exParser.standardQualifiedName_return standardQualifiedName229 = null;

        AS3_exParser.typePostfixSyntax_return typePostfixSyntax230 = null;


        object D_tree=null;
        object L_tree=null;
        object G_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 97) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2162:18: (D= DOT L= LT standardQualifiedName ( typePostfixSyntax )? G= GT )
            // AS3_ex.g3:2163:2: D= DOT L= LT standardQualifiedName ( typePostfixSyntax )? G= GT
            {
            	root_0 = (object)adaptor.GetNilNode();

            	D=(IToken)Match(input,DOT,FOLLOW_DOT_in_typePostfixSyntax10018); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{D_tree = (object)adaptor.Create(D);
            		adaptor.AddChild(root_0, D_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)D);
            	}
            	L=(IToken)Match(input,LT,FOLLOW_LT_in_typePostfixSyntax10024); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{L_tree = (object)adaptor.Create(L);
            		adaptor.AddChild(root_0, L_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)L);
            	}
            	PushFollow(FOLLOW_standardQualifiedName_in_typePostfixSyntax10028);
            	standardQualifiedName229 = standardQualifiedName();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, standardQualifiedName229.Tree);
            	// AS3_ex.g3:2163:85: ( typePostfixSyntax )?
            	int alt111 = 2;
            	int LA111_0 = input.LA(1);

            	if ( (LA111_0 == DOT) )
            	{
            	    alt111 = 1;
            	}
            	switch (alt111) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:2163:86: typePostfixSyntax
            	        {
            	        	PushFollow(FOLLOW_typePostfixSyntax_in_typePostfixSyntax10031);
            	        	typePostfixSyntax230 = typePostfixSyntax();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, typePostfixSyntax230.Tree);

            	        }
            	        break;

            	}

            	G=(IToken)Match(input,GT,FOLLOW_GT_in_typePostfixSyntax10037); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{G_tree = (object)adaptor.Create(G);
            		adaptor.AddChild(root_0, G_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)G);
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 97, typePostfixSyntax_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "typePostfixSyntax"

    public class qualifiedIdentifier_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "qualifiedIdentifier"
    // AS3_ex.g3:2166:1: qualifiedIdentifier : I= IDENTIFIER ;
    public AS3_exParser.qualifiedIdentifier_return qualifiedIdentifier() // throws RecognitionException [1]
    {   
        AS3_exParser.qualifiedIdentifier_return retval = new AS3_exParser.qualifiedIdentifier_return();
        retval.Start = input.LT(1);
        int qualifiedIdentifier_StartIndex = input.Index();
        object root_0 = null;

        IToken I = null;

        object I_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 98) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2167:5: (I= IDENTIFIER )
            // AS3_ex.g3:2167:9: I= IDENTIFIER
            {
            	root_0 = (object)adaptor.GetNilNode();

            	I=(IToken)Match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_qualifiedIdentifier10061); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{I_tree = (object)adaptor.Create(I);
            		adaptor.AddChild(root_0, I_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)I);
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 98, qualifiedIdentifier_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "qualifiedIdentifier"

    public class parExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "parExpression"
    // AS3_ex.g3:2173:1: parExpression : L= LPAREN expression R= RPAREN ;
    public AS3_exParser.parExpression_return parExpression() // throws RecognitionException [1]
    {   
        AS3_exParser.parExpression_return retval = new AS3_exParser.parExpression_return();
        retval.Start = input.LT(1);
        int parExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        IToken R = null;
        AS3_exParser.expression_return expression231 = null;


        object L_tree=null;
        object R_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 99) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2174:5: (L= LPAREN expression R= RPAREN )
            // AS3_ex.g3:2174:7: L= LPAREN expression R= RPAREN
            {
            	root_0 = (object)adaptor.GetNilNode();

            	L=(IToken)Match(input,LPAREN,FOLLOW_LPAREN_in_parExpression10086); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{L_tree = (object)adaptor.Create(L);
            		adaptor.AddChild(root_0, L_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)L);InsertWS(mPrinter.GetAdvancedSpacesInsideParens());
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  PushExpressionIndent();
            	}
            	PushFollow(FOLLOW_expression_in_parExpression10093);
            	expression231 = expression();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, expression231.Tree);
            	R=(IToken)Match(input,RPAREN,FOLLOW_RPAREN_in_parExpression10098); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{R_tree = (object)adaptor.Create(R);
            		adaptor.AddChild(root_0, R_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  InsertWS(mPrinter.GetAdvancedSpacesInsideParens());Emit((CommonToken)R);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  PopIndent();
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 99, parExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "parExpression"

    public class expression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "expression"
    // AS3_ex.g3:2177:1: expression : assignmentExpression (C= COMMA assignmentExpression )* ;
    public AS3_exParser.expression_return expression() // throws RecognitionException [1]
    {   
        AS3_exParser.expression_return retval = new AS3_exParser.expression_return();
        retval.Start = input.LT(1);
        int expression_StartIndex = input.Index();
        object root_0 = null;

        IToken C = null;
        AS3_exParser.assignmentExpression_return assignmentExpression232 = null;

        AS3_exParser.assignmentExpression_return assignmentExpression233 = null;


        object C_tree=null;


        	WrapOptions options=mPrinter.GetExpressionWrapOptions();
        	bool pushedFormat=false;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 100) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2182:5: ( assignmentExpression (C= COMMA assignmentExpression )* )
            // AS3_ex.g3:2183:6: assignmentExpression (C= COMMA assignmentExpression )*
            {
            	root_0 = (object)adaptor.GetNilNode();

            	if ( state.backtracking == 0 ) 
            	{
            	  pushedFormat=PushFormatType(options, true);
            	}
            	PushFollow(FOLLOW_assignmentExpression_in_expression10139);
            	assignmentExpression232 = assignmentExpression();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, assignmentExpression232.Tree);
            	// AS3_ex.g3:2184:27: (C= COMMA assignmentExpression )*
            	do 
            	{
            	    int alt112 = 2;
            	    int LA112_0 = input.LA(1);

            	    if ( (LA112_0 == COMMA) )
            	    {
            	        alt112 = 1;
            	    }


            	    switch (alt112) 
            		{
            			case 1 :
            			    // AS3_ex.g3:2184:29: C= COMMA assignmentExpression
            			    {
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  InsertWS(mPrinter.GetSpacesBeforeComma());
            			    	}
            			    	C=(IToken)Match(input,COMMA,FOLLOW_COMMA_in_expression10147); if (state.failed) return retval;
            			    	if ( state.backtracking == 0 )
            			    	{C_tree = (object)adaptor.Create(C);
            			    		adaptor.AddChild(root_0, C_tree);
            			    	}
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  Emit((CommonToken)C);
            			    	}
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  InsertWS(mPrinter.GetSpacesAfterComma());
            			    	}
            			    	PushFollow(FOLLOW_assignmentExpression_in_expression10153);
            			    	assignmentExpression233 = assignmentExpression();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, assignmentExpression233.Tree);

            			    }
            			    break;

            			default:
            			    goto loop112;
            	    }
            	} while (true);

            	loop112:
            		;	// Stops C# compiler whining that label 'loop112' has no statements

            	if ( state.backtracking == 0 ) 
            	{

            	  	   	    if (pushedFormat)
            	  	   	    	mPrinter.PopFormatMode();
            	      	
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 100, expression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "expression"

    public class expressionNoIn_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "expressionNoIn"
    // AS3_ex.g3:2191:1: expressionNoIn : assignmentExpressionNoIn (C= COMMA assignmentExpressionNoIn )* ;
    public AS3_exParser.expressionNoIn_return expressionNoIn() // throws RecognitionException [1]
    {   
        AS3_exParser.expressionNoIn_return retval = new AS3_exParser.expressionNoIn_return();
        retval.Start = input.LT(1);
        int expressionNoIn_StartIndex = input.Index();
        object root_0 = null;

        IToken C = null;
        AS3_exParser.assignmentExpressionNoIn_return assignmentExpressionNoIn234 = null;

        AS3_exParser.assignmentExpressionNoIn_return assignmentExpressionNoIn235 = null;


        object C_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 101) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2192:5: ( assignmentExpressionNoIn (C= COMMA assignmentExpressionNoIn )* )
            // AS3_ex.g3:2192:9: assignmentExpressionNoIn (C= COMMA assignmentExpressionNoIn )*
            {
            	root_0 = (object)adaptor.GetNilNode();

            	PushFollow(FOLLOW_assignmentExpressionNoIn_in_expressionNoIn10181);
            	assignmentExpressionNoIn234 = assignmentExpressionNoIn();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, assignmentExpressionNoIn234.Tree);
            	// AS3_ex.g3:2192:34: (C= COMMA assignmentExpressionNoIn )*
            	do 
            	{
            	    int alt113 = 2;
            	    int LA113_0 = input.LA(1);

            	    if ( (LA113_0 == COMMA) )
            	    {
            	        alt113 = 1;
            	    }


            	    switch (alt113) 
            		{
            			case 1 :
            			    // AS3_ex.g3:2192:36: C= COMMA assignmentExpressionNoIn
            			    {
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  InsertWS(mPrinter.GetSpacesBeforeComma());
            			    	}
            			    	C=(IToken)Match(input,COMMA,FOLLOW_COMMA_in_expressionNoIn10189); if (state.failed) return retval;
            			    	if ( state.backtracking == 0 )
            			    	{C_tree = (object)adaptor.Create(C);
            			    		adaptor.AddChild(root_0, C_tree);
            			    	}
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  Emit((CommonToken)C);
            			    	}
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  InsertWS(mPrinter.GetSpacesAfterComma());
            			    	}
            			    	PushFollow(FOLLOW_assignmentExpressionNoIn_in_expressionNoIn10195);
            			    	assignmentExpressionNoIn235 = assignmentExpressionNoIn();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, assignmentExpressionNoIn235.Tree);

            			    }
            			    break;

            			default:
            			    goto loop113;
            	    }
            	} while (true);

            	loop113:
            		;	// Stops C# compiler whining that label 'loop113' has no statements


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 101, expressionNoIn_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "expressionNoIn"

    public class assignmentExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "assignmentExpression"
    // AS3_ex.g3:2196:1: assignmentExpression : ( leftHandSideExpression assignmentOperator assignmentExpression | conditionalExpression );
    public AS3_exParser.assignmentExpression_return assignmentExpression() // throws RecognitionException [1]
    {   
        AS3_exParser.assignmentExpression_return retval = new AS3_exParser.assignmentExpression_return();
        retval.Start = input.LT(1);
        int assignmentExpression_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.leftHandSideExpression_return leftHandSideExpression236 = null;

        AS3_exParser.assignmentOperator_return assignmentOperator237 = null;

        AS3_exParser.assignmentExpression_return assignmentExpression238 = null;

        AS3_exParser.conditionalExpression_return conditionalExpression239 = null;



        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 102) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2197:5: ( leftHandSideExpression assignmentOperator assignmentExpression | conditionalExpression )
            int alt114 = 2;
            alt114 = dfa114.Predict(input);
            switch (alt114) 
            {
                case 1 :
                    // AS3_ex.g3:2198:7: leftHandSideExpression assignmentOperator assignmentExpression
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_leftHandSideExpression_in_assignmentExpression10224);
                    	leftHandSideExpression236 = leftHandSideExpression();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, leftHandSideExpression236.Tree);
                    	PushFollow(FOLLOW_assignmentOperator_in_assignmentExpression10227);
                    	assignmentOperator237 = assignmentOperator();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, assignmentOperator237.Tree);
                    	PushFollow(FOLLOW_assignmentExpression_in_assignmentExpression10230);
                    	assignmentExpression238 = assignmentExpression();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, assignmentExpression238.Tree);

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:2199:7: conditionalExpression
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_conditionalExpression_in_assignmentExpression10238);
                    	conditionalExpression239 = conditionalExpression();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, conditionalExpression239.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 102, assignmentExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "assignmentExpression"

    public class assignmentExpressionNoIn_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "assignmentExpressionNoIn"
    // AS3_ex.g3:2203:1: assignmentExpressionNoIn : ( conditionalExpressionNoIn | leftHandSideExpression assignmentOperator assignmentExpressionNoIn );
    public AS3_exParser.assignmentExpressionNoIn_return assignmentExpressionNoIn() // throws RecognitionException [1]
    {   
        AS3_exParser.assignmentExpressionNoIn_return retval = new AS3_exParser.assignmentExpressionNoIn_return();
        retval.Start = input.LT(1);
        int assignmentExpressionNoIn_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.conditionalExpressionNoIn_return conditionalExpressionNoIn240 = null;

        AS3_exParser.leftHandSideExpression_return leftHandSideExpression241 = null;

        AS3_exParser.assignmentOperator_return assignmentOperator242 = null;

        AS3_exParser.assignmentExpressionNoIn_return assignmentExpressionNoIn243 = null;



        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 103) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2204:5: ( conditionalExpressionNoIn | leftHandSideExpression assignmentOperator assignmentExpressionNoIn )
            int alt115 = 2;
            alt115 = dfa115.Predict(input);
            switch (alt115) 
            {
                case 1 :
                    // AS3_ex.g3:2204:9: conditionalExpressionNoIn
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_conditionalExpressionNoIn_in_assignmentExpressionNoIn10258);
                    	conditionalExpressionNoIn240 = conditionalExpressionNoIn();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, conditionalExpressionNoIn240.Tree);

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:2205:9: leftHandSideExpression assignmentOperator assignmentExpressionNoIn
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_leftHandSideExpression_in_assignmentExpressionNoIn10268);
                    	leftHandSideExpression241 = leftHandSideExpression();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, leftHandSideExpression241.Tree);
                    	PushFollow(FOLLOW_assignmentOperator_in_assignmentExpressionNoIn10271);
                    	assignmentOperator242 = assignmentOperator();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, assignmentOperator242.Tree);
                    	PushFollow(FOLLOW_assignmentExpressionNoIn_in_assignmentExpressionNoIn10274);
                    	assignmentExpressionNoIn243 = assignmentExpressionNoIn();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, assignmentExpressionNoIn243.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 103, assignmentExpressionNoIn_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "assignmentExpressionNoIn"

    public class assignmentOperator_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "assignmentOperator"
    // AS3_ex.g3:2208:1: assignmentOperator : op= assignmentOperator_int ;
    public AS3_exParser.assignmentOperator_return assignmentOperator() // throws RecognitionException [1]
    {   
        AS3_exParser.assignmentOperator_return retval = new AS3_exParser.assignmentOperator_return();
        retval.Start = input.LT(1);
        int assignmentOperator_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.assignmentOperator_int_return op = null;



        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 104) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2209:2: (op= assignmentOperator_int )
            // AS3_ex.g3:2209:4: op= assignmentOperator_int
            {
            	root_0 = (object)adaptor.GetNilNode();

            	PushFollow(FOLLOW_assignmentOperator_int_in_assignmentOperator10290);
            	op = assignmentOperator_int();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, op.Tree);
            	if ( state.backtracking == 0 ) 
            	{
            	  InsertWS(mPrinter.GetSpacesAroundAssignment());
            	  	   Emit((CommonToken)((op != null) ? ((IToken)op.Start) : null));
            	  	   InsertWS(mPrinter.GetSpacesAroundAssignment());
            	  	  
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 104, assignmentOperator_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "assignmentOperator"

    public class assignmentOperator_int_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "assignmentOperator_int"
    // AS3_ex.g3:2216:1: assignmentOperator_int : ( ASSIGN | s= STAR a= ASSIGN | DIV_ASSIGN | MOD_ASSIGN | ADD_ASSIGN | SUB_ASSIGN | SHL_ASSIGN | ( ( '>' '>' '=' )=>t1= '>' t2= '>' t3= '=' {...}? -> SHR_ASSIGN ) | ( ( '>' '>' '>' '=' )=>t1= '>' t2= '>' t3= '>' t4= '=' {...}? -> SHU_ASSIGN ) | AND_ASSIGN | XOR_ASSIGN | OR_ASSIGN | LOR_ASSIGN | LAND_ASSIGN );
    public AS3_exParser.assignmentOperator_int_return assignmentOperator_int() // throws RecognitionException [1]
    {   
        AS3_exParser.assignmentOperator_int_return retval = new AS3_exParser.assignmentOperator_int_return();
        retval.Start = input.LT(1);
        int assignmentOperator_int_StartIndex = input.Index();
        object root_0 = null;

        IToken s = null;
        IToken a = null;
        IToken t1 = null;
        IToken t2 = null;
        IToken t3 = null;
        IToken t4 = null;
        IToken ASSIGN244 = null;
        IToken DIV_ASSIGN245 = null;
        IToken MOD_ASSIGN246 = null;
        IToken ADD_ASSIGN247 = null;
        IToken SUB_ASSIGN248 = null;
        IToken SHL_ASSIGN249 = null;
        IToken AND_ASSIGN250 = null;
        IToken XOR_ASSIGN251 = null;
        IToken OR_ASSIGN252 = null;
        IToken LOR_ASSIGN253 = null;
        IToken LAND_ASSIGN254 = null;

        object s_tree=null;
        object a_tree=null;
        object t1_tree=null;
        object t2_tree=null;
        object t3_tree=null;
        object t4_tree=null;
        object ASSIGN244_tree=null;
        object DIV_ASSIGN245_tree=null;
        object MOD_ASSIGN246_tree=null;
        object ADD_ASSIGN247_tree=null;
        object SUB_ASSIGN248_tree=null;
        object SHL_ASSIGN249_tree=null;
        object AND_ASSIGN250_tree=null;
        object XOR_ASSIGN251_tree=null;
        object OR_ASSIGN252_tree=null;
        object LOR_ASSIGN253_tree=null;
        object LAND_ASSIGN254_tree=null;
        RewriteRuleTokenStream stream_GT = new RewriteRuleTokenStream(adaptor,"token GT");
        RewriteRuleTokenStream stream_ASSIGN = new RewriteRuleTokenStream(adaptor,"token ASSIGN");

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 105) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2217:5: ( ASSIGN | s= STAR a= ASSIGN | DIV_ASSIGN | MOD_ASSIGN | ADD_ASSIGN | SUB_ASSIGN | SHL_ASSIGN | ( ( '>' '>' '=' )=>t1= '>' t2= '>' t3= '=' {...}? -> SHR_ASSIGN ) | ( ( '>' '>' '>' '=' )=>t1= '>' t2= '>' t3= '>' t4= '=' {...}? -> SHU_ASSIGN ) | AND_ASSIGN | XOR_ASSIGN | OR_ASSIGN | LOR_ASSIGN | LAND_ASSIGN )
            int alt116 = 14;
            alt116 = dfa116.Predict(input);
            switch (alt116) 
            {
                case 1 :
                    // AS3_ex.g3:2217:7: ASSIGN
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	ASSIGN244=(IToken)Match(input,ASSIGN,FOLLOW_ASSIGN_in_assignmentOperator_int10316); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{ASSIGN244_tree = (object)adaptor.Create(ASSIGN244);
                    		adaptor.AddChild(root_0, ASSIGN244_tree);
                    	}

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:2219:4: s= STAR a= ASSIGN
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	s=(IToken)Match(input,STAR,FOLLOW_STAR_in_assignmentOperator_int10325); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{s_tree = (object)adaptor.Create(s);
                    		adaptor.AddChild(root_0, s_tree);
                    	}
                    	a=(IToken)Match(input,ASSIGN,FOLLOW_ASSIGN_in_assignmentOperator_int10329); if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  s.Text = "*=";
                    	}

                    }
                    break;
                case 3 :
                    // AS3_ex.g3:2220:7: DIV_ASSIGN
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	DIV_ASSIGN245=(IToken)Match(input,DIV_ASSIGN,FOLLOW_DIV_ASSIGN_in_assignmentOperator_int10340); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{DIV_ASSIGN245_tree = (object)adaptor.Create(DIV_ASSIGN245);
                    		adaptor.AddChild(root_0, DIV_ASSIGN245_tree);
                    	}

                    }
                    break;
                case 4 :
                    // AS3_ex.g3:2221:7: MOD_ASSIGN
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	MOD_ASSIGN246=(IToken)Match(input,MOD_ASSIGN,FOLLOW_MOD_ASSIGN_in_assignmentOperator_int10349); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{MOD_ASSIGN246_tree = (object)adaptor.Create(MOD_ASSIGN246);
                    		adaptor.AddChild(root_0, MOD_ASSIGN246_tree);
                    	}

                    }
                    break;
                case 5 :
                    // AS3_ex.g3:2222:7: ADD_ASSIGN
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	ADD_ASSIGN247=(IToken)Match(input,ADD_ASSIGN,FOLLOW_ADD_ASSIGN_in_assignmentOperator_int10358); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{ADD_ASSIGN247_tree = (object)adaptor.Create(ADD_ASSIGN247);
                    		adaptor.AddChild(root_0, ADD_ASSIGN247_tree);
                    	}

                    }
                    break;
                case 6 :
                    // AS3_ex.g3:2223:7: SUB_ASSIGN
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	SUB_ASSIGN248=(IToken)Match(input,SUB_ASSIGN,FOLLOW_SUB_ASSIGN_in_assignmentOperator_int10367); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{SUB_ASSIGN248_tree = (object)adaptor.Create(SUB_ASSIGN248);
                    		adaptor.AddChild(root_0, SUB_ASSIGN248_tree);
                    	}

                    }
                    break;
                case 7 :
                    // AS3_ex.g3:2224:7: SHL_ASSIGN
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	SHL_ASSIGN249=(IToken)Match(input,SHL_ASSIGN,FOLLOW_SHL_ASSIGN_in_assignmentOperator_int10375); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{SHL_ASSIGN249_tree = (object)adaptor.Create(SHL_ASSIGN249);
                    		adaptor.AddChild(root_0, SHL_ASSIGN249_tree);
                    	}

                    }
                    break;
                case 8 :
                    // AS3_ex.g3:2227:9: ( ( '>' '>' '=' )=>t1= '>' t2= '>' t3= '=' {...}? -> SHR_ASSIGN )
                    {
                    	// AS3_ex.g3:2227:9: ( ( '>' '>' '=' )=>t1= '>' t2= '>' t3= '=' {...}? -> SHR_ASSIGN )
                    	// AS3_ex.g3:2227:10: ( '>' '>' '=' )=>t1= '>' t2= '>' t3= '=' {...}?
                    	{
                    		t1=(IToken)Match(input,GT,FOLLOW_GT_in_assignmentOperator_int10399); if (state.failed) return retval; 
                    		if ( state.backtracking==0 ) stream_GT.Add(t1);

                    		t2=(IToken)Match(input,GT,FOLLOW_GT_in_assignmentOperator_int10403); if (state.failed) return retval; 
                    		if ( state.backtracking==0 ) stream_GT.Add(t2);

                    		t3=(IToken)Match(input,ASSIGN,FOLLOW_ASSIGN_in_assignmentOperator_int10407); if (state.failed) return retval; 
                    		if ( state.backtracking==0 ) stream_ASSIGN.Add(t3);

                    		if ( !(( t1.Line == t2.Line && 
                    		          t1.CharPositionInLine + 1 == t2.CharPositionInLine && 
                    		          t2.Line == t3.Line && 
                    		          t2.CharPositionInLine + 1 == t3.CharPositionInLine )) ) 
                    		{
                    		    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    		    throw new FailedPredicateException(input, "assignmentOperator_int", " $t1.Line == $t2.Line && \r\n          $t1.CharPositionInLine + 1 == $t2.CharPositionInLine && \r\n          $t2.Line == $t3.Line && \r\n          $t2.CharPositionInLine + 1 == $t3.CharPositionInLine ");
                    		}


                    		// AST REWRITE
                    		// elements:          
                    		// token labels:      
                    		// rule labels:       retval
                    		// token list labels: 
                    		// rule list labels:  
                    		if ( state.backtracking==0 ) {
                    		retval.Tree = root_0;
                    		RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));

                    		root_0 = (object)adaptor.GetNilNode();
                    		// 2232:7: -> SHR_ASSIGN
                    		{
                    		    adaptor.AddChild(root_0, (object)adaptor.Create(SHR_ASSIGN, "SHR_ASSIGN"));

                    		}

                    		retval.Tree = root_0;retval.Tree = root_0;}
                    	}

                    	if ( state.backtracking == 0 ) 
                    	{
                    	  t1.Text = ">>=";
                    	}

                    }
                    break;
                case 9 :
                    // AS3_ex.g3:2234:7: ( ( '>' '>' '>' '=' )=>t1= '>' t2= '>' t3= '>' t4= '=' {...}? -> SHU_ASSIGN )
                    {
                    	// AS3_ex.g3:2234:7: ( ( '>' '>' '>' '=' )=>t1= '>' t2= '>' t3= '>' t4= '=' {...}? -> SHU_ASSIGN )
                    	// AS3_ex.g3:2234:8: ( '>' '>' '>' '=' )=>t1= '>' t2= '>' t3= '>' t4= '=' {...}?
                    	{
                    		t1=(IToken)Match(input,GT,FOLLOW_GT_in_assignmentOperator_int10453); if (state.failed) return retval; 
                    		if ( state.backtracking==0 ) stream_GT.Add(t1);

                    		t2=(IToken)Match(input,GT,FOLLOW_GT_in_assignmentOperator_int10457); if (state.failed) return retval; 
                    		if ( state.backtracking==0 ) stream_GT.Add(t2);

                    		t3=(IToken)Match(input,GT,FOLLOW_GT_in_assignmentOperator_int10461); if (state.failed) return retval; 
                    		if ( state.backtracking==0 ) stream_GT.Add(t3);

                    		t4=(IToken)Match(input,ASSIGN,FOLLOW_ASSIGN_in_assignmentOperator_int10465); if (state.failed) return retval; 
                    		if ( state.backtracking==0 ) stream_ASSIGN.Add(t4);

                    		if ( !(( t1.Line == t2.Line && 
                    		          t1.CharPositionInLine + 1 == t2.CharPositionInLine &&
                    		          t2.Line == t3.Line && 
                    		          t2.CharPositionInLine + 1 == t3.CharPositionInLine &&
                    		          t3.Line == t4.Line && 
                    		          t3.CharPositionInLine + 1 == t4.CharPositionInLine )) ) 
                    		{
                    		    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    		    throw new FailedPredicateException(input, "assignmentOperator_int", " $t1.Line == $t2.Line && \r\n          $t1.CharPositionInLine + 1 == $t2.CharPositionInLine &&\r\n          $t2.Line == $t3.Line && \r\n          $t2.CharPositionInLine + 1 == $t3.CharPositionInLine &&\r\n          $t3.Line == $t4.Line && \r\n          $t3.CharPositionInLine + 1 == $t4.CharPositionInLine ");
                    		}


                    		// AST REWRITE
                    		// elements:          
                    		// token labels:      
                    		// rule labels:       retval
                    		// token list labels: 
                    		// rule list labels:  
                    		if ( state.backtracking==0 ) {
                    		retval.Tree = root_0;
                    		RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));

                    		root_0 = (object)adaptor.GetNilNode();
                    		// 2241:7: -> SHU_ASSIGN
                    		{
                    		    adaptor.AddChild(root_0, (object)adaptor.Create(SHU_ASSIGN, "SHU_ASSIGN"));

                    		}

                    		retval.Tree = root_0;retval.Tree = root_0;}
                    	}

                    	if ( state.backtracking == 0 ) 
                    	{
                    	  t1.Text = ">>>=";
                    	}

                    }
                    break;
                case 10 :
                    // AS3_ex.g3:2242:7: AND_ASSIGN
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	AND_ASSIGN250=(IToken)Match(input,AND_ASSIGN,FOLLOW_AND_ASSIGN_in_assignmentOperator_int10496); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{AND_ASSIGN250_tree = (object)adaptor.Create(AND_ASSIGN250);
                    		adaptor.AddChild(root_0, AND_ASSIGN250_tree);
                    	}

                    }
                    break;
                case 11 :
                    // AS3_ex.g3:2243:7: XOR_ASSIGN
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	XOR_ASSIGN251=(IToken)Match(input,XOR_ASSIGN,FOLLOW_XOR_ASSIGN_in_assignmentOperator_int10505); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{XOR_ASSIGN251_tree = (object)adaptor.Create(XOR_ASSIGN251);
                    		adaptor.AddChild(root_0, XOR_ASSIGN251_tree);
                    	}

                    }
                    break;
                case 12 :
                    // AS3_ex.g3:2244:7: OR_ASSIGN
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	OR_ASSIGN252=(IToken)Match(input,OR_ASSIGN,FOLLOW_OR_ASSIGN_in_assignmentOperator_int10514); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{OR_ASSIGN252_tree = (object)adaptor.Create(OR_ASSIGN252);
                    		adaptor.AddChild(root_0, OR_ASSIGN252_tree);
                    	}

                    }
                    break;
                case 13 :
                    // AS3_ex.g3:2245:7: LOR_ASSIGN
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	LOR_ASSIGN253=(IToken)Match(input,LOR_ASSIGN,FOLLOW_LOR_ASSIGN_in_assignmentOperator_int10522); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{LOR_ASSIGN253_tree = (object)adaptor.Create(LOR_ASSIGN253);
                    		adaptor.AddChild(root_0, LOR_ASSIGN253_tree);
                    	}

                    }
                    break;
                case 14 :
                    // AS3_ex.g3:2246:7: LAND_ASSIGN
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	LAND_ASSIGN254=(IToken)Match(input,LAND_ASSIGN,FOLLOW_LAND_ASSIGN_in_assignmentOperator_int10530); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{LAND_ASSIGN254_tree = (object)adaptor.Create(LAND_ASSIGN254);
                    		adaptor.AddChild(root_0, LAND_ASSIGN254_tree);
                    	}

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 105, assignmentOperator_int_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "assignmentOperator_int"

    public class conditionalExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "conditionalExpression"
    // AS3_ex.g3:2250:1: conditionalExpression : logicalORExpression (Q= QUE assignmentExpression C= COLON assignmentExpression )? ;
    public AS3_exParser.conditionalExpression_return conditionalExpression() // throws RecognitionException [1]
    {   
        AS3_exParser.conditionalExpression_return retval = new AS3_exParser.conditionalExpression_return();
        retval.Start = input.LT(1);
        int conditionalExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken Q = null;
        IToken C = null;
        AS3_exParser.logicalORExpression_return logicalORExpression255 = null;

        AS3_exParser.assignmentExpression_return assignmentExpression256 = null;

        AS3_exParser.assignmentExpression_return assignmentExpression257 = null;


        object Q_tree=null;
        object C_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 106) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2251:5: ( logicalORExpression (Q= QUE assignmentExpression C= COLON assignmentExpression )? )
            // AS3_ex.g3:2251:9: logicalORExpression (Q= QUE assignmentExpression C= COLON assignmentExpression )?
            {
            	root_0 = (object)adaptor.GetNilNode();

            	PushFollow(FOLLOW_logicalORExpression_in_conditionalExpression10550);
            	logicalORExpression255 = logicalORExpression();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, logicalORExpression255.Tree);
            	// AS3_ex.g3:2251:29: (Q= QUE assignmentExpression C= COLON assignmentExpression )?
            	int alt117 = 2;
            	int LA117_0 = input.LA(1);

            	if ( (LA117_0 == QUE) )
            	{
            	    alt117 = 1;
            	}
            	switch (alt117) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:2251:31: Q= QUE assignmentExpression C= COLON assignmentExpression
            	        {
            	        	Q=(IToken)Match(input,QUE,FOLLOW_QUE_in_conditionalExpression10556); if (state.failed) return retval;
            	        	if ( state.backtracking == 0 )
            	        	{Q_tree = (object)adaptor.Create(Q);
            	        		adaptor.AddChild(root_0, Q_tree);
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  IndentEmit((CommonToken)Q);
            	        	}
            	        	PushFollow(FOLLOW_assignmentExpression_in_conditionalExpression10561);
            	        	assignmentExpression256 = assignmentExpression();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, assignmentExpression256.Tree);
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  PopIndent();
            	        	}
            	        	C=(IToken)Match(input,COLON,FOLLOW_COLON_in_conditionalExpression10568); if (state.failed) return retval;
            	        	if ( state.backtracking == 0 )
            	        	{C_tree = (object)adaptor.Create(C);
            	        		adaptor.AddChild(root_0, C_tree);
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  IndentEmit((CommonToken)C);
            	        	}
            	        	PushFollow(FOLLOW_assignmentExpression_in_conditionalExpression10573);
            	        	assignmentExpression257 = assignmentExpression();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, assignmentExpression257.Tree);
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  PopIndent();
            	        	}

            	        }
            	        break;

            	}


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 106, conditionalExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "conditionalExpression"

    public class conditionalExpressionNoIn_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "conditionalExpressionNoIn"
    // AS3_ex.g3:2254:1: conditionalExpressionNoIn : logicalORExpressionNoIn (Q= QUE assignmentExpression C= COLON assignmentExpression )? ;
    public AS3_exParser.conditionalExpressionNoIn_return conditionalExpressionNoIn() // throws RecognitionException [1]
    {   
        AS3_exParser.conditionalExpressionNoIn_return retval = new AS3_exParser.conditionalExpressionNoIn_return();
        retval.Start = input.LT(1);
        int conditionalExpressionNoIn_StartIndex = input.Index();
        object root_0 = null;

        IToken Q = null;
        IToken C = null;
        AS3_exParser.logicalORExpressionNoIn_return logicalORExpressionNoIn258 = null;

        AS3_exParser.assignmentExpression_return assignmentExpression259 = null;

        AS3_exParser.assignmentExpression_return assignmentExpression260 = null;


        object Q_tree=null;
        object C_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 107) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2255:5: ( logicalORExpressionNoIn (Q= QUE assignmentExpression C= COLON assignmentExpression )? )
            // AS3_ex.g3:2255:9: logicalORExpressionNoIn (Q= QUE assignmentExpression C= COLON assignmentExpression )?
            {
            	root_0 = (object)adaptor.GetNilNode();

            	PushFollow(FOLLOW_logicalORExpressionNoIn_in_conditionalExpressionNoIn10600);
            	logicalORExpressionNoIn258 = logicalORExpressionNoIn();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, logicalORExpressionNoIn258.Tree);
            	// AS3_ex.g3:2255:33: (Q= QUE assignmentExpression C= COLON assignmentExpression )?
            	int alt118 = 2;
            	int LA118_0 = input.LA(1);

            	if ( (LA118_0 == QUE) )
            	{
            	    alt118 = 1;
            	}
            	switch (alt118) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:2255:35: Q= QUE assignmentExpression C= COLON assignmentExpression
            	        {
            	        	Q=(IToken)Match(input,QUE,FOLLOW_QUE_in_conditionalExpressionNoIn10606); if (state.failed) return retval;
            	        	if ( state.backtracking == 0 )
            	        	{Q_tree = (object)adaptor.Create(Q);
            	        		adaptor.AddChild(root_0, Q_tree);
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  IndentEmit((CommonToken)Q);
            	        	}
            	        	PushFollow(FOLLOW_assignmentExpression_in_conditionalExpressionNoIn10610);
            	        	assignmentExpression259 = assignmentExpression();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, assignmentExpression259.Tree);
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  PopIndent();
            	        	}
            	        	C=(IToken)Match(input,COLON,FOLLOW_COLON_in_conditionalExpressionNoIn10617); if (state.failed) return retval;
            	        	if ( state.backtracking == 0 )
            	        	{C_tree = (object)adaptor.Create(C);
            	        		adaptor.AddChild(root_0, C_tree);
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  IndentEmit((CommonToken)C);
            	        	}
            	        	PushFollow(FOLLOW_assignmentExpression_in_conditionalExpressionNoIn10622);
            	        	assignmentExpression260 = assignmentExpression();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, assignmentExpression260.Tree);
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  PopIndent();
            	        	}

            	        }
            	        break;

            	}


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 107, conditionalExpressionNoIn_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "conditionalExpressionNoIn"

    public class logicalORExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "logicalORExpression"
    // AS3_ex.g3:2259:1: logicalORExpression : logicalANDExpression (L= LOR logicalANDExpression )* ;
    public AS3_exParser.logicalORExpression_return logicalORExpression() // throws RecognitionException [1]
    {   
        AS3_exParser.logicalORExpression_return retval = new AS3_exParser.logicalORExpression_return();
        retval.Start = input.LT(1);
        int logicalORExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        AS3_exParser.logicalANDExpression_return logicalANDExpression261 = null;

        AS3_exParser.logicalANDExpression_return logicalANDExpression262 = null;


        object L_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 108) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2260:5: ( logicalANDExpression (L= LOR logicalANDExpression )* )
            // AS3_ex.g3:2260:9: logicalANDExpression (L= LOR logicalANDExpression )*
            {
            	root_0 = (object)adaptor.GetNilNode();

            	PushFollow(FOLLOW_logicalANDExpression_in_logicalORExpression10654);
            	logicalANDExpression261 = logicalANDExpression();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, logicalANDExpression261.Tree);
            	// AS3_ex.g3:2260:30: (L= LOR logicalANDExpression )*
            	do 
            	{
            	    int alt119 = 2;
            	    int LA119_0 = input.LA(1);

            	    if ( (LA119_0 == LOR) )
            	    {
            	        alt119 = 1;
            	    }


            	    switch (alt119) 
            		{
            			case 1 :
            			    // AS3_ex.g3:2260:32: L= LOR logicalANDExpression
            			    {
            			    	L=(IToken)Match(input,LOR,FOLLOW_LOR_in_logicalORExpression10660); if (state.failed) return retval;
            			    	if ( state.backtracking == 0 )
            			    	{L_tree = (object)adaptor.Create(L);
            			    		adaptor.AddChild(root_0, L_tree);
            			    	}
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  IndentEmit((CommonToken)L);
            			    	}
            			    	PushFollow(FOLLOW_logicalANDExpression_in_logicalORExpression10664);
            			    	logicalANDExpression262 = logicalANDExpression();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, logicalANDExpression262.Tree);
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  PopIndent();
            			    	}

            			    }
            			    break;

            			default:
            			    goto loop119;
            	    }
            	} while (true);

            	loop119:
            		;	// Stops C# compiler whining that label 'loop119' has no statements


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 108, logicalORExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "logicalORExpression"

    public class logicalORExpressionNoIn_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "logicalORExpressionNoIn"
    // AS3_ex.g3:2263:1: logicalORExpressionNoIn : logicalANDExpressionNoIn (L= LOR logicalANDExpressionNoIn )* ;
    public AS3_exParser.logicalORExpressionNoIn_return logicalORExpressionNoIn() // throws RecognitionException [1]
    {   
        AS3_exParser.logicalORExpressionNoIn_return retval = new AS3_exParser.logicalORExpressionNoIn_return();
        retval.Start = input.LT(1);
        int logicalORExpressionNoIn_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        AS3_exParser.logicalANDExpressionNoIn_return logicalANDExpressionNoIn263 = null;

        AS3_exParser.logicalANDExpressionNoIn_return logicalANDExpressionNoIn264 = null;


        object L_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 109) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2264:5: ( logicalANDExpressionNoIn (L= LOR logicalANDExpressionNoIn )* )
            // AS3_ex.g3:2264:9: logicalANDExpressionNoIn (L= LOR logicalANDExpressionNoIn )*
            {
            	root_0 = (object)adaptor.GetNilNode();

            	PushFollow(FOLLOW_logicalANDExpressionNoIn_in_logicalORExpressionNoIn10692);
            	logicalANDExpressionNoIn263 = logicalANDExpressionNoIn();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, logicalANDExpressionNoIn263.Tree);
            	// AS3_ex.g3:2264:34: (L= LOR logicalANDExpressionNoIn )*
            	do 
            	{
            	    int alt120 = 2;
            	    int LA120_0 = input.LA(1);

            	    if ( (LA120_0 == LOR) )
            	    {
            	        alt120 = 1;
            	    }


            	    switch (alt120) 
            		{
            			case 1 :
            			    // AS3_ex.g3:2264:36: L= LOR logicalANDExpressionNoIn
            			    {
            			    	L=(IToken)Match(input,LOR,FOLLOW_LOR_in_logicalORExpressionNoIn10698); if (state.failed) return retval;
            			    	if ( state.backtracking == 0 )
            			    	{L_tree = (object)adaptor.Create(L);
            			    		adaptor.AddChild(root_0, L_tree);
            			    	}
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  IndentEmit((CommonToken)L);
            			    	}
            			    	PushFollow(FOLLOW_logicalANDExpressionNoIn_in_logicalORExpressionNoIn10702);
            			    	logicalANDExpressionNoIn264 = logicalANDExpressionNoIn();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, logicalANDExpressionNoIn264.Tree);
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  PopIndent();
            			    	}

            			    }
            			    break;

            			default:
            			    goto loop120;
            	    }
            	} while (true);

            	loop120:
            		;	// Stops C# compiler whining that label 'loop120' has no statements


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 109, logicalORExpressionNoIn_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "logicalORExpressionNoIn"

    public class logicalANDExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "logicalANDExpression"
    // AS3_ex.g3:2267:1: logicalANDExpression : bitwiseORExpression (L= LAND bitwiseORExpression )* ;
    public AS3_exParser.logicalANDExpression_return logicalANDExpression() // throws RecognitionException [1]
    {   
        AS3_exParser.logicalANDExpression_return retval = new AS3_exParser.logicalANDExpression_return();
        retval.Start = input.LT(1);
        int logicalANDExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        AS3_exParser.bitwiseORExpression_return bitwiseORExpression265 = null;

        AS3_exParser.bitwiseORExpression_return bitwiseORExpression266 = null;


        object L_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 110) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2268:5: ( bitwiseORExpression (L= LAND bitwiseORExpression )* )
            // AS3_ex.g3:2268:9: bitwiseORExpression (L= LAND bitwiseORExpression )*
            {
            	root_0 = (object)adaptor.GetNilNode();

            	PushFollow(FOLLOW_bitwiseORExpression_in_logicalANDExpression10734);
            	bitwiseORExpression265 = bitwiseORExpression();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, bitwiseORExpression265.Tree);
            	// AS3_ex.g3:2268:29: (L= LAND bitwiseORExpression )*
            	do 
            	{
            	    int alt121 = 2;
            	    int LA121_0 = input.LA(1);

            	    if ( (LA121_0 == LAND) )
            	    {
            	        alt121 = 1;
            	    }


            	    switch (alt121) 
            		{
            			case 1 :
            			    // AS3_ex.g3:2268:31: L= LAND bitwiseORExpression
            			    {
            			    	L=(IToken)Match(input,LAND,FOLLOW_LAND_in_logicalANDExpression10740); if (state.failed) return retval;
            			    	if ( state.backtracking == 0 )
            			    	{L_tree = (object)adaptor.Create(L);
            			    		adaptor.AddChild(root_0, L_tree);
            			    	}
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  IndentEmit((CommonToken)L);
            			    	}
            			    	PushFollow(FOLLOW_bitwiseORExpression_in_logicalANDExpression10744);
            			    	bitwiseORExpression266 = bitwiseORExpression();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, bitwiseORExpression266.Tree);
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  PopIndent();
            			    	}

            			    }
            			    break;

            			default:
            			    goto loop121;
            	    }
            	} while (true);

            	loop121:
            		;	// Stops C# compiler whining that label 'loop121' has no statements


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 110, logicalANDExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "logicalANDExpression"

    public class logicalANDExpressionNoIn_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "logicalANDExpressionNoIn"
    // AS3_ex.g3:2271:1: logicalANDExpressionNoIn : bitwiseORExpressionNoIn (L= LAND bitwiseORExpressionNoIn )* ;
    public AS3_exParser.logicalANDExpressionNoIn_return logicalANDExpressionNoIn() // throws RecognitionException [1]
    {   
        AS3_exParser.logicalANDExpressionNoIn_return retval = new AS3_exParser.logicalANDExpressionNoIn_return();
        retval.Start = input.LT(1);
        int logicalANDExpressionNoIn_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        AS3_exParser.bitwiseORExpressionNoIn_return bitwiseORExpressionNoIn267 = null;

        AS3_exParser.bitwiseORExpressionNoIn_return bitwiseORExpressionNoIn268 = null;


        object L_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 111) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2272:5: ( bitwiseORExpressionNoIn (L= LAND bitwiseORExpressionNoIn )* )
            // AS3_ex.g3:2272:9: bitwiseORExpressionNoIn (L= LAND bitwiseORExpressionNoIn )*
            {
            	root_0 = (object)adaptor.GetNilNode();

            	PushFollow(FOLLOW_bitwiseORExpressionNoIn_in_logicalANDExpressionNoIn10771);
            	bitwiseORExpressionNoIn267 = bitwiseORExpressionNoIn();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, bitwiseORExpressionNoIn267.Tree);
            	// AS3_ex.g3:2272:33: (L= LAND bitwiseORExpressionNoIn )*
            	do 
            	{
            	    int alt122 = 2;
            	    int LA122_0 = input.LA(1);

            	    if ( (LA122_0 == LAND) )
            	    {
            	        alt122 = 1;
            	    }


            	    switch (alt122) 
            		{
            			case 1 :
            			    // AS3_ex.g3:2272:35: L= LAND bitwiseORExpressionNoIn
            			    {
            			    	L=(IToken)Match(input,LAND,FOLLOW_LAND_in_logicalANDExpressionNoIn10777); if (state.failed) return retval;
            			    	if ( state.backtracking == 0 )
            			    	{L_tree = (object)adaptor.Create(L);
            			    		adaptor.AddChild(root_0, L_tree);
            			    	}
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  IndentEmit((CommonToken)L);
            			    	}
            			    	PushFollow(FOLLOW_bitwiseORExpressionNoIn_in_logicalANDExpressionNoIn10781);
            			    	bitwiseORExpressionNoIn268 = bitwiseORExpressionNoIn();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, bitwiseORExpressionNoIn268.Tree);
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  PopIndent();
            			    	}

            			    }
            			    break;

            			default:
            			    goto loop122;
            	    }
            	} while (true);

            	loop122:
            		;	// Stops C# compiler whining that label 'loop122' has no statements


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 111, logicalANDExpressionNoIn_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "logicalANDExpressionNoIn"

    public class bitwiseORExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "bitwiseORExpression"
    // AS3_ex.g3:2276:1: bitwiseORExpression : bitwiseXORExpression (O= OR bitwiseXORExpression )* ;
    public AS3_exParser.bitwiseORExpression_return bitwiseORExpression() // throws RecognitionException [1]
    {   
        AS3_exParser.bitwiseORExpression_return retval = new AS3_exParser.bitwiseORExpression_return();
        retval.Start = input.LT(1);
        int bitwiseORExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken O = null;
        AS3_exParser.bitwiseXORExpression_return bitwiseXORExpression269 = null;

        AS3_exParser.bitwiseXORExpression_return bitwiseXORExpression270 = null;


        object O_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 112) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2277:5: ( bitwiseXORExpression (O= OR bitwiseXORExpression )* )
            // AS3_ex.g3:2277:9: bitwiseXORExpression (O= OR bitwiseXORExpression )*
            {
            	root_0 = (object)adaptor.GetNilNode();

            	PushFollow(FOLLOW_bitwiseXORExpression_in_bitwiseORExpression10813);
            	bitwiseXORExpression269 = bitwiseXORExpression();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, bitwiseXORExpression269.Tree);
            	// AS3_ex.g3:2277:30: (O= OR bitwiseXORExpression )*
            	do 
            	{
            	    int alt123 = 2;
            	    int LA123_0 = input.LA(1);

            	    if ( (LA123_0 == OR) )
            	    {
            	        alt123 = 1;
            	    }


            	    switch (alt123) 
            		{
            			case 1 :
            			    // AS3_ex.g3:2277:32: O= OR bitwiseXORExpression
            			    {
            			    	O=(IToken)Match(input,OR,FOLLOW_OR_in_bitwiseORExpression10819); if (state.failed) return retval;
            			    	if ( state.backtracking == 0 )
            			    	{O_tree = (object)adaptor.Create(O);
            			    		adaptor.AddChild(root_0, O_tree);
            			    	}
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  IndentEmit((CommonToken)O);
            			    	}
            			    	PushFollow(FOLLOW_bitwiseXORExpression_in_bitwiseORExpression10823);
            			    	bitwiseXORExpression270 = bitwiseXORExpression();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, bitwiseXORExpression270.Tree);
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  PopIndent();
            			    	}

            			    }
            			    break;

            			default:
            			    goto loop123;
            	    }
            	} while (true);

            	loop123:
            		;	// Stops C# compiler whining that label 'loop123' has no statements


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 112, bitwiseORExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "bitwiseORExpression"

    public class bitwiseORExpressionNoIn_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "bitwiseORExpressionNoIn"
    // AS3_ex.g3:2280:1: bitwiseORExpressionNoIn : bitwiseXORExpressionNoIn (O= OR bitwiseXORExpressionNoIn )* ;
    public AS3_exParser.bitwiseORExpressionNoIn_return bitwiseORExpressionNoIn() // throws RecognitionException [1]
    {   
        AS3_exParser.bitwiseORExpressionNoIn_return retval = new AS3_exParser.bitwiseORExpressionNoIn_return();
        retval.Start = input.LT(1);
        int bitwiseORExpressionNoIn_StartIndex = input.Index();
        object root_0 = null;

        IToken O = null;
        AS3_exParser.bitwiseXORExpressionNoIn_return bitwiseXORExpressionNoIn271 = null;

        AS3_exParser.bitwiseXORExpressionNoIn_return bitwiseXORExpressionNoIn272 = null;


        object O_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 113) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2281:5: ( bitwiseXORExpressionNoIn (O= OR bitwiseXORExpressionNoIn )* )
            // AS3_ex.g3:2281:9: bitwiseXORExpressionNoIn (O= OR bitwiseXORExpressionNoIn )*
            {
            	root_0 = (object)adaptor.GetNilNode();

            	PushFollow(FOLLOW_bitwiseXORExpressionNoIn_in_bitwiseORExpressionNoIn10850);
            	bitwiseXORExpressionNoIn271 = bitwiseXORExpressionNoIn();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, bitwiseXORExpressionNoIn271.Tree);
            	// AS3_ex.g3:2281:34: (O= OR bitwiseXORExpressionNoIn )*
            	do 
            	{
            	    int alt124 = 2;
            	    int LA124_0 = input.LA(1);

            	    if ( (LA124_0 == OR) )
            	    {
            	        alt124 = 1;
            	    }


            	    switch (alt124) 
            		{
            			case 1 :
            			    // AS3_ex.g3:2281:36: O= OR bitwiseXORExpressionNoIn
            			    {
            			    	O=(IToken)Match(input,OR,FOLLOW_OR_in_bitwiseORExpressionNoIn10856); if (state.failed) return retval;
            			    	if ( state.backtracking == 0 )
            			    	{O_tree = (object)adaptor.Create(O);
            			    		adaptor.AddChild(root_0, O_tree);
            			    	}
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  IndentEmit((CommonToken)O);
            			    	}
            			    	PushFollow(FOLLOW_bitwiseXORExpressionNoIn_in_bitwiseORExpressionNoIn10860);
            			    	bitwiseXORExpressionNoIn272 = bitwiseXORExpressionNoIn();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, bitwiseXORExpressionNoIn272.Tree);
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  PopIndent();
            			    	}

            			    }
            			    break;

            			default:
            			    goto loop124;
            	    }
            	} while (true);

            	loop124:
            		;	// Stops C# compiler whining that label 'loop124' has no statements


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 113, bitwiseORExpressionNoIn_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "bitwiseORExpressionNoIn"

    public class bitwiseXORExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "bitwiseXORExpression"
    // AS3_ex.g3:2284:1: bitwiseXORExpression : bitwiseANDExpression (x= XOR bitwiseANDExpression )* ;
    public AS3_exParser.bitwiseXORExpression_return bitwiseXORExpression() // throws RecognitionException [1]
    {   
        AS3_exParser.bitwiseXORExpression_return retval = new AS3_exParser.bitwiseXORExpression_return();
        retval.Start = input.LT(1);
        int bitwiseXORExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken x = null;
        AS3_exParser.bitwiseANDExpression_return bitwiseANDExpression273 = null;

        AS3_exParser.bitwiseANDExpression_return bitwiseANDExpression274 = null;


        object x_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 114) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2285:5: ( bitwiseANDExpression (x= XOR bitwiseANDExpression )* )
            // AS3_ex.g3:2285:9: bitwiseANDExpression (x= XOR bitwiseANDExpression )*
            {
            	root_0 = (object)adaptor.GetNilNode();

            	PushFollow(FOLLOW_bitwiseANDExpression_in_bitwiseXORExpression10891);
            	bitwiseANDExpression273 = bitwiseANDExpression();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, bitwiseANDExpression273.Tree);
            	// AS3_ex.g3:2285:30: (x= XOR bitwiseANDExpression )*
            	do 
            	{
            	    int alt125 = 2;
            	    int LA125_0 = input.LA(1);

            	    if ( (LA125_0 == XOR) )
            	    {
            	        alt125 = 1;
            	    }


            	    switch (alt125) 
            		{
            			case 1 :
            			    // AS3_ex.g3:2285:32: x= XOR bitwiseANDExpression
            			    {
            			    	x=(IToken)Match(input,XOR,FOLLOW_XOR_in_bitwiseXORExpression10897); if (state.failed) return retval;
            			    	if ( state.backtracking == 0 )
            			    	{x_tree = (object)adaptor.Create(x);
            			    		adaptor.AddChild(root_0, x_tree);
            			    	}
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  IndentEmit((CommonToken)x);
            			    	}
            			    	PushFollow(FOLLOW_bitwiseANDExpression_in_bitwiseXORExpression10901);
            			    	bitwiseANDExpression274 = bitwiseANDExpression();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, bitwiseANDExpression274.Tree);
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  PopIndent();
            			    	}

            			    }
            			    break;

            			default:
            			    goto loop125;
            	    }
            	} while (true);

            	loop125:
            		;	// Stops C# compiler whining that label 'loop125' has no statements


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 114, bitwiseXORExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "bitwiseXORExpression"

    public class bitwiseXORExpressionNoIn_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "bitwiseXORExpressionNoIn"
    // AS3_ex.g3:2288:1: bitwiseXORExpressionNoIn : bitwiseANDExpressionNoIn (x= XOR bitwiseANDExpressionNoIn )* ;
    public AS3_exParser.bitwiseXORExpressionNoIn_return bitwiseXORExpressionNoIn() // throws RecognitionException [1]
    {   
        AS3_exParser.bitwiseXORExpressionNoIn_return retval = new AS3_exParser.bitwiseXORExpressionNoIn_return();
        retval.Start = input.LT(1);
        int bitwiseXORExpressionNoIn_StartIndex = input.Index();
        object root_0 = null;

        IToken x = null;
        AS3_exParser.bitwiseANDExpressionNoIn_return bitwiseANDExpressionNoIn275 = null;

        AS3_exParser.bitwiseANDExpressionNoIn_return bitwiseANDExpressionNoIn276 = null;


        object x_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 115) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2289:5: ( bitwiseANDExpressionNoIn (x= XOR bitwiseANDExpressionNoIn )* )
            // AS3_ex.g3:2289:9: bitwiseANDExpressionNoIn (x= XOR bitwiseANDExpressionNoIn )*
            {
            	root_0 = (object)adaptor.GetNilNode();

            	PushFollow(FOLLOW_bitwiseANDExpressionNoIn_in_bitwiseXORExpressionNoIn10928);
            	bitwiseANDExpressionNoIn275 = bitwiseANDExpressionNoIn();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, bitwiseANDExpressionNoIn275.Tree);
            	// AS3_ex.g3:2289:34: (x= XOR bitwiseANDExpressionNoIn )*
            	do 
            	{
            	    int alt126 = 2;
            	    int LA126_0 = input.LA(1);

            	    if ( (LA126_0 == XOR) )
            	    {
            	        alt126 = 1;
            	    }


            	    switch (alt126) 
            		{
            			case 1 :
            			    // AS3_ex.g3:2289:36: x= XOR bitwiseANDExpressionNoIn
            			    {
            			    	x=(IToken)Match(input,XOR,FOLLOW_XOR_in_bitwiseXORExpressionNoIn10934); if (state.failed) return retval;
            			    	if ( state.backtracking == 0 )
            			    	{x_tree = (object)adaptor.Create(x);
            			    		adaptor.AddChild(root_0, x_tree);
            			    	}
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  IndentEmit((CommonToken)x);
            			    	}
            			    	PushFollow(FOLLOW_bitwiseANDExpressionNoIn_in_bitwiseXORExpressionNoIn10938);
            			    	bitwiseANDExpressionNoIn276 = bitwiseANDExpressionNoIn();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, bitwiseANDExpressionNoIn276.Tree);
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  PopIndent();
            			    	}

            			    }
            			    break;

            			default:
            			    goto loop126;
            	    }
            	} while (true);

            	loop126:
            		;	// Stops C# compiler whining that label 'loop126' has no statements


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 115, bitwiseXORExpressionNoIn_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "bitwiseXORExpressionNoIn"

    public class bitwiseANDExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "bitwiseANDExpression"
    // AS3_ex.g3:2292:1: bitwiseANDExpression : equalityExpression (A= AND equalityExpression )* ;
    public AS3_exParser.bitwiseANDExpression_return bitwiseANDExpression() // throws RecognitionException [1]
    {   
        AS3_exParser.bitwiseANDExpression_return retval = new AS3_exParser.bitwiseANDExpression_return();
        retval.Start = input.LT(1);
        int bitwiseANDExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken A = null;
        AS3_exParser.equalityExpression_return equalityExpression277 = null;

        AS3_exParser.equalityExpression_return equalityExpression278 = null;


        object A_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 116) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2293:5: ( equalityExpression (A= AND equalityExpression )* )
            // AS3_ex.g3:2293:9: equalityExpression (A= AND equalityExpression )*
            {
            	root_0 = (object)adaptor.GetNilNode();

            	PushFollow(FOLLOW_equalityExpression_in_bitwiseANDExpression10965);
            	equalityExpression277 = equalityExpression();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, equalityExpression277.Tree);
            	// AS3_ex.g3:2293:28: (A= AND equalityExpression )*
            	do 
            	{
            	    int alt127 = 2;
            	    int LA127_0 = input.LA(1);

            	    if ( (LA127_0 == AND) )
            	    {
            	        alt127 = 1;
            	    }


            	    switch (alt127) 
            		{
            			case 1 :
            			    // AS3_ex.g3:2293:30: A= AND equalityExpression
            			    {
            			    	A=(IToken)Match(input,AND,FOLLOW_AND_in_bitwiseANDExpression10971); if (state.failed) return retval;
            			    	if ( state.backtracking == 0 )
            			    	{A_tree = (object)adaptor.Create(A);
            			    		adaptor.AddChild(root_0, A_tree);
            			    	}
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  IndentEmit((CommonToken)A);
            			    	}
            			    	PushFollow(FOLLOW_equalityExpression_in_bitwiseANDExpression10975);
            			    	equalityExpression278 = equalityExpression();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, equalityExpression278.Tree);
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  PopIndent();
            			    	}

            			    }
            			    break;

            			default:
            			    goto loop127;
            	    }
            	} while (true);

            	loop127:
            		;	// Stops C# compiler whining that label 'loop127' has no statements


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 116, bitwiseANDExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "bitwiseANDExpression"

    public class bitwiseANDExpressionNoIn_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "bitwiseANDExpressionNoIn"
    // AS3_ex.g3:2296:1: bitwiseANDExpressionNoIn : equalityExpressionNoIn (A= AND equalityExpressionNoIn )* ;
    public AS3_exParser.bitwiseANDExpressionNoIn_return bitwiseANDExpressionNoIn() // throws RecognitionException [1]
    {   
        AS3_exParser.bitwiseANDExpressionNoIn_return retval = new AS3_exParser.bitwiseANDExpressionNoIn_return();
        retval.Start = input.LT(1);
        int bitwiseANDExpressionNoIn_StartIndex = input.Index();
        object root_0 = null;

        IToken A = null;
        AS3_exParser.equalityExpressionNoIn_return equalityExpressionNoIn279 = null;

        AS3_exParser.equalityExpressionNoIn_return equalityExpressionNoIn280 = null;


        object A_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 117) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2297:5: ( equalityExpressionNoIn (A= AND equalityExpressionNoIn )* )
            // AS3_ex.g3:2297:9: equalityExpressionNoIn (A= AND equalityExpressionNoIn )*
            {
            	root_0 = (object)adaptor.GetNilNode();

            	PushFollow(FOLLOW_equalityExpressionNoIn_in_bitwiseANDExpressionNoIn11002);
            	equalityExpressionNoIn279 = equalityExpressionNoIn();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, equalityExpressionNoIn279.Tree);
            	// AS3_ex.g3:2297:32: (A= AND equalityExpressionNoIn )*
            	do 
            	{
            	    int alt128 = 2;
            	    int LA128_0 = input.LA(1);

            	    if ( (LA128_0 == AND) )
            	    {
            	        alt128 = 1;
            	    }


            	    switch (alt128) 
            		{
            			case 1 :
            			    // AS3_ex.g3:2297:34: A= AND equalityExpressionNoIn
            			    {
            			    	A=(IToken)Match(input,AND,FOLLOW_AND_in_bitwiseANDExpressionNoIn11008); if (state.failed) return retval;
            			    	if ( state.backtracking == 0 )
            			    	{A_tree = (object)adaptor.Create(A);
            			    		adaptor.AddChild(root_0, A_tree);
            			    	}
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  IndentEmit((CommonToken)A);
            			    	}
            			    	PushFollow(FOLLOW_equalityExpressionNoIn_in_bitwiseANDExpressionNoIn11012);
            			    	equalityExpressionNoIn280 = equalityExpressionNoIn();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, equalityExpressionNoIn280.Tree);
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  PopIndent();
            			    	}

            			    }
            			    break;

            			default:
            			    goto loop128;
            	    }
            	} while (true);

            	loop128:
            		;	// Stops C# compiler whining that label 'loop128' has no statements


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 117, bitwiseANDExpressionNoIn_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "bitwiseANDExpressionNoIn"

    public class equalityExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "equalityExpression"
    // AS3_ex.g3:2301:1: equalityExpression : relationalExpression (eq= ( EQ | NEQ | SAME | NSAME ) relationalExpression )* ;
    public AS3_exParser.equalityExpression_return equalityExpression() // throws RecognitionException [1]
    {   
        AS3_exParser.equalityExpression_return retval = new AS3_exParser.equalityExpression_return();
        retval.Start = input.LT(1);
        int equalityExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken eq = null;
        AS3_exParser.relationalExpression_return relationalExpression281 = null;

        AS3_exParser.relationalExpression_return relationalExpression282 = null;


        object eq_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 118) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2302:5: ( relationalExpression (eq= ( EQ | NEQ | SAME | NSAME ) relationalExpression )* )
            // AS3_ex.g3:2302:9: relationalExpression (eq= ( EQ | NEQ | SAME | NSAME ) relationalExpression )*
            {
            	root_0 = (object)adaptor.GetNilNode();

            	PushFollow(FOLLOW_relationalExpression_in_equalityExpression11040);
            	relationalExpression281 = relationalExpression();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, relationalExpression281.Tree);
            	// AS3_ex.g3:2302:30: (eq= ( EQ | NEQ | SAME | NSAME ) relationalExpression )*
            	do 
            	{
            	    int alt129 = 2;
            	    int LA129_0 = input.LA(1);

            	    if ( ((LA129_0 >= EQ && LA129_0 <= NSAME)) )
            	    {
            	        alt129 = 1;
            	    }


            	    switch (alt129) 
            		{
            			case 1 :
            			    // AS3_ex.g3:2302:32: eq= ( EQ | NEQ | SAME | NSAME ) relationalExpression
            			    {
            			    	eq = (IToken)input.LT(1);
            			    	if ( (input.LA(1) >= EQ && input.LA(1) <= NSAME) ) 
            			    	{
            			    	    input.Consume();
            			    	    if ( state.backtracking == 0 ) adaptor.AddChild(root_0, (object)adaptor.Create(eq));
            			    	    state.errorRecovery = false;state.failed = false;
            			    	}
            			    	else 
            			    	{
            			    	    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            			    	    MismatchedSetException mse = new MismatchedSetException(null,input);
            			    	    throw mse;
            			    	}

            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  IndentEmit((CommonToken)eq);
            			    	}
            			    	PushFollow(FOLLOW_relationalExpression_in_equalityExpression11058);
            			    	relationalExpression282 = relationalExpression();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, relationalExpression282.Tree);
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  PopIndent();
            			    	}

            			    }
            			    break;

            			default:
            			    goto loop129;
            	    }
            	} while (true);

            	loop129:
            		;	// Stops C# compiler whining that label 'loop129' has no statements


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 118, equalityExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "equalityExpression"

    public class equalityExpressionNoIn_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "equalityExpressionNoIn"
    // AS3_ex.g3:2305:1: equalityExpressionNoIn : relationalExpressionNoIn (eq= ( EQ | NEQ | SAME | NSAME ) relationalExpressionNoIn )* ;
    public AS3_exParser.equalityExpressionNoIn_return equalityExpressionNoIn() // throws RecognitionException [1]
    {   
        AS3_exParser.equalityExpressionNoIn_return retval = new AS3_exParser.equalityExpressionNoIn_return();
        retval.Start = input.LT(1);
        int equalityExpressionNoIn_StartIndex = input.Index();
        object root_0 = null;

        IToken eq = null;
        AS3_exParser.relationalExpressionNoIn_return relationalExpressionNoIn283 = null;

        AS3_exParser.relationalExpressionNoIn_return relationalExpressionNoIn284 = null;


        object eq_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 119) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2306:5: ( relationalExpressionNoIn (eq= ( EQ | NEQ | SAME | NSAME ) relationalExpressionNoIn )* )
            // AS3_ex.g3:2306:9: relationalExpressionNoIn (eq= ( EQ | NEQ | SAME | NSAME ) relationalExpressionNoIn )*
            {
            	root_0 = (object)adaptor.GetNilNode();

            	PushFollow(FOLLOW_relationalExpressionNoIn_in_equalityExpressionNoIn11085);
            	relationalExpressionNoIn283 = relationalExpressionNoIn();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, relationalExpressionNoIn283.Tree);
            	// AS3_ex.g3:2306:34: (eq= ( EQ | NEQ | SAME | NSAME ) relationalExpressionNoIn )*
            	do 
            	{
            	    int alt130 = 2;
            	    int LA130_0 = input.LA(1);

            	    if ( ((LA130_0 >= EQ && LA130_0 <= NSAME)) )
            	    {
            	        alt130 = 1;
            	    }


            	    switch (alt130) 
            		{
            			case 1 :
            			    // AS3_ex.g3:2306:36: eq= ( EQ | NEQ | SAME | NSAME ) relationalExpressionNoIn
            			    {
            			    	eq = (IToken)input.LT(1);
            			    	if ( (input.LA(1) >= EQ && input.LA(1) <= NSAME) ) 
            			    	{
            			    	    input.Consume();
            			    	    if ( state.backtracking == 0 ) adaptor.AddChild(root_0, (object)adaptor.Create(eq));
            			    	    state.errorRecovery = false;state.failed = false;
            			    	}
            			    	else 
            			    	{
            			    	    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            			    	    MismatchedSetException mse = new MismatchedSetException(null,input);
            			    	    throw mse;
            			    	}

            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  IndentEmit((CommonToken)eq);
            			    	}
            			    	PushFollow(FOLLOW_relationalExpressionNoIn_in_equalityExpressionNoIn11104);
            			    	relationalExpressionNoIn284 = relationalExpressionNoIn();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, relationalExpressionNoIn284.Tree);
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  PopIndent();
            			    	}

            			    }
            			    break;

            			default:
            			    goto loop130;
            	    }
            	} while (true);

            	loop130:
            		;	// Stops C# compiler whining that label 'loop130' has no statements


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 119, equalityExpressionNoIn_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "equalityExpressionNoIn"

    public class relationalExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "relationalExpression"
    // AS3_ex.g3:2310:1: relationalExpression : shiftExpression ( (g= GT (assign= ASSIGN )? | eq= ( IN | LT | LTE | INSTANCEOF | IS | AS ) ) shiftExpression )* ;
    public AS3_exParser.relationalExpression_return relationalExpression() // throws RecognitionException [1]
    {   
        AS3_exParser.relationalExpression_return retval = new AS3_exParser.relationalExpression_return();
        retval.Start = input.LT(1);
        int relationalExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken g = null;
        IToken assign = null;
        IToken eq = null;
        AS3_exParser.shiftExpression_return shiftExpression285 = null;

        AS3_exParser.shiftExpression_return shiftExpression286 = null;


        object g_tree=null;
        object assign_tree=null;
        object eq_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 120) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2311:5: ( shiftExpression ( (g= GT (assign= ASSIGN )? | eq= ( IN | LT | LTE | INSTANCEOF | IS | AS ) ) shiftExpression )* )
            // AS3_ex.g3:2311:9: shiftExpression ( (g= GT (assign= ASSIGN )? | eq= ( IN | LT | LTE | INSTANCEOF | IS | AS ) ) shiftExpression )*
            {
            	root_0 = (object)adaptor.GetNilNode();

            	PushFollow(FOLLOW_shiftExpression_in_relationalExpression11132);
            	shiftExpression285 = shiftExpression();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, shiftExpression285.Tree);
            	// AS3_ex.g3:2312:6: ( (g= GT (assign= ASSIGN )? | eq= ( IN | LT | LTE | INSTANCEOF | IS | AS ) ) shiftExpression )*
            	do 
            	{
            	    int alt133 = 2;
            	    alt133 = dfa133.Predict(input);
            	    switch (alt133) 
            		{
            			case 1 :
            			    // AS3_ex.g3:2313:7: (g= GT (assign= ASSIGN )? | eq= ( IN | LT | LTE | INSTANCEOF | IS | AS ) ) shiftExpression
            			    {
            			    	// AS3_ex.g3:2313:7: (g= GT (assign= ASSIGN )? | eq= ( IN | LT | LTE | INSTANCEOF | IS | AS ) )
            			    	int alt132 = 2;
            			    	int LA132_0 = input.LA(1);

            			    	if ( (LA132_0 == GT) )
            			    	{
            			    	    alt132 = 1;
            			    	}
            			    	else if ( (LA132_0 == AS || (LA132_0 >= IN && LA132_0 <= INSTANCEOF) || LA132_0 == IS || LA132_0 == LT || LA132_0 == LTE) )
            			    	{
            			    	    alt132 = 2;
            			    	}
            			    	else 
            			    	{
            			    	    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            			    	    NoViableAltException nvae_d132s0 =
            			    	        new NoViableAltException("", 132, 0, input);

            			    	    throw nvae_d132s0;
            			    	}
            			    	switch (alt132) 
            			    	{
            			    	    case 1 :
            			    	        // AS3_ex.g3:2313:9: g= GT (assign= ASSIGN )?
            			    	        {
            			    	        	g=(IToken)Match(input,GT,FOLLOW_GT_in_relationalExpression11152); if (state.failed) return retval;
            			    	        	if ( state.backtracking == 0 )
            			    	        	{g_tree = (object)adaptor.Create(g);
            			    	        		adaptor.AddChild(root_0, g_tree);
            			    	        	}
            			    	        	// AS3_ex.g3:2313:14: (assign= ASSIGN )?
            			    	        	int alt131 = 2;
            			    	        	int LA131_0 = input.LA(1);

            			    	        	if ( (LA131_0 == ASSIGN) )
            			    	        	{
            			    	        	    alt131 = 1;
            			    	        	}
            			    	        	switch (alt131) 
            			    	        	{
            			    	        	    case 1 :
            			    	        	        // AS3_ex.g3:2313:15: assign= ASSIGN
            			    	        	        {
            			    	        	        	assign=(IToken)Match(input,ASSIGN,FOLLOW_ASSIGN_in_relationalExpression11157); if (state.failed) return retval;
            			    	        	        	if ( state.backtracking == 0 )
            			    	        	        	{assign_tree = (object)adaptor.Create(assign);
            			    	        	        		adaptor.AddChild(root_0, assign_tree);
            			    	        	        	}

            			    	        	        }
            			    	        	        break;

            			    	        	}

            			    	        	if ( state.backtracking == 0 ) 
            			    	        	{
            			    	        	  if (assign!=null)
            			    	        	  		         {
            			    	        	  		         	g.Text = ">=";
            			    	        	  		         	g.Type = GTE;
            			    	        	  		         }
            			    	        	  		         IndentEmit((CommonToken)g);
            			    	        	  		        
            			    	        	}

            			    	        }
            			    	        break;
            			    	    case 2 :
            			    	        // AS3_ex.g3:2321:14: eq= ( IN | LT | LTE | INSTANCEOF | IS | AS )
            			    	        {
            			    	        	eq = (IToken)input.LT(1);
            			    	        	if ( input.LA(1) == AS || (input.LA(1) >= IN && input.LA(1) <= INSTANCEOF) || input.LA(1) == IS || input.LA(1) == LT || input.LA(1) == LTE ) 
            			    	        	{
            			    	        	    input.Consume();
            			    	        	    if ( state.backtracking == 0 ) adaptor.AddChild(root_0, (object)adaptor.Create(eq));
            			    	        	    state.errorRecovery = false;state.failed = false;
            			    	        	}
            			    	        	else 
            			    	        	{
            			    	        	    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            			    	        	    MismatchedSetException mse = new MismatchedSetException(null,input);
            			    	        	    throw mse;
            			    	        	}

            			    	        	if ( state.backtracking == 0 ) 
            			    	        	{
            			    	        	  IndentEmit((CommonToken)eq);
            			    	        	}

            			    	        }
            			    	        break;

            			    	}

            			    	PushFollow(FOLLOW_shiftExpression_in_relationalExpression11228);
            			    	shiftExpression286 = shiftExpression();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, shiftExpression286.Tree);
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  PopIndent();
            			    	}

            			    }
            			    break;

            			default:
            			    goto loop133;
            	    }
            	} while (true);

            	loop133:
            		;	// Stops C# compiler whining that label 'loop133' has no statements


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 120, relationalExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "relationalExpression"

    public class relationalExpressionNoIn_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "relationalExpressionNoIn"
    // AS3_ex.g3:2327:1: relationalExpressionNoIn : shiftExpression ( (g= GT (assign= ASSIGN )? | eq= ( LT | LTE | INSTANCEOF | IS | AS ) ) shiftExpression )* ;
    public AS3_exParser.relationalExpressionNoIn_return relationalExpressionNoIn() // throws RecognitionException [1]
    {   
        AS3_exParser.relationalExpressionNoIn_return retval = new AS3_exParser.relationalExpressionNoIn_return();
        retval.Start = input.LT(1);
        int relationalExpressionNoIn_StartIndex = input.Index();
        object root_0 = null;

        IToken g = null;
        IToken assign = null;
        IToken eq = null;
        AS3_exParser.shiftExpression_return shiftExpression287 = null;

        AS3_exParser.shiftExpression_return shiftExpression288 = null;


        object g_tree=null;
        object assign_tree=null;
        object eq_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 121) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2328:5: ( shiftExpression ( (g= GT (assign= ASSIGN )? | eq= ( LT | LTE | INSTANCEOF | IS | AS ) ) shiftExpression )* )
            // AS3_ex.g3:2328:9: shiftExpression ( (g= GT (assign= ASSIGN )? | eq= ( LT | LTE | INSTANCEOF | IS | AS ) ) shiftExpression )*
            {
            	root_0 = (object)adaptor.GetNilNode();

            	PushFollow(FOLLOW_shiftExpression_in_relationalExpressionNoIn11264);
            	shiftExpression287 = shiftExpression();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, shiftExpression287.Tree);
            	// AS3_ex.g3:2329:6: ( (g= GT (assign= ASSIGN )? | eq= ( LT | LTE | INSTANCEOF | IS | AS ) ) shiftExpression )*
            	do 
            	{
            	    int alt136 = 2;
            	    int LA136_0 = input.LA(1);

            	    if ( (LA136_0 == AS || LA136_0 == INSTANCEOF || LA136_0 == IS || (LA136_0 >= LT && LA136_0 <= LTE)) )
            	    {
            	        alt136 = 1;
            	    }


            	    switch (alt136) 
            		{
            			case 1 :
            			    // AS3_ex.g3:2330:7: (g= GT (assign= ASSIGN )? | eq= ( LT | LTE | INSTANCEOF | IS | AS ) ) shiftExpression
            			    {
            			    	// AS3_ex.g3:2330:7: (g= GT (assign= ASSIGN )? | eq= ( LT | LTE | INSTANCEOF | IS | AS ) )
            			    	int alt135 = 2;
            			    	int LA135_0 = input.LA(1);

            			    	if ( (LA135_0 == GT) )
            			    	{
            			    	    alt135 = 1;
            			    	}
            			    	else if ( (LA135_0 == AS || LA135_0 == INSTANCEOF || LA135_0 == IS || LA135_0 == LT || LA135_0 == LTE) )
            			    	{
            			    	    alt135 = 2;
            			    	}
            			    	else 
            			    	{
            			    	    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            			    	    NoViableAltException nvae_d135s0 =
            			    	        new NoViableAltException("", 135, 0, input);

            			    	    throw nvae_d135s0;
            			    	}
            			    	switch (alt135) 
            			    	{
            			    	    case 1 :
            			    	        // AS3_ex.g3:2330:9: g= GT (assign= ASSIGN )?
            			    	        {
            			    	        	g=(IToken)Match(input,GT,FOLLOW_GT_in_relationalExpressionNoIn11284); if (state.failed) return retval;
            			    	        	if ( state.backtracking == 0 )
            			    	        	{g_tree = (object)adaptor.Create(g);
            			    	        		adaptor.AddChild(root_0, g_tree);
            			    	        	}
            			    	        	// AS3_ex.g3:2330:14: (assign= ASSIGN )?
            			    	        	int alt134 = 2;
            			    	        	int LA134_0 = input.LA(1);

            			    	        	if ( (LA134_0 == ASSIGN) )
            			    	        	{
            			    	        	    alt134 = 1;
            			    	        	}
            			    	        	switch (alt134) 
            			    	        	{
            			    	        	    case 1 :
            			    	        	        // AS3_ex.g3:2330:15: assign= ASSIGN
            			    	        	        {
            			    	        	        	assign=(IToken)Match(input,ASSIGN,FOLLOW_ASSIGN_in_relationalExpressionNoIn11289); if (state.failed) return retval;
            			    	        	        	if ( state.backtracking == 0 )
            			    	        	        	{assign_tree = (object)adaptor.Create(assign);
            			    	        	        		adaptor.AddChild(root_0, assign_tree);
            			    	        	        	}

            			    	        	        }
            			    	        	        break;

            			    	        	}

            			    	        	if ( state.backtracking == 0 ) 
            			    	        	{
            			    	        	  if (assign!=null)
            			    	        	  		         {
            			    	        	  		         	g.Text = ">=";
            			    	        	  		         	g.Type = GTE;
            			    	        	  		         }
            			    	        	  		         IndentEmit((CommonToken)g);
            			    	        	  		        
            			    	        	}

            			    	        }
            			    	        break;
            			    	    case 2 :
            			    	        // AS3_ex.g3:2338:14: eq= ( LT | LTE | INSTANCEOF | IS | AS )
            			    	        {
            			    	        	eq = (IToken)input.LT(1);
            			    	        	if ( input.LA(1) == AS || input.LA(1) == INSTANCEOF || input.LA(1) == IS || input.LA(1) == LT || input.LA(1) == LTE ) 
            			    	        	{
            			    	        	    input.Consume();
            			    	        	    if ( state.backtracking == 0 ) adaptor.AddChild(root_0, (object)adaptor.Create(eq));
            			    	        	    state.errorRecovery = false;state.failed = false;
            			    	        	}
            			    	        	else 
            			    	        	{
            			    	        	    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            			    	        	    MismatchedSetException mse = new MismatchedSetException(null,input);
            			    	        	    throw mse;
            			    	        	}

            			    	        	if ( state.backtracking == 0 ) 
            			    	        	{
            			    	        	  IndentEmit((CommonToken)eq);
            			    	        	}

            			    	        }
            			    	        break;

            			    	}

            			    	PushFollow(FOLLOW_shiftExpression_in_relationalExpressionNoIn11358);
            			    	shiftExpression288 = shiftExpression();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, shiftExpression288.Tree);
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  PopIndent();
            			    	}

            			    }
            			    break;

            			default:
            			    goto loop136;
            	    }
            	} while (true);

            	loop136:
            		;	// Stops C# compiler whining that label 'loop136' has no statements


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 121, relationalExpressionNoIn_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "relationalExpressionNoIn"

    public class shiftExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "shiftExpression"
    // AS3_ex.g3:2345:1: shiftExpression : additiveExpression ( (t1= SHL | ( ( '>' '>' )=>t1= '>' t2= '>' {...}? -> SHR ) | ( ( '>' '>' '>' )=>t1= '>' t2= '>' t3= '>' {...}? -> SHU ) ) additiveExpression )* ;
    public AS3_exParser.shiftExpression_return shiftExpression() // throws RecognitionException [1]
    {   
        AS3_exParser.shiftExpression_return retval = new AS3_exParser.shiftExpression_return();
        retval.Start = input.LT(1);
        int shiftExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken t1 = null;
        IToken t2 = null;
        IToken t3 = null;
        AS3_exParser.additiveExpression_return additiveExpression289 = null;

        AS3_exParser.additiveExpression_return additiveExpression290 = null;


        object t1_tree=null;
        object t2_tree=null;
        object t3_tree=null;
        RewriteRuleTokenStream stream_GT = new RewriteRuleTokenStream(adaptor,"token GT");
        RewriteRuleTokenStream stream_SHL = new RewriteRuleTokenStream(adaptor,"token SHL");
        RewriteRuleSubtreeStream stream_additiveExpression = new RewriteRuleSubtreeStream(adaptor,"rule additiveExpression");
        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 122) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2346:5: ( additiveExpression ( (t1= SHL | ( ( '>' '>' )=>t1= '>' t2= '>' {...}? -> SHR ) | ( ( '>' '>' '>' )=>t1= '>' t2= '>' t3= '>' {...}? -> SHU ) ) additiveExpression )* )
            // AS3_ex.g3:2346:9: additiveExpression ( (t1= SHL | ( ( '>' '>' )=>t1= '>' t2= '>' {...}? -> SHR ) | ( ( '>' '>' '>' )=>t1= '>' t2= '>' t3= '>' {...}? -> SHU ) ) additiveExpression )*
            {
            	PushFollow(FOLLOW_additiveExpression_in_shiftExpression11391);
            	additiveExpression289 = additiveExpression();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking==0 ) stream_additiveExpression.Add(additiveExpression289.Tree);
            	// AS3_ex.g3:2346:28: ( (t1= SHL | ( ( '>' '>' )=>t1= '>' t2= '>' {...}? -> SHR ) | ( ( '>' '>' '>' )=>t1= '>' t2= '>' t3= '>' {...}? -> SHU ) ) additiveExpression )*
            	do 
            	{
            	    int alt138 = 2;
            	    int LA138_0 = input.LA(1);

            	    if ( (LA138_0 == GT) )
            	    {
            	        int LA138_1 = input.LA(2);

            	        if ( (LA138_1 == GT) )
            	        {
            	            alt138 = 1;
            	        }


            	    }
            	    else if ( (LA138_0 == SHL) )
            	    {
            	        alt138 = 1;
            	    }


            	    switch (alt138) 
            		{
            			case 1 :
            			    // AS3_ex.g3:2347:7: (t1= SHL | ( ( '>' '>' )=>t1= '>' t2= '>' {...}? -> SHR ) | ( ( '>' '>' '>' )=>t1= '>' t2= '>' t3= '>' {...}? -> SHU ) ) additiveExpression
            			    {
            			    	// AS3_ex.g3:2347:7: (t1= SHL | ( ( '>' '>' )=>t1= '>' t2= '>' {...}? -> SHR ) | ( ( '>' '>' '>' )=>t1= '>' t2= '>' t3= '>' {...}? -> SHU ) )
            			    	int alt137 = 3;
            			    	int LA137_0 = input.LA(1);

            			    	if ( (LA137_0 == SHL) )
            			    	{
            			    	    alt137 = 1;
            			    	}
            			    	else if ( (LA137_0 == GT) )
            			    	{
            			    	    int LA137_2 = input.LA(2);

            			    	    if ( (LA137_2 == GT) )
            			    	    {
            			    	        int LA137_3 = input.LA(3);

            			    	        if ( (LA137_3 == GT) && (synpred283_AS3_ex()) )
            			    	        {
            			    	            alt137 = 3;
            			    	        }
            			    	        else if ( ((LA137_3 >= AS && LA137_3 <= STATIC) || LA137_3 == LCURLY || LA137_3 == LPAREN || LA137_3 == LBRACK || LA137_3 == LT || (LA137_3 >= PLUS && LA137_3 <= STAR) || (LA137_3 >= INC && LA137_3 <= DEC) || (LA137_3 >= NOT && LA137_3 <= INV) || (LA137_3 >= XML_AT && LA137_3 <= XML_LS_STD) || (LA137_3 >= SINGLE_QUOTE_LITERAL && LA137_3 <= DOUBLE_QUOTE_LITERAL) || LA137_3 == REGULAR_EXPR_LITERAL || LA137_3 == HEX_NUMBER_LITERAL || LA137_3 == DEC_NUMBER_LITERAL || LA137_3 == IDENTIFIER || (LA137_3 >= XML_COMMENT && LA137_3 <= XML_PI)) )
            			    	        {
            			    	            alt137 = 2;
            			    	        }
            			    	        else 
            			    	        {
            			    	            if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            			    	            NoViableAltException nvae_d137s3 =
            			    	                new NoViableAltException("", 137, 3, input);

            			    	            throw nvae_d137s3;
            			    	        }
            			    	    }
            			    	    else 
            			    	    {
            			    	        if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            			    	        NoViableAltException nvae_d137s2 =
            			    	            new NoViableAltException("", 137, 2, input);

            			    	        throw nvae_d137s2;
            			    	    }
            			    	}
            			    	else 
            			    	{
            			    	    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            			    	    NoViableAltException nvae_d137s0 =
            			    	        new NoViableAltException("", 137, 0, input);

            			    	    throw nvae_d137s0;
            			    	}
            			    	switch (alt137) 
            			    	{
            			    	    case 1 :
            			    	        // AS3_ex.g3:2348:8: t1= SHL
            			    	        {
            			    	        	t1=(IToken)Match(input,SHL,FOLLOW_SHL_in_shiftExpression11413); if (state.failed) return retval; 
            			    	        	if ( state.backtracking==0 ) stream_SHL.Add(t1);


            			    	        }
            			    	        break;
            			    	    case 2 :
            			    	        // AS3_ex.g3:2349:11: ( ( '>' '>' )=>t1= '>' t2= '>' {...}? -> SHR )
            			    	        {
            			    	        	// AS3_ex.g3:2349:11: ( ( '>' '>' )=>t1= '>' t2= '>' {...}? -> SHR )
            			    	        	// AS3_ex.g3:2349:12: ( '>' '>' )=>t1= '>' t2= '>' {...}?
            			    	        	{
            			    	        		t1=(IToken)Match(input,GT,FOLLOW_GT_in_shiftExpression11435); if (state.failed) return retval; 
            			    	        		if ( state.backtracking==0 ) stream_GT.Add(t1);

            			    	        		t2=(IToken)Match(input,GT,FOLLOW_GT_in_shiftExpression11439); if (state.failed) return retval; 
            			    	        		if ( state.backtracking==0 ) stream_GT.Add(t2);

            			    	        		if ( !(( t1.Line == t2.Line && 
            			    	        		          			t1.CharPositionInLine + 1 == t2.CharPositionInLine )) ) 
            			    	        		{
            			    	        		    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            			    	        		    throw new FailedPredicateException(input, "shiftExpression", " $t1.Line == $t2.Line && \r\n          \t\t\t$t1.CharPositionInLine + 1 == $t2.CharPositionInLine ");
            			    	        		}


            			    	        		// AST REWRITE
            			    	        		// elements:          
            			    	        		// token labels:      
            			    	        		// rule labels:       retval
            			    	        		// token list labels: 
            			    	        		// rule list labels:  
            			    	        		if ( state.backtracking==0 ) {
            			    	        		retval.Tree = root_0;
            			    	        		RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));

            			    	        		root_0 = (object)adaptor.GetNilNode();
            			    	        		// 2352:10: -> SHR
            			    	        		{
            			    	        		    adaptor.AddChild(root_0, (object)adaptor.Create(SHR, "SHR"));

            			    	        		}

            			    	        		retval.Tree = root_0;retval.Tree = root_0;}
            			    	        	}

            			    	        	if ( state.backtracking == 0 ) 
            			    	        	{
            			    	        	  t1.Text = ">>";
            			    	        	}

            			    	        }
            			    	        break;
            			    	    case 3 :
            			    	        // AS3_ex.g3:2353:10: ( ( '>' '>' '>' )=>t1= '>' t2= '>' t3= '>' {...}? -> SHU )
            			    	        {
            			    	        	// AS3_ex.g3:2353:10: ( ( '>' '>' '>' )=>t1= '>' t2= '>' t3= '>' {...}? -> SHU )
            			    	        	// AS3_ex.g3:2353:11: ( '>' '>' '>' )=>t1= '>' t2= '>' t3= '>' {...}?
            			    	        	{
            			    	        		t1=(IToken)Match(input,GT,FOLLOW_GT_in_shiftExpression11490); if (state.failed) return retval; 
            			    	        		if ( state.backtracking==0 ) stream_GT.Add(t1);

            			    	        		t2=(IToken)Match(input,GT,FOLLOW_GT_in_shiftExpression11494); if (state.failed) return retval; 
            			    	        		if ( state.backtracking==0 ) stream_GT.Add(t2);

            			    	        		t3=(IToken)Match(input,GT,FOLLOW_GT_in_shiftExpression11498); if (state.failed) return retval; 
            			    	        		if ( state.backtracking==0 ) stream_GT.Add(t3);

            			    	        		if ( !(( t1.Line == t2.Line && 
            			    	        		          			t1.CharPositionInLine + 1 == t2.CharPositionInLine &&
            			    	        		          			t2.Line == t3.Line && 
            			    	        		          			t2.CharPositionInLine + 1 == t3.CharPositionInLine )) ) 
            			    	        		{
            			    	        		    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            			    	        		    throw new FailedPredicateException(input, "shiftExpression", " $t1.Line == $t2.Line && \r\n          \t\t\t$t1.CharPositionInLine + 1 == $t2.CharPositionInLine &&\r\n          \t\t\t$t2.Line == $t3.Line && \r\n          \t\t\t$t2.CharPositionInLine + 1 == $t3.CharPositionInLine ");
            			    	        		}


            			    	        		// AST REWRITE
            			    	        		// elements:          
            			    	        		// token labels:      
            			    	        		// rule labels:       retval
            			    	        		// token list labels: 
            			    	        		// rule list labels:  
            			    	        		if ( state.backtracking==0 ) {
            			    	        		retval.Tree = root_0;
            			    	        		RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));

            			    	        		root_0 = (object)adaptor.GetNilNode();
            			    	        		// 2358:10: -> SHU
            			    	        		{
            			    	        		    adaptor.AddChild(root_0, (object)adaptor.Create(SHU, "SHU"));

            			    	        		}

            			    	        		retval.Tree = root_0;retval.Tree = root_0;}
            			    	        	}

            			    	        	if ( state.backtracking == 0 ) 
            			    	        	{
            			    	        	  t1.Text = ">>>";
            			    	        	}

            			    	        }
            			    	        break;

            			    	}

            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  IndentEmit((CommonToken)t1);
            			    	}
            			    	PushFollow(FOLLOW_additiveExpression_in_shiftExpression11545);
            			    	additiveExpression290 = additiveExpression();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking==0 ) stream_additiveExpression.Add(additiveExpression290.Tree);
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  PopIndent();
            			    	}

            			    }
            			    break;

            			default:
            			    goto loop138;
            	    }
            	} while (true);

            	loop138:
            		;	// Stops C# compiler whining that label 'loop138' has no statements


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 122, shiftExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "shiftExpression"

    public class additiveExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "additiveExpression"
    // AS3_ex.g3:2365:1: additiveExpression : multiplicativeExpression (op= ( PLUS | SUB ) multiplicativeExpression )* ;
    public AS3_exParser.additiveExpression_return additiveExpression() // throws RecognitionException [1]
    {   
        AS3_exParser.additiveExpression_return retval = new AS3_exParser.additiveExpression_return();
        retval.Start = input.LT(1);
        int additiveExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken op = null;
        AS3_exParser.multiplicativeExpression_return multiplicativeExpression291 = null;

        AS3_exParser.multiplicativeExpression_return multiplicativeExpression292 = null;


        object op_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 123) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2366:5: ( multiplicativeExpression (op= ( PLUS | SUB ) multiplicativeExpression )* )
            // AS3_ex.g3:2366:9: multiplicativeExpression (op= ( PLUS | SUB ) multiplicativeExpression )*
            {
            	root_0 = (object)adaptor.GetNilNode();

            	PushFollow(FOLLOW_multiplicativeExpression_in_additiveExpression11575);
            	multiplicativeExpression291 = multiplicativeExpression();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, multiplicativeExpression291.Tree);
            	// AS3_ex.g3:2366:34: (op= ( PLUS | SUB ) multiplicativeExpression )*
            	do 
            	{
            	    int alt139 = 2;
            	    alt139 = dfa139.Predict(input);
            	    switch (alt139) 
            		{
            			case 1 :
            			    // AS3_ex.g3:2366:36: op= ( PLUS | SUB ) multiplicativeExpression
            			    {
            			    	op = (IToken)input.LT(1);
            			    	if ( (input.LA(1) >= PLUS && input.LA(1) <= SUB) ) 
            			    	{
            			    	    input.Consume();
            			    	    if ( state.backtracking == 0 ) adaptor.AddChild(root_0, (object)adaptor.Create(op));
            			    	    state.errorRecovery = false;state.failed = false;
            			    	}
            			    	else 
            			    	{
            			    	    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            			    	    MismatchedSetException mse = new MismatchedSetException(null,input);
            			    	    throw mse;
            			    	}

            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  IndentEmit((CommonToken)op);
            			    	}
            			    	PushFollow(FOLLOW_multiplicativeExpression_in_additiveExpression11589);
            			    	multiplicativeExpression292 = multiplicativeExpression();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, multiplicativeExpression292.Tree);
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  PopIndent();
            			    	}

            			    }
            			    break;

            			default:
            			    goto loop139;
            	    }
            	} while (true);

            	loop139:
            		;	// Stops C# compiler whining that label 'loop139' has no statements


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 123, additiveExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "additiveExpression"

    public class multiplicativeExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "multiplicativeExpression"
    // AS3_ex.g3:2370:1: multiplicativeExpression : unaryExpression (op= ( STAR | DIV | MOD ) unaryExpression )* ;
    public AS3_exParser.multiplicativeExpression_return multiplicativeExpression() // throws RecognitionException [1]
    {   
        AS3_exParser.multiplicativeExpression_return retval = new AS3_exParser.multiplicativeExpression_return();
        retval.Start = input.LT(1);
        int multiplicativeExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken op = null;
        AS3_exParser.unaryExpression_return unaryExpression293 = null;

        AS3_exParser.unaryExpression_return unaryExpression294 = null;


        object op_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 124) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2371:5: ( unaryExpression (op= ( STAR | DIV | MOD ) unaryExpression )* )
            // AS3_ex.g3:2371:9: unaryExpression (op= ( STAR | DIV | MOD ) unaryExpression )*
            {
            	root_0 = (object)adaptor.GetNilNode();

            	PushFollow(FOLLOW_unaryExpression_in_multiplicativeExpression11613);
            	unaryExpression293 = unaryExpression();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, unaryExpression293.Tree);
            	// AS3_ex.g3:2371:25: (op= ( STAR | DIV | MOD ) unaryExpression )*
            	do 
            	{
            	    int alt140 = 2;
            	    alt140 = dfa140.Predict(input);
            	    switch (alt140) 
            		{
            			case 1 :
            			    // AS3_ex.g3:2371:27: op= ( STAR | DIV | MOD ) unaryExpression
            			    {
            			    	op = (IToken)input.LT(1);
            			    	if ( (input.LA(1) >= STAR && input.LA(1) <= MOD) ) 
            			    	{
            			    	    input.Consume();
            			    	    if ( state.backtracking == 0 ) adaptor.AddChild(root_0, (object)adaptor.Create(op));
            			    	    state.errorRecovery = false;state.failed = false;
            			    	}
            			    	else 
            			    	{
            			    	    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            			    	    MismatchedSetException mse = new MismatchedSetException(null,input);
            			    	    throw mse;
            			    	}

            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  IndentEmit((CommonToken)op);
            			    	}
            			    	PushFollow(FOLLOW_unaryExpression_in_multiplicativeExpression11628);
            			    	unaryExpression294 = unaryExpression();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, unaryExpression294.Tree);
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  PopIndent();
            			    	}

            			    }
            			    break;

            			default:
            			    goto loop140;
            	    }
            	} while (true);

            	loop140:
            		;	// Stops C# compiler whining that label 'loop140' has no statements


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 124, multiplicativeExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "multiplicativeExpression"

    public class unaryExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "unaryExpression"
    // AS3_ex.g3:2375:1: unaryExpression : ( postfixExpression | op= ( NOT | INV ) unaryExpression | unaryOp postfixExpression );
    public AS3_exParser.unaryExpression_return unaryExpression() // throws RecognitionException [1]
    {   
        AS3_exParser.unaryExpression_return retval = new AS3_exParser.unaryExpression_return();
        retval.Start = input.LT(1);
        int unaryExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken op = null;
        AS3_exParser.postfixExpression_return postfixExpression295 = null;

        AS3_exParser.unaryExpression_return unaryExpression296 = null;

        AS3_exParser.unaryOp_return unaryOp297 = null;

        AS3_exParser.postfixExpression_return postfixExpression298 = null;


        object op_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 125) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2376:5: ( postfixExpression | op= ( NOT | INV ) unaryExpression | unaryOp postfixExpression )
            int alt141 = 3;
            alt141 = dfa141.Predict(input);
            switch (alt141) 
            {
                case 1 :
                    // AS3_ex.g3:2376:9: postfixExpression
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_postfixExpression_in_unaryExpression11652);
                    	postfixExpression295 = postfixExpression();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, postfixExpression295.Tree);

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:2377:8: op= ( NOT | INV ) unaryExpression
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	op = (IToken)input.LT(1);
                    	if ( (input.LA(1) >= NOT && input.LA(1) <= INV) ) 
                    	{
                    	    input.Consume();
                    	    if ( state.backtracking == 0 ) adaptor.AddChild(root_0, (object)adaptor.Create(op));
                    	    state.errorRecovery = false;state.failed = false;
                    	}
                    	else 
                    	{
                    	    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    	    MismatchedSetException mse = new MismatchedSetException(null,input);
                    	    throw mse;
                    	}

                    	if ( state.backtracking == 0 ) 
                    	{
                    	  Emit((CommonToken)op);
                    	}
                    	PushFollow(FOLLOW_unaryExpression_in_unaryExpression11673);
                    	unaryExpression296 = unaryExpression();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, unaryExpression296.Tree);

                    }
                    break;
                case 3 :
                    // AS3_ex.g3:2378:9: unaryOp postfixExpression
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_unaryOp_in_unaryExpression11683);
                    	unaryOp297 = unaryOp();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, unaryOp297.Tree);
                    	PushFollow(FOLLOW_postfixExpression_in_unaryExpression11685);
                    	postfixExpression298 = postfixExpression();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, postfixExpression298.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 125, unaryExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "unaryExpression"

    public class unaryOp_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "unaryOp"
    // AS3_ex.g3:2383:1: unaryOp : op= ( DELETE | VOID | TYPEOF | INC | DEC | PLUS | SUB | INV | NOT ) ;
    public AS3_exParser.unaryOp_return unaryOp() // throws RecognitionException [1]
    {   
        AS3_exParser.unaryOp_return retval = new AS3_exParser.unaryOp_return();
        retval.Start = input.LT(1);
        int unaryOp_StartIndex = input.Index();
        object root_0 = null;

        IToken op = null;

        object op_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 126) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2384:5: (op= ( DELETE | VOID | TYPEOF | INC | DEC | PLUS | SUB | INV | NOT ) )
            // AS3_ex.g3:2384:9: op= ( DELETE | VOID | TYPEOF | INC | DEC | PLUS | SUB | INV | NOT )
            {
            	root_0 = (object)adaptor.GetNilNode();

            	op = (IToken)input.LT(1);
            	if ( input.LA(1) == DELETE || input.LA(1) == TYPEOF || input.LA(1) == VOID || (input.LA(1) >= PLUS && input.LA(1) <= SUB) || (input.LA(1) >= INC && input.LA(1) <= DEC) || (input.LA(1) >= NOT && input.LA(1) <= INV) ) 
            	{
            	    input.Consume();
            	    if ( state.backtracking == 0 ) adaptor.AddChild(root_0, (object)adaptor.Create(op));
            	    state.errorRecovery = false;state.failed = false;
            	}
            	else 
            	{
            	    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            	    MismatchedSetException mse = new MismatchedSetException(null,input);
            	    throw mse;
            	}

            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)op);
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 126, unaryOp_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "unaryOp"

    public class postfixExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "postfixExpression"
    // AS3_ex.g3:2389:1: postfixExpression : leftHandSideExpression ( postfixOp )? ;
    public AS3_exParser.postfixExpression_return postfixExpression() // throws RecognitionException [1]
    {   
        AS3_exParser.postfixExpression_return retval = new AS3_exParser.postfixExpression_return();
        retval.Start = input.LT(1);
        int postfixExpression_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.leftHandSideExpression_return leftHandSideExpression299 = null;

        AS3_exParser.postfixOp_return postfixOp300 = null;



        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 127) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2390:5: ( leftHandSideExpression ( postfixOp )? )
            // AS3_ex.g3:2390:9: leftHandSideExpression ( postfixOp )?
            {
            	root_0 = (object)adaptor.GetNilNode();

            	PushFollow(FOLLOW_leftHandSideExpression_in_postfixExpression11773);
            	leftHandSideExpression299 = leftHandSideExpression();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, leftHandSideExpression299.Tree);
            	// AS3_ex.g3:2390:32: ( postfixOp )?
            	int alt142 = 2;
            	alt142 = dfa142.Predict(input);
            	switch (alt142) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:0:0: postfixOp
            	        {
            	        	PushFollow(FOLLOW_postfixOp_in_postfixExpression11775);
            	        	postfixOp300 = postfixOp();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, postfixOp300.Tree);

            	        }
            	        break;

            	}


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 127, postfixExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "postfixExpression"

    public class postfixOp_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "postfixOp"
    // AS3_ex.g3:2393:1: postfixOp : op= ( INC | DEC ) ;
    public AS3_exParser.postfixOp_return postfixOp() // throws RecognitionException [1]
    {   
        AS3_exParser.postfixOp_return retval = new AS3_exParser.postfixOp_return();
        retval.Start = input.LT(1);
        int postfixOp_StartIndex = input.Index();
        object root_0 = null;

        IToken op = null;

        object op_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 128) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2394:5: (op= ( INC | DEC ) )
            // AS3_ex.g3:2394:9: op= ( INC | DEC )
            {
            	root_0 = (object)adaptor.GetNilNode();

            	op = (IToken)input.LT(1);
            	if ( (input.LA(1) >= INC && input.LA(1) <= DEC) ) 
            	{
            	    input.Consume();
            	    if ( state.backtracking == 0 ) adaptor.AddChild(root_0, (object)adaptor.Create(op));
            	    state.errorRecovery = false;state.failed = false;
            	}
            	else 
            	{
            	    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            	    MismatchedSetException mse = new MismatchedSetException(null,input);
            	    throw mse;
            	}

            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)op);
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 128, postfixOp_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "postfixOp"

    public class memberExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "memberExpression"
    // AS3_ex.g3:2398:1: memberExpression : ( primaryExpression | functionExpression | newExpression );
    public AS3_exParser.memberExpression_return memberExpression() // throws RecognitionException [1]
    {   
        AS3_exParser.memberExpression_return retval = new AS3_exParser.memberExpression_return();
        retval.Start = input.LT(1);
        int memberExpression_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.primaryExpression_return primaryExpression301 = null;

        AS3_exParser.functionExpression_return functionExpression302 = null;

        AS3_exParser.newExpression_return newExpression303 = null;



        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 129) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2399:2: ( primaryExpression | functionExpression | newExpression )
            int alt143 = 3;
            switch ( input.LA(1) ) 
            {
            case AS:
            case BREAK:
            case CASE:
            case CATCH:
            case CLASS:
            case CONST:
            case CONTINUE:
            case DEFAULT:
            case DELETE:
            case DO:
            case ELSE:
            case EXTENDS:
            case FALSE:
            case FINALLY:
            case FOR:
            case IF:
            case IMPLEMENTS:
            case IMPORT:
            case IN:
            case INSTANCEOF:
            case INTERFACE:
            case INTERNAL:
            case IS:
            case NATIVE:
            case NULL:
            case PACKAGE:
            case PRIVATE:
            case PROTECTED:
            case PUBLIC:
            case RETURN:
            case SUPER:
            case SWITCH:
            case THIS:
            case THROW:
            case TO:
            case TRUE:
            case TRY:
            case TYPEOF:
            case USE:
            case VAR:
            case VOID:
            case WHILE:
            case WITH:
            case EACH:
            case GET:
            case SET:
            case NAMESPACE:
            case INCLUDE:
            case DYNAMIC:
            case FINAL:
            case OVERRIDE:
            case STATIC:
            case LCURLY:
            case LPAREN:
            case LBRACK:
            case LT:
            case STAR:
            case XML_AT:
            case XML_LS_STD:
            case SINGLE_QUOTE_LITERAL:
            case DOUBLE_QUOTE_LITERAL:
            case REGULAR_EXPR_LITERAL:
            case HEX_NUMBER_LITERAL:
            case DEC_NUMBER_LITERAL:
            case IDENTIFIER:
            case XML_COMMENT:
            case XML_CDATA:
            case XML_PI:
            	{
                alt143 = 1;
                }
                break;
            case FUNCTION:
            	{
                int LA143_2 = input.LA(2);

                if ( (LA143_2 == DOT || LA143_2 == SUB || LA143_2 == COLON || LA143_2 == XML_NS_OP) )
                {
                    alt143 = 1;
                }
                else if ( (LA143_2 == LPAREN || LA143_2 == IDENTIFIER) )
                {
                    alt143 = 2;
                }
                else 
                {
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    NoViableAltException nvae_d143s2 =
                        new NoViableAltException("", 143, 2, input);

                    throw nvae_d143s2;
                }
                }
                break;
            case NEW:
            	{
                int LA143_3 = input.LA(2);

                if ( (LA143_3 == DOT || LA143_3 == SUB || LA143_3 == COLON || LA143_3 == XML_NS_OP) )
                {
                    alt143 = 1;
                }
                else if ( ((LA143_3 >= AS && LA143_3 <= STATIC) || LA143_3 == LCURLY || LA143_3 == LPAREN || LA143_3 == LBRACK || LA143_3 == LT || LA143_3 == STAR || (LA143_3 >= XML_AT && LA143_3 <= XML_LS_STD) || (LA143_3 >= SINGLE_QUOTE_LITERAL && LA143_3 <= DOUBLE_QUOTE_LITERAL) || LA143_3 == REGULAR_EXPR_LITERAL || LA143_3 == HEX_NUMBER_LITERAL || LA143_3 == DEC_NUMBER_LITERAL || LA143_3 == IDENTIFIER || (LA143_3 >= XML_COMMENT && LA143_3 <= XML_PI)) )
                {
                    alt143 = 3;
                }
                else 
                {
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    NoViableAltException nvae_d143s3 =
                        new NoViableAltException("", 143, 3, input);

                    throw nvae_d143s3;
                }
                }
                break;
            	default:
            	    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            	    NoViableAltException nvae_d143s0 =
            	        new NoViableAltException("", 143, 0, input);

            	    throw nvae_d143s0;
            }

            switch (alt143) 
            {
                case 1 :
                    // AS3_ex.g3:2399:4: primaryExpression
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_primaryExpression_in_memberExpression11823);
                    	primaryExpression301 = primaryExpression();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, primaryExpression301.Tree);

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:2400:4: functionExpression
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_functionExpression_in_memberExpression11828);
                    	functionExpression302 = functionExpression();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, functionExpression302.Tree);

                    }
                    break;
                case 3 :
                    // AS3_ex.g3:2401:4: newExpression
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_newExpression_in_memberExpression11833);
                    	newExpression303 = newExpression();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, newExpression303.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 129, memberExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "memberExpression"

    public class newExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "newExpression"
    // AS3_ex.g3:2404:1: newExpression : N= NEW primaryExpression ;
    public AS3_exParser.newExpression_return newExpression() // throws RecognitionException [1]
    {   
        AS3_exParser.newExpression_return retval = new AS3_exParser.newExpression_return();
        retval.Start = input.LT(1);
        int newExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken N = null;
        AS3_exParser.primaryExpression_return primaryExpression304 = null;


        object N_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 130) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2405:2: (N= NEW primaryExpression )
            // AS3_ex.g3:2405:4: N= NEW primaryExpression
            {
            	root_0 = (object)adaptor.GetNilNode();

            	N=(IToken)Match(input,NEW,FOLLOW_NEW_in_newExpression11846); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{N_tree = (object)adaptor.Create(N);
            		adaptor.AddChild(root_0, N_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)N);InsertWS(1);
            	}
            	PushFollow(FOLLOW_primaryExpression_in_newExpression11851);
            	primaryExpression304 = primaryExpression();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, primaryExpression304.Tree);

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 130, newExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "newExpression"

    public class leftHandSideExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "leftHandSideExpression"
    // AS3_ex.g3:2409:1: leftHandSideExpression : memberExpression ( arguments | L= LBRACK expression R= RBRACK | D= DOT ( eitherIdentifier op= XML_NS_OP )? eitherIdentifier | E= XML_ELLIPSIS ( eitherIdentifier op= XML_NS_OP )? eitherIdentifier | D= DOT parExpression | typePostfixSyntax )* ;
    public AS3_exParser.leftHandSideExpression_return leftHandSideExpression() // throws RecognitionException [1]
    {   
        AS3_exParser.leftHandSideExpression_return retval = new AS3_exParser.leftHandSideExpression_return();
        retval.Start = input.LT(1);
        int leftHandSideExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        IToken R = null;
        IToken D = null;
        IToken op = null;
        IToken E = null;
        AS3_exParser.memberExpression_return memberExpression305 = null;

        AS3_exParser.arguments_return arguments306 = null;

        AS3_exParser.expression_return expression307 = null;

        AS3_exParser.eitherIdentifier_return eitherIdentifier308 = null;

        AS3_exParser.eitherIdentifier_return eitherIdentifier309 = null;

        AS3_exParser.eitherIdentifier_return eitherIdentifier310 = null;

        AS3_exParser.eitherIdentifier_return eitherIdentifier311 = null;

        AS3_exParser.parExpression_return parExpression312 = null;

        AS3_exParser.typePostfixSyntax_return typePostfixSyntax313 = null;


        object L_tree=null;
        object R_tree=null;
        object D_tree=null;
        object op_tree=null;
        object E_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 131) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2410:5: ( memberExpression ( arguments | L= LBRACK expression R= RBRACK | D= DOT ( eitherIdentifier op= XML_NS_OP )? eitherIdentifier | E= XML_ELLIPSIS ( eitherIdentifier op= XML_NS_OP )? eitherIdentifier | D= DOT parExpression | typePostfixSyntax )* )
            // AS3_ex.g3:2410:9: memberExpression ( arguments | L= LBRACK expression R= RBRACK | D= DOT ( eitherIdentifier op= XML_NS_OP )? eitherIdentifier | E= XML_ELLIPSIS ( eitherIdentifier op= XML_NS_OP )? eitherIdentifier | D= DOT parExpression | typePostfixSyntax )*
            {
            	root_0 = (object)adaptor.GetNilNode();

            	PushFollow(FOLLOW_memberExpression_in_leftHandSideExpression11868);
            	memberExpression305 = memberExpression();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, memberExpression305.Tree);
            	// AS3_ex.g3:2411:5: ( arguments | L= LBRACK expression R= RBRACK | D= DOT ( eitherIdentifier op= XML_NS_OP )? eitherIdentifier | E= XML_ELLIPSIS ( eitherIdentifier op= XML_NS_OP )? eitherIdentifier | D= DOT parExpression | typePostfixSyntax )*
            	do 
            	{
            	    int alt146 = 7;
            	    alt146 = dfa146.Predict(input);
            	    switch (alt146) 
            		{
            			case 1 :
            			    // AS3_ex.g3:2412:7: arguments
            			    {
            			    	PushFollow(FOLLOW_arguments_in_leftHandSideExpression11883);
            			    	arguments306 = arguments();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, arguments306.Tree);

            			    }
            			    break;
            			case 2 :
            			    // AS3_ex.g3:2413:9: L= LBRACK expression R= RBRACK
            			    {
            			    	L=(IToken)Match(input,LBRACK,FOLLOW_LBRACK_in_leftHandSideExpression11895); if (state.failed) return retval;
            			    	if ( state.backtracking == 0 )
            			    	{L_tree = (object)adaptor.Create(L);
            			    		adaptor.AddChild(root_0, L_tree);
            			    	}
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  Emit((CommonToken)L);InsertWS(mPrinter.GetAdvancedSpacesInsideArrayReferenceBrackets());
            			    	}
            			    	PushFollow(FOLLOW_expression_in_leftHandSideExpression11899);
            			    	expression307 = expression();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, expression307.Tree);
            			    	R=(IToken)Match(input,RBRACK,FOLLOW_RBRACK_in_leftHandSideExpression11903); if (state.failed) return retval;
            			    	if ( state.backtracking == 0 )
            			    	{R_tree = (object)adaptor.Create(R);
            			    		adaptor.AddChild(root_0, R_tree);
            			    	}
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  InsertWS(mPrinter.GetAdvancedSpacesInsideArrayReferenceBrackets());Emit((CommonToken)R);
            			    	}

            			    }
            			    break;
            			case 3 :
            			    // AS3_ex.g3:2415:9: D= DOT ( eitherIdentifier op= XML_NS_OP )? eitherIdentifier
            			    {
            			    	D=(IToken)Match(input,DOT,FOLLOW_DOT_in_leftHandSideExpression11918); if (state.failed) return retval;
            			    	if ( state.backtracking == 0 )
            			    	{D_tree = (object)adaptor.Create(D);
            			    		adaptor.AddChild(root_0, D_tree);
            			    	}
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  Emit((CommonToken)D);
            			    	}
            			    	// AS3_ex.g3:2415:40: ( eitherIdentifier op= XML_NS_OP )?
            			    	int alt144 = 2;
            			    	switch ( input.LA(1) ) 
            			    	{
            			    	    case IDENTIFIER:
            			    	    	{
            			    	        int LA144_1 = input.LA(2);

            			    	        if ( (synpred307_AS3_ex()) )
            			    	        {
            			    	            alt144 = 1;
            			    	        }
            			    	        }
            			    	        break;
            			    	    case XML_AT:
            			    	    	{
            			    	        int LA144_2 = input.LA(2);

            			    	        if ( (synpred307_AS3_ex()) )
            			    	        {
            			    	            alt144 = 1;
            			    	        }
            			    	        }
            			    	        break;
            			    	    case AS:
            			    	    case BREAK:
            			    	    case CASE:
            			    	    case CATCH:
            			    	    case CLASS:
            			    	    case CONST:
            			    	    case CONTINUE:
            			    	    case DEFAULT:
            			    	    case DELETE:
            			    	    case DO:
            			    	    case ELSE:
            			    	    case EXTENDS:
            			    	    case FALSE:
            			    	    case FINALLY:
            			    	    case FOR:
            			    	    case FUNCTION:
            			    	    case IF:
            			    	    case IMPLEMENTS:
            			    	    case IMPORT:
            			    	    case IN:
            			    	    case INSTANCEOF:
            			    	    case INTERFACE:
            			    	    case INTERNAL:
            			    	    case IS:
            			    	    case NEW:
            			    	    case NULL:
            			    	    case PACKAGE:
            			    	    case PRIVATE:
            			    	    case PROTECTED:
            			    	    case PUBLIC:
            			    	    case RETURN:
            			    	    case SUPER:
            			    	    case SWITCH:
            			    	    case THIS:
            			    	    case THROW:
            			    	    case TRUE:
            			    	    case TRY:
            			    	    case TYPEOF:
            			    	    case USE:
            			    	    case VAR:
            			    	    case VOID:
            			    	    case WHILE:
            			    	    case WITH:
            			    	    case INCLUDE:
            			    	    	{
            			    	        int LA144_3 = input.LA(2);

            			    	        if ( (synpred307_AS3_ex()) )
            			    	        {
            			    	            alt144 = 1;
            			    	        }
            			    	        }
            			    	        break;
            			    	    case NATIVE:
            			    	    case TO:
            			    	    case EACH:
            			    	    case GET:
            			    	    case SET:
            			    	    case NAMESPACE:
            			    	    case DYNAMIC:
            			    	    case FINAL:
            			    	    case OVERRIDE:
            			    	    case STATIC:
            			    	    	{
            			    	        int LA144_4 = input.LA(2);

            			    	        if ( (synpred307_AS3_ex()) )
            			    	        {
            			    	            alt144 = 1;
            			    	        }
            			    	        }
            			    	        break;
            			    	    case STAR:
            			    	    	{
            			    	        int LA144_5 = input.LA(2);

            			    	        if ( (synpred307_AS3_ex()) )
            			    	        {
            			    	            alt144 = 1;
            			    	        }
            			    	        }
            			    	        break;
            			    	}

            			    	switch (alt144) 
            			    	{
            			    	    case 1 :
            			    	        // AS3_ex.g3:2415:41: eitherIdentifier op= XML_NS_OP
            			    	        {
            			    	        	PushFollow(FOLLOW_eitherIdentifier_in_leftHandSideExpression11923);
            			    	        	eitherIdentifier308 = eitherIdentifier();
            			    	        	state.followingStackPointer--;
            			    	        	if (state.failed) return retval;
            			    	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, eitherIdentifier308.Tree);
            			    	        	op=(IToken)Match(input,XML_NS_OP,FOLLOW_XML_NS_OP_in_leftHandSideExpression11927); if (state.failed) return retval;
            			    	        	if ( state.backtracking == 0 )
            			    	        	{op_tree = (object)adaptor.Create(op);
            			    	        		adaptor.AddChild(root_0, op_tree);
            			    	        	}
            			    	        	if ( state.backtracking == 0 ) 
            			    	        	{
            			    	        	  Emit((CommonToken)op);
            			    	        	}

            			    	        }
            			    	        break;

            			    	}

            			    	PushFollow(FOLLOW_eitherIdentifier_in_leftHandSideExpression11934);
            			    	eitherIdentifier309 = eitherIdentifier();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, eitherIdentifier309.Tree);

            			    }
            			    break;
            			case 4 :
            			    // AS3_ex.g3:2416:9: E= XML_ELLIPSIS ( eitherIdentifier op= XML_NS_OP )? eitherIdentifier
            			    {
            			    	E=(IToken)Match(input,XML_ELLIPSIS,FOLLOW_XML_ELLIPSIS_in_leftHandSideExpression11946); if (state.failed) return retval;
            			    	if ( state.backtracking == 0 )
            			    	{E_tree = (object)adaptor.Create(E);
            			    		adaptor.AddChild(root_0, E_tree);
            			    	}
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  Emit((CommonToken)E);
            			    	}
            			    	// AS3_ex.g3:2416:48: ( eitherIdentifier op= XML_NS_OP )?
            			    	int alt145 = 2;
            			    	switch ( input.LA(1) ) 
            			    	{
            			    	    case IDENTIFIER:
            			    	    	{
            			    	        int LA145_1 = input.LA(2);

            			    	        if ( (synpred309_AS3_ex()) )
            			    	        {
            			    	            alt145 = 1;
            			    	        }
            			    	        }
            			    	        break;
            			    	    case XML_AT:
            			    	    	{
            			    	        int LA145_2 = input.LA(2);

            			    	        if ( (synpred309_AS3_ex()) )
            			    	        {
            			    	            alt145 = 1;
            			    	        }
            			    	        }
            			    	        break;
            			    	    case AS:
            			    	    case BREAK:
            			    	    case CASE:
            			    	    case CATCH:
            			    	    case CLASS:
            			    	    case CONST:
            			    	    case CONTINUE:
            			    	    case DEFAULT:
            			    	    case DELETE:
            			    	    case DO:
            			    	    case ELSE:
            			    	    case EXTENDS:
            			    	    case FALSE:
            			    	    case FINALLY:
            			    	    case FOR:
            			    	    case FUNCTION:
            			    	    case IF:
            			    	    case IMPLEMENTS:
            			    	    case IMPORT:
            			    	    case IN:
            			    	    case INSTANCEOF:
            			    	    case INTERFACE:
            			    	    case INTERNAL:
            			    	    case IS:
            			    	    case NEW:
            			    	    case NULL:
            			    	    case PACKAGE:
            			    	    case PRIVATE:
            			    	    case PROTECTED:
            			    	    case PUBLIC:
            			    	    case RETURN:
            			    	    case SUPER:
            			    	    case SWITCH:
            			    	    case THIS:
            			    	    case THROW:
            			    	    case TRUE:
            			    	    case TRY:
            			    	    case TYPEOF:
            			    	    case USE:
            			    	    case VAR:
            			    	    case VOID:
            			    	    case WHILE:
            			    	    case WITH:
            			    	    case INCLUDE:
            			    	    	{
            			    	        int LA145_3 = input.LA(2);

            			    	        if ( (synpred309_AS3_ex()) )
            			    	        {
            			    	            alt145 = 1;
            			    	        }
            			    	        }
            			    	        break;
            			    	    case NATIVE:
            			    	    case TO:
            			    	    case EACH:
            			    	    case GET:
            			    	    case SET:
            			    	    case NAMESPACE:
            			    	    case DYNAMIC:
            			    	    case FINAL:
            			    	    case OVERRIDE:
            			    	    case STATIC:
            			    	    	{
            			    	        int LA145_4 = input.LA(2);

            			    	        if ( (synpred309_AS3_ex()) )
            			    	        {
            			    	            alt145 = 1;
            			    	        }
            			    	        }
            			    	        break;
            			    	    case STAR:
            			    	    	{
            			    	        int LA145_5 = input.LA(2);

            			    	        if ( (synpred309_AS3_ex()) )
            			    	        {
            			    	            alt145 = 1;
            			    	        }
            			    	        }
            			    	        break;
            			    	}

            			    	switch (alt145) 
            			    	{
            			    	    case 1 :
            			    	        // AS3_ex.g3:2416:49: eitherIdentifier op= XML_NS_OP
            			    	        {
            			    	        	PushFollow(FOLLOW_eitherIdentifier_in_leftHandSideExpression11950);
            			    	        	eitherIdentifier310 = eitherIdentifier();
            			    	        	state.followingStackPointer--;
            			    	        	if (state.failed) return retval;
            			    	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, eitherIdentifier310.Tree);
            			    	        	op=(IToken)Match(input,XML_NS_OP,FOLLOW_XML_NS_OP_in_leftHandSideExpression11954); if (state.failed) return retval;
            			    	        	if ( state.backtracking == 0 )
            			    	        	{op_tree = (object)adaptor.Create(op);
            			    	        		adaptor.AddChild(root_0, op_tree);
            			    	        	}
            			    	        	if ( state.backtracking == 0 ) 
            			    	        	{
            			    	        	  Emit((CommonToken)op);
            			    	        	}

            			    	        }
            			    	        break;

            			    	}

            			    	PushFollow(FOLLOW_eitherIdentifier_in_leftHandSideExpression11961);
            			    	eitherIdentifier311 = eitherIdentifier();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, eitherIdentifier311.Tree);

            			    }
            			    break;
            			case 5 :
            			    // AS3_ex.g3:2417:9: D= DOT parExpression
            			    {
            			    	D=(IToken)Match(input,DOT,FOLLOW_DOT_in_leftHandSideExpression11973); if (state.failed) return retval;
            			    	if ( state.backtracking == 0 )
            			    	{D_tree = (object)adaptor.Create(D);
            			    		adaptor.AddChild(root_0, D_tree);
            			    	}
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  Emit((CommonToken)D);
            			    	}
            			    	PushFollow(FOLLOW_parExpression_in_leftHandSideExpression11977);
            			    	parExpression312 = parExpression();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, parExpression312.Tree);

            			    }
            			    break;
            			case 6 :
            			    // AS3_ex.g3:2418:9: typePostfixSyntax
            			    {
            			    	PushFollow(FOLLOW_typePostfixSyntax_in_leftHandSideExpression11987);
            			    	typePostfixSyntax313 = typePostfixSyntax();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, typePostfixSyntax313.Tree);

            			    }
            			    break;

            			default:
            			    goto loop146;
            	    }
            	} while (true);

            	loop146:
            		;	// Stops C# compiler whining that label 'loop146' has no statements


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 131, leftHandSideExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "leftHandSideExpression"

    public class eitherIdentifier_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "eitherIdentifier"
    // AS3_ex.g3:2422:1: eitherIdentifier : (I= IDENTIFIER | xmlPropertyIdentifier | allKeywords );
    public AS3_exParser.eitherIdentifier_return eitherIdentifier() // throws RecognitionException [1]
    {   
        AS3_exParser.eitherIdentifier_return retval = new AS3_exParser.eitherIdentifier_return();
        retval.Start = input.LT(1);
        int eitherIdentifier_StartIndex = input.Index();
        object root_0 = null;

        IToken I = null;
        AS3_exParser.xmlPropertyIdentifier_return xmlPropertyIdentifier314 = null;

        AS3_exParser.allKeywords_return allKeywords315 = null;


        object I_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 132) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2423:2: (I= IDENTIFIER | xmlPropertyIdentifier | allKeywords )
            int alt147 = 3;
            switch ( input.LA(1) ) 
            {
            case IDENTIFIER:
            	{
                int LA147_1 = input.LA(2);

                if ( (synpred313_AS3_ex()) )
                {
                    alt147 = 1;
                }
                else if ( (synpred314_AS3_ex()) )
                {
                    alt147 = 2;
                }
                else 
                {
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    NoViableAltException nvae_d147s1 =
                        new NoViableAltException("", 147, 1, input);

                    throw nvae_d147s1;
                }
                }
                break;
            case STAR:
            case XML_AT:
            	{
                alt147 = 2;
                }
                break;
            case AS:
            case BREAK:
            case CASE:
            case CATCH:
            case CLASS:
            case CONST:
            case CONTINUE:
            case DEFAULT:
            case DELETE:
            case DO:
            case ELSE:
            case EXTENDS:
            case FALSE:
            case FINALLY:
            case FOR:
            case FUNCTION:
            case IF:
            case IMPLEMENTS:
            case IMPORT:
            case IN:
            case INSTANCEOF:
            case INTERFACE:
            case INTERNAL:
            case IS:
            case NEW:
            case NULL:
            case PACKAGE:
            case PRIVATE:
            case PROTECTED:
            case PUBLIC:
            case RETURN:
            case SUPER:
            case SWITCH:
            case THIS:
            case THROW:
            case TRUE:
            case TRY:
            case TYPEOF:
            case USE:
            case VAR:
            case VOID:
            case WHILE:
            case WITH:
            case INCLUDE:
            	{
                int LA147_3 = input.LA(2);

                if ( (synpred314_AS3_ex()) )
                {
                    alt147 = 2;
                }
                else if ( (true) )
                {
                    alt147 = 3;
                }
                else 
                {
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    NoViableAltException nvae_d147s3 =
                        new NoViableAltException("", 147, 3, input);

                    throw nvae_d147s3;
                }
                }
                break;
            case NATIVE:
            case TO:
            case EACH:
            case GET:
            case SET:
            case NAMESPACE:
            case DYNAMIC:
            case FINAL:
            case OVERRIDE:
            case STATIC:
            	{
                int LA147_4 = input.LA(2);

                if ( (synpred314_AS3_ex()) )
                {
                    alt147 = 2;
                }
                else if ( (true) )
                {
                    alt147 = 3;
                }
                else 
                {
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    NoViableAltException nvae_d147s4 =
                        new NoViableAltException("", 147, 4, input);

                    throw nvae_d147s4;
                }
                }
                break;
            	default:
            	    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            	    NoViableAltException nvae_d147s0 =
            	        new NoViableAltException("", 147, 0, input);

            	    throw nvae_d147s0;
            }

            switch (alt147) 
            {
                case 1 :
                    // AS3_ex.g3:2423:4: I= IDENTIFIER
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	I=(IToken)Match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_eitherIdentifier12017); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{I_tree = (object)adaptor.Create(I);
                    		adaptor.AddChild(root_0, I_tree);
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  Emit((CommonToken)I);
                    	}

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:2424:5: xmlPropertyIdentifier
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_xmlPropertyIdentifier_in_eitherIdentifier12027);
                    	xmlPropertyIdentifier314 = xmlPropertyIdentifier();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlPropertyIdentifier314.Tree);

                    }
                    break;
                case 3 :
                    // AS3_ex.g3:2425:5: allKeywords
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_allKeywords_in_eitherIdentifier12033);
                    	allKeywords315 = allKeywords();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, allKeywords315.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 132, eitherIdentifier_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "eitherIdentifier"

    public class typeSpecifier_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "typeSpecifier"
    // AS3_ex.g3:2428:1: typeSpecifier : (I= IDENTIFIER | notQuiteReservedWord | I= INTERNAL | D= DEFAULT );
    public AS3_exParser.typeSpecifier_return typeSpecifier() // throws RecognitionException [1]
    {   
        AS3_exParser.typeSpecifier_return retval = new AS3_exParser.typeSpecifier_return();
        retval.Start = input.LT(1);
        int typeSpecifier_StartIndex = input.Index();
        object root_0 = null;

        IToken I = null;
        IToken D = null;
        AS3_exParser.notQuiteReservedWord_return notQuiteReservedWord316 = null;


        object I_tree=null;
        object D_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 133) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2428:14: (I= IDENTIFIER | notQuiteReservedWord | I= INTERNAL | D= DEFAULT )
            int alt148 = 4;
            switch ( input.LA(1) ) 
            {
            case IDENTIFIER:
            	{
                alt148 = 1;
                }
                break;
            case NATIVE:
            case TO:
            case EACH:
            case GET:
            case SET:
            case NAMESPACE:
            case DYNAMIC:
            case FINAL:
            case OVERRIDE:
            case STATIC:
            	{
                alt148 = 2;
                }
                break;
            case INTERNAL:
            	{
                alt148 = 3;
                }
                break;
            case DEFAULT:
            	{
                alt148 = 4;
                }
                break;
            	default:
            	    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            	    NoViableAltException nvae_d148s0 =
            	        new NoViableAltException("", 148, 0, input);

            	    throw nvae_d148s0;
            }

            switch (alt148) 
            {
                case 1 :
                    // AS3_ex.g3:2429:2: I= IDENTIFIER
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	I=(IToken)Match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_typeSpecifier12046); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{I_tree = (object)adaptor.Create(I);
                    		adaptor.AddChild(root_0, I_tree);
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  Emit((CommonToken)I);
                    	}

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:2429:42: notQuiteReservedWord
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_notQuiteReservedWord_in_typeSpecifier12052);
                    	notQuiteReservedWord316 = notQuiteReservedWord();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, notQuiteReservedWord316.Tree);

                    }
                    break;
                case 3 :
                    // AS3_ex.g3:2429:65: I= INTERNAL
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	I=(IToken)Match(input,INTERNAL,FOLLOW_INTERNAL_in_typeSpecifier12058); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{I_tree = (object)adaptor.Create(I);
                    		adaptor.AddChild(root_0, I_tree);
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  Emit((CommonToken)I);
                    	}

                    }
                    break;
                case 4 :
                    // AS3_ex.g3:2429:103: D= DEFAULT
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	D=(IToken)Match(input,DEFAULT,FOLLOW_DEFAULT_in_typeSpecifier12066); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{D_tree = (object)adaptor.Create(D);
                    		adaptor.AddChild(root_0, D_tree);
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  Emit((CommonToken)D);
                    	}

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 133, typeSpecifier_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "typeSpecifier"

    public class notQuiteReservedWord_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "notQuiteReservedWord"
    // AS3_ex.g3:2432:1: notQuiteReservedWord : word= ( TO | NATIVE | EACH | GET | SET | NAMESPACE | DYNAMIC | FINAL | OVERRIDE | STATIC ) ;
    public AS3_exParser.notQuiteReservedWord_return notQuiteReservedWord() // throws RecognitionException [1]
    {   
        AS3_exParser.notQuiteReservedWord_return retval = new AS3_exParser.notQuiteReservedWord_return();
        retval.Start = input.LT(1);
        int notQuiteReservedWord_StartIndex = input.Index();
        object root_0 = null;

        IToken word = null;

        object word_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 134) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2433:2: (word= ( TO | NATIVE | EACH | GET | SET | NAMESPACE | DYNAMIC | FINAL | OVERRIDE | STATIC ) )
            // AS3_ex.g3:2434:2: word= ( TO | NATIVE | EACH | GET | SET | NAMESPACE | DYNAMIC | FINAL | OVERRIDE | STATIC )
            {
            	root_0 = (object)adaptor.GetNilNode();

            	word = (IToken)input.LT(1);
            	if ( input.LA(1) == NATIVE || input.LA(1) == TO || (input.LA(1) >= EACH && input.LA(1) <= NAMESPACE) || (input.LA(1) >= DYNAMIC && input.LA(1) <= STATIC) ) 
            	{
            	    input.Consume();
            	    if ( state.backtracking == 0 ) adaptor.AddChild(root_0, (object)adaptor.Create(word));
            	    state.errorRecovery = false;state.failed = false;
            	}
            	else 
            	{
            	    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            	    MismatchedSetException mse = new MismatchedSetException(null,input);
            	    throw mse;
            	}

            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)word);
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 134, notQuiteReservedWord_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "notQuiteReservedWord"

    public class allKeywords_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "allKeywords"
    // AS3_ex.g3:2437:1: allKeywords : ( reservedWord | notQuiteReservedWord ) ;
    public AS3_exParser.allKeywords_return allKeywords() // throws RecognitionException [1]
    {   
        AS3_exParser.allKeywords_return retval = new AS3_exParser.allKeywords_return();
        retval.Start = input.LT(1);
        int allKeywords_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.reservedWord_return reservedWord317 = null;

        AS3_exParser.notQuiteReservedWord_return notQuiteReservedWord318 = null;



        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 135) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2438:2: ( ( reservedWord | notQuiteReservedWord ) )
            // AS3_ex.g3:2438:4: ( reservedWord | notQuiteReservedWord )
            {
            	root_0 = (object)adaptor.GetNilNode();

            	// AS3_ex.g3:2438:4: ( reservedWord | notQuiteReservedWord )
            	int alt149 = 2;
            	int LA149_0 = input.LA(1);

            	if ( ((LA149_0 >= AS && LA149_0 <= IS) || (LA149_0 >= NEW && LA149_0 <= THROW) || (LA149_0 >= TRUE && LA149_0 <= WITH) || LA149_0 == INCLUDE) )
            	{
            	    alt149 = 1;
            	}
            	else if ( (LA149_0 == NATIVE || LA149_0 == TO || (LA149_0 >= EACH && LA149_0 <= NAMESPACE) || (LA149_0 >= DYNAMIC && LA149_0 <= STATIC)) )
            	{
            	    alt149 = 2;
            	}
            	else 
            	{
            	    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            	    NoViableAltException nvae_d149s0 =
            	        new NoViableAltException("", 149, 0, input);

            	    throw nvae_d149s0;
            	}
            	switch (alt149) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:2438:5: reservedWord
            	        {
            	        	PushFollow(FOLLOW_reservedWord_in_allKeywords12137);
            	        	reservedWord317 = reservedWord();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, reservedWord317.Tree);

            	        }
            	        break;
            	    case 2 :
            	        // AS3_ex.g3:2438:20: notQuiteReservedWord
            	        {
            	        	PushFollow(FOLLOW_notQuiteReservedWord_in_allKeywords12141);
            	        	notQuiteReservedWord318 = notQuiteReservedWord();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, notQuiteReservedWord318.Tree);

            	        }
            	        break;

            	}


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 135, allKeywords_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "allKeywords"

    public class reservedWord_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "reservedWord"
    // AS3_ex.g3:2440:1: reservedWord : word= ( AS | BREAK | CASE | CATCH | CLASS | CONST | CONTINUE | DEFAULT | DELETE | DO | ELSE | EXTENDS | FALSE | FINALLY | FOR | FUNCTION | IF | IMPLEMENTS | IMPORT | IN | INSTANCEOF | INTERFACE | INTERNAL | IS | NEW | NULL | PACKAGE | PRIVATE | PROTECTED | PUBLIC | RETURN | SUPER | SWITCH | THIS | THROW | TRUE | TRY | TYPEOF | USE | VAR | VOID | WHILE | WITH | INCLUDE ) ;
    public AS3_exParser.reservedWord_return reservedWord() // throws RecognitionException [1]
    {   
        AS3_exParser.reservedWord_return retval = new AS3_exParser.reservedWord_return();
        retval.Start = input.LT(1);
        int reservedWord_StartIndex = input.Index();
        object root_0 = null;

        IToken word = null;

        object word_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 136) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2441:2: (word= ( AS | BREAK | CASE | CATCH | CLASS | CONST | CONTINUE | DEFAULT | DELETE | DO | ELSE | EXTENDS | FALSE | FINALLY | FOR | FUNCTION | IF | IMPLEMENTS | IMPORT | IN | INSTANCEOF | INTERFACE | INTERNAL | IS | NEW | NULL | PACKAGE | PRIVATE | PROTECTED | PUBLIC | RETURN | SUPER | SWITCH | THIS | THROW | TRUE | TRY | TYPEOF | USE | VAR | VOID | WHILE | WITH | INCLUDE ) )
            // AS3_ex.g3:2442:5: word= ( AS | BREAK | CASE | CATCH | CLASS | CONST | CONTINUE | DEFAULT | DELETE | DO | ELSE | EXTENDS | FALSE | FINALLY | FOR | FUNCTION | IF | IMPLEMENTS | IMPORT | IN | INSTANCEOF | INTERFACE | INTERNAL | IS | NEW | NULL | PACKAGE | PRIVATE | PROTECTED | PUBLIC | RETURN | SUPER | SWITCH | THIS | THROW | TRUE | TRY | TYPEOF | USE | VAR | VOID | WHILE | WITH | INCLUDE )
            {
            	root_0 = (object)adaptor.GetNilNode();

            	word = (IToken)input.LT(1);
            	if ( (input.LA(1) >= AS && input.LA(1) <= IS) || (input.LA(1) >= NEW && input.LA(1) <= THROW) || (input.LA(1) >= TRUE && input.LA(1) <= WITH) || input.LA(1) == INCLUDE ) 
            	{
            	    input.Consume();
            	    if ( state.backtracking == 0 ) adaptor.AddChild(root_0, (object)adaptor.Create(word));
            	    state.errorRecovery = false;state.failed = false;
            	}
            	else 
            	{
            	    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            	    MismatchedSetException mse = new MismatchedSetException(null,input);
            	    throw mse;
            	}

            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)word);
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 136, reservedWord_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "reservedWord"

    public class arguments_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "arguments"
    // AS3_ex.g3:2499:1: arguments : L= LPAREN ( assignmentExpression (C= COMMA assignmentExpression )* )? R= RPAREN ;
    public AS3_exParser.arguments_return arguments() // throws RecognitionException [1]
    {   
        AS3_exParser.arguments_return retval = new AS3_exParser.arguments_return();
        retval.Start = input.LT(1);
        int arguments_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        IToken C = null;
        IToken R = null;
        AS3_exParser.assignmentExpression_return assignmentExpression319 = null;

        AS3_exParser.assignmentExpression_return assignmentExpression320 = null;


        object L_tree=null;
        object C_tree=null;
        object R_tree=null;


        	WrapOptions options=mPrinter.GetMethodCallWrapOptions();
        	bool pushedFormat=false;
        	bool pushedIndent=false;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 137) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2506:2: (L= LPAREN ( assignmentExpression (C= COMMA assignmentExpression )* )? R= RPAREN )
            // AS3_ex.g3:2507:4: L= LPAREN ( assignmentExpression (C= COMMA assignmentExpression )* )? R= RPAREN
            {
            	root_0 = (object)adaptor.GetNilNode();

            	if ( state.backtracking == 0 ) 
            	{
            	  pushedFormat=PushFormatType(options, false);
            	}
            	L=(IToken)Match(input,LPAREN,FOLLOW_LPAREN_in_arguments12722); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{L_tree = (object)adaptor.Create(L);
            		adaptor.AddChild(root_0, L_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)L);InsertWS(mPrinter.GetAdvancedSpacesInsideParens());
            	}
            	// AS3_ex.g3:2509:4: ( assignmentExpression (C= COMMA assignmentExpression )* )?
            	int alt151 = 2;
            	int LA151_0 = input.LA(1);

            	if ( ((LA151_0 >= AS && LA151_0 <= STATIC) || LA151_0 == VOID || LA151_0 == LCURLY || LA151_0 == LPAREN || LA151_0 == LBRACK || LA151_0 == LT || (LA151_0 >= PLUS && LA151_0 <= STAR) || (LA151_0 >= INC && LA151_0 <= DEC) || (LA151_0 >= NOT && LA151_0 <= INV) || (LA151_0 >= XML_AT && LA151_0 <= XML_LS_STD) || (LA151_0 >= SINGLE_QUOTE_LITERAL && LA151_0 <= DOUBLE_QUOTE_LITERAL) || LA151_0 == REGULAR_EXPR_LITERAL || LA151_0 == HEX_NUMBER_LITERAL || LA151_0 == DEC_NUMBER_LITERAL || LA151_0 == IDENTIFIER || (LA151_0 >= XML_COMMENT && LA151_0 <= XML_PI)) )
            	{
            	    alt151 = 1;
            	}
            	switch (alt151) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:2509:6: assignmentExpression (C= COMMA assignmentExpression )*
            	        {
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  pushedIndent=PushLazyParmIndent(pushedIndent, options.IndentStyle);
            	        	}
            	        	PushFollow(FOLLOW_assignmentExpression_in_arguments12734);
            	        	assignmentExpression319 = assignmentExpression();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, assignmentExpression319.Tree);
            	        	// AS3_ex.g3:2510:10: (C= COMMA assignmentExpression )*
            	        	do 
            	        	{
            	        	    int alt150 = 2;
            	        	    int LA150_0 = input.LA(1);

            	        	    if ( (LA150_0 == COMMA) )
            	        	    {
            	        	        alt150 = 1;
            	        	    }


            	        	    switch (alt150) 
            	        		{
            	        			case 1 :
            	        			    // AS3_ex.g3:2511:11: C= COMMA assignmentExpression
            	        			    {
            	        			    	C=(IToken)Match(input,COMMA,FOLLOW_COMMA_in_arguments12762); if (state.failed) return retval;
            	        			    	if ( state.backtracking == 0 )
            	        			    	{C_tree = (object)adaptor.Create(C);
            	        			    		adaptor.AddChild(root_0, C_tree);
            	        			    	}
            	        			    	if ( state.backtracking == 0 ) 
            	        			    	{
            	        			    	  pushedIndent=EmitCommaWithSpacingAndCRs(options, (CommonToken) C, pushedIndent);
            	        			    	}
            	        			    	PushFollow(FOLLOW_assignmentExpression_in_arguments12787);
            	        			    	assignmentExpression320 = assignmentExpression();
            	        			    	state.followingStackPointer--;
            	        			    	if (state.failed) return retval;
            	        			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, assignmentExpression320.Tree);

            	        			    }
            	        			    break;

            	        			default:
            	        			    goto loop150;
            	        	    }
            	        	} while (true);

            	        	loop150:
            	        		;	// Stops C# compiler whining that label 'loop150' has no statements


            	        }
            	        break;

            	}

            	R=(IToken)Match(input,RPAREN,FOLLOW_RPAREN_in_arguments12815); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{R_tree = (object)adaptor.Create(R);
            		adaptor.AddChild(root_0, R_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  InsertWS(mPrinter.GetAdvancedSpacesInsideParens());Emit((CommonToken)R);
            	}
            	if ( state.backtracking == 0 ) 
            	{

            	          if (pushedIndent)
            	     	    	PopIndent();
            	     	    if (pushedFormat)
            	     	    	mPrinter.PopFormatMode();
            	        
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 137, arguments_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "arguments"

    public class suffix_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "suffix"
    // AS3_ex.g3:2528:1: suffix : ( indexSuffix | propertyReferenceSuffix );
    public AS3_exParser.suffix_return suffix() // throws RecognitionException [1]
    {   
        AS3_exParser.suffix_return retval = new AS3_exParser.suffix_return();
        retval.Start = input.LT(1);
        int suffix_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.indexSuffix_return indexSuffix321 = null;

        AS3_exParser.propertyReferenceSuffix_return propertyReferenceSuffix322 = null;



        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 138) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2529:5: ( indexSuffix | propertyReferenceSuffix )
            int alt152 = 2;
            int LA152_0 = input.LA(1);

            if ( (LA152_0 == LBRACK) )
            {
                alt152 = 1;
            }
            else if ( (LA152_0 == DOT) )
            {
                alt152 = 2;
            }
            else 
            {
                if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                NoViableAltException nvae_d152s0 =
                    new NoViableAltException("", 152, 0, input);

                throw nvae_d152s0;
            }
            switch (alt152) 
            {
                case 1 :
                    // AS3_ex.g3:2529:10: indexSuffix
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_indexSuffix_in_suffix12854);
                    	indexSuffix321 = indexSuffix();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, indexSuffix321.Tree);

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:2529:24: propertyReferenceSuffix
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_propertyReferenceSuffix_in_suffix12858);
                    	propertyReferenceSuffix322 = propertyReferenceSuffix();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, propertyReferenceSuffix322.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 138, suffix_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "suffix"

    public class indexSuffix_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "indexSuffix"
    // AS3_ex.g3:2532:1: indexSuffix : L= LBRACK expression R= RBRACK ;
    public AS3_exParser.indexSuffix_return indexSuffix() // throws RecognitionException [1]
    {   
        AS3_exParser.indexSuffix_return retval = new AS3_exParser.indexSuffix_return();
        retval.Start = input.LT(1);
        int indexSuffix_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        IToken R = null;
        AS3_exParser.expression_return expression323 = null;


        object L_tree=null;
        object R_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 139) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2533:5: (L= LBRACK expression R= RBRACK )
            // AS3_ex.g3:2533:10: L= LBRACK expression R= RBRACK
            {
            	root_0 = (object)adaptor.GetNilNode();

            	L=(IToken)Match(input,LBRACK,FOLLOW_LBRACK_in_indexSuffix12899); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{L_tree = (object)adaptor.Create(L);
            		adaptor.AddChild(root_0, L_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)L);InsertWS(mPrinter.GetAdvancedSpacesInsideArrayReferenceBrackets());
            	}
            	PushFollow(FOLLOW_expression_in_indexSuffix12904);
            	expression323 = expression();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, expression323.Tree);
            	R=(IToken)Match(input,RBRACK,FOLLOW_RBRACK_in_indexSuffix12909); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{R_tree = (object)adaptor.Create(R);
            		adaptor.AddChild(root_0, R_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  InsertWS(mPrinter.GetAdvancedSpacesInsideArrayReferenceBrackets());Emit((CommonToken)R);
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 139, indexSuffix_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "indexSuffix"

    public class propertyReferenceSuffix_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "propertyReferenceSuffix"
    // AS3_ex.g3:2536:1: propertyReferenceSuffix : (D= DOT I= IDENTIFIER | D= DOT xmlPropertyIdentifier | D= DOT );
    public AS3_exParser.propertyReferenceSuffix_return propertyReferenceSuffix() // throws RecognitionException [1]
    {   
        AS3_exParser.propertyReferenceSuffix_return retval = new AS3_exParser.propertyReferenceSuffix_return();
        retval.Start = input.LT(1);
        int propertyReferenceSuffix_StartIndex = input.Index();
        object root_0 = null;

        IToken D = null;
        IToken I = null;
        AS3_exParser.xmlPropertyIdentifier_return xmlPropertyIdentifier324 = null;


        object D_tree=null;
        object I_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 140) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2537:5: (D= DOT I= IDENTIFIER | D= DOT xmlPropertyIdentifier | D= DOT )
            int alt153 = 3;
            int LA153_0 = input.LA(1);

            if ( (LA153_0 == DOT) )
            {
                switch ( input.LA(2) ) 
                {
                case AS:
                case BREAK:
                case CASE:
                case CATCH:
                case CLASS:
                case CONST:
                case CONTINUE:
                case DEFAULT:
                case DELETE:
                case DO:
                case ELSE:
                case EXTENDS:
                case FALSE:
                case FINALLY:
                case FOR:
                case FUNCTION:
                case IF:
                case IMPLEMENTS:
                case IMPORT:
                case IN:
                case INSTANCEOF:
                case INTERFACE:
                case INTERNAL:
                case IS:
                case NATIVE:
                case NEW:
                case NULL:
                case PACKAGE:
                case PRIVATE:
                case PROTECTED:
                case PUBLIC:
                case RETURN:
                case SUPER:
                case SWITCH:
                case THIS:
                case THROW:
                case TO:
                case TRUE:
                case TRY:
                case TYPEOF:
                case USE:
                case VAR:
                case VOID:
                case WHILE:
                case WITH:
                case EACH:
                case GET:
                case SET:
                case NAMESPACE:
                case INCLUDE:
                case DYNAMIC:
                case FINAL:
                case OVERRIDE:
                case STATIC:
                case STAR:
                case XML_AT:
                	{
                    alt153 = 2;
                    }
                    break;
                case IDENTIFIER:
                	{
                    int LA153_3 = input.LA(3);

                    if ( (LA153_3 == DOT || LA153_3 == SUB || LA153_3 == COLON || LA153_3 == XML_NS_OP) )
                    {
                        alt153 = 2;
                    }
                    else if ( (LA153_3 == EOF) )
                    {
                        alt153 = 1;
                    }
                    else 
                    {
                        if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                        NoViableAltException nvae_d153s3 =
                            new NoViableAltException("", 153, 3, input);

                        throw nvae_d153s3;
                    }
                    }
                    break;
                case EOF:
                	{
                    alt153 = 3;
                    }
                    break;
                	default:
                	    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                	    NoViableAltException nvae_d153s1 =
                	        new NoViableAltException("", 153, 1, input);

                	    throw nvae_d153s1;
                }

            }
            else 
            {
                if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                NoViableAltException nvae_d153s0 =
                    new NoViableAltException("", 153, 0, input);

                throw nvae_d153s0;
            }
            switch (alt153) 
            {
                case 1 :
                    // AS3_ex.g3:2537:10: D= DOT I= IDENTIFIER
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	D=(IToken)Match(input,DOT,FOLLOW_DOT_in_propertyReferenceSuffix12937); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{D_tree = (object)adaptor.Create(D);
                    		adaptor.AddChild(root_0, D_tree);
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  Emit((CommonToken)D);
                    	}
                    	I=(IToken)Match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_propertyReferenceSuffix12944); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{I_tree = (object)adaptor.Create(I);
                    		adaptor.AddChild(root_0, I_tree);
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  Emit((CommonToken)I);
                    	}

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:2538:10: D= DOT xmlPropertyIdentifier
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	D=(IToken)Match(input,DOT,FOLLOW_DOT_in_propertyReferenceSuffix12959); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{D_tree = (object)adaptor.Create(D);
                    		adaptor.AddChild(root_0, D_tree);
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  Emit((CommonToken)D);
                    	}
                    	PushFollow(FOLLOW_xmlPropertyIdentifier_in_propertyReferenceSuffix12964);
                    	xmlPropertyIdentifier324 = xmlPropertyIdentifier();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlPropertyIdentifier324.Tree);

                    }
                    break;
                case 3 :
                    // AS3_ex.g3:2539:10: D= DOT
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	D=(IToken)Match(input,DOT,FOLLOW_DOT_in_propertyReferenceSuffix12977); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{D_tree = (object)adaptor.Create(D);
                    		adaptor.AddChild(root_0, D_tree);
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  Emit((CommonToken)D);
                    	}

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 140, propertyReferenceSuffix_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "propertyReferenceSuffix"

    public class primaryExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "primaryExpression"
    // AS3_ex.g3:2543:1: primaryExpression : primaryExpressionHelper ;
    public AS3_exParser.primaryExpression_return primaryExpression() // throws RecognitionException [1]
    {   
        AS3_exParser.primaryExpression_return retval = new AS3_exParser.primaryExpression_return();
        retval.Start = input.LT(1);
        int primaryExpression_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.primaryExpressionHelper_return primaryExpressionHelper325 = null;



        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 141) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2544:5: ( primaryExpressionHelper )
            // AS3_ex.g3:2544:10: primaryExpressionHelper
            {
            	root_0 = (object)adaptor.GetNilNode();

            	PushFollow(FOLLOW_primaryExpressionHelper_in_primaryExpression13010);
            	primaryExpressionHelper325 = primaryExpressionHelper();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, primaryExpressionHelper325.Tree);

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 141, primaryExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "primaryExpression"

    public class primaryExpressionHelper_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "primaryExpressionHelper"
    // AS3_ex.g3:2548:1: primaryExpressionHelper : (T= THIS | S= SUPER | literal | arrayLiteral | objectLiteral | identifierLiteral | xmlPrimaryExpression | parExpression | conditionalCompilerOption | l= LT type g= GT ( arrayLiteral )? );
    public AS3_exParser.primaryExpressionHelper_return primaryExpressionHelper() // throws RecognitionException [1]
    {   
        AS3_exParser.primaryExpressionHelper_return retval = new AS3_exParser.primaryExpressionHelper_return();
        retval.Start = input.LT(1);
        int primaryExpressionHelper_StartIndex = input.Index();
        object root_0 = null;

        IToken T = null;
        IToken S = null;
        IToken l = null;
        IToken g = null;
        AS3_exParser.literal_return literal326 = null;

        AS3_exParser.arrayLiteral_return arrayLiteral327 = null;

        AS3_exParser.objectLiteral_return objectLiteral328 = null;

        AS3_exParser.identifierLiteral_return identifierLiteral329 = null;

        AS3_exParser.xmlPrimaryExpression_return xmlPrimaryExpression330 = null;

        AS3_exParser.parExpression_return parExpression331 = null;

        AS3_exParser.conditionalCompilerOption_return conditionalCompilerOption332 = null;

        AS3_exParser.type_return type333 = null;

        AS3_exParser.arrayLiteral_return arrayLiteral334 = null;


        object T_tree=null;
        object S_tree=null;
        object l_tree=null;
        object g_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 142) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2549:5: (T= THIS | S= SUPER | literal | arrayLiteral | objectLiteral | identifierLiteral | xmlPrimaryExpression | parExpression | conditionalCompilerOption | l= LT type g= GT ( arrayLiteral )? )
            int alt155 = 10;
            alt155 = dfa155.Predict(input);
            switch (alt155) 
            {
                case 1 :
                    // AS3_ex.g3:2549:9: T= THIS
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	T=(IToken)Match(input,THIS,FOLLOW_THIS_in_primaryExpressionHelper13037); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{T_tree = (object)adaptor.Create(T);
                    		adaptor.AddChild(root_0, T_tree);
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  Emit((CommonToken)T);
                    	}

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:2550:9: S= SUPER
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	S=(IToken)Match(input,SUPER,FOLLOW_SUPER_in_primaryExpressionHelper13051); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{S_tree = (object)adaptor.Create(S);
                    		adaptor.AddChild(root_0, S_tree);
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  Emit((CommonToken)S);
                    	}

                    }
                    break;
                case 3 :
                    // AS3_ex.g3:2551:9: literal
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_literal_in_primaryExpressionHelper13063);
                    	literal326 = literal();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, literal326.Tree);

                    }
                    break;
                case 4 :
                    // AS3_ex.g3:2552:9: arrayLiteral
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_arrayLiteral_in_primaryExpressionHelper13075);
                    	arrayLiteral327 = arrayLiteral();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, arrayLiteral327.Tree);

                    }
                    break;
                case 5 :
                    // AS3_ex.g3:2553:9: objectLiteral
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_objectLiteral_in_primaryExpressionHelper13086);
                    	objectLiteral328 = objectLiteral();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, objectLiteral328.Tree);

                    }
                    break;
                case 6 :
                    // AS3_ex.g3:2554:9: identifierLiteral
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_identifierLiteral_in_primaryExpressionHelper13098);
                    	identifierLiteral329 = identifierLiteral();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, identifierLiteral329.Tree);

                    }
                    break;
                case 7 :
                    // AS3_ex.g3:2555:9: xmlPrimaryExpression
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_xmlPrimaryExpression_in_primaryExpressionHelper13109);
                    	xmlPrimaryExpression330 = xmlPrimaryExpression();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlPrimaryExpression330.Tree);

                    }
                    break;
                case 8 :
                    // AS3_ex.g3:2556:9: parExpression
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_parExpression_in_primaryExpressionHelper13119);
                    	parExpression331 = parExpression();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, parExpression331.Tree);

                    }
                    break;
                case 9 :
                    // AS3_ex.g3:2557:9: conditionalCompilerOption
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_conditionalCompilerOption_in_primaryExpressionHelper13130);
                    	conditionalCompilerOption332 = conditionalCompilerOption();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, conditionalCompilerOption332.Tree);

                    }
                    break;
                case 10 :
                    // AS3_ex.g3:2558:6: l= LT type g= GT ( arrayLiteral )?
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	l=(IToken)Match(input,LT,FOLLOW_LT_in_primaryExpressionHelper13139); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{l_tree = (object)adaptor.Create(l);
                    		adaptor.AddChild(root_0, l_tree);
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  Emit((CommonToken)l);
                    	}
                    	PushFollow(FOLLOW_type_in_primaryExpressionHelper13143);
                    	type333 = type();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, type333.Tree);
                    	g=(IToken)Match(input,GT,FOLLOW_GT_in_primaryExpressionHelper13147); if (state.failed) return retval;
                    	if ( state.backtracking == 0 )
                    	{g_tree = (object)adaptor.Create(g);
                    		adaptor.AddChild(root_0, g_tree);
                    	}
                    	if ( state.backtracking == 0 ) 
                    	{
                    	  Emit((CommonToken)g);
                    	}
                    	// AS3_ex.g3:2558:71: ( arrayLiteral )?
                    	int alt154 = 2;
                    	alt154 = dfa154.Predict(input);
                    	switch (alt154) 
                    	{
                    	    case 1 :
                    	        // AS3_ex.g3:2558:72: arrayLiteral
                    	        {
                    	        	PushFollow(FOLLOW_arrayLiteral_in_primaryExpressionHelper13152);
                    	        	arrayLiteral334 = arrayLiteral();
                    	        	state.followingStackPointer--;
                    	        	if (state.failed) return retval;
                    	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, arrayLiteral334.Tree);

                    	        }
                    	        break;

                    	}


                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 142, primaryExpressionHelper_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "primaryExpressionHelper"

    public class objectLiteral_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "objectLiteral"
    // AS3_ex.g3:2562:1: objectLiteral : L= LCURLY ( propertyNameAndValueList )? R= RCURLY ;
    public AS3_exParser.objectLiteral_return objectLiteral() // throws RecognitionException [1]
    {   
        AS3_exParser.objectLiteral_return retval = new AS3_exParser.objectLiteral_return();
        retval.Start = input.LT(1);
        int objectLiteral_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        IToken R = null;
        AS3_exParser.propertyNameAndValueList_return propertyNameAndValueList335 = null;


        object L_tree=null;
        object R_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 143) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2563:5: (L= LCURLY ( propertyNameAndValueList )? R= RCURLY )
            // AS3_ex.g3:2563:9: L= LCURLY ( propertyNameAndValueList )? R= RCURLY
            {
            	root_0 = (object)adaptor.GetNilNode();

            	L=(IToken)Match(input,LCURLY,FOLLOW_LCURLY_in_objectLiteral13177); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{L_tree = (object)adaptor.Create(L);
            		adaptor.AddChild(root_0, L_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)L);InsertWS(mPrinter.GetAdvancedSpacesInsideObjectBraces());PushIndent(true);
            	}
            	// AS3_ex.g3:2563:117: ( propertyNameAndValueList )?
            	int alt156 = 2;
            	int LA156_0 = input.LA(1);

            	if ( (LA156_0 == NATIVE || LA156_0 == TO || (LA156_0 >= EACH && LA156_0 <= NAMESPACE) || (LA156_0 >= DYNAMIC && LA156_0 <= STATIC) || (LA156_0 >= SINGLE_QUOTE_LITERAL && LA156_0 <= DOUBLE_QUOTE_LITERAL) || LA156_0 == HEX_NUMBER_LITERAL || LA156_0 == DEC_NUMBER_LITERAL || LA156_0 == IDENTIFIER) )
            	{
            	    alt156 = 1;
            	}
            	switch (alt156) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:0:0: propertyNameAndValueList
            	        {
            	        	PushFollow(FOLLOW_propertyNameAndValueList_in_objectLiteral13181);
            	        	propertyNameAndValueList335 = propertyNameAndValueList();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, propertyNameAndValueList335.Tree);

            	        }
            	        break;

            	}

            	R=(IToken)Match(input,RCURLY,FOLLOW_RCURLY_in_objectLiteral13186); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{R_tree = (object)adaptor.Create(R);
            		adaptor.AddChild(root_0, R_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  PopIndent();InsertWS(mPrinter.GetAdvancedSpacesInsideObjectBraces());Emit((CommonToken)R);
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 143, objectLiteral_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "objectLiteral"

    public class propertyNameAndValueList_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "propertyNameAndValueList"
    // AS3_ex.g3:2566:1: propertyNameAndValueList : propertyNameAndValue (C= COMMA propertyNameAndValue )* ;
    public AS3_exParser.propertyNameAndValueList_return propertyNameAndValueList() // throws RecognitionException [1]
    {   
        AS3_exParser.propertyNameAndValueList_return retval = new AS3_exParser.propertyNameAndValueList_return();
        retval.Start = input.LT(1);
        int propertyNameAndValueList_StartIndex = input.Index();
        object root_0 = null;

        IToken C = null;
        AS3_exParser.propertyNameAndValue_return propertyNameAndValue336 = null;

        AS3_exParser.propertyNameAndValue_return propertyNameAndValue337 = null;


        object C_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 144) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2567:5: ( propertyNameAndValue (C= COMMA propertyNameAndValue )* )
            // AS3_ex.g3:2567:9: propertyNameAndValue (C= COMMA propertyNameAndValue )*
            {
            	root_0 = (object)adaptor.GetNilNode();

            	PushFollow(FOLLOW_propertyNameAndValue_in_propertyNameAndValueList13208);
            	propertyNameAndValue336 = propertyNameAndValue();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, propertyNameAndValue336.Tree);
            	// AS3_ex.g3:2567:30: (C= COMMA propertyNameAndValue )*
            	do 
            	{
            	    int alt157 = 2;
            	    int LA157_0 = input.LA(1);

            	    if ( (LA157_0 == COMMA) )
            	    {
            	        alt157 = 1;
            	    }


            	    switch (alt157) 
            		{
            			case 1 :
            			    // AS3_ex.g3:2567:31: C= COMMA propertyNameAndValue
            			    {
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  InsertWS(mPrinter.GetSpacesBeforeComma());
            			    	}
            			    	C=(IToken)Match(input,COMMA,FOLLOW_COMMA_in_propertyNameAndValueList13214); if (state.failed) return retval;
            			    	if ( state.backtracking == 0 )
            			    	{C_tree = (object)adaptor.Create(C);
            			    		adaptor.AddChild(root_0, C_tree);
            			    	}
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  Emit((CommonToken)C);
            			    	}
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  InsertWS(mPrinter.GetSpacesAfterComma());
            			    	}
            			    	PushFollow(FOLLOW_propertyNameAndValue_in_propertyNameAndValueList13219);
            			    	propertyNameAndValue337 = propertyNameAndValue();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, propertyNameAndValue337.Tree);

            			    }
            			    break;

            			default:
            			    goto loop157;
            	    }
            	} while (true);

            	loop157:
            		;	// Stops C# compiler whining that label 'loop157' has no statements


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 144, propertyNameAndValueList_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "propertyNameAndValueList"

    public class propertyNameAndValue_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "propertyNameAndValue"
    // AS3_ex.g3:2570:1: propertyNameAndValue : propertyName C= COLON assignmentExpression ;
    public AS3_exParser.propertyNameAndValue_return propertyNameAndValue() // throws RecognitionException [1]
    {   
        AS3_exParser.propertyNameAndValue_return retval = new AS3_exParser.propertyNameAndValue_return();
        retval.Start = input.LT(1);
        int propertyNameAndValue_StartIndex = input.Index();
        object root_0 = null;

        IToken C = null;
        AS3_exParser.propertyName_return propertyName338 = null;

        AS3_exParser.assignmentExpression_return assignmentExpression339 = null;


        object C_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 145) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2571:5: ( propertyName C= COLON assignmentExpression )
            // AS3_ex.g3:2571:9: propertyName C= COLON assignmentExpression
            {
            	root_0 = (object)adaptor.GetNilNode();

            	PushFollow(FOLLOW_propertyName_in_propertyNameAndValue13240);
            	propertyName338 = propertyName();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, propertyName338.Tree);
            	C=(IToken)Match(input,COLON,FOLLOW_COLON_in_propertyNameAndValue13244); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{C_tree = (object)adaptor.Create(C);
            		adaptor.AddChild(root_0, C_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{

            	      		Emit((CommonToken)C);
            	      		InsertWS(mPrinter.GetSpacesAfterLabel());
            	      		
            	}
            	PushFollow(FOLLOW_assignmentExpression_in_propertyNameAndValue13262);
            	assignmentExpression339 = assignmentExpression();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, assignmentExpression339.Tree);

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 145, propertyNameAndValue_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "propertyNameAndValue"

    public class propertyName_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "propertyName"
    // AS3_ex.g3:2579:1: propertyName : ( identifierLiteral | stringLiteral | numericLiteral );
    public AS3_exParser.propertyName_return propertyName() // throws RecognitionException [1]
    {   
        AS3_exParser.propertyName_return retval = new AS3_exParser.propertyName_return();
        retval.Start = input.LT(1);
        int propertyName_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.identifierLiteral_return identifierLiteral340 = null;

        AS3_exParser.stringLiteral_return stringLiteral341 = null;

        AS3_exParser.numericLiteral_return numericLiteral342 = null;



        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 146) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2580:5: ( identifierLiteral | stringLiteral | numericLiteral )
            int alt158 = 3;
            switch ( input.LA(1) ) 
            {
            case NATIVE:
            case TO:
            case EACH:
            case GET:
            case SET:
            case NAMESPACE:
            case DYNAMIC:
            case FINAL:
            case OVERRIDE:
            case STATIC:
            case IDENTIFIER:
            	{
                alt158 = 1;
                }
                break;
            case SINGLE_QUOTE_LITERAL:
            case DOUBLE_QUOTE_LITERAL:
            	{
                alt158 = 2;
                }
                break;
            case HEX_NUMBER_LITERAL:
            case DEC_NUMBER_LITERAL:
            	{
                alt158 = 3;
                }
                break;
            	default:
            	    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
            	    NoViableAltException nvae_d158s0 =
            	        new NoViableAltException("", 158, 0, input);

            	    throw nvae_d158s0;
            }

            switch (alt158) 
            {
                case 1 :
                    // AS3_ex.g3:2580:9: identifierLiteral
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_identifierLiteral_in_propertyName13281);
                    	identifierLiteral340 = identifierLiteral();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, identifierLiteral340.Tree);

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:2581:9: stringLiteral
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_stringLiteral_in_propertyName13292);
                    	stringLiteral341 = stringLiteral();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, stringLiteral341.Tree);

                    }
                    break;
                case 3 :
                    // AS3_ex.g3:2582:9: numericLiteral
                    {
                    	root_0 = (object)adaptor.GetNilNode();

                    	PushFollow(FOLLOW_numericLiteral_in_propertyName13303);
                    	numericLiteral342 = numericLiteral();
                    	state.followingStackPointer--;
                    	if (state.failed) return retval;
                    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, numericLiteral342.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 146, propertyName_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "propertyName"

    public class arrayLiteral_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "arrayLiteral"
    // AS3_ex.g3:2586:1: arrayLiteral : L= LBRACK ( elementList )? R= RBRACK ;
    public AS3_exParser.arrayLiteral_return arrayLiteral() // throws RecognitionException [1]
    {   
        AS3_exParser.arrayLiteral_return retval = new AS3_exParser.arrayLiteral_return();
        retval.Start = input.LT(1);
        int arrayLiteral_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        IToken R = null;
        AS3_exParser.elementList_return elementList343 = null;


        object L_tree=null;
        object R_tree=null;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 147) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2587:5: (L= LBRACK ( elementList )? R= RBRACK )
            // AS3_ex.g3:2587:9: L= LBRACK ( elementList )? R= RBRACK
            {
            	root_0 = (object)adaptor.GetNilNode();

            	L=(IToken)Match(input,LBRACK,FOLLOW_LBRACK_in_arrayLiteral13326); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{L_tree = (object)adaptor.Create(L);
            		adaptor.AddChild(root_0, L_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  Emit((CommonToken)L);InsertWS(mPrinter.GetAdvancedSpacesInsideArrayDeclBrackets());
            	}
            	// AS3_ex.g3:2587:105: ( elementList )?
            	int alt159 = 2;
            	int LA159_0 = input.LA(1);

            	if ( ((LA159_0 >= AS && LA159_0 <= STATIC) || LA159_0 == VOID || LA159_0 == LCURLY || LA159_0 == LPAREN || LA159_0 == LBRACK || LA159_0 == LT || (LA159_0 >= PLUS && LA159_0 <= STAR) || (LA159_0 >= INC && LA159_0 <= DEC) || (LA159_0 >= NOT && LA159_0 <= INV) || (LA159_0 >= XML_AT && LA159_0 <= XML_LS_STD) || (LA159_0 >= SINGLE_QUOTE_LITERAL && LA159_0 <= DOUBLE_QUOTE_LITERAL) || LA159_0 == REGULAR_EXPR_LITERAL || LA159_0 == HEX_NUMBER_LITERAL || LA159_0 == DEC_NUMBER_LITERAL || LA159_0 == IDENTIFIER || (LA159_0 >= XML_COMMENT && LA159_0 <= XML_PI)) )
            	{
            	    alt159 = 1;
            	}
            	switch (alt159) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:0:0: elementList
            	        {
            	        	PushFollow(FOLLOW_elementList_in_arrayLiteral13330);
            	        	elementList343 = elementList();
            	        	state.followingStackPointer--;
            	        	if (state.failed) return retval;
            	        	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, elementList343.Tree);

            	        }
            	        break;

            	}

            	R=(IToken)Match(input,RBRACK,FOLLOW_RBRACK_in_arrayLiteral13335); if (state.failed) return retval;
            	if ( state.backtracking == 0 )
            	{R_tree = (object)adaptor.Create(R);
            		adaptor.AddChild(root_0, R_tree);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  InsertWS(mPrinter.GetAdvancedSpacesInsideArrayDeclBrackets());Emit((CommonToken)R);
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 147, arrayLiteral_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "arrayLiteral"

    public class elementList_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
        	get { return tree; }
        	set { tree = (object) value; }
        }
    };

    // $ANTLR start "elementList"
    // AS3_ex.g3:2590:1: elementList : assignmentExpression (C= COMMA assignmentExpression )* (C= COMMA )? ;
    public AS3_exParser.elementList_return elementList() // throws RecognitionException [1]
    {   
        AS3_exParser.elementList_return retval = new AS3_exParser.elementList_return();
        retval.Start = input.LT(1);
        int elementList_StartIndex = input.Index();
        object root_0 = null;

        IToken C = null;
        AS3_exParser.assignmentExpression_return assignmentExpression344 = null;

        AS3_exParser.assignmentExpression_return assignmentExpression345 = null;


        object C_tree=null;


        	WrapOptions options=mPrinter.GetArrayInitWrapOptions();
        	bool pushedFormat=false;
        	bool pushedIndent=false;

        try 
    	{
    	    if ( (state.backtracking > 0) && AlreadyParsedRule(input, 148) ) 
    	    {
    	    	return retval; 
    	    }
            // AS3_ex.g3:2597:5: ( assignmentExpression (C= COMMA assignmentExpression )* (C= COMMA )? )
            // AS3_ex.g3:2598:6: assignmentExpression (C= COMMA assignmentExpression )* (C= COMMA )?
            {
            	root_0 = (object)adaptor.GetNilNode();

            	if ( state.backtracking == 0 ) 
            	{
            	  pushedFormat=PushFormatType(options, false);
            	}
            	if ( state.backtracking == 0 ) 
            	{
            	  pushedIndent=PushLazyParmIndent(pushedIndent, options.IndentStyle);
            	}
            	PushFollow(FOLLOW_assignmentExpression_in_elementList13381);
            	assignmentExpression344 = assignmentExpression();
            	state.followingStackPointer--;
            	if (state.failed) return retval;
            	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, assignmentExpression344.Tree);
            	// AS3_ex.g3:2601:6: (C= COMMA assignmentExpression )*
            	do 
            	{
            	    int alt160 = 2;
            	    int LA160_0 = input.LA(1);

            	    if ( (LA160_0 == COMMA) )
            	    {
            	        int LA160_1 = input.LA(2);

            	        if ( ((LA160_1 >= AS && LA160_1 <= STATIC) || LA160_1 == LCURLY || LA160_1 == LPAREN || LA160_1 == LBRACK || LA160_1 == LT || (LA160_1 >= PLUS && LA160_1 <= STAR) || (LA160_1 >= INC && LA160_1 <= DEC) || (LA160_1 >= NOT && LA160_1 <= INV) || (LA160_1 >= XML_AT && LA160_1 <= XML_LS_STD) || (LA160_1 >= SINGLE_QUOTE_LITERAL && LA160_1 <= DOUBLE_QUOTE_LITERAL) || LA160_1 == REGULAR_EXPR_LITERAL || LA160_1 == HEX_NUMBER_LITERAL || LA160_1 == DEC_NUMBER_LITERAL || LA160_1 == IDENTIFIER || (LA160_1 >= XML_COMMENT && LA160_1 <= XML_PI)) )
            	        {
            	            alt160 = 1;
            	        }


            	    }


            	    switch (alt160) 
            		{
            			case 1 :
            			    // AS3_ex.g3:2602:7: C= COMMA assignmentExpression
            			    {
            			    	C=(IToken)Match(input,COMMA,FOLLOW_COMMA_in_elementList13399); if (state.failed) return retval;
            			    	if ( state.backtracking == 0 )
            			    	{C_tree = (object)adaptor.Create(C);
            			    		adaptor.AddChild(root_0, C_tree);
            			    	}
            			    	if ( state.backtracking == 0 ) 
            			    	{
            			    	  pushedIndent=EmitCommaWithSpacingAndCRs(options,(CommonToken) C, pushedIndent);
            			    	}
            			    	PushFollow(FOLLOW_assignmentExpression_in_elementList13416);
            			    	assignmentExpression345 = assignmentExpression();
            			    	state.followingStackPointer--;
            			    	if (state.failed) return retval;
            			    	if ( state.backtracking == 0 ) adaptor.AddChild(root_0, assignmentExpression345.Tree);

            			    }
            			    break;

            			default:
            			    goto loop160;
            	    }
            	} while (true);

            	loop160:
            		;	// Stops C# compiler whining that label 'loop160' has no statements

            	// AS3_ex.g3:2605:9: (C= COMMA )?
            	int alt161 = 2;
            	int LA161_0 = input.LA(1);

            	if ( (LA161_0 == COMMA) )
            	{
            	    alt161 = 1;
            	}
            	switch (alt161) 
            	{
            	    case 1 :
            	        // AS3_ex.g3:2605:10: C= COMMA
            	        {
            	        	C=(IToken)Match(input,COMMA,FOLLOW_COMMA_in_elementList13429); if (state.failed) return retval;
            	        	if ( state.backtracking == 0 )
            	        	{C_tree = (object)adaptor.Create(C);
            	        		adaptor.AddChild(root_0, C_tree);
            	        	}
            	        	if ( state.backtracking == 0 ) 
            	        	{
            	        	  Emit((CommonToken)C);
            	        	}

            	        }
            	        break;

            	}

            	if ( state.backtracking == 0 ) 
            	{

            	  			if (pushedIndent)
            	  				PopIndent();
            	      	    if (pushedFormat)
            	      	    	mPrinter.PopFormatMode();
            	  		
            	}

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {	retval.Tree = (object)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
    	// Conversion of the second argument necessary, but harmless
    	retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
    	{
            if ( state.backtracking > 0 ) 
            {
            	Memoize(input, 148, elementList_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "elementList"

    // $ANTLR start "synpred9_AS3_ex"
    public void synpred9_AS3_ex_fragment() {
        IToken s = null;
        IToken d = null;
        IToken c = null;
        IToken I2 = null;

        // AS3_ex.g3:1252:95: ({...}? => (s= SUB | d= DOT | c= COLON ) {...}? => (I2= IDENTIFIER | allKeywords ) )
        // AS3_ex.g3:1252:95: {...}? => (s= SUB | d= DOT | c= COLON ) {...}? => (I2= IDENTIFIER | allKeywords )
        {
        	if ( !((!PromoteWhitespace())) ) 
        	{
        	    if ( state.backtracking > 0 ) {state.failed = true; return ;}
        	    throw new FailedPredicateException(input, "synpred9_AS3_ex", "!PromoteWhitespace()");
        	}
        	// AS3_ex.g3:1252:121: (s= SUB | d= DOT | c= COLON )
        	int alt162 = 3;
        	switch ( input.LA(1) ) 
        	{
        	case SUB:
        		{
        	    alt162 = 1;
        	    }
        	    break;
        	case DOT:
        		{
        	    alt162 = 2;
        	    }
        	    break;
        	case COLON:
        		{
        	    alt162 = 3;
        	    }
        	    break;
        		default:
        		    if ( state.backtracking > 0 ) {state.failed = true; return ;}
        		    NoViableAltException nvae_d162s0 =
        		        new NoViableAltException("", 162, 0, input);

        		    throw nvae_d162s0;
        	}

        	switch (alt162) 
        	{
        	    case 1 :
        	        // AS3_ex.g3:1252:122: s= SUB
        	        {
        	        	s=(IToken)Match(input,SUB,FOLLOW_SUB_in_synpred9_AS3_ex3820); if (state.failed) return ;

        	        }
        	        break;
        	    case 2 :
        	        // AS3_ex.g3:1252:155: d= DOT
        	        {
        	        	d=(IToken)Match(input,DOT,FOLLOW_DOT_in_synpred9_AS3_ex3828); if (state.failed) return ;

        	        }
        	        break;
        	    case 3 :
        	        // AS3_ex.g3:1252:188: c= COLON
        	        {
        	        	c=(IToken)Match(input,COLON,FOLLOW_COLON_in_synpred9_AS3_ex3836); if (state.failed) return ;

        	        }
        	        break;

        	}

        	if ( !((!PromoteWhitespace())) ) 
        	{
        	    if ( state.backtracking > 0 ) {state.failed = true; return ;}
        	    throw new FailedPredicateException(input, "synpred9_AS3_ex", "!PromoteWhitespace()");
        	}
        	// AS3_ex.g3:1252:248: (I2= IDENTIFIER | allKeywords )
        	int alt163 = 2;
        	int LA163_0 = input.LA(1);

        	if ( (LA163_0 == IDENTIFIER) )
        	{
        	    alt163 = 1;
        	}
        	else if ( ((LA163_0 >= AS && LA163_0 <= STATIC)) )
        	{
        	    alt163 = 2;
        	}
        	else 
        	{
        	    if ( state.backtracking > 0 ) {state.failed = true; return ;}
        	    NoViableAltException nvae_d163s0 =
        	        new NoViableAltException("", 163, 0, input);

        	    throw nvae_d163s0;
        	}
        	switch (alt163) 
        	{
        	    case 1 :
        	        // AS3_ex.g3:1252:249: I2= IDENTIFIER
        	        {
        	        	I2=(IToken)Match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_synpred9_AS3_ex3847); if (state.failed) return ;

        	        }
        	        break;
        	    case 2 :
        	        // AS3_ex.g3:1252:291: allKeywords
        	        {
        	        	PushFollow(FOLLOW_allKeywords_in_synpred9_AS3_ex3853);
        	        	allKeywords();
        	        	state.followingStackPointer--;
        	        	if (state.failed) return ;

        	        }
        	        break;

        	}


        }
    }
    // $ANTLR end "synpred9_AS3_ex"

    // $ANTLR start "synpred68_AS3_ex"
    public void synpred68_AS3_ex_fragment() {
        IToken x = null;

        // AS3_ex.g3:1350:6: (x= XML_TEXT )
        // AS3_ex.g3:1350:6: x= XML_TEXT
        {
        	x=(IToken)Match(input,XML_TEXT,FOLLOW_XML_TEXT_in_synpred68_AS3_ex4895); if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred68_AS3_ex"

    // $ANTLR start "synpred69_AS3_ex"
    public void synpred69_AS3_ex_fragment() {
        // AS3_ex.g3:1350:44: ( xmlTextElement )
        // AS3_ex.g3:1350:44: xmlTextElement
        {
        	PushFollow(FOLLOW_xmlTextElement_in_synpred69_AS3_ex4901);
        	xmlTextElement();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred69_AS3_ex"

    // $ANTLR start "synpred73_AS3_ex"
    public void synpred73_AS3_ex_fragment() {
        // AS3_ex.g3:1373:11: ( xmlQualifiedIdentifier )
        // AS3_ex.g3:1373:11: xmlQualifiedIdentifier
        {
        	PushFollow(FOLLOW_xmlQualifiedIdentifier_in_synpred73_AS3_ex5128);
        	xmlQualifiedIdentifier();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred73_AS3_ex"

    // $ANTLR start "synpred74_AS3_ex"
    public void synpred74_AS3_ex_fragment() {
        // AS3_ex.g3:1380:12: ( xmlQualifiedIdentifier )
        // AS3_ex.g3:1380:12: xmlQualifiedIdentifier
        {
        	PushFollow(FOLLOW_xmlQualifiedIdentifier_in_synpred74_AS3_ex5233);
        	xmlQualifiedIdentifier();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred74_AS3_ex"

    // $ANTLR start "synpred75_AS3_ex"
    public void synpred75_AS3_ex_fragment() {
        // AS3_ex.g3:1381:14: ( xmlPropertySelector )
        // AS3_ex.g3:1381:14: xmlPropertySelector
        {
        	PushFollow(FOLLOW_xmlPropertySelector_in_synpred75_AS3_ex5248);
        	xmlPropertySelector();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred75_AS3_ex"

    // $ANTLR start "synpred97_AS3_ex"
    public void synpred97_AS3_ex_fragment() {
        // AS3_ex.g3:1529:7: ( propertyDeclaration )
        // AS3_ex.g3:1529:7: propertyDeclaration
        {
        	PushFollow(FOLLOW_propertyDeclaration_in_synpred97_AS3_ex6067);
        	propertyDeclaration();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred97_AS3_ex"

    // $ANTLR start "synpred98_AS3_ex"
    public void synpred98_AS3_ex_fragment() {
        // AS3_ex.g3:1529:29: ( functionDeclaration )
        // AS3_ex.g3:1529:29: functionDeclaration
        {
        	PushFollow(FOLLOW_functionDeclaration_in_synpred98_AS3_ex6071);
        	functionDeclaration();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred98_AS3_ex"

    // $ANTLR start "synpred99_AS3_ex"
    public void synpred99_AS3_ex_fragment() {
        // AS3_ex.g3:1529:51: ( statement )
        // AS3_ex.g3:1529:51: statement
        {
        	PushFollow(FOLLOW_statement_in_synpred99_AS3_ex6075);
        	statement();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred99_AS3_ex"

    // $ANTLR start "synpred100_AS3_ex"
    public void synpred100_AS3_ex_fragment() {
        // AS3_ex.g3:1529:63: ( directive )
        // AS3_ex.g3:1529:63: directive
        {
        	PushFollow(FOLLOW_directive_in_synpred100_AS3_ex6079);
        	directive();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred100_AS3_ex"

    // $ANTLR start "synpred101_AS3_ex"
    public void synpred101_AS3_ex_fragment() {
        // AS3_ex.g3:1529:75: ( interfaceFunctionDeclaration )
        // AS3_ex.g3:1529:75: interfaceFunctionDeclaration
        {
        	PushFollow(FOLLOW_interfaceFunctionDeclaration_in_synpred101_AS3_ex6083);
        	interfaceFunctionDeclaration();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred101_AS3_ex"

    // $ANTLR start "synpred103_AS3_ex"
    public void synpred103_AS3_ex_fragment() {
        // AS3_ex.g3:1533:9: ( classOrInterfaceDecl )
        // AS3_ex.g3:1533:9: classOrInterfaceDecl
        {
        	PushFollow(FOLLOW_classOrInterfaceDecl_in_synpred103_AS3_ex6109);
        	classOrInterfaceDecl();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred103_AS3_ex"

    // $ANTLR start "synpred104_AS3_ex"
    public void synpred104_AS3_ex_fragment() {
        // AS3_ex.g3:1533:32: ( propertyDeclaration )
        // AS3_ex.g3:1533:32: propertyDeclaration
        {
        	PushFollow(FOLLOW_propertyDeclaration_in_synpred104_AS3_ex6113);
        	propertyDeclaration();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred104_AS3_ex"

    // $ANTLR start "synpred105_AS3_ex"
    public void synpred105_AS3_ex_fragment() {
        // AS3_ex.g3:1533:54: ( functionDeclaration )
        // AS3_ex.g3:1533:54: functionDeclaration
        {
        	PushFollow(FOLLOW_functionDeclaration_in_synpred105_AS3_ex6117);
        	functionDeclaration();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred105_AS3_ex"

    // $ANTLR start "synpred106_AS3_ex"
    public void synpred106_AS3_ex_fragment() {
        // AS3_ex.g3:1533:76: ( interfaceFunctionDeclaration )
        // AS3_ex.g3:1533:76: interfaceFunctionDeclaration
        {
        	PushFollow(FOLLOW_interfaceFunctionDeclaration_in_synpred106_AS3_ex6121);
        	interfaceFunctionDeclaration();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred106_AS3_ex"

    // $ANTLR start "synpred107_AS3_ex"
    public void synpred107_AS3_ex_fragment() {
        // AS3_ex.g3:1533:107: ( statement )
        // AS3_ex.g3:1533:107: statement
        {
        	PushFollow(FOLLOW_statement_in_synpred107_AS3_ex6125);
        	statement();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred107_AS3_ex"

    // $ANTLR start "synpred120_AS3_ex"
    public void synpred120_AS3_ex_fragment() {
        IToken s = null;

        // AS3_ex.g3:1587:39: (s= SEMI )
        // AS3_ex.g3:1587:39: s= SEMI
        {
        	s=(IToken)Match(input,SEMI,FOLLOW_SEMI_in_synpred120_AS3_ex6484); if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred120_AS3_ex"

    // $ANTLR start "synpred129_AS3_ex"
    public void synpred129_AS3_ex_fragment() {
        // AS3_ex.g3:1656:9: ( propertyDeclaration )
        // AS3_ex.g3:1656:9: propertyDeclaration
        {
        	PushFollow(FOLLOW_propertyDeclaration_in_synpred129_AS3_ex6806);
        	propertyDeclaration();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred129_AS3_ex"

    // $ANTLR start "synpred130_AS3_ex"
    public void synpred130_AS3_ex_fragment() {
        // AS3_ex.g3:1656:31: ( functionDeclaration )
        // AS3_ex.g3:1656:31: functionDeclaration
        {
        	PushFollow(FOLLOW_functionDeclaration_in_synpred130_AS3_ex6810);
        	functionDeclaration();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred130_AS3_ex"

    // $ANTLR start "synpred131_AS3_ex"
    public void synpred131_AS3_ex_fragment() {
        // AS3_ex.g3:1656:53: ( statement )
        // AS3_ex.g3:1656:53: statement
        {
        	PushFollow(FOLLOW_statement_in_synpred131_AS3_ex6814);
        	statement();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred131_AS3_ex"

    // $ANTLR start "synpred132_AS3_ex"
    public void synpred132_AS3_ex_fragment() {
        // AS3_ex.g3:1660:9: ( propertyDeclaration )
        // AS3_ex.g3:1660:9: propertyDeclaration
        {
        	PushFollow(FOLLOW_propertyDeclaration_in_synpred132_AS3_ex6835);
        	propertyDeclaration();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred132_AS3_ex"

    // $ANTLR start "synpred133_AS3_ex"
    public void synpred133_AS3_ex_fragment() {
        // AS3_ex.g3:1660:31: ( interfaceFunctionDeclaration )
        // AS3_ex.g3:1660:31: interfaceFunctionDeclaration
        {
        	PushFollow(FOLLOW_interfaceFunctionDeclaration_in_synpred133_AS3_ex6839);
        	interfaceFunctionDeclaration();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred133_AS3_ex"

    // $ANTLR start "synpred134_AS3_ex"
    public void synpred134_AS3_ex_fragment() {
        // AS3_ex.g3:1660:62: ( statement )
        // AS3_ex.g3:1660:62: statement
        {
        	PushFollow(FOLLOW_statement_in_synpred134_AS3_ex6843);
        	statement();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred134_AS3_ex"

    // $ANTLR start "synpred142_AS3_ex"
    public void synpred142_AS3_ex_fragment() {
        // AS3_ex.g3:1681:135: ( memberModifiers )
        // AS3_ex.g3:1681:135: memberModifiers
        {
        	PushFollow(FOLLOW_memberModifiers_in_synpred142_AS3_ex6980);
        	memberModifiers();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred142_AS3_ex"

    // $ANTLR start "synpred157_AS3_ex"
    public void synpred157_AS3_ex_fragment() {
        // AS3_ex.g3:1745:8: ( statement )
        // AS3_ex.g3:1745:8: statement
        {
        	PushFollow(FOLLOW_statement_in_synpred157_AS3_ex7462);
        	statement();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred157_AS3_ex"

    // $ANTLR start "synpred158_AS3_ex"
    public void synpred158_AS3_ex_fragment() {
        // AS3_ex.g3:1745:18: ( functionDeclaration )
        // AS3_ex.g3:1745:18: functionDeclaration
        {
        	PushFollow(FOLLOW_functionDeclaration_in_synpred158_AS3_ex7464);
        	functionDeclaration();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred158_AS3_ex"

    // $ANTLR start "synpred159_AS3_ex"
    public void synpred159_AS3_ex_fragment() {
        // AS3_ex.g3:1754:9: ( memberModifier )
        // AS3_ex.g3:1754:9: memberModifier
        {
        	PushFollow(FOLLOW_memberModifier_in_synpred159_AS3_ex7506);
        	memberModifier();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred159_AS3_ex"

    // $ANTLR start "synpred169_AS3_ex"
    public void synpred169_AS3_ex_fragment() {
        // AS3_ex.g3:1785:6: ( blockStatement )
        // AS3_ex.g3:1785:6: blockStatement
        {
        	if ( state.backtracking == 0 ) 
        	{
        	  SetBlockFlag(true);
        	}
        	PushFollow(FOLLOW_blockStatement_in_synpred169_AS3_ex7673);
        	blockStatement();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred169_AS3_ex"

    // $ANTLR start "synpred170_AS3_ex"
    public void synpred170_AS3_ex_fragment() {
        // AS3_ex.g3:1786:9: ( directive )
        // AS3_ex.g3:1786:9: directive
        {
        	if ( state.backtracking == 0 ) 
        	{
        	  InsertStatementCR();
        	}
        	PushFollow(FOLLOW_directive_in_synpred170_AS3_ex7684);
        	directive();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred170_AS3_ex"

    // $ANTLR start "synpred171_AS3_ex"
    public void synpred171_AS3_ex_fragment() {
        // AS3_ex.g3:1787:9: ( namespaceDirective )
        // AS3_ex.g3:1787:9: namespaceDirective
        {
        	if ( state.backtracking == 0 ) 
        	{
        	  InsertStatementCR();
        	}
        	PushFollow(FOLLOW_namespaceDirective_in_synpred171_AS3_ex7695);
        	namespaceDirective();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred171_AS3_ex"

    // $ANTLR start "synpred172_AS3_ex"
    public void synpred172_AS3_ex_fragment() {
        // AS3_ex.g3:1788:9: ( expression semic )
        // AS3_ex.g3:1788:9: expression semic
        {
        	if ( state.backtracking == 0 ) 
        	{
        	  InsertStatementCR();
        	}
        	PushFollow(FOLLOW_expression_in_synpred172_AS3_ex7708);
        	expression();
        	state.followingStackPointer--;
        	if (state.failed) return ;
        	PushFollow(FOLLOW_semic_in_synpred172_AS3_ex7710);
        	semic();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred172_AS3_ex"

    // $ANTLR start "synpred173_AS3_ex"
    public void synpred173_AS3_ex_fragment() {
        // AS3_ex.g3:1789:9: ( constantVarStatement )
        // AS3_ex.g3:1789:9: constantVarStatement
        {
        	if ( state.backtracking == 0 ) 
        	{
        	  InsertStatementCR();
        	}
        	PushFollow(FOLLOW_constantVarStatement_in_synpred173_AS3_ex7725);
        	constantVarStatement();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred173_AS3_ex"

    // $ANTLR start "synpred174_AS3_ex"
    public void synpred174_AS3_ex_fragment() {
        // AS3_ex.g3:1790:9: ( tryStatement )
        // AS3_ex.g3:1790:9: tryStatement
        {
        	if ( state.backtracking == 0 ) 
        	{
        	  MarkBlockFlag();InsertLines(mPrinter.GetBlankLinesBeforeControlStatement());
        	}
        	PushFollow(FOLLOW_tryStatement_in_synpred174_AS3_ex7738);
        	tryStatement();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred174_AS3_ex"

    // $ANTLR start "synpred175_AS3_ex"
    public void synpred175_AS3_ex_fragment() {
        // AS3_ex.g3:1791:9: ( labelledStatement )
        // AS3_ex.g3:1791:9: labelledStatement
        {
        	if ( state.backtracking == 0 ) 
        	{
        	  InsertLines(mPrinter.GetBlankLinesBeforeControlStatement());
        	}
        	PushFollow(FOLLOW_labelledStatement_in_synpred175_AS3_ex7750);
        	labelledStatement();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred175_AS3_ex"

    // $ANTLR start "synpred176_AS3_ex"
    public void synpred176_AS3_ex_fragment() {
        // AS3_ex.g3:1792:9: ( switchStatement )
        // AS3_ex.g3:1792:9: switchStatement
        {
        	if ( state.backtracking == 0 ) 
        	{
        	  MarkBlockFlag();
        	}
        	PushFollow(FOLLOW_switchStatement_in_synpred176_AS3_ex7763);
        	switchStatement();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred176_AS3_ex"

    // $ANTLR start "synpred177_AS3_ex"
    public void synpred177_AS3_ex_fragment() {
        // AS3_ex.g3:1793:9: ( withStatement )
        // AS3_ex.g3:1793:9: withStatement
        {
        	if ( state.backtracking == 0 ) 
        	{
        	  MarkBlockFlag();InsertLines(mPrinter.GetBlankLinesBeforeControlStatement());
        	}
        	PushFollow(FOLLOW_withStatement_in_synpred177_AS3_ex7775);
        	withStatement();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred177_AS3_ex"

    // $ANTLR start "synpred178_AS3_ex"
    public void synpred178_AS3_ex_fragment() {
        // AS3_ex.g3:1794:9: ( returnStatement )
        // AS3_ex.g3:1794:9: returnStatement
        {
        	if ( state.backtracking == 0 ) 
        	{
        	  InsertStatementCR();
        	}
        	PushFollow(FOLLOW_returnStatement_in_synpred178_AS3_ex7789);
        	returnStatement();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred178_AS3_ex"

    // $ANTLR start "synpred179_AS3_ex"
    public void synpred179_AS3_ex_fragment() {
        // AS3_ex.g3:1795:9: ( breakStatement )
        // AS3_ex.g3:1795:9: breakStatement
        {
        	if ( state.backtracking == 0 ) 
        	{
        	  InsertStatementCR();
        	}
        	PushFollow(FOLLOW_breakStatement_in_synpred179_AS3_ex7805);
        	breakStatement();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred179_AS3_ex"

    // $ANTLR start "synpred180_AS3_ex"
    public void synpred180_AS3_ex_fragment() {
        // AS3_ex.g3:1796:9: ( continueStatement )
        // AS3_ex.g3:1796:9: continueStatement
        {
        	if ( state.backtracking == 0 ) 
        	{
        	  InsertStatementCR();
        	}
        	PushFollow(FOLLOW_continueStatement_in_synpred180_AS3_ex7821);
        	continueStatement();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred180_AS3_ex"

    // $ANTLR start "synpred181_AS3_ex"
    public void synpred181_AS3_ex_fragment() {
        // AS3_ex.g3:1797:9: ( forStatement )
        // AS3_ex.g3:1797:9: forStatement
        {
        	if ( state.backtracking == 0 ) 
        	{
        	  MarkBlockFlag();InsertLines(mPrinter.GetBlankLinesBeforeControlStatement());
        	}
        	PushFollow(FOLLOW_forStatement_in_synpred181_AS3_ex7835);
        	forStatement();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred181_AS3_ex"

    // $ANTLR start "synpred182_AS3_ex"
    public void synpred182_AS3_ex_fragment() {
        // AS3_ex.g3:1798:9: ( forInStatement )
        // AS3_ex.g3:1798:9: forInStatement
        {
        	if ( state.backtracking == 0 ) 
        	{
        	  MarkBlockFlag();InsertLines(mPrinter.GetBlankLinesBeforeControlStatement());
        	}
        	PushFollow(FOLLOW_forInStatement_in_synpred182_AS3_ex7847);
        	forInStatement();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred182_AS3_ex"

    // $ANTLR start "synpred183_AS3_ex"
    public void synpred183_AS3_ex_fragment() {
        // AS3_ex.g3:1799:9: ( forEachInStatement )
        // AS3_ex.g3:1799:9: forEachInStatement
        {
        	if ( state.backtracking == 0 ) 
        	{
        	  MarkBlockFlag();InsertLines(mPrinter.GetBlankLinesBeforeControlStatement());
        	}
        	PushFollow(FOLLOW_forEachInStatement_in_synpred183_AS3_ex7859);
        	forEachInStatement();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred183_AS3_ex"

    // $ANTLR start "synpred184_AS3_ex"
    public void synpred184_AS3_ex_fragment() {
        // AS3_ex.g3:1800:9: ( doWhileStatement )
        // AS3_ex.g3:1800:9: doWhileStatement
        {
        	if ( state.backtracking == 0 ) 
        	{
        	  MarkBlockFlag();InsertLines(mPrinter.GetBlankLinesBeforeControlStatement());
        	}
        	PushFollow(FOLLOW_doWhileStatement_in_synpred184_AS3_ex7871);
        	doWhileStatement();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred184_AS3_ex"

    // $ANTLR start "synpred185_AS3_ex"
    public void synpred185_AS3_ex_fragment() {
        // AS3_ex.g3:1801:9: ( whileStatement )
        // AS3_ex.g3:1801:9: whileStatement
        {
        	if ( state.backtracking == 0 ) 
        	{
        	  MarkBlockFlag();InsertLines(mPrinter.GetBlankLinesBeforeControlStatement());
        	}
        	PushFollow(FOLLOW_whileStatement_in_synpred185_AS3_ex7883);
        	whileStatement();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred185_AS3_ex"

    // $ANTLR start "synpred186_AS3_ex"
    public void synpred186_AS3_ex_fragment() {
        // AS3_ex.g3:1802:9: ( ifStatement )
        // AS3_ex.g3:1802:9: ifStatement
        {
        	if ( state.backtracking == 0 ) 
        	{
        	  InsertLines(mPrinter.GetBlankLinesBeforeControlStatement());
        	}
        	PushFollow(FOLLOW_ifStatement_in_synpred186_AS3_ex7894);
        	ifStatement();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred186_AS3_ex"

    // $ANTLR start "synpred188_AS3_ex"
    public void synpred188_AS3_ex_fragment() {
        // AS3_ex.g3:1804:9: ( variableStatement )
        // AS3_ex.g3:1804:9: variableStatement
        {
        	if ( state.backtracking == 0 ) 
        	{
        	  InsertStatementCR();
        	}
        	PushFollow(FOLLOW_variableStatement_in_synpred188_AS3_ex7919);
        	variableStatement();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred188_AS3_ex"

    // $ANTLR start "synpred191_AS3_ex"
    public void synpred191_AS3_ex_fragment() {
        IToken S = null;

        // AS3_ex.g3:1832:68: (S= SEMI )
        // AS3_ex.g3:1832:68: S= SEMI
        {
        	S=(IToken)Match(input,SEMI,FOLLOW_SEMI_in_synpred191_AS3_ex8059); if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred191_AS3_ex"

    // $ANTLR start "synpred195_AS3_ex"
    public void synpred195_AS3_ex_fragment() {
        // AS3_ex.g3:1860:11: ( ( catchClause )+ finallyClause )
        // AS3_ex.g3:1860:11: ( catchClause )+ finallyClause
        {
        	// AS3_ex.g3:1860:11: ( catchClause )+
        	int cnt172 = 0;
        	do 
        	{
        	    int alt172 = 2;
        	    int LA172_0 = input.LA(1);

        	    if ( (LA172_0 == CATCH) )
        	    {
        	        alt172 = 1;
        	    }


        	    switch (alt172) 
        		{
        			case 1 :
        			    // AS3_ex.g3:0:0: catchClause
        			    {
        			    	PushFollow(FOLLOW_catchClause_in_synpred195_AS3_ex8295);
        			    	catchClause();
        			    	state.followingStackPointer--;
        			    	if (state.failed) return ;

        			    }
        			    break;

        			default:
        			    if ( cnt172 >= 1 ) goto loop172;
        			    if ( state.backtracking > 0 ) {state.failed = true; return ;}
        		            EarlyExitException eee =
        		                new EarlyExitException(172, input);
        		            throw eee;
        	    }
        	    cnt172++;
        	} while (true);

        	loop172:
        		;	// Stops C# compiler whinging that label 'loop172' has no statements

        	PushFollow(FOLLOW_finallyClause_in_synpred195_AS3_ex8298);
        	finallyClause();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred195_AS3_ex"

    // $ANTLR start "synpred197_AS3_ex"
    public void synpred197_AS3_ex_fragment() {
        // AS3_ex.g3:1861:11: ( ( catchClause )+ )
        // AS3_ex.g3:1861:11: ( catchClause )+
        {
        	// AS3_ex.g3:1861:11: ( catchClause )+
        	int cnt173 = 0;
        	do 
        	{
        	    int alt173 = 2;
        	    int LA173_0 = input.LA(1);

        	    if ( (LA173_0 == CATCH) )
        	    {
        	        alt173 = 1;
        	    }


        	    switch (alt173) 
        		{
        			case 1 :
        			    // AS3_ex.g3:0:0: catchClause
        			    {
        			    	PushFollow(FOLLOW_catchClause_in_synpred197_AS3_ex8310);
        			    	catchClause();
        			    	state.followingStackPointer--;
        			    	if (state.failed) return ;

        			    }
        			    break;

        			default:
        			    if ( cnt173 >= 1 ) goto loop173;
        			    if ( state.backtracking > 0 ) {state.failed = true; return ;}
        		            EarlyExitException eee =
        		                new EarlyExitException(173, input);
        		            throw eee;
        	    }
        	    cnt173++;
        	} while (true);

        	loop173:
        		;	// Stops C# compiler whinging that label 'loop173' has no statements


        }
    }
    // $ANTLR end "synpred197_AS3_ex"

    // $ANTLR start "synpred199_AS3_ex"
    public void synpred199_AS3_ex_fragment() {
        // AS3_ex.g3:1909:61: ( statement )
        // AS3_ex.g3:1909:61: statement
        {
        	PushFollow(FOLLOW_statement_in_synpred199_AS3_ex8576);
        	statement();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred199_AS3_ex"

    // $ANTLR start "synpred209_AS3_ex"
    public void synpred209_AS3_ex_fragment() {
        // AS3_ex.g3:1994:9: ( variableDeclarationNoInList )
        // AS3_ex.g3:1994:9: variableDeclarationNoInList
        {
        	PushFollow(FOLLOW_variableDeclarationNoInList_in_synpred209_AS3_ex9131);
        	variableDeclarationNoInList();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred209_AS3_ex"

    // $ANTLR start "synpred210_AS3_ex"
    public void synpred210_AS3_ex_fragment() {
        IToken S = null;

        // AS3_ex.g3:2008:241: (S= SEMI )
        // AS3_ex.g3:2008:241: S= SEMI
        {
        	S=(IToken)Match(input,SEMI,FOLLOW_SEMI_in_synpred210_AS3_ex9212); if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred210_AS3_ex"

    // $ANTLR start "synpred211_AS3_ex"
    public void synpred211_AS3_ex_fragment() {
        IToken E = null;

        // AS3_ex.g3:2063:26: (E= ELSE statement )
        // AS3_ex.g3:2063:26: E= ELSE statement
        {
        	E=(IToken)Match(input,ELSE,FOLLOW_ELSE_in_synpred211_AS3_ex9451); if (state.failed) return ;
        	PushFollow(FOLLOW_statement_in_synpred211_AS3_ex9492);
        	statement();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred211_AS3_ex"

    // $ANTLR start "synpred228_AS3_ex"
    public void synpred228_AS3_ex_fragment() {
        // AS3_ex.g3:2198:7: ( leftHandSideExpression assignmentOperator assignmentExpression )
        // AS3_ex.g3:2198:7: leftHandSideExpression assignmentOperator assignmentExpression
        {
        	PushFollow(FOLLOW_leftHandSideExpression_in_synpred228_AS3_ex10224);
        	leftHandSideExpression();
        	state.followingStackPointer--;
        	if (state.failed) return ;
        	PushFollow(FOLLOW_assignmentOperator_in_synpred228_AS3_ex10227);
        	assignmentOperator();
        	state.followingStackPointer--;
        	if (state.failed) return ;
        	PushFollow(FOLLOW_assignmentExpression_in_synpred228_AS3_ex10230);
        	assignmentExpression();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred228_AS3_ex"

    // $ANTLR start "synpred229_AS3_ex"
    public void synpred229_AS3_ex_fragment() {
        // AS3_ex.g3:2204:9: ( conditionalExpressionNoIn )
        // AS3_ex.g3:2204:9: conditionalExpressionNoIn
        {
        	PushFollow(FOLLOW_conditionalExpressionNoIn_in_synpred229_AS3_ex10258);
        	conditionalExpressionNoIn();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred229_AS3_ex"

    // $ANTLR start "synpred272_AS3_ex"
    public void synpred272_AS3_ex_fragment() {
        IToken g = null;
        IToken assign = null;
        IToken eq = null;

        // AS3_ex.g3:2313:7: ( (g= GT (assign= ASSIGN )? | eq= ( IN | LT | LTE | INSTANCEOF | IS | AS ) ) shiftExpression )
        // AS3_ex.g3:2313:7: (g= GT (assign= ASSIGN )? | eq= ( IN | LT | LTE | INSTANCEOF | IS | AS ) ) shiftExpression
        {
        	// AS3_ex.g3:2313:7: (g= GT (assign= ASSIGN )? | eq= ( IN | LT | LTE | INSTANCEOF | IS | AS ) )
        	int alt176 = 2;
        	int LA176_0 = input.LA(1);

        	if ( (LA176_0 == GT) )
        	{
        	    alt176 = 1;
        	}
        	else if ( (LA176_0 == AS || (LA176_0 >= IN && LA176_0 <= INSTANCEOF) || LA176_0 == IS || LA176_0 == LT || LA176_0 == LTE) )
        	{
        	    alt176 = 2;
        	}
        	else 
        	{
        	    if ( state.backtracking > 0 ) {state.failed = true; return ;}
        	    NoViableAltException nvae_d176s0 =
        	        new NoViableAltException("", 176, 0, input);

        	    throw nvae_d176s0;
        	}
        	switch (alt176) 
        	{
        	    case 1 :
        	        // AS3_ex.g3:2313:9: g= GT (assign= ASSIGN )?
        	        {
        	        	g=(IToken)Match(input,GT,FOLLOW_GT_in_synpred272_AS3_ex11152); if (state.failed) return ;
        	        	// AS3_ex.g3:2313:14: (assign= ASSIGN )?
        	        	int alt175 = 2;
        	        	int LA175_0 = input.LA(1);

        	        	if ( (LA175_0 == ASSIGN) )
        	        	{
        	        	    alt175 = 1;
        	        	}
        	        	switch (alt175) 
        	        	{
        	        	    case 1 :
        	        	        // AS3_ex.g3:2313:15: assign= ASSIGN
        	        	        {
        	        	        	assign=(IToken)Match(input,ASSIGN,FOLLOW_ASSIGN_in_synpred272_AS3_ex11157); if (state.failed) return ;

        	        	        }
        	        	        break;

        	        	}


        	        }
        	        break;
        	    case 2 :
        	        // AS3_ex.g3:2321:14: eq= ( IN | LT | LTE | INSTANCEOF | IS | AS )
        	        {
        	        	eq = (IToken)input.LT(1);
        	        	if ( input.LA(1) == AS || (input.LA(1) >= IN && input.LA(1) <= INSTANCEOF) || input.LA(1) == IS || input.LA(1) == LT || input.LA(1) == LTE ) 
        	        	{
        	        	    input.Consume();
        	        	    state.errorRecovery = false;state.failed = false;
        	        	}
        	        	else 
        	        	{
        	        	    if ( state.backtracking > 0 ) {state.failed = true; return ;}
        	        	    MismatchedSetException mse = new MismatchedSetException(null,input);
        	        	    throw mse;
        	        	}


        	        }
        	        break;

        	}

        	PushFollow(FOLLOW_shiftExpression_in_synpred272_AS3_ex11228);
        	shiftExpression();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred272_AS3_ex"

    // $ANTLR start "synpred283_AS3_ex"
    public void synpred283_AS3_ex_fragment() {
        // AS3_ex.g3:2353:11: ( '>' '>' '>' )
        // AS3_ex.g3:2353:12: '>' '>' '>'
        {
        	Match(input,GT,FOLLOW_GT_in_synpred283_AS3_ex11480); if (state.failed) return ;
        	Match(input,GT,FOLLOW_GT_in_synpred283_AS3_ex11482); if (state.failed) return ;
        	Match(input,GT,FOLLOW_GT_in_synpred283_AS3_ex11484); if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred283_AS3_ex"

    // $ANTLR start "synpred286_AS3_ex"
    public void synpred286_AS3_ex_fragment() {
        IToken op = null;

        // AS3_ex.g3:2366:36: (op= ( PLUS | SUB ) multiplicativeExpression )
        // AS3_ex.g3:2366:36: op= ( PLUS | SUB ) multiplicativeExpression
        {
        	op = (IToken)input.LT(1);
        	if ( (input.LA(1) >= PLUS && input.LA(1) <= SUB) ) 
        	{
        	    input.Consume();
        	    state.errorRecovery = false;state.failed = false;
        	}
        	else 
        	{
        	    if ( state.backtracking > 0 ) {state.failed = true; return ;}
        	    MismatchedSetException mse = new MismatchedSetException(null,input);
        	    throw mse;
        	}

        	PushFollow(FOLLOW_multiplicativeExpression_in_synpred286_AS3_ex11589);
        	multiplicativeExpression();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred286_AS3_ex"

    // $ANTLR start "synpred289_AS3_ex"
    public void synpred289_AS3_ex_fragment() {
        IToken op = null;

        // AS3_ex.g3:2371:27: (op= ( STAR | DIV | MOD ) unaryExpression )
        // AS3_ex.g3:2371:27: op= ( STAR | DIV | MOD ) unaryExpression
        {
        	op = (IToken)input.LT(1);
        	if ( (input.LA(1) >= STAR && input.LA(1) <= MOD) ) 
        	{
        	    input.Consume();
        	    state.errorRecovery = false;state.failed = false;
        	}
        	else 
        	{
        	    if ( state.backtracking > 0 ) {state.failed = true; return ;}
        	    MismatchedSetException mse = new MismatchedSetException(null,input);
        	    throw mse;
        	}

        	PushFollow(FOLLOW_unaryExpression_in_synpred289_AS3_ex11628);
        	unaryExpression();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred289_AS3_ex"

    // $ANTLR start "synpred290_AS3_ex"
    public void synpred290_AS3_ex_fragment() {
        // AS3_ex.g3:2376:9: ( postfixExpression )
        // AS3_ex.g3:2376:9: postfixExpression
        {
        	PushFollow(FOLLOW_postfixExpression_in_synpred290_AS3_ex11652);
        	postfixExpression();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred290_AS3_ex"

    // $ANTLR start "synpred292_AS3_ex"
    public void synpred292_AS3_ex_fragment() {
        IToken op = null;

        // AS3_ex.g3:2377:8: (op= ( NOT | INV ) unaryExpression )
        // AS3_ex.g3:2377:8: op= ( NOT | INV ) unaryExpression
        {
        	op = (IToken)input.LT(1);
        	if ( (input.LA(1) >= NOT && input.LA(1) <= INV) ) 
        	{
        	    input.Consume();
        	    state.errorRecovery = false;state.failed = false;
        	}
        	else 
        	{
        	    if ( state.backtracking > 0 ) {state.failed = true; return ;}
        	    MismatchedSetException mse = new MismatchedSetException(null,input);
        	    throw mse;
        	}

        	PushFollow(FOLLOW_unaryExpression_in_synpred292_AS3_ex11673);
        	unaryExpression();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred292_AS3_ex"

    // $ANTLR start "synpred301_AS3_ex"
    public void synpred301_AS3_ex_fragment() {
        // AS3_ex.g3:2390:32: ( postfixOp )
        // AS3_ex.g3:2390:32: postfixOp
        {
        	PushFollow(FOLLOW_postfixOp_in_synpred301_AS3_ex11775);
        	postfixOp();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred301_AS3_ex"

    // $ANTLR start "synpred305_AS3_ex"
    public void synpred305_AS3_ex_fragment() {
        // AS3_ex.g3:2412:7: ( arguments )
        // AS3_ex.g3:2412:7: arguments
        {
        	PushFollow(FOLLOW_arguments_in_synpred305_AS3_ex11883);
        	arguments();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred305_AS3_ex"

    // $ANTLR start "synpred306_AS3_ex"
    public void synpred306_AS3_ex_fragment() {
        IToken L = null;
        IToken R = null;

        // AS3_ex.g3:2413:9: (L= LBRACK expression R= RBRACK )
        // AS3_ex.g3:2413:9: L= LBRACK expression R= RBRACK
        {
        	L=(IToken)Match(input,LBRACK,FOLLOW_LBRACK_in_synpred306_AS3_ex11895); if (state.failed) return ;
        	PushFollow(FOLLOW_expression_in_synpred306_AS3_ex11899);
        	expression();
        	state.followingStackPointer--;
        	if (state.failed) return ;
        	R=(IToken)Match(input,RBRACK,FOLLOW_RBRACK_in_synpred306_AS3_ex11903); if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred306_AS3_ex"

    // $ANTLR start "synpred307_AS3_ex"
    public void synpred307_AS3_ex_fragment() {
        IToken op = null;

        // AS3_ex.g3:2415:41: ( eitherIdentifier op= XML_NS_OP )
        // AS3_ex.g3:2415:41: eitherIdentifier op= XML_NS_OP
        {
        	PushFollow(FOLLOW_eitherIdentifier_in_synpred307_AS3_ex11923);
        	eitherIdentifier();
        	state.followingStackPointer--;
        	if (state.failed) return ;
        	op=(IToken)Match(input,XML_NS_OP,FOLLOW_XML_NS_OP_in_synpred307_AS3_ex11927); if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred307_AS3_ex"

    // $ANTLR start "synpred308_AS3_ex"
    public void synpred308_AS3_ex_fragment() {
        IToken D = null;
        IToken op = null;

        // AS3_ex.g3:2415:9: (D= DOT ( eitherIdentifier op= XML_NS_OP )? eitherIdentifier )
        // AS3_ex.g3:2415:9: D= DOT ( eitherIdentifier op= XML_NS_OP )? eitherIdentifier
        {
        	D=(IToken)Match(input,DOT,FOLLOW_DOT_in_synpred308_AS3_ex11918); if (state.failed) return ;
        	// AS3_ex.g3:2415:40: ( eitherIdentifier op= XML_NS_OP )?
        	int alt181 = 2;
        	switch ( input.LA(1) ) 
        	{
        	    case IDENTIFIER:
        	    	{
        	        int LA181_1 = input.LA(2);

        	        if ( (synpred307_AS3_ex()) )
        	        {
        	            alt181 = 1;
        	        }
        	        }
        	        break;
        	    case XML_AT:
        	    	{
        	        int LA181_2 = input.LA(2);

        	        if ( (synpred307_AS3_ex()) )
        	        {
        	            alt181 = 1;
        	        }
        	        }
        	        break;
        	    case AS:
        	    case BREAK:
        	    case CASE:
        	    case CATCH:
        	    case CLASS:
        	    case CONST:
        	    case CONTINUE:
        	    case DEFAULT:
        	    case DELETE:
        	    case DO:
        	    case ELSE:
        	    case EXTENDS:
        	    case FALSE:
        	    case FINALLY:
        	    case FOR:
        	    case FUNCTION:
        	    case IF:
        	    case IMPLEMENTS:
        	    case IMPORT:
        	    case IN:
        	    case INSTANCEOF:
        	    case INTERFACE:
        	    case INTERNAL:
        	    case IS:
        	    case NEW:
        	    case NULL:
        	    case PACKAGE:
        	    case PRIVATE:
        	    case PROTECTED:
        	    case PUBLIC:
        	    case RETURN:
        	    case SUPER:
        	    case SWITCH:
        	    case THIS:
        	    case THROW:
        	    case TRUE:
        	    case TRY:
        	    case TYPEOF:
        	    case USE:
        	    case VAR:
        	    case VOID:
        	    case WHILE:
        	    case WITH:
        	    case INCLUDE:
        	    	{
        	        int LA181_3 = input.LA(2);

        	        if ( (synpred307_AS3_ex()) )
        	        {
        	            alt181 = 1;
        	        }
        	        }
        	        break;
        	    case NATIVE:
        	    case TO:
        	    case EACH:
        	    case GET:
        	    case SET:
        	    case NAMESPACE:
        	    case DYNAMIC:
        	    case FINAL:
        	    case OVERRIDE:
        	    case STATIC:
        	    	{
        	        int LA181_4 = input.LA(2);

        	        if ( (synpred307_AS3_ex()) )
        	        {
        	            alt181 = 1;
        	        }
        	        }
        	        break;
        	    case STAR:
        	    	{
        	        int LA181_5 = input.LA(2);

        	        if ( (synpred307_AS3_ex()) )
        	        {
        	            alt181 = 1;
        	        }
        	        }
        	        break;
        	}

        	switch (alt181) 
        	{
        	    case 1 :
        	        // AS3_ex.g3:2415:41: eitherIdentifier op= XML_NS_OP
        	        {
        	        	PushFollow(FOLLOW_eitherIdentifier_in_synpred308_AS3_ex11923);
        	        	eitherIdentifier();
        	        	state.followingStackPointer--;
        	        	if (state.failed) return ;
        	        	op=(IToken)Match(input,XML_NS_OP,FOLLOW_XML_NS_OP_in_synpred308_AS3_ex11927); if (state.failed) return ;

        	        }
        	        break;

        	}

        	PushFollow(FOLLOW_eitherIdentifier_in_synpred308_AS3_ex11934);
        	eitherIdentifier();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred308_AS3_ex"

    // $ANTLR start "synpred309_AS3_ex"
    public void synpred309_AS3_ex_fragment() {
        IToken op = null;

        // AS3_ex.g3:2416:49: ( eitherIdentifier op= XML_NS_OP )
        // AS3_ex.g3:2416:49: eitherIdentifier op= XML_NS_OP
        {
        	PushFollow(FOLLOW_eitherIdentifier_in_synpred309_AS3_ex11950);
        	eitherIdentifier();
        	state.followingStackPointer--;
        	if (state.failed) return ;
        	op=(IToken)Match(input,XML_NS_OP,FOLLOW_XML_NS_OP_in_synpred309_AS3_ex11954); if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred309_AS3_ex"

    // $ANTLR start "synpred311_AS3_ex"
    public void synpred311_AS3_ex_fragment() {
        IToken D = null;

        // AS3_ex.g3:2417:9: (D= DOT parExpression )
        // AS3_ex.g3:2417:9: D= DOT parExpression
        {
        	D=(IToken)Match(input,DOT,FOLLOW_DOT_in_synpred311_AS3_ex11973); if (state.failed) return ;
        	PushFollow(FOLLOW_parExpression_in_synpred311_AS3_ex11977);
        	parExpression();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred311_AS3_ex"

    // $ANTLR start "synpred312_AS3_ex"
    public void synpred312_AS3_ex_fragment() {
        // AS3_ex.g3:2418:9: ( typePostfixSyntax )
        // AS3_ex.g3:2418:9: typePostfixSyntax
        {
        	PushFollow(FOLLOW_typePostfixSyntax_in_synpred312_AS3_ex11987);
        	typePostfixSyntax();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred312_AS3_ex"

    // $ANTLR start "synpred313_AS3_ex"
    public void synpred313_AS3_ex_fragment() {
        IToken I = null;

        // AS3_ex.g3:2423:4: (I= IDENTIFIER )
        // AS3_ex.g3:2423:4: I= IDENTIFIER
        {
        	I=(IToken)Match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_synpred313_AS3_ex12017); if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred313_AS3_ex"

    // $ANTLR start "synpred314_AS3_ex"
    public void synpred314_AS3_ex_fragment() {
        // AS3_ex.g3:2424:5: ( xmlPropertyIdentifier )
        // AS3_ex.g3:2424:5: xmlPropertyIdentifier
        {
        	PushFollow(FOLLOW_xmlPropertyIdentifier_in_synpred314_AS3_ex12027);
        	xmlPropertyIdentifier();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred314_AS3_ex"

    // $ANTLR start "synpred376_AS3_ex"
    public void synpred376_AS3_ex_fragment() {
        IToken T = null;

        // AS3_ex.g3:2549:9: (T= THIS )
        // AS3_ex.g3:2549:9: T= THIS
        {
        	T=(IToken)Match(input,THIS,FOLLOW_THIS_in_synpred376_AS3_ex13037); if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred376_AS3_ex"

    // $ANTLR start "synpred377_AS3_ex"
    public void synpred377_AS3_ex_fragment() {
        IToken S = null;

        // AS3_ex.g3:2550:9: (S= SUPER )
        // AS3_ex.g3:2550:9: S= SUPER
        {
        	S=(IToken)Match(input,SUPER,FOLLOW_SUPER_in_synpred377_AS3_ex13051); if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred377_AS3_ex"

    // $ANTLR start "synpred378_AS3_ex"
    public void synpred378_AS3_ex_fragment() {
        // AS3_ex.g3:2551:9: ( literal )
        // AS3_ex.g3:2551:9: literal
        {
        	PushFollow(FOLLOW_literal_in_synpred378_AS3_ex13063);
        	literal();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred378_AS3_ex"

    // $ANTLR start "synpred381_AS3_ex"
    public void synpred381_AS3_ex_fragment() {
        // AS3_ex.g3:2554:9: ( identifierLiteral )
        // AS3_ex.g3:2554:9: identifierLiteral
        {
        	PushFollow(FOLLOW_identifierLiteral_in_synpred381_AS3_ex13098);
        	identifierLiteral();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred381_AS3_ex"

    // $ANTLR start "synpred382_AS3_ex"
    public void synpred382_AS3_ex_fragment() {
        // AS3_ex.g3:2555:9: ( xmlPrimaryExpression )
        // AS3_ex.g3:2555:9: xmlPrimaryExpression
        {
        	PushFollow(FOLLOW_xmlPrimaryExpression_in_synpred382_AS3_ex13109);
        	xmlPrimaryExpression();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred382_AS3_ex"

    // $ANTLR start "synpred384_AS3_ex"
    public void synpred384_AS3_ex_fragment() {
        // AS3_ex.g3:2557:9: ( conditionalCompilerOption )
        // AS3_ex.g3:2557:9: conditionalCompilerOption
        {
        	PushFollow(FOLLOW_conditionalCompilerOption_in_synpred384_AS3_ex13130);
        	conditionalCompilerOption();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred384_AS3_ex"

    // $ANTLR start "synpred385_AS3_ex"
    public void synpred385_AS3_ex_fragment() {
        // AS3_ex.g3:2558:72: ( arrayLiteral )
        // AS3_ex.g3:2558:72: arrayLiteral
        {
        	PushFollow(FOLLOW_arrayLiteral_in_synpred385_AS3_ex13152);
        	arrayLiteral();
        	state.followingStackPointer--;
        	if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred385_AS3_ex"

    // Delegated rules

   	public bool synpred382_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred382_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred384_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred384_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred272_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred272_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred283_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred283_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred185_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred185_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred99_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred99_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred134_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred134_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred174_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred174_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred175_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred175_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred178_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred178_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred286_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred286_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred131_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred131_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred183_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred183_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred305_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred305_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred130_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred130_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred133_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred133_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred191_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred191_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred306_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred306_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred210_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred210_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred378_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred378_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred98_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred98_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred290_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred290_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred142_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred142_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred9_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred9_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred309_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred309_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred292_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred292_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred129_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred129_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred211_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred211_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred107_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred107_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred377_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred377_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred376_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred376_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred301_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred301_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred120_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred120_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred197_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred197_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred170_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred170_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred195_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred195_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred101_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred101_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred199_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred199_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred182_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred182_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred308_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred308_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred381_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred381_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred184_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred184_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred74_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred74_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred171_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred171_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred289_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred289_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred68_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred68_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred385_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred385_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred307_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred307_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred179_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred179_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred180_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred180_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred97_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred97_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred105_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred105_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred159_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred159_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred69_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred69_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred228_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred228_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred158_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred158_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred176_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred176_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred169_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred169_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred103_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred103_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred106_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred106_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred73_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred73_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred100_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred100_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred173_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred173_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred177_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred177_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred181_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred181_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred311_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred311_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred75_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred75_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred132_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred132_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred312_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred312_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred157_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred157_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred313_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred313_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred209_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred209_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred314_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred314_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred186_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred186_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred104_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred104_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred172_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred172_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred229_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred229_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}
   	public bool synpred188_AS3_ex() 
   	{
   	    state.backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred188_AS3_ex_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !state.failed;
   	    input.Rewind(start);
   	    state.backtracking--;
   	    state.failed = false;
   	    return success;
   	}


   	protected DFA8 dfa8;
   	protected DFA14 dfa14;
   	protected DFA34 dfa34;
   	protected DFA36 dfa36;
   	protected DFA54 dfa54;
   	protected DFA55 dfa55;
   	protected DFA74 dfa74;
   	protected DFA76 dfa76;
   	protected DFA86 dfa86;
   	protected DFA114 dfa114;
   	protected DFA115 dfa115;
   	protected DFA116 dfa116;
   	protected DFA133 dfa133;
   	protected DFA139 dfa139;
   	protected DFA140 dfa140;
   	protected DFA141 dfa141;
   	protected DFA142 dfa142;
   	protected DFA146 dfa146;
   	protected DFA155 dfa155;
   	protected DFA154 dfa154;
	private void InitializeCyclicDFAs()
	{
    	this.dfa8 = new DFA8(this);
    	this.dfa14 = new DFA14(this);
    	this.dfa34 = new DFA34(this);
    	this.dfa36 = new DFA36(this);
    	this.dfa54 = new DFA54(this);
    	this.dfa55 = new DFA55(this);
    	this.dfa74 = new DFA74(this);
    	this.dfa76 = new DFA76(this);
    	this.dfa86 = new DFA86(this);
    	this.dfa114 = new DFA114(this);
    	this.dfa115 = new DFA115(this);
    	this.dfa116 = new DFA116(this);
    	this.dfa133 = new DFA133(this);
    	this.dfa139 = new DFA139(this);
    	this.dfa140 = new DFA140(this);
    	this.dfa141 = new DFA141(this);
    	this.dfa142 = new DFA142(this);
    	this.dfa146 = new DFA146(this);
    	this.dfa155 = new DFA155(this);
    	this.dfa154 = new DFA154(this);
	    this.dfa8.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA8_SpecialStateTransition);
	    this.dfa14.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA14_SpecialStateTransition);
	    this.dfa34.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA34_SpecialStateTransition);
	    this.dfa36.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA36_SpecialStateTransition);
	    this.dfa54.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA54_SpecialStateTransition);
	    this.dfa55.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA55_SpecialStateTransition);
	    this.dfa74.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA74_SpecialStateTransition);
	    this.dfa76.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA76_SpecialStateTransition);
	    this.dfa86.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA86_SpecialStateTransition);
	    this.dfa114.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA114_SpecialStateTransition);
	    this.dfa115.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA115_SpecialStateTransition);

	    this.dfa133.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA133_SpecialStateTransition);
	    this.dfa139.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA139_SpecialStateTransition);
	    this.dfa140.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA140_SpecialStateTransition);
	    this.dfa141.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA141_SpecialStateTransition);
	    this.dfa142.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA142_SpecialStateTransition);
	    this.dfa146.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA146_SpecialStateTransition);
	    this.dfa155.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA155_SpecialStateTransition);
	    this.dfa154.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA154_SpecialStateTransition);
	}

    const string DFA8_eotS =
        "\x32\uffff";
    const string DFA8_eofS =
        "\x01\x01\x03\uffff\x01\x01\x2d\uffff";
    const string DFA8_minS =
        "\x01\x04\x01\uffff\x03\x04\x2c\x00\x01\uffff";
    const string DFA8_maxS =
        "\x01\u0092\x01\uffff\x01\u008e\x02\u0092\x2c\x00\x01\uffff";
    const string DFA8_acceptS =
        "\x01\uffff\x01\x02\x2f\uffff\x01\x01";
    const string DFA8_specialS =
        "\x05\uffff\x01\x18\x01\x07\x01\x22\x01\x1e\x01\x15\x01\x28\x01"+
        "\x09\x01\x12\x01\x2b\x01\x0d\x01\x20\x01\x26\x01\x05\x01\x2a\x01"+
        "\x13\x01\x1c\x01\x0c\x01\x0a\x01\x10\x01\x1a\x01\x00\x01\x06\x01"+
        "\x1b\x01\x0e\x01\x27\x01\x0b\x01\x14\x01\x25\x01\x11\x01\x03\x01"+
        "\x24\x01\x21\x01\x29\x01\x17\x01\x01\x01\x0f\x01\x16\x01\x08\x01"+
        "\x04\x01\x1d\x01\x02\x01\x23\x01\x19\x01\x1f\x01\uffff}>";
    static readonly string[] DFA8_transitionS = {
            "\x3d\x01\x01\x02\x04\x01\x01\uffff\x05\x01\x01\x03\x06\x01"+
            "\x02\uffff\x08\x01\x01\x04\x01\x01\x02\uffff\x05\x01\x02\uffff"+
            "\x05\x01\x01\uffff\x02\x01\x01\uffff\x03\x01\x0c\uffff\x02\x01"+
            "\x02\uffff\x01\x01\x04\uffff\x01\x01\x02\uffff\x01\x01\x01\uffff"+
            "\x01\x01\x01\uffff\x03\x01",
            "",
            "\x18\x06\x01\x07\x0b\x06\x01\x07\x08\x06\x04\x07\x01\x06\x04"+
            "\x07\x03\uffff\x01\x01\x05\uffff\x01\x01\x09\uffff\x01\x01\x24"+
            "\uffff\x01\x01\x1b\uffff\x01\x05",
            "\x08\x12\x01\x11\x03\x12\x01\x0c\x02\x12\x01\x0f\x08\x12\x01"+
            "\x0e\x01\x10\x01\x0a\x05\x12\x01\x09\x01\x12\x01\x08\x01\x12"+
            "\x01\x0e\x01\x0b\x01\x12\x01\x11\x02\x12\x01\x11\x02\x12\x04"+
            "\x0e\x01\x12\x04\x0e\x01\uffff\x01\x01\x01\uffff\x01\x01\x01"+
            "\uffff\x01\x01\x03\uffff\x01\x01\x07\uffff\x03\x01\x02\uffff"+
            "\x02\x01\x06\uffff\x02\x01\x18\uffff\x02\x01\x0c\uffff\x02\x01"+
            "\x02\uffff\x01\x01\x04\uffff\x01\x01\x02\uffff\x01\x01\x01\uffff"+
            "\x01\x0d\x01\uffff\x03\x01",
            "\x01\x30\x01\x27\x01\x2f\x02\x30\x01\x21\x01\x28\x01\x20\x01"+
            "\x1c\x01\x2a\x02\x30\x01\x17\x01\x30\x01\x29\x01\x1a\x01\x2c"+
            "\x01\x30\x01\x1f\x05\x30\x01\x22\x01\x1b\x01\x15\x04\x30\x01"+
            "\x26\x01\x14\x01\x24\x01\x13\x01\x2e\x01\x22\x01\x16\x01\x23"+
            "\x01\x1c\x01\x1e\x01\x2d\x01\x1c\x01\x2b\x01\x25\x03\x22\x01"+
            "\x19\x01\x1d\x04\x22\x04\x01\x01\uffff\x01\x01\x03\uffff\x01"+
            "\x01\x07\uffff\x03\x01\x02\uffff\x02\x01\x06\uffff\x02\x01\x18"+
            "\uffff\x02\x01\x0c\uffff\x02\x01\x02\uffff\x01\x01\x04\uffff"+
            "\x01\x01\x02\uffff\x01\x01\x01\uffff\x01\x18\x01\uffff\x03\x01",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            ""
    };

    static readonly short[] DFA8_eot = DFA.UnpackEncodedString(DFA8_eotS);
    static readonly short[] DFA8_eof = DFA.UnpackEncodedString(DFA8_eofS);
    static readonly char[] DFA8_min = DFA.UnpackEncodedStringToUnsignedChars(DFA8_minS);
    static readonly char[] DFA8_max = DFA.UnpackEncodedStringToUnsignedChars(DFA8_maxS);
    static readonly short[] DFA8_accept = DFA.UnpackEncodedString(DFA8_acceptS);
    static readonly short[] DFA8_special = DFA.UnpackEncodedString(DFA8_specialS);
    static readonly short[][] DFA8_transition = DFA.UnpackEncodedStringArray(DFA8_transitionS);

    protected class DFA8 : DFA
    {
        public DFA8(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 8;
            this.eot = DFA8_eot;
            this.eof = DFA8_eof;
            this.min = DFA8_min;
            this.max = DFA8_max;
            this.accept = DFA8_accept;
            this.special = DFA8_special;
            this.transition = DFA8_transition;

        }

        override public string Description
        {
            get { return "()* loopback of 1252:93: ({...}? => (s= SUB | d= DOT | c= COLON ) {...}? => (I2= IDENTIFIER | allKeywords ) )*"; }
        }

    }


    protected internal int DFA8_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
            ITokenStream input = (ITokenStream)_input;
    	int _s = s;
        switch ( s )
        {
               	case 0 : 
                   	int LA8_25 = input.LA(1);

                   	 
                   	int index8_25 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( ((synpred9_AS3_ex() && (!PromoteWhitespace()))) ) { s = 49; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index8_25);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 1 : 
                   	int LA8_39 = input.LA(1);

                   	 
                   	int index8_39 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( ((synpred9_AS3_ex() && (!PromoteWhitespace()))) ) { s = 49; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index8_39);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 2 : 
                   	int LA8_45 = input.LA(1);

                   	 
                   	int index8_45 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( ((synpred9_AS3_ex() && (!PromoteWhitespace()))) ) { s = 49; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index8_45);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 3 : 
                   	int LA8_34 = input.LA(1);

                   	 
                   	int index8_34 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( ((synpred9_AS3_ex() && (!PromoteWhitespace()))) ) { s = 49; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index8_34);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 4 : 
                   	int LA8_43 = input.LA(1);

                   	 
                   	int index8_43 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( ((synpred9_AS3_ex() && (!PromoteWhitespace()))) ) { s = 49; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index8_43);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 5 : 
                   	int LA8_17 = input.LA(1);

                   	 
                   	int index8_17 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( ((synpred9_AS3_ex() && (!PromoteWhitespace()))) ) { s = 49; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index8_17);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 6 : 
                   	int LA8_26 = input.LA(1);

                   	 
                   	int index8_26 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( ((synpred9_AS3_ex() && (!PromoteWhitespace()))) ) { s = 49; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index8_26);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 7 : 
                   	int LA8_6 = input.LA(1);

                   	 
                   	int index8_6 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( ((synpred9_AS3_ex() && (!PromoteWhitespace()))) ) { s = 49; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index8_6);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 8 : 
                   	int LA8_42 = input.LA(1);

                   	 
                   	int index8_42 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( ((synpred9_AS3_ex() && (!PromoteWhitespace()))) ) { s = 49; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index8_42);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 9 : 
                   	int LA8_11 = input.LA(1);

                   	 
                   	int index8_11 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( ((synpred9_AS3_ex() && (!PromoteWhitespace()))) ) { s = 49; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index8_11);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 10 : 
                   	int LA8_22 = input.LA(1);

                   	 
                   	int index8_22 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( ((synpred9_AS3_ex() && (!PromoteWhitespace()))) ) { s = 49; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index8_22);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 11 : 
                   	int LA8_30 = input.LA(1);

                   	 
                   	int index8_30 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( ((synpred9_AS3_ex() && (!PromoteWhitespace()))) ) { s = 49; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index8_30);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 12 : 
                   	int LA8_21 = input.LA(1);

                   	 
                   	int index8_21 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( ((synpred9_AS3_ex() && (!PromoteWhitespace()))) ) { s = 49; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index8_21);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 13 : 
                   	int LA8_14 = input.LA(1);

                   	 
                   	int index8_14 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( ((synpred9_AS3_ex() && (!PromoteWhitespace()))) ) { s = 49; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index8_14);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 14 : 
                   	int LA8_28 = input.LA(1);

                   	 
                   	int index8_28 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( ((synpred9_AS3_ex() && (!PromoteWhitespace()))) ) { s = 49; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index8_28);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 15 : 
                   	int LA8_40 = input.LA(1);

                   	 
                   	int index8_40 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( ((synpred9_AS3_ex() && (!PromoteWhitespace()))) ) { s = 49; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index8_40);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 16 : 
                   	int LA8_23 = input.LA(1);

                   	 
                   	int index8_23 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( ((synpred9_AS3_ex() && (!PromoteWhitespace()))) ) { s = 49; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index8_23);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 17 : 
                   	int LA8_33 = input.LA(1);

                   	 
                   	int index8_33 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( ((synpred9_AS3_ex() && (!PromoteWhitespace()))) ) { s = 49; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index8_33);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 18 : 
                   	int LA8_12 = input.LA(1);

                   	 
                   	int index8_12 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( ((synpred9_AS3_ex() && (!PromoteWhitespace()))) ) { s = 49; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index8_12);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 19 : 
                   	int LA8_19 = input.LA(1);

                   	 
                   	int index8_19 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( ((synpred9_AS3_ex() && (!PromoteWhitespace()))) ) { s = 49; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index8_19);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 20 : 
                   	int LA8_31 = input.LA(1);

                   	 
                   	int index8_31 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( ((synpred9_AS3_ex() && (!PromoteWhitespace()))) ) { s = 49; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index8_31);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 21 : 
                   	int LA8_9 = input.LA(1);

                   	 
                   	int index8_9 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( ((synpred9_AS3_ex() && (!PromoteWhitespace()))) ) { s = 49; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index8_9);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 22 : 
                   	int LA8_41 = input.LA(1);

                   	 
                   	int index8_41 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( ((synpred9_AS3_ex() && (!PromoteWhitespace()))) ) { s = 49; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index8_41);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 23 : 
                   	int LA8_38 = input.LA(1);

                   	 
                   	int index8_38 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( ((synpred9_AS3_ex() && (!PromoteWhitespace()))) ) { s = 49; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index8_38);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 24 : 
                   	int LA8_5 = input.LA(1);

                   	 
                   	int index8_5 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( ((synpred9_AS3_ex() && (!PromoteWhitespace()))) ) { s = 49; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index8_5);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 25 : 
                   	int LA8_47 = input.LA(1);

                   	 
                   	int index8_47 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( ((synpred9_AS3_ex() && (!PromoteWhitespace()))) ) { s = 49; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index8_47);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 26 : 
                   	int LA8_24 = input.LA(1);

                   	 
                   	int index8_24 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( ((synpred9_AS3_ex() && (!PromoteWhitespace()))) ) { s = 49; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index8_24);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 27 : 
                   	int LA8_27 = input.LA(1);

                   	 
                   	int index8_27 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( ((synpred9_AS3_ex() && (!PromoteWhitespace()))) ) { s = 49; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index8_27);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 28 : 
                   	int LA8_20 = input.LA(1);

                   	 
                   	int index8_20 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( ((synpred9_AS3_ex() && (!PromoteWhitespace()))) ) { s = 49; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index8_20);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 29 : 
                   	int LA8_44 = input.LA(1);

                   	 
                   	int index8_44 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( ((synpred9_AS3_ex() && (!PromoteWhitespace()))) ) { s = 49; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index8_44);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 30 : 
                   	int LA8_8 = input.LA(1);

                   	 
                   	int index8_8 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( ((synpred9_AS3_ex() && (!PromoteWhitespace()))) ) { s = 49; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index8_8);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 31 : 
                   	int LA8_48 = input.LA(1);

                   	 
                   	int index8_48 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( ((synpred9_AS3_ex() && (!PromoteWhitespace()))) ) { s = 49; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index8_48);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 32 : 
                   	int LA8_15 = input.LA(1);

                   	 
                   	int index8_15 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( ((synpred9_AS3_ex() && (!PromoteWhitespace()))) ) { s = 49; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index8_15);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 33 : 
                   	int LA8_36 = input.LA(1);

                   	 
                   	int index8_36 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( ((synpred9_AS3_ex() && (!PromoteWhitespace()))) ) { s = 49; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index8_36);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 34 : 
                   	int LA8_7 = input.LA(1);

                   	 
                   	int index8_7 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( ((synpred9_AS3_ex() && (!PromoteWhitespace()))) ) { s = 49; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index8_7);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 35 : 
                   	int LA8_46 = input.LA(1);

                   	 
                   	int index8_46 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( ((synpred9_AS3_ex() && (!PromoteWhitespace()))) ) { s = 49; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index8_46);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 36 : 
                   	int LA8_35 = input.LA(1);

                   	 
                   	int index8_35 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( ((synpred9_AS3_ex() && (!PromoteWhitespace()))) ) { s = 49; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index8_35);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 37 : 
                   	int LA8_32 = input.LA(1);

                   	 
                   	int index8_32 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( ((synpred9_AS3_ex() && (!PromoteWhitespace()))) ) { s = 49; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index8_32);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 38 : 
                   	int LA8_16 = input.LA(1);

                   	 
                   	int index8_16 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( ((synpred9_AS3_ex() && (!PromoteWhitespace()))) ) { s = 49; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index8_16);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 39 : 
                   	int LA8_29 = input.LA(1);

                   	 
                   	int index8_29 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( ((synpred9_AS3_ex() && (!PromoteWhitespace()))) ) { s = 49; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index8_29);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 40 : 
                   	int LA8_10 = input.LA(1);

                   	 
                   	int index8_10 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( ((synpred9_AS3_ex() && (!PromoteWhitespace()))) ) { s = 49; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index8_10);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 41 : 
                   	int LA8_37 = input.LA(1);

                   	 
                   	int index8_37 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( ((synpred9_AS3_ex() && (!PromoteWhitespace()))) ) { s = 49; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index8_37);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 42 : 
                   	int LA8_18 = input.LA(1);

                   	 
                   	int index8_18 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( ((synpred9_AS3_ex() && (!PromoteWhitespace()))) ) { s = 49; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index8_18);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 43 : 
                   	int LA8_13 = input.LA(1);

                   	 
                   	int index8_13 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( ((synpred9_AS3_ex() && (!PromoteWhitespace()))) ) { s = 49; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index8_13);
                   	if ( s >= 0 ) return s;
                   	break;
        }
        if (state.backtracking > 0) {state.failed = true; return -1;}
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 8, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA14_eotS =
        "\x0a\uffff";
    const string DFA14_eofS =
        "\x03\uffff\x02\x05\x05\uffff";
    const string DFA14_minS =
        "\x01\x04\x02\uffff\x02\x04\x01\uffff\x04\x00";
    const string DFA14_maxS =
        "\x01\u008e\x02\uffff\x01\u0092\x01\u008e\x01\uffff\x04\x00";
    const string DFA14_acceptS =
        "\x01\uffff\x01\x01\x01\x02\x02\uffff\x01\x03\x04\uffff";
    const string DFA14_specialS =
        "\x06\uffff\x01\x01\x01\x00\x01\x02\x01\x03}>";
    static readonly string[] DFA14_transitionS = {
            "\x36\x02\x13\uffff\x01\x03\x24\uffff\x01\x01\x1b\uffff\x01"+
            "\x02",
            "",
            "",
            "\x42\x05\x01\uffff\x0c\x05\x02\uffff\x0a\x05\x02\uffff\x05"+
            "\x05\x02\uffff\x05\x05\x01\uffff\x01\x05\x02\uffff\x01\x04\x02"+
            "\x05\x0c\uffff\x02\x05\x02\uffff\x01\x05\x04\uffff\x01\x05\x02"+
            "\uffff\x01\x05\x01\uffff\x01\x05\x01\uffff\x03\x05",
            "\x18\x07\x01\x08\x0b\x07\x01\x08\x08\x07\x04\x08\x01\x07\x04"+
            "\x08\x05\uffff\x01\x02\x0d\uffff\x01\x09\x24\uffff\x01\x05\x1b"+
            "\uffff\x01\x06",
            "",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff"
    };

    static readonly short[] DFA14_eot = DFA.UnpackEncodedString(DFA14_eotS);
    static readonly short[] DFA14_eof = DFA.UnpackEncodedString(DFA14_eofS);
    static readonly char[] DFA14_min = DFA.UnpackEncodedStringToUnsignedChars(DFA14_minS);
    static readonly char[] DFA14_max = DFA.UnpackEncodedStringToUnsignedChars(DFA14_maxS);
    static readonly short[] DFA14_accept = DFA.UnpackEncodedString(DFA14_acceptS);
    static readonly short[] DFA14_special = DFA.UnpackEncodedString(DFA14_specialS);
    static readonly short[][] DFA14_transition = DFA.UnpackEncodedStringArray(DFA14_transitionS);

    protected class DFA14 : DFA
    {
        public DFA14(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 14;
            this.eot = DFA14_eot;
            this.eof = DFA14_eof;
            this.min = DFA14_min;
            this.max = DFA14_max;
            this.accept = DFA14_accept;
            this.special = DFA14_special;
            this.transition = DFA14_transition;

        }

        override public string Description
        {
            get { return "1371:1: xmlPropertyIdentifier : ( xmlAttributeIdentifier | xmlQualifiedIdentifier | s= STAR );"; }
        }

    }


    protected internal int DFA14_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
            ITokenStream input = (ITokenStream)_input;
    	int _s = s;
        switch ( s )
        {
               	case 0 : 
                   	int LA14_7 = input.LA(1);

                   	 
                   	int index14_7 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred73_AS3_ex()) ) { s = 2; }

                   	else if ( (true) ) { s = 5; }

                   	 
                   	input.Seek(index14_7);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 1 : 
                   	int LA14_6 = input.LA(1);

                   	 
                   	int index14_6 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred73_AS3_ex()) ) { s = 2; }

                   	else if ( (true) ) { s = 5; }

                   	 
                   	input.Seek(index14_6);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 2 : 
                   	int LA14_8 = input.LA(1);

                   	 
                   	int index14_8 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred73_AS3_ex()) ) { s = 2; }

                   	else if ( (true) ) { s = 5; }

                   	 
                   	input.Seek(index14_8);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 3 : 
                   	int LA14_9 = input.LA(1);

                   	 
                   	int index14_9 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred73_AS3_ex()) ) { s = 2; }

                   	else if ( (true) ) { s = 5; }

                   	 
                   	input.Seek(index14_9);
                   	if ( s >= 0 ) return s;
                   	break;
        }
        if (state.backtracking > 0) {state.failed = true; return -1;}
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 14, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA34_eotS =
        "\x37\uffff";
    const string DFA34_eofS =
        "\x01\x01\x36\uffff";
    const string DFA34_minS =
        "\x01\x04\x01\uffff\x08\x00\x01\uffff\x05\x00\x27\uffff";
    const string DFA34_maxS =
        "\x01\u0092\x01\uffff\x08\x00\x01\uffff\x05\x00\x27\uffff";
    const string DFA34_acceptS =
        "\x01\uffff\x01\x06\x08\uffff\x01\x03\x28\uffff\x01\x01\x01\x02"+
        "\x01\x05\x01\x04";
    const string DFA34_specialS =
        "\x02\uffff\x01\x00\x01\x01\x01\x02\x01\x03\x01\x04\x01\x05\x01"+
        "\x06\x01\x07\x01\uffff\x01\x08\x01\x09\x01\x0a\x01\x0b\x01\x0c\x27"+
        "\uffff}>";
    static readonly string[] DFA34_transitionS = {
            "\x05\x0a\x01\x07\x01\x0a\x01\x0f\x07\x0a\x01\x09\x02\x0a\x01"+
            "\x0e\x03\x0a\x01\x05\x01\x0a\x01\x03\x03\x0a\x03\x05\x05\x0a"+
            "\x01\x08\x03\x0a\x01\x0d\x01\x06\x03\x0a\x03\x08\x01\x04\x01"+
            "\x0c\x04\x03\x02\x0a\x01\uffff\x01\x0a\x01\uffff\x01\x0b\x03"+
            "\uffff\x01\x0a\x07\uffff\x03\x0a\x02\uffff\x02\x0a\x06\uffff"+
            "\x02\x0a\x18\uffff\x02\x0a\x0c\uffff\x02\x0a\x02\uffff\x01\x0a"+
            "\x04\uffff\x01\x0a\x02\uffff\x01\x0a\x01\uffff\x01\x02\x01\uffff"+
            "\x03\x0a",
            "",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
    };

    static readonly short[] DFA34_eot = DFA.UnpackEncodedString(DFA34_eotS);
    static readonly short[] DFA34_eof = DFA.UnpackEncodedString(DFA34_eofS);
    static readonly char[] DFA34_min = DFA.UnpackEncodedStringToUnsignedChars(DFA34_minS);
    static readonly char[] DFA34_max = DFA.UnpackEncodedStringToUnsignedChars(DFA34_maxS);
    static readonly short[] DFA34_accept = DFA.UnpackEncodedString(DFA34_acceptS);
    static readonly short[] DFA34_special = DFA.UnpackEncodedString(DFA34_specialS);
    static readonly short[][] DFA34_transition = DFA.UnpackEncodedStringArray(DFA34_transitionS);

    protected class DFA34 : DFA
    {
        public DFA34(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 34;
            this.eot = DFA34_eot;
            this.eof = DFA34_eof;
            this.min = DFA34_min;
            this.max = DFA34_max;
            this.accept = DFA34_accept;
            this.special = DFA34_special;
            this.transition = DFA34_transition;

        }

        override public string Description
        {
            get { return "()* loopback of 1529:6: ( propertyDeclaration | functionDeclaration | statement | directive | interfaceFunctionDeclaration )*"; }
        }

    }


    protected internal int DFA34_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
            ITokenStream input = (ITokenStream)_input;
    	int _s = s;
        switch ( s )
        {
               	case 0 : 
                   	int LA34_2 = input.LA(1);

                   	 
                   	int index34_2 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred97_AS3_ex()) ) { s = 51; }

                   	else if ( (synpred98_AS3_ex()) ) { s = 52; }

                   	else if ( (synpred99_AS3_ex()) ) { s = 10; }

                   	else if ( (synpred101_AS3_ex()) ) { s = 53; }

                   	 
                   	input.Seek(index34_2);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 1 : 
                   	int LA34_3 = input.LA(1);

                   	 
                   	int index34_3 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred97_AS3_ex()) ) { s = 51; }

                   	else if ( (synpred98_AS3_ex()) ) { s = 52; }

                   	else if ( (synpred99_AS3_ex()) ) { s = 10; }

                   	else if ( (synpred101_AS3_ex()) ) { s = 53; }

                   	 
                   	input.Seek(index34_3);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 2 : 
                   	int LA34_4 = input.LA(1);

                   	 
                   	int index34_4 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred97_AS3_ex()) ) { s = 51; }

                   	else if ( (synpred98_AS3_ex()) ) { s = 52; }

                   	else if ( (synpred99_AS3_ex()) ) { s = 10; }

                   	else if ( (synpred101_AS3_ex()) ) { s = 53; }

                   	 
                   	input.Seek(index34_4);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 3 : 
                   	int LA34_5 = input.LA(1);

                   	 
                   	int index34_5 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred97_AS3_ex()) ) { s = 51; }

                   	else if ( (synpred98_AS3_ex()) ) { s = 52; }

                   	else if ( (synpred99_AS3_ex()) ) { s = 10; }

                   	else if ( (synpred101_AS3_ex()) ) { s = 53; }

                   	 
                   	input.Seek(index34_5);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 4 : 
                   	int LA34_6 = input.LA(1);

                   	 
                   	int index34_6 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred97_AS3_ex()) ) { s = 51; }

                   	else if ( (synpred99_AS3_ex()) ) { s = 10; }

                   	 
                   	input.Seek(index34_6);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 5 : 
                   	int LA34_7 = input.LA(1);

                   	 
                   	int index34_7 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred97_AS3_ex()) ) { s = 51; }

                   	else if ( (synpred99_AS3_ex()) ) { s = 10; }

                   	 
                   	input.Seek(index34_7);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 6 : 
                   	int LA34_8 = input.LA(1);

                   	 
                   	int index34_8 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred97_AS3_ex()) ) { s = 51; }

                   	else if ( (synpred98_AS3_ex()) ) { s = 52; }

                   	else if ( (synpred99_AS3_ex()) ) { s = 10; }

                   	else if ( (synpred101_AS3_ex()) ) { s = 53; }

                   	 
                   	input.Seek(index34_8);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 7 : 
                   	int LA34_9 = input.LA(1);

                   	 
                   	int index34_9 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred98_AS3_ex()) ) { s = 52; }

                   	else if ( (synpred99_AS3_ex()) ) { s = 10; }

                   	else if ( (synpred101_AS3_ex()) ) { s = 53; }

                   	 
                   	input.Seek(index34_9);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 8 : 
                   	int LA34_11 = input.LA(1);

                   	 
                   	int index34_11 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred99_AS3_ex()) ) { s = 10; }

                   	else if ( (synpred100_AS3_ex()) ) { s = 54; }

                   	 
                   	input.Seek(index34_11);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 9 : 
                   	int LA34_12 = input.LA(1);

                   	 
                   	int index34_12 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred99_AS3_ex()) ) { s = 10; }

                   	else if ( (synpred100_AS3_ex()) ) { s = 54; }

                   	 
                   	input.Seek(index34_12);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 10 : 
                   	int LA34_13 = input.LA(1);

                   	 
                   	int index34_13 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred99_AS3_ex()) ) { s = 10; }

                   	else if ( (synpred100_AS3_ex()) ) { s = 54; }

                   	 
                   	input.Seek(index34_13);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 11 : 
                   	int LA34_14 = input.LA(1);

                   	 
                   	int index34_14 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred99_AS3_ex()) ) { s = 10; }

                   	else if ( (synpred100_AS3_ex()) ) { s = 54; }

                   	 
                   	input.Seek(index34_14);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 12 : 
                   	int LA34_15 = input.LA(1);

                   	 
                   	int index34_15 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred99_AS3_ex()) ) { s = 10; }

                   	else if ( (synpred100_AS3_ex()) ) { s = 54; }

                   	 
                   	input.Seek(index34_15);
                   	if ( s >= 0 ) return s;
                   	break;
        }
        if (state.backtracking > 0) {state.failed = true; return -1;}
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 34, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA36_eotS =
        "\x39\uffff";
    const string DFA36_eofS =
        "\x39\uffff";
    const string DFA36_minS =
        "\x01\x04\x0a\x00\x01\uffff\x05\x00\x28\uffff";
    const string DFA36_maxS =
        "\x01\u0092\x0a\x00\x01\uffff\x05\x00\x28\uffff";
    const string DFA36_acceptS =
        "\x0b\uffff\x01\x05\x28\uffff\x01\x01\x01\x02\x01\x03\x01\x04\x01"+
        "\x06";
    const string DFA36_specialS =
        "\x01\uffff\x01\x00\x01\x01\x01\x02\x01\x03\x01\x04\x01\x05\x01"+
        "\x06\x01\x07\x01\x08\x01\x09\x01\uffff\x01\x0a\x01\x0b\x01\x0c\x01"+
        "\x0d\x01\x0e\x28\uffff}>";
    static readonly string[] DFA36_transitionS = {
            "\x04\x0b\x01\x06\x01\x08\x01\x0b\x01\x10\x07\x0b\x01\x0a\x02"+
            "\x0b\x01\x0f\x02\x0b\x01\x05\x01\x04\x01\x0b\x01\x02\x03\x0b"+
            "\x03\x04\x05\x0b\x01\x09\x03\x0b\x01\x0e\x01\x07\x03\x0b\x03"+
            "\x09\x01\x03\x01\x0d\x04\x02\x02\x0b\x01\uffff\x01\x0b\x01\uffff"+
            "\x01\x0c\x03\uffff\x01\x0b\x07\uffff\x03\x0b\x02\uffff\x02\x0b"+
            "\x06\uffff\x02\x0b\x18\uffff\x02\x0b\x0c\uffff\x02\x0b\x02\uffff"+
            "\x01\x0b\x04\uffff\x01\x0b\x02\uffff\x01\x0b\x01\uffff\x01\x01"+
            "\x01\uffff\x03\x0b",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
    };

    static readonly short[] DFA36_eot = DFA.UnpackEncodedString(DFA36_eotS);
    static readonly short[] DFA36_eof = DFA.UnpackEncodedString(DFA36_eofS);
    static readonly char[] DFA36_min = DFA.UnpackEncodedStringToUnsignedChars(DFA36_minS);
    static readonly char[] DFA36_max = DFA.UnpackEncodedStringToUnsignedChars(DFA36_maxS);
    static readonly short[] DFA36_accept = DFA.UnpackEncodedString(DFA36_acceptS);
    static readonly short[] DFA36_special = DFA.UnpackEncodedString(DFA36_specialS);
    static readonly short[][] DFA36_transition = DFA.UnpackEncodedStringArray(DFA36_transitionS);

    protected class DFA36 : DFA
    {
        public DFA36(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 36;
            this.eot = DFA36_eot;
            this.eof = DFA36_eof;
            this.min = DFA36_min;
            this.max = DFA36_max;
            this.accept = DFA36_accept;
            this.special = DFA36_special;
            this.transition = DFA36_transition;

        }

        override public string Description
        {
            get { return "1532:1: packageElement : ( classOrInterfaceDecl | propertyDeclaration | functionDeclaration | interfaceFunctionDeclaration | statement | directive );"; }
        }

    }


    protected internal int DFA36_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
            ITokenStream input = (ITokenStream)_input;
    	int _s = s;
        switch ( s )
        {
               	case 0 : 
                   	int LA36_1 = input.LA(1);

                   	 
                   	int index36_1 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred103_AS3_ex()) ) { s = 52; }

                   	else if ( (synpred104_AS3_ex()) ) { s = 53; }

                   	else if ( (synpred105_AS3_ex()) ) { s = 54; }

                   	else if ( (synpred106_AS3_ex()) ) { s = 55; }

                   	else if ( (synpred107_AS3_ex()) ) { s = 11; }

                   	 
                   	input.Seek(index36_1);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 1 : 
                   	int LA36_2 = input.LA(1);

                   	 
                   	int index36_2 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred103_AS3_ex()) ) { s = 52; }

                   	else if ( (synpred104_AS3_ex()) ) { s = 53; }

                   	else if ( (synpred105_AS3_ex()) ) { s = 54; }

                   	else if ( (synpred106_AS3_ex()) ) { s = 55; }

                   	else if ( (synpred107_AS3_ex()) ) { s = 11; }

                   	 
                   	input.Seek(index36_2);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 2 : 
                   	int LA36_3 = input.LA(1);

                   	 
                   	int index36_3 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred103_AS3_ex()) ) { s = 52; }

                   	else if ( (synpred104_AS3_ex()) ) { s = 53; }

                   	else if ( (synpred105_AS3_ex()) ) { s = 54; }

                   	else if ( (synpred106_AS3_ex()) ) { s = 55; }

                   	else if ( (synpred107_AS3_ex()) ) { s = 11; }

                   	 
                   	input.Seek(index36_3);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 3 : 
                   	int LA36_4 = input.LA(1);

                   	 
                   	int index36_4 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred103_AS3_ex()) ) { s = 52; }

                   	else if ( (synpred104_AS3_ex()) ) { s = 53; }

                   	else if ( (synpred105_AS3_ex()) ) { s = 54; }

                   	else if ( (synpred106_AS3_ex()) ) { s = 55; }

                   	else if ( (synpred107_AS3_ex()) ) { s = 11; }

                   	 
                   	input.Seek(index36_4);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 4 : 
                   	int LA36_5 = input.LA(1);

                   	 
                   	int index36_5 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred103_AS3_ex()) ) { s = 52; }

                   	else if ( (synpred107_AS3_ex()) ) { s = 11; }

                   	 
                   	input.Seek(index36_5);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 5 : 
                   	int LA36_6 = input.LA(1);

                   	 
                   	int index36_6 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred103_AS3_ex()) ) { s = 52; }

                   	else if ( (synpred107_AS3_ex()) ) { s = 11; }

                   	 
                   	input.Seek(index36_6);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 6 : 
                   	int LA36_7 = input.LA(1);

                   	 
                   	int index36_7 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred104_AS3_ex()) ) { s = 53; }

                   	else if ( (synpred107_AS3_ex()) ) { s = 11; }

                   	 
                   	input.Seek(index36_7);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 7 : 
                   	int LA36_8 = input.LA(1);

                   	 
                   	int index36_8 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred104_AS3_ex()) ) { s = 53; }

                   	else if ( (synpred107_AS3_ex()) ) { s = 11; }

                   	 
                   	input.Seek(index36_8);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 8 : 
                   	int LA36_9 = input.LA(1);

                   	 
                   	int index36_9 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred103_AS3_ex()) ) { s = 52; }

                   	else if ( (synpred104_AS3_ex()) ) { s = 53; }

                   	else if ( (synpred105_AS3_ex()) ) { s = 54; }

                   	else if ( (synpred106_AS3_ex()) ) { s = 55; }

                   	else if ( (synpred107_AS3_ex()) ) { s = 11; }

                   	 
                   	input.Seek(index36_9);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 9 : 
                   	int LA36_10 = input.LA(1);

                   	 
                   	int index36_10 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred105_AS3_ex()) ) { s = 54; }

                   	else if ( (synpred106_AS3_ex()) ) { s = 55; }

                   	else if ( (synpred107_AS3_ex()) ) { s = 11; }

                   	 
                   	input.Seek(index36_10);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 10 : 
                   	int LA36_12 = input.LA(1);

                   	 
                   	int index36_12 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred107_AS3_ex()) ) { s = 11; }

                   	else if ( (true) ) { s = 56; }

                   	 
                   	input.Seek(index36_12);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 11 : 
                   	int LA36_13 = input.LA(1);

                   	 
                   	int index36_13 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred107_AS3_ex()) ) { s = 11; }

                   	else if ( (true) ) { s = 56; }

                   	 
                   	input.Seek(index36_13);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 12 : 
                   	int LA36_14 = input.LA(1);

                   	 
                   	int index36_14 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred107_AS3_ex()) ) { s = 11; }

                   	else if ( (true) ) { s = 56; }

                   	 
                   	input.Seek(index36_14);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 13 : 
                   	int LA36_15 = input.LA(1);

                   	 
                   	int index36_15 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred107_AS3_ex()) ) { s = 11; }

                   	else if ( (true) ) { s = 56; }

                   	 
                   	input.Seek(index36_15);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 14 : 
                   	int LA36_16 = input.LA(1);

                   	 
                   	int index36_16 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred107_AS3_ex()) ) { s = 11; }

                   	else if ( (true) ) { s = 56; }

                   	 
                   	input.Seek(index36_16);
                   	if ( s >= 0 ) return s;
                   	break;
        }
        if (state.backtracking > 0) {state.failed = true; return -1;}
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 36, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA54_eotS =
        "\x35\uffff";
    const string DFA54_eofS =
        "\x35\uffff";
    const string DFA54_minS =
        "\x01\x04\x08\x00\x01\uffff\x05\x00\x26\uffff";
    const string DFA54_maxS =
        "\x01\u0092\x08\x00\x01\uffff\x05\x00\x26\uffff";
    const string DFA54_acceptS =
        "\x09\uffff\x01\x03\x28\uffff\x01\x01\x01\x02\x01\x04";
    const string DFA54_specialS =
        "\x01\uffff\x01\x00\x01\x01\x01\x02\x01\x03\x01\x04\x01\x05\x01"+
        "\x06\x01\x07\x01\uffff\x01\x08\x01\x09\x01\x0a\x01\x0b\x01\x0c\x26"+
        "\uffff}>";
    static readonly string[] DFA54_transitionS = {
            "\x05\x09\x01\x06\x01\x09\x01\x0e\x07\x09\x01\x08\x02\x09\x01"+
            "\x0d\x03\x09\x01\x04\x01\x09\x01\x02\x03\x09\x03\x04\x05\x09"+
            "\x01\x07\x03\x09\x01\x0c\x01\x05\x03\x09\x03\x07\x01\x03\x01"+
            "\x0b\x04\x02\x02\x09\x01\uffff\x01\x09\x01\uffff\x01\x0a\x03"+
            "\uffff\x01\x09\x07\uffff\x03\x09\x02\uffff\x02\x09\x06\uffff"+
            "\x02\x09\x18\uffff\x02\x09\x0c\uffff\x02\x09\x02\uffff\x01\x09"+
            "\x04\uffff\x01\x09\x02\uffff\x01\x09\x01\uffff\x01\x01\x01\uffff"+
            "\x03\x09",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
    };

    static readonly short[] DFA54_eot = DFA.UnpackEncodedString(DFA54_eotS);
    static readonly short[] DFA54_eof = DFA.UnpackEncodedString(DFA54_eofS);
    static readonly char[] DFA54_min = DFA.UnpackEncodedStringToUnsignedChars(DFA54_minS);
    static readonly char[] DFA54_max = DFA.UnpackEncodedStringToUnsignedChars(DFA54_maxS);
    static readonly short[] DFA54_accept = DFA.UnpackEncodedString(DFA54_acceptS);
    static readonly short[] DFA54_special = DFA.UnpackEncodedString(DFA54_specialS);
    static readonly short[][] DFA54_transition = DFA.UnpackEncodedStringArray(DFA54_transitionS);

    protected class DFA54 : DFA
    {
        public DFA54(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 54;
            this.eot = DFA54_eot;
            this.eof = DFA54_eof;
            this.min = DFA54_min;
            this.max = DFA54_max;
            this.accept = DFA54_accept;
            this.special = DFA54_special;
            this.transition = DFA54_transition;

        }

        override public string Description
        {
            get { return "1655:1: classBodyElement : ( propertyDeclaration | functionDeclaration | statement | directive );"; }
        }

    }


    protected internal int DFA54_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
            ITokenStream input = (ITokenStream)_input;
    	int _s = s;
        switch ( s )
        {
               	case 0 : 
                   	int LA54_1 = input.LA(1);

                   	 
                   	int index54_1 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred129_AS3_ex()) ) { s = 50; }

                   	else if ( (synpred130_AS3_ex()) ) { s = 51; }

                   	else if ( (synpred131_AS3_ex()) ) { s = 9; }

                   	 
                   	input.Seek(index54_1);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 1 : 
                   	int LA54_2 = input.LA(1);

                   	 
                   	int index54_2 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred129_AS3_ex()) ) { s = 50; }

                   	else if ( (synpred130_AS3_ex()) ) { s = 51; }

                   	else if ( (synpred131_AS3_ex()) ) { s = 9; }

                   	 
                   	input.Seek(index54_2);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 2 : 
                   	int LA54_3 = input.LA(1);

                   	 
                   	int index54_3 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred129_AS3_ex()) ) { s = 50; }

                   	else if ( (synpred130_AS3_ex()) ) { s = 51; }

                   	else if ( (synpred131_AS3_ex()) ) { s = 9; }

                   	 
                   	input.Seek(index54_3);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 3 : 
                   	int LA54_4 = input.LA(1);

                   	 
                   	int index54_4 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred129_AS3_ex()) ) { s = 50; }

                   	else if ( (synpred130_AS3_ex()) ) { s = 51; }

                   	else if ( (synpred131_AS3_ex()) ) { s = 9; }

                   	 
                   	input.Seek(index54_4);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 4 : 
                   	int LA54_5 = input.LA(1);

                   	 
                   	int index54_5 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred129_AS3_ex()) ) { s = 50; }

                   	else if ( (synpred131_AS3_ex()) ) { s = 9; }

                   	 
                   	input.Seek(index54_5);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 5 : 
                   	int LA54_6 = input.LA(1);

                   	 
                   	int index54_6 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred129_AS3_ex()) ) { s = 50; }

                   	else if ( (synpred131_AS3_ex()) ) { s = 9; }

                   	 
                   	input.Seek(index54_6);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 6 : 
                   	int LA54_7 = input.LA(1);

                   	 
                   	int index54_7 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred129_AS3_ex()) ) { s = 50; }

                   	else if ( (synpred130_AS3_ex()) ) { s = 51; }

                   	else if ( (synpred131_AS3_ex()) ) { s = 9; }

                   	 
                   	input.Seek(index54_7);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 7 : 
                   	int LA54_8 = input.LA(1);

                   	 
                   	int index54_8 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred130_AS3_ex()) ) { s = 51; }

                   	else if ( (synpred131_AS3_ex()) ) { s = 9; }

                   	 
                   	input.Seek(index54_8);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 8 : 
                   	int LA54_10 = input.LA(1);

                   	 
                   	int index54_10 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred131_AS3_ex()) ) { s = 9; }

                   	else if ( (true) ) { s = 52; }

                   	 
                   	input.Seek(index54_10);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 9 : 
                   	int LA54_11 = input.LA(1);

                   	 
                   	int index54_11 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred131_AS3_ex()) ) { s = 9; }

                   	else if ( (true) ) { s = 52; }

                   	 
                   	input.Seek(index54_11);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 10 : 
                   	int LA54_12 = input.LA(1);

                   	 
                   	int index54_12 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred131_AS3_ex()) ) { s = 9; }

                   	else if ( (true) ) { s = 52; }

                   	 
                   	input.Seek(index54_12);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 11 : 
                   	int LA54_13 = input.LA(1);

                   	 
                   	int index54_13 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred131_AS3_ex()) ) { s = 9; }

                   	else if ( (true) ) { s = 52; }

                   	 
                   	input.Seek(index54_13);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 12 : 
                   	int LA54_14 = input.LA(1);

                   	 
                   	int index54_14 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred131_AS3_ex()) ) { s = 9; }

                   	else if ( (true) ) { s = 52; }

                   	 
                   	input.Seek(index54_14);
                   	if ( s >= 0 ) return s;
                   	break;
        }
        if (state.backtracking > 0) {state.failed = true; return -1;}
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 54, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA55_eotS =
        "\x35\uffff";
    const string DFA55_eofS =
        "\x35\uffff";
    const string DFA55_minS =
        "\x01\x04\x08\x00\x01\uffff\x05\x00\x26\uffff";
    const string DFA55_maxS =
        "\x01\u0092\x08\x00\x01\uffff\x05\x00\x26\uffff";
    const string DFA55_acceptS =
        "\x09\uffff\x01\x03\x28\uffff\x01\x01\x01\x02\x01\x04";
    const string DFA55_specialS =
        "\x01\uffff\x01\x00\x01\x01\x01\x02\x01\x03\x01\x04\x01\x05\x01"+
        "\x06\x01\x07\x01\uffff\x01\x08\x01\x09\x01\x0a\x01\x0b\x01\x0c\x26"+
        "\uffff}>";
    static readonly string[] DFA55_transitionS = {
            "\x05\x09\x01\x06\x01\x09\x01\x0e\x07\x09\x01\x08\x02\x09\x01"+
            "\x0d\x03\x09\x01\x04\x01\x09\x01\x02\x03\x09\x03\x04\x05\x09"+
            "\x01\x07\x03\x09\x01\x0c\x01\x05\x03\x09\x03\x07\x01\x03\x01"+
            "\x0b\x04\x02\x02\x09\x01\uffff\x01\x09\x01\uffff\x01\x0a\x03"+
            "\uffff\x01\x09\x07\uffff\x03\x09\x02\uffff\x02\x09\x06\uffff"+
            "\x02\x09\x18\uffff\x02\x09\x0c\uffff\x02\x09\x02\uffff\x01\x09"+
            "\x04\uffff\x01\x09\x02\uffff\x01\x09\x01\uffff\x01\x01\x01\uffff"+
            "\x03\x09",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
    };

    static readonly short[] DFA55_eot = DFA.UnpackEncodedString(DFA55_eotS);
    static readonly short[] DFA55_eof = DFA.UnpackEncodedString(DFA55_eofS);
    static readonly char[] DFA55_min = DFA.UnpackEncodedStringToUnsignedChars(DFA55_minS);
    static readonly char[] DFA55_max = DFA.UnpackEncodedStringToUnsignedChars(DFA55_maxS);
    static readonly short[] DFA55_accept = DFA.UnpackEncodedString(DFA55_acceptS);
    static readonly short[] DFA55_special = DFA.UnpackEncodedString(DFA55_specialS);
    static readonly short[][] DFA55_transition = DFA.UnpackEncodedStringArray(DFA55_transitionS);

    protected class DFA55 : DFA
    {
        public DFA55(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 55;
            this.eot = DFA55_eot;
            this.eof = DFA55_eof;
            this.min = DFA55_min;
            this.max = DFA55_max;
            this.accept = DFA55_accept;
            this.special = DFA55_special;
            this.transition = DFA55_transition;

        }

        override public string Description
        {
            get { return "1659:1: interfaceElement : ( propertyDeclaration | interfaceFunctionDeclaration | statement | directive );"; }
        }

    }


    protected internal int DFA55_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
            ITokenStream input = (ITokenStream)_input;
    	int _s = s;
        switch ( s )
        {
               	case 0 : 
                   	int LA55_1 = input.LA(1);

                   	 
                   	int index55_1 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred132_AS3_ex()) ) { s = 50; }

                   	else if ( (synpred133_AS3_ex()) ) { s = 51; }

                   	else if ( (synpred134_AS3_ex()) ) { s = 9; }

                   	 
                   	input.Seek(index55_1);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 1 : 
                   	int LA55_2 = input.LA(1);

                   	 
                   	int index55_2 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred132_AS3_ex()) ) { s = 50; }

                   	else if ( (synpred133_AS3_ex()) ) { s = 51; }

                   	else if ( (synpred134_AS3_ex()) ) { s = 9; }

                   	 
                   	input.Seek(index55_2);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 2 : 
                   	int LA55_3 = input.LA(1);

                   	 
                   	int index55_3 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred132_AS3_ex()) ) { s = 50; }

                   	else if ( (synpred133_AS3_ex()) ) { s = 51; }

                   	else if ( (synpred134_AS3_ex()) ) { s = 9; }

                   	 
                   	input.Seek(index55_3);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 3 : 
                   	int LA55_4 = input.LA(1);

                   	 
                   	int index55_4 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred132_AS3_ex()) ) { s = 50; }

                   	else if ( (synpred133_AS3_ex()) ) { s = 51; }

                   	else if ( (synpred134_AS3_ex()) ) { s = 9; }

                   	 
                   	input.Seek(index55_4);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 4 : 
                   	int LA55_5 = input.LA(1);

                   	 
                   	int index55_5 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred132_AS3_ex()) ) { s = 50; }

                   	else if ( (synpred134_AS3_ex()) ) { s = 9; }

                   	 
                   	input.Seek(index55_5);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 5 : 
                   	int LA55_6 = input.LA(1);

                   	 
                   	int index55_6 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred132_AS3_ex()) ) { s = 50; }

                   	else if ( (synpred134_AS3_ex()) ) { s = 9; }

                   	 
                   	input.Seek(index55_6);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 6 : 
                   	int LA55_7 = input.LA(1);

                   	 
                   	int index55_7 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred132_AS3_ex()) ) { s = 50; }

                   	else if ( (synpred133_AS3_ex()) ) { s = 51; }

                   	else if ( (synpred134_AS3_ex()) ) { s = 9; }

                   	 
                   	input.Seek(index55_7);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 7 : 
                   	int LA55_8 = input.LA(1);

                   	 
                   	int index55_8 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred133_AS3_ex()) ) { s = 51; }

                   	else if ( (synpred134_AS3_ex()) ) { s = 9; }

                   	 
                   	input.Seek(index55_8);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 8 : 
                   	int LA55_10 = input.LA(1);

                   	 
                   	int index55_10 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred134_AS3_ex()) ) { s = 9; }

                   	else if ( (true) ) { s = 52; }

                   	 
                   	input.Seek(index55_10);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 9 : 
                   	int LA55_11 = input.LA(1);

                   	 
                   	int index55_11 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred134_AS3_ex()) ) { s = 9; }

                   	else if ( (true) ) { s = 52; }

                   	 
                   	input.Seek(index55_11);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 10 : 
                   	int LA55_12 = input.LA(1);

                   	 
                   	int index55_12 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred134_AS3_ex()) ) { s = 9; }

                   	else if ( (true) ) { s = 52; }

                   	 
                   	input.Seek(index55_12);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 11 : 
                   	int LA55_13 = input.LA(1);

                   	 
                   	int index55_13 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred134_AS3_ex()) ) { s = 9; }

                   	else if ( (true) ) { s = 52; }

                   	 
                   	input.Seek(index55_13);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 12 : 
                   	int LA55_14 = input.LA(1);

                   	 
                   	int index55_14 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred134_AS3_ex()) ) { s = 9; }

                   	else if ( (true) ) { s = 52; }

                   	 
                   	input.Seek(index55_14);
                   	if ( s >= 0 ) return s;
                   	break;
        }
        if (state.backtracking > 0) {state.failed = true; return -1;}
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 55, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA74_eotS =
        "\x34\uffff";
    const string DFA74_eofS =
        "\x34\uffff";
    const string DFA74_minS =
        "\x01\x04\x01\uffff\x02\x00\x06\uffff\x01\x00\x0b\uffff\x01\x00"+
        "\x19\uffff\x02\x00\x02\uffff";
    const string DFA74_maxS =
        "\x01\u0092\x01\uffff\x02\x00\x06\uffff\x01\x00\x0b\uffff\x01\x00"+
        "\x19\uffff\x02\x00\x02\uffff";
    const string DFA74_acceptS =
        "\x01\uffff\x01\x03\x02\uffff\x01\x01\x2e\uffff\x01\x02";
    const string DFA74_specialS =
        "\x02\uffff\x01\x00\x01\x01\x06\uffff\x01\x02\x0b\uffff\x01\x03"+
        "\x19\uffff\x01\x04\x01\x05\x02\uffff}>";
    static readonly string[] DFA74_transitionS = {
            "\x0f\x04\x01\x16\x06\x04\x01\x30\x01\x04\x01\x0a\x03\x04\x03"+
            "\x30\x05\x04\x01\x31\x08\x04\x03\x31\x01\x03\x01\x04\x04\x0a"+
            "\x02\x04\x01\x01\x01\x04\x01\uffff\x01\x04\x03\uffff\x01\x04"+
            "\x07\uffff\x03\x04\x02\uffff\x02\x04\x06\uffff\x02\x04\x18\uffff"+
            "\x02\x04\x0c\uffff\x02\x04\x02\uffff\x01\x04\x04\uffff\x01\x04"+
            "\x02\uffff\x01\x04\x01\uffff\x01\x02\x01\uffff\x03\x04",
            "",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "\x01\uffff",
            "\x01\uffff",
            "",
            ""
    };

    static readonly short[] DFA74_eot = DFA.UnpackEncodedString(DFA74_eotS);
    static readonly short[] DFA74_eof = DFA.UnpackEncodedString(DFA74_eofS);
    static readonly char[] DFA74_min = DFA.UnpackEncodedStringToUnsignedChars(DFA74_minS);
    static readonly char[] DFA74_max = DFA.UnpackEncodedStringToUnsignedChars(DFA74_maxS);
    static readonly short[] DFA74_accept = DFA.UnpackEncodedString(DFA74_acceptS);
    static readonly short[] DFA74_special = DFA.UnpackEncodedString(DFA74_specialS);
    static readonly short[][] DFA74_transition = DFA.UnpackEncodedStringArray(DFA74_transitionS);

    protected class DFA74 : DFA
    {
        public DFA74(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 74;
            this.eot = DFA74_eot;
            this.eof = DFA74_eof;
            this.min = DFA74_min;
            this.max = DFA74_max;
            this.accept = DFA74_accept;
            this.special = DFA74_special;
            this.transition = DFA74_transition;

        }

        override public string Description
        {
            get { return "()* loopback of 1745:7: ( statement | functionDeclaration )*"; }
        }

    }


    protected internal int DFA74_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
            ITokenStream input = (ITokenStream)_input;
    	int _s = s;
        switch ( s )
        {
               	case 0 : 
                   	int LA74_2 = input.LA(1);

                   	 
                   	int index74_2 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred157_AS3_ex()) ) { s = 4; }

                   	else if ( (synpred158_AS3_ex()) ) { s = 51; }

                   	 
                   	input.Seek(index74_2);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 1 : 
                   	int LA74_3 = input.LA(1);

                   	 
                   	int index74_3 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred157_AS3_ex()) ) { s = 4; }

                   	else if ( (synpred158_AS3_ex()) ) { s = 51; }

                   	 
                   	input.Seek(index74_3);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 2 : 
                   	int LA74_10 = input.LA(1);

                   	 
                   	int index74_10 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred157_AS3_ex()) ) { s = 4; }

                   	else if ( (synpred158_AS3_ex()) ) { s = 51; }

                   	 
                   	input.Seek(index74_10);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 3 : 
                   	int LA74_22 = input.LA(1);

                   	 
                   	int index74_22 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred157_AS3_ex()) ) { s = 4; }

                   	else if ( (synpred158_AS3_ex()) ) { s = 51; }

                   	 
                   	input.Seek(index74_22);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 4 : 
                   	int LA74_48 = input.LA(1);

                   	 
                   	int index74_48 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred157_AS3_ex()) ) { s = 4; }

                   	else if ( (synpred158_AS3_ex()) ) { s = 51; }

                   	 
                   	input.Seek(index74_48);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 5 : 
                   	int LA74_49 = input.LA(1);

                   	 
                   	int index74_49 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred157_AS3_ex()) ) { s = 4; }

                   	else if ( (synpred158_AS3_ex()) ) { s = 51; }

                   	 
                   	input.Seek(index74_49);
                   	if ( s >= 0 ) return s;
                   	break;
        }
        if (state.backtracking > 0) {state.failed = true; return -1;}
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 74, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA76_eotS =
        "\x43\uffff";
    const string DFA76_eofS =
        "\x43\uffff";
    const string DFA76_minS =
        "\x01\x04\x09\x00\x16\uffff\x01\x00\x01\uffff\x0b\x00\x01\uffff"+
        "\x01\x00\x14\uffff";
    const string DFA76_maxS =
        "\x01\u0092\x09\x00\x16\uffff\x01\x00\x01\uffff\x0b\x00\x01\uffff"+
        "\x01\x00\x14\uffff";
    const string DFA76_acceptS =
        "\x0a\uffff\x01\x04\x22\uffff\x01\x13\x02\uffff\x01\x01\x01\x07"+
        "\x01\x14\x01\x03\x01\x02\x01\x05\x01\x06\x01\x08\x01\x09\x01\x0a"+
        "\x01\x0b\x01\x0c\x01\x0d\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12"+
        "\x01\x15";
    const string DFA76_specialS =
        "\x01\uffff\x01\x00\x01\x01\x01\x02\x01\x03\x01\x04\x01\x05\x01"+
        "\x06\x01\x07\x01\x08\x16\uffff\x01\x09\x01\uffff\x01\x0a\x01\x0b"+
        "\x01\x0c\x01\x0d\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13"+
        "\x01\x14\x01\uffff\x01\x15\x14\uffff}>";
    static readonly string[] DFA76_transitionS = {
            "\x01\x0a\x01\x26\x03\x0a\x01\x20\x01\x27\x01\x08\x01\x0a\x01"+
            "\x29\x04\x0a\x01\x28\x01\x0a\x01\x2b\x01\x0a\x01\x07\x05\x0a"+
            "\x01\x09\x06\x0a\x01\x25\x01\x0a\x01\x23\x01\x0a\x01\x2e\x01"+
            "\x09\x01\x0a\x01\x22\x01\x0a\x01\x06\x01\x2c\x01\x0a\x01\x2a"+
            "\x01\x24\x03\x09\x01\x02\x01\x05\x04\x09\x01\x2d\x01\x03\x01"+
            "\uffff\x01\x0a\x01\uffff\x01\x04\x03\uffff\x01\x0a\x07\uffff"+
            "\x03\x0a\x02\uffff\x02\x0a\x06\uffff\x02\x0a\x18\uffff\x02\x0a"+
            "\x0c\uffff\x02\x0a\x02\uffff\x01\x0a\x04\uffff\x01\x0a\x02\uffff"+
            "\x01\x0a\x01\uffff\x01\x01\x01\uffff\x03\x0a",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "\x01\uffff",
            "",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
    };

    static readonly short[] DFA76_eot = DFA.UnpackEncodedString(DFA76_eotS);
    static readonly short[] DFA76_eof = DFA.UnpackEncodedString(DFA76_eofS);
    static readonly char[] DFA76_min = DFA.UnpackEncodedStringToUnsignedChars(DFA76_minS);
    static readonly char[] DFA76_max = DFA.UnpackEncodedStringToUnsignedChars(DFA76_maxS);
    static readonly short[] DFA76_accept = DFA.UnpackEncodedString(DFA76_acceptS);
    static readonly short[] DFA76_special = DFA.UnpackEncodedString(DFA76_specialS);
    static readonly short[][] DFA76_transition = DFA.UnpackEncodedStringArray(DFA76_transitionS);

    protected class DFA76 : DFA
    {
        public DFA76(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 76;
            this.eot = DFA76_eot;
            this.eof = DFA76_eof;
            this.min = DFA76_min;
            this.max = DFA76_max;
            this.accept = DFA76_accept;
            this.special = DFA76_special;
            this.transition = DFA76_transition;

        }

        override public string Description
        {
            get { return "1783:1: statement : ( blockStatement | directive | namespaceDirective | expression semic | constantVarStatement | tryStatement | labelledStatement | switchStatement | withStatement | returnStatement | breakStatement | continueStatement | forStatement | forInStatement | forEachInStatement | doWhileStatement | whileStatement | ifStatement | emptyStatement | variableStatement | throwStatement );"; }
        }

    }


    protected internal int DFA76_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
            ITokenStream input = (ITokenStream)_input;
    	int _s = s;
        switch ( s )
        {
               	case 0 : 
                   	int LA76_1 = input.LA(1);

                   	 
                   	int index76_1 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred169_AS3_ex()) ) { s = 48; }

                   	else if ( (synpred172_AS3_ex()) ) { s = 10; }

                   	else if ( (synpred175_AS3_ex()) ) { s = 49; }

                   	else if ( (synpred188_AS3_ex()) ) { s = 50; }

                   	 
                   	input.Seek(index76_1);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 1 : 
                   	int LA76_2 = input.LA(1);

                   	 
                   	int index76_2 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred169_AS3_ex()) ) { s = 48; }

                   	else if ( (synpred171_AS3_ex()) ) { s = 51; }

                   	else if ( (synpred172_AS3_ex()) ) { s = 10; }

                   	 
                   	input.Seek(index76_2);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 2 : 
                   	int LA76_3 = input.LA(1);

                   	 
                   	int index76_3 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred169_AS3_ex()) ) { s = 48; }

                   	else if ( (synpred172_AS3_ex()) ) { s = 10; }

                   	 
                   	input.Seek(index76_3);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 3 : 
                   	int LA76_4 = input.LA(1);

                   	 
                   	int index76_4 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred170_AS3_ex()) ) { s = 52; }

                   	else if ( (synpred172_AS3_ex()) ) { s = 10; }

                   	 
                   	input.Seek(index76_4);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 4 : 
                   	int LA76_5 = input.LA(1);

                   	 
                   	int index76_5 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred170_AS3_ex()) ) { s = 52; }

                   	else if ( (synpred172_AS3_ex()) ) { s = 10; }

                   	 
                   	input.Seek(index76_5);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 5 : 
                   	int LA76_6 = input.LA(1);

                   	 
                   	int index76_6 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred170_AS3_ex()) ) { s = 52; }

                   	else if ( (synpred172_AS3_ex()) ) { s = 10; }

                   	 
                   	input.Seek(index76_6);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 6 : 
                   	int LA76_7 = input.LA(1);

                   	 
                   	int index76_7 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred170_AS3_ex()) ) { s = 52; }

                   	else if ( (synpred172_AS3_ex()) ) { s = 10; }

                   	 
                   	input.Seek(index76_7);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 7 : 
                   	int LA76_8 = input.LA(1);

                   	 
                   	int index76_8 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred170_AS3_ex()) ) { s = 52; }

                   	else if ( (synpred172_AS3_ex()) ) { s = 10; }

                   	 
                   	input.Seek(index76_8);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 8 : 
                   	int LA76_9 = input.LA(1);

                   	 
                   	int index76_9 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred169_AS3_ex()) ) { s = 48; }

                   	else if ( (synpred172_AS3_ex()) ) { s = 10; }

                   	 
                   	input.Seek(index76_9);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 9 : 
                   	int LA76_32 = input.LA(1);

                   	 
                   	int index76_32 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred172_AS3_ex()) ) { s = 10; }

                   	else if ( (synpred173_AS3_ex()) ) { s = 53; }

                   	 
                   	input.Seek(index76_32);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 10 : 
                   	int LA76_34 = input.LA(1);

                   	 
                   	int index76_34 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred172_AS3_ex()) ) { s = 10; }

                   	else if ( (synpred174_AS3_ex()) ) { s = 54; }

                   	 
                   	input.Seek(index76_34);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 11 : 
                   	int LA76_35 = input.LA(1);

                   	 
                   	int index76_35 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred172_AS3_ex()) ) { s = 10; }

                   	else if ( (synpred176_AS3_ex()) ) { s = 55; }

                   	 
                   	input.Seek(index76_35);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 12 : 
                   	int LA76_36 = input.LA(1);

                   	 
                   	int index76_36 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred172_AS3_ex()) ) { s = 10; }

                   	else if ( (synpred177_AS3_ex()) ) { s = 56; }

                   	 
                   	input.Seek(index76_36);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 13 : 
                   	int LA76_37 = input.LA(1);

                   	 
                   	int index76_37 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred172_AS3_ex()) ) { s = 10; }

                   	else if ( (synpred178_AS3_ex()) ) { s = 57; }

                   	 
                   	input.Seek(index76_37);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 14 : 
                   	int LA76_38 = input.LA(1);

                   	 
                   	int index76_38 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred172_AS3_ex()) ) { s = 10; }

                   	else if ( (synpred179_AS3_ex()) ) { s = 58; }

                   	 
                   	input.Seek(index76_38);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 15 : 
                   	int LA76_39 = input.LA(1);

                   	 
                   	int index76_39 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred172_AS3_ex()) ) { s = 10; }

                   	else if ( (synpred180_AS3_ex()) ) { s = 59; }

                   	 
                   	input.Seek(index76_39);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 16 : 
                   	int LA76_40 = input.LA(1);

                   	 
                   	int index76_40 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred172_AS3_ex()) ) { s = 10; }

                   	else if ( (synpred181_AS3_ex()) ) { s = 60; }

                   	else if ( (synpred182_AS3_ex()) ) { s = 61; }

                   	else if ( (synpred183_AS3_ex()) ) { s = 62; }

                   	 
                   	input.Seek(index76_40);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 17 : 
                   	int LA76_41 = input.LA(1);

                   	 
                   	int index76_41 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred172_AS3_ex()) ) { s = 10; }

                   	else if ( (synpred184_AS3_ex()) ) { s = 63; }

                   	 
                   	input.Seek(index76_41);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 18 : 
                   	int LA76_42 = input.LA(1);

                   	 
                   	int index76_42 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred172_AS3_ex()) ) { s = 10; }

                   	else if ( (synpred185_AS3_ex()) ) { s = 64; }

                   	 
                   	input.Seek(index76_42);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 19 : 
                   	int LA76_43 = input.LA(1);

                   	 
                   	int index76_43 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred172_AS3_ex()) ) { s = 10; }

                   	else if ( (synpred186_AS3_ex()) ) { s = 65; }

                   	 
                   	input.Seek(index76_43);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 20 : 
                   	int LA76_44 = input.LA(1);

                   	 
                   	int index76_44 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred172_AS3_ex()) ) { s = 10; }

                   	else if ( (synpred188_AS3_ex()) ) { s = 50; }

                   	 
                   	input.Seek(index76_44);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 21 : 
                   	int LA76_46 = input.LA(1);

                   	 
                   	int index76_46 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred172_AS3_ex()) ) { s = 10; }

                   	else if ( (true) ) { s = 66; }

                   	 
                   	input.Seek(index76_46);
                   	if ( s >= 0 ) return s;
                   	break;
        }
        if (state.backtracking > 0) {state.failed = true; return -1;}
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 76, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA86_eotS =
        "\x33\uffff";
    const string DFA86_eofS =
        "\x01\x02\x32\uffff";
    const string DFA86_minS =
        "\x01\x04\x01\x00\x01\uffff\x02\x00\x2e\uffff";
    const string DFA86_maxS =
        "\x01\u0092\x01\x00\x01\uffff\x02\x00\x2e\uffff";
    const string DFA86_acceptS =
        "\x02\uffff\x01\x02\x03\uffff\x01\x01\x2c\uffff";
    const string DFA86_specialS =
        "\x01\uffff\x01\x00\x01\uffff\x01\x01\x01\x02\x2e\uffff}>";
    static readonly string[] DFA86_transitionS = {
            "\x01\x06\x01\x01\x01\x03\x04\x06\x01\x04\x30\x06\x01\x02\x01"+
            "\x06\x01\uffff\x01\x06\x03\uffff\x01\x06\x07\uffff\x03\x06\x02"+
            "\uffff\x02\x06\x06\uffff\x02\x06\x18\uffff\x02\x06\x0c\uffff"+
            "\x02\x06\x02\uffff\x01\x06\x04\uffff\x01\x06\x02\uffff\x01\x06"+
            "\x01\uffff\x01\x06\x01\uffff\x03\x06",
            "\x01\uffff",
            "",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
    };

    static readonly short[] DFA86_eot = DFA.UnpackEncodedString(DFA86_eotS);
    static readonly short[] DFA86_eof = DFA.UnpackEncodedString(DFA86_eofS);
    static readonly char[] DFA86_min = DFA.UnpackEncodedStringToUnsignedChars(DFA86_minS);
    static readonly char[] DFA86_max = DFA.UnpackEncodedStringToUnsignedChars(DFA86_maxS);
    static readonly short[] DFA86_accept = DFA.UnpackEncodedString(DFA86_acceptS);
    static readonly short[] DFA86_special = DFA.UnpackEncodedString(DFA86_specialS);
    static readonly short[][] DFA86_transition = DFA.UnpackEncodedStringArray(DFA86_transitionS);

    protected class DFA86 : DFA
    {
        public DFA86(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 86;
            this.eot = DFA86_eot;
            this.eof = DFA86_eof;
            this.min = DFA86_min;
            this.max = DFA86_max;
            this.accept = DFA86_accept;
            this.special = DFA86_special;
            this.transition = DFA86_transition;

        }

        override public string Description
        {
            get { return "()* loopback of 1909:61: ( statement )*"; }
        }

    }


    protected internal int DFA86_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
            ITokenStream input = (ITokenStream)_input;
    	int _s = s;
        switch ( s )
        {
               	case 0 : 
                   	int LA86_1 = input.LA(1);

                   	 
                   	int index86_1 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred199_AS3_ex()) ) { s = 6; }

                   	else if ( (true) ) { s = 2; }

                   	 
                   	input.Seek(index86_1);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 1 : 
                   	int LA86_3 = input.LA(1);

                   	 
                   	int index86_3 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred199_AS3_ex()) ) { s = 6; }

                   	else if ( (true) ) { s = 2; }

                   	 
                   	input.Seek(index86_3);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 2 : 
                   	int LA86_4 = input.LA(1);

                   	 
                   	int index86_4 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred199_AS3_ex()) ) { s = 6; }

                   	else if ( (true) ) { s = 2; }

                   	 
                   	input.Seek(index86_4);
                   	if ( s >= 0 ) return s;
                   	break;
        }
        if (state.backtracking > 0) {state.failed = true; return -1;}
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 86, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA114_eotS =
        "\x1e\uffff";
    const string DFA114_eofS =
        "\x1e\uffff";
    const string DFA114_minS =
        "\x01\x04\x19\x00\x01\uffff\x01\x00\x02\uffff";
    const string DFA114_maxS =
        "\x01\u0092\x19\x00\x01\uffff\x01\x00\x02\uffff";
    const string DFA114_acceptS =
        "\x1a\uffff\x01\x02\x02\uffff\x01\x01";
    const string DFA114_specialS =
        "\x01\uffff\x01\x00\x01\x01\x01\x02\x01\x03\x01\x04\x01\x05\x01"+
        "\x06\x01\x07\x01\x08\x01\x09\x01\x0a\x01\x0b\x01\x0c\x01\x0d\x01"+
        "\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01"+
        "\x16\x01\x17\x01\x18\x01\uffff\x01\x19\x02\uffff}>";
    static readonly string[] DFA114_transitionS = {
            "\x08\x1b\x01\x19\x03\x1b\x01\x05\x02\x1b\x01\x10\x08\x1b\x01"+
            "\x0e\x01\x18\x01\x03\x05\x1b\x01\x02\x01\x1b\x01\x01\x01\x1b"+
            "\x01\x0e\x01\x04\x01\x1b\x01\x19\x02\x1b\x01\x19\x02\x1b\x04"+
            "\x0e\x01\x1b\x04\x0e\x01\uffff\x01\x0c\x01\uffff\x01\x17\x01"+
            "\uffff\x01\x0b\x03\uffff\x01\x15\x07\uffff\x02\x1a\x01\x11\x02"+
            "\uffff\x02\x1a\x06\uffff\x02\x1a\x18\uffff\x01\x0f\x01\x16\x0c"+
            "\uffff\x01\x08\x01\x09\x02\uffff\x01\x0a\x04\uffff\x01\x07\x02"+
            "\uffff\x01\x06\x01\uffff\x01\x0d\x01\uffff\x01\x12\x01\x13\x01"+
            "\x14",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "\x01\uffff",
            "",
            ""
    };

    static readonly short[] DFA114_eot = DFA.UnpackEncodedString(DFA114_eotS);
    static readonly short[] DFA114_eof = DFA.UnpackEncodedString(DFA114_eofS);
    static readonly char[] DFA114_min = DFA.UnpackEncodedStringToUnsignedChars(DFA114_minS);
    static readonly char[] DFA114_max = DFA.UnpackEncodedStringToUnsignedChars(DFA114_maxS);
    static readonly short[] DFA114_accept = DFA.UnpackEncodedString(DFA114_acceptS);
    static readonly short[] DFA114_special = DFA.UnpackEncodedString(DFA114_specialS);
    static readonly short[][] DFA114_transition = DFA.UnpackEncodedStringArray(DFA114_transitionS);

    protected class DFA114 : DFA
    {
        public DFA114(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 114;
            this.eot = DFA114_eot;
            this.eof = DFA114_eof;
            this.min = DFA114_min;
            this.max = DFA114_max;
            this.accept = DFA114_accept;
            this.special = DFA114_special;
            this.transition = DFA114_transition;

        }

        override public string Description
        {
            get { return "2196:1: assignmentExpression : ( leftHandSideExpression assignmentOperator assignmentExpression | conditionalExpression );"; }
        }

    }


    protected internal int DFA114_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
            ITokenStream input = (ITokenStream)_input;
    	int _s = s;
        switch ( s )
        {
               	case 0 : 
                   	int LA114_1 = input.LA(1);

                   	 
                   	int index114_1 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred228_AS3_ex()) ) { s = 29; }

                   	else if ( (true) ) { s = 26; }

                   	 
                   	input.Seek(index114_1);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 1 : 
                   	int LA114_2 = input.LA(1);

                   	 
                   	int index114_2 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred228_AS3_ex()) ) { s = 29; }

                   	else if ( (true) ) { s = 26; }

                   	 
                   	input.Seek(index114_2);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 2 : 
                   	int LA114_3 = input.LA(1);

                   	 
                   	int index114_3 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred228_AS3_ex()) ) { s = 29; }

                   	else if ( (true) ) { s = 26; }

                   	 
                   	input.Seek(index114_3);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 3 : 
                   	int LA114_4 = input.LA(1);

                   	 
                   	int index114_4 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred228_AS3_ex()) ) { s = 29; }

                   	else if ( (true) ) { s = 26; }

                   	 
                   	input.Seek(index114_4);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 4 : 
                   	int LA114_5 = input.LA(1);

                   	 
                   	int index114_5 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred228_AS3_ex()) ) { s = 29; }

                   	else if ( (true) ) { s = 26; }

                   	 
                   	input.Seek(index114_5);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 5 : 
                   	int LA114_6 = input.LA(1);

                   	 
                   	int index114_6 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred228_AS3_ex()) ) { s = 29; }

                   	else if ( (true) ) { s = 26; }

                   	 
                   	input.Seek(index114_6);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 6 : 
                   	int LA114_7 = input.LA(1);

                   	 
                   	int index114_7 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred228_AS3_ex()) ) { s = 29; }

                   	else if ( (true) ) { s = 26; }

                   	 
                   	input.Seek(index114_7);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 7 : 
                   	int LA114_8 = input.LA(1);

                   	 
                   	int index114_8 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred228_AS3_ex()) ) { s = 29; }

                   	else if ( (true) ) { s = 26; }

                   	 
                   	input.Seek(index114_8);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 8 : 
                   	int LA114_9 = input.LA(1);

                   	 
                   	int index114_9 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred228_AS3_ex()) ) { s = 29; }

                   	else if ( (true) ) { s = 26; }

                   	 
                   	input.Seek(index114_9);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 9 : 
                   	int LA114_10 = input.LA(1);

                   	 
                   	int index114_10 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred228_AS3_ex()) ) { s = 29; }

                   	else if ( (true) ) { s = 26; }

                   	 
                   	input.Seek(index114_10);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 10 : 
                   	int LA114_11 = input.LA(1);

                   	 
                   	int index114_11 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred228_AS3_ex()) ) { s = 29; }

                   	else if ( (true) ) { s = 26; }

                   	 
                   	input.Seek(index114_11);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 11 : 
                   	int LA114_12 = input.LA(1);

                   	 
                   	int index114_12 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred228_AS3_ex()) ) { s = 29; }

                   	else if ( (true) ) { s = 26; }

                   	 
                   	input.Seek(index114_12);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 12 : 
                   	int LA114_13 = input.LA(1);

                   	 
                   	int index114_13 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred228_AS3_ex()) ) { s = 29; }

                   	else if ( (true) ) { s = 26; }

                   	 
                   	input.Seek(index114_13);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 13 : 
                   	int LA114_14 = input.LA(1);

                   	 
                   	int index114_14 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred228_AS3_ex()) ) { s = 29; }

                   	else if ( (true) ) { s = 26; }

                   	 
                   	input.Seek(index114_14);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 14 : 
                   	int LA114_15 = input.LA(1);

                   	 
                   	int index114_15 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred228_AS3_ex()) ) { s = 29; }

                   	else if ( (true) ) { s = 26; }

                   	 
                   	input.Seek(index114_15);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 15 : 
                   	int LA114_16 = input.LA(1);

                   	 
                   	int index114_16 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred228_AS3_ex()) ) { s = 29; }

                   	else if ( (true) ) { s = 26; }

                   	 
                   	input.Seek(index114_16);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 16 : 
                   	int LA114_17 = input.LA(1);

                   	 
                   	int index114_17 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred228_AS3_ex()) ) { s = 29; }

                   	else if ( (true) ) { s = 26; }

                   	 
                   	input.Seek(index114_17);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 17 : 
                   	int LA114_18 = input.LA(1);

                   	 
                   	int index114_18 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred228_AS3_ex()) ) { s = 29; }

                   	else if ( (true) ) { s = 26; }

                   	 
                   	input.Seek(index114_18);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 18 : 
                   	int LA114_19 = input.LA(1);

                   	 
                   	int index114_19 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred228_AS3_ex()) ) { s = 29; }

                   	else if ( (true) ) { s = 26; }

                   	 
                   	input.Seek(index114_19);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 19 : 
                   	int LA114_20 = input.LA(1);

                   	 
                   	int index114_20 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred228_AS3_ex()) ) { s = 29; }

                   	else if ( (true) ) { s = 26; }

                   	 
                   	input.Seek(index114_20);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 20 : 
                   	int LA114_21 = input.LA(1);

                   	 
                   	int index114_21 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred228_AS3_ex()) ) { s = 29; }

                   	else if ( (true) ) { s = 26; }

                   	 
                   	input.Seek(index114_21);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 21 : 
                   	int LA114_22 = input.LA(1);

                   	 
                   	int index114_22 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred228_AS3_ex()) ) { s = 29; }

                   	else if ( (true) ) { s = 26; }

                   	 
                   	input.Seek(index114_22);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 22 : 
                   	int LA114_23 = input.LA(1);

                   	 
                   	int index114_23 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred228_AS3_ex()) ) { s = 29; }

                   	else if ( (true) ) { s = 26; }

                   	 
                   	input.Seek(index114_23);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 23 : 
                   	int LA114_24 = input.LA(1);

                   	 
                   	int index114_24 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred228_AS3_ex()) ) { s = 29; }

                   	else if ( (true) ) { s = 26; }

                   	 
                   	input.Seek(index114_24);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 24 : 
                   	int LA114_25 = input.LA(1);

                   	 
                   	int index114_25 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred228_AS3_ex()) ) { s = 29; }

                   	else if ( (true) ) { s = 26; }

                   	 
                   	input.Seek(index114_25);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 25 : 
                   	int LA114_27 = input.LA(1);

                   	 
                   	int index114_27 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred228_AS3_ex()) ) { s = 29; }

                   	else if ( (true) ) { s = 26; }

                   	 
                   	input.Seek(index114_27);
                   	if ( s >= 0 ) return s;
                   	break;
        }
        if (state.backtracking > 0) {state.failed = true; return -1;}
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 114, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA115_eotS =
        "\x1e\uffff";
    const string DFA115_eofS =
        "\x1e\uffff";
    const string DFA115_minS =
        "\x01\x04\x19\x00\x01\uffff\x01\x00\x02\uffff";
    const string DFA115_maxS =
        "\x01\u0092\x19\x00\x01\uffff\x01\x00\x02\uffff";
    const string DFA115_acceptS =
        "\x1a\uffff\x01\x01\x02\uffff\x01\x02";
    const string DFA115_specialS =
        "\x01\uffff\x01\x00\x01\x01\x01\x02\x01\x03\x01\x04\x01\x05\x01"+
        "\x06\x01\x07\x01\x08\x01\x09\x01\x0a\x01\x0b\x01\x0c\x01\x0d\x01"+
        "\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01"+
        "\x16\x01\x17\x01\x18\x01\uffff\x01\x19\x02\uffff}>";
    static readonly string[] DFA115_transitionS = {
            "\x08\x1b\x01\x19\x03\x1b\x01\x05\x02\x1b\x01\x10\x08\x1b\x01"+
            "\x0e\x01\x18\x01\x03\x05\x1b\x01\x02\x01\x1b\x01\x01\x01\x1b"+
            "\x01\x0e\x01\x04\x01\x1b\x01\x19\x02\x1b\x01\x19\x02\x1b\x04"+
            "\x0e\x01\x1b\x04\x0e\x01\uffff\x01\x0c\x01\uffff\x01\x17\x01"+
            "\uffff\x01\x0b\x03\uffff\x01\x15\x07\uffff\x02\x1a\x01\x11\x02"+
            "\uffff\x02\x1a\x06\uffff\x02\x1a\x18\uffff\x01\x0f\x01\x16\x0c"+
            "\uffff\x01\x08\x01\x09\x02\uffff\x01\x0a\x04\uffff\x01\x07\x02"+
            "\uffff\x01\x06\x01\uffff\x01\x0d\x01\uffff\x01\x12\x01\x13\x01"+
            "\x14",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "\x01\uffff",
            "",
            ""
    };

    static readonly short[] DFA115_eot = DFA.UnpackEncodedString(DFA115_eotS);
    static readonly short[] DFA115_eof = DFA.UnpackEncodedString(DFA115_eofS);
    static readonly char[] DFA115_min = DFA.UnpackEncodedStringToUnsignedChars(DFA115_minS);
    static readonly char[] DFA115_max = DFA.UnpackEncodedStringToUnsignedChars(DFA115_maxS);
    static readonly short[] DFA115_accept = DFA.UnpackEncodedString(DFA115_acceptS);
    static readonly short[] DFA115_special = DFA.UnpackEncodedString(DFA115_specialS);
    static readonly short[][] DFA115_transition = DFA.UnpackEncodedStringArray(DFA115_transitionS);

    protected class DFA115 : DFA
    {
        public DFA115(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 115;
            this.eot = DFA115_eot;
            this.eof = DFA115_eof;
            this.min = DFA115_min;
            this.max = DFA115_max;
            this.accept = DFA115_accept;
            this.special = DFA115_special;
            this.transition = DFA115_transition;

        }

        override public string Description
        {
            get { return "2203:1: assignmentExpressionNoIn : ( conditionalExpressionNoIn | leftHandSideExpression assignmentOperator assignmentExpressionNoIn );"; }
        }

    }


    protected internal int DFA115_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
            ITokenStream input = (ITokenStream)_input;
    	int _s = s;
        switch ( s )
        {
               	case 0 : 
                   	int LA115_1 = input.LA(1);

                   	 
                   	int index115_1 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred229_AS3_ex()) ) { s = 26; }

                   	else if ( (true) ) { s = 29; }

                   	 
                   	input.Seek(index115_1);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 1 : 
                   	int LA115_2 = input.LA(1);

                   	 
                   	int index115_2 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred229_AS3_ex()) ) { s = 26; }

                   	else if ( (true) ) { s = 29; }

                   	 
                   	input.Seek(index115_2);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 2 : 
                   	int LA115_3 = input.LA(1);

                   	 
                   	int index115_3 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred229_AS3_ex()) ) { s = 26; }

                   	else if ( (true) ) { s = 29; }

                   	 
                   	input.Seek(index115_3);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 3 : 
                   	int LA115_4 = input.LA(1);

                   	 
                   	int index115_4 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred229_AS3_ex()) ) { s = 26; }

                   	else if ( (true) ) { s = 29; }

                   	 
                   	input.Seek(index115_4);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 4 : 
                   	int LA115_5 = input.LA(1);

                   	 
                   	int index115_5 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred229_AS3_ex()) ) { s = 26; }

                   	else if ( (true) ) { s = 29; }

                   	 
                   	input.Seek(index115_5);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 5 : 
                   	int LA115_6 = input.LA(1);

                   	 
                   	int index115_6 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred229_AS3_ex()) ) { s = 26; }

                   	else if ( (true) ) { s = 29; }

                   	 
                   	input.Seek(index115_6);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 6 : 
                   	int LA115_7 = input.LA(1);

                   	 
                   	int index115_7 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred229_AS3_ex()) ) { s = 26; }

                   	else if ( (true) ) { s = 29; }

                   	 
                   	input.Seek(index115_7);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 7 : 
                   	int LA115_8 = input.LA(1);

                   	 
                   	int index115_8 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred229_AS3_ex()) ) { s = 26; }

                   	else if ( (true) ) { s = 29; }

                   	 
                   	input.Seek(index115_8);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 8 : 
                   	int LA115_9 = input.LA(1);

                   	 
                   	int index115_9 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred229_AS3_ex()) ) { s = 26; }

                   	else if ( (true) ) { s = 29; }

                   	 
                   	input.Seek(index115_9);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 9 : 
                   	int LA115_10 = input.LA(1);

                   	 
                   	int index115_10 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred229_AS3_ex()) ) { s = 26; }

                   	else if ( (true) ) { s = 29; }

                   	 
                   	input.Seek(index115_10);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 10 : 
                   	int LA115_11 = input.LA(1);

                   	 
                   	int index115_11 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred229_AS3_ex()) ) { s = 26; }

                   	else if ( (true) ) { s = 29; }

                   	 
                   	input.Seek(index115_11);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 11 : 
                   	int LA115_12 = input.LA(1);

                   	 
                   	int index115_12 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred229_AS3_ex()) ) { s = 26; }

                   	else if ( (true) ) { s = 29; }

                   	 
                   	input.Seek(index115_12);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 12 : 
                   	int LA115_13 = input.LA(1);

                   	 
                   	int index115_13 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred229_AS3_ex()) ) { s = 26; }

                   	else if ( (true) ) { s = 29; }

                   	 
                   	input.Seek(index115_13);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 13 : 
                   	int LA115_14 = input.LA(1);

                   	 
                   	int index115_14 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred229_AS3_ex()) ) { s = 26; }

                   	else if ( (true) ) { s = 29; }

                   	 
                   	input.Seek(index115_14);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 14 : 
                   	int LA115_15 = input.LA(1);

                   	 
                   	int index115_15 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred229_AS3_ex()) ) { s = 26; }

                   	else if ( (true) ) { s = 29; }

                   	 
                   	input.Seek(index115_15);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 15 : 
                   	int LA115_16 = input.LA(1);

                   	 
                   	int index115_16 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred229_AS3_ex()) ) { s = 26; }

                   	else if ( (true) ) { s = 29; }

                   	 
                   	input.Seek(index115_16);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 16 : 
                   	int LA115_17 = input.LA(1);

                   	 
                   	int index115_17 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred229_AS3_ex()) ) { s = 26; }

                   	else if ( (true) ) { s = 29; }

                   	 
                   	input.Seek(index115_17);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 17 : 
                   	int LA115_18 = input.LA(1);

                   	 
                   	int index115_18 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred229_AS3_ex()) ) { s = 26; }

                   	else if ( (true) ) { s = 29; }

                   	 
                   	input.Seek(index115_18);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 18 : 
                   	int LA115_19 = input.LA(1);

                   	 
                   	int index115_19 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred229_AS3_ex()) ) { s = 26; }

                   	else if ( (true) ) { s = 29; }

                   	 
                   	input.Seek(index115_19);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 19 : 
                   	int LA115_20 = input.LA(1);

                   	 
                   	int index115_20 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred229_AS3_ex()) ) { s = 26; }

                   	else if ( (true) ) { s = 29; }

                   	 
                   	input.Seek(index115_20);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 20 : 
                   	int LA115_21 = input.LA(1);

                   	 
                   	int index115_21 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred229_AS3_ex()) ) { s = 26; }

                   	else if ( (true) ) { s = 29; }

                   	 
                   	input.Seek(index115_21);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 21 : 
                   	int LA115_22 = input.LA(1);

                   	 
                   	int index115_22 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred229_AS3_ex()) ) { s = 26; }

                   	else if ( (true) ) { s = 29; }

                   	 
                   	input.Seek(index115_22);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 22 : 
                   	int LA115_23 = input.LA(1);

                   	 
                   	int index115_23 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred229_AS3_ex()) ) { s = 26; }

                   	else if ( (true) ) { s = 29; }

                   	 
                   	input.Seek(index115_23);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 23 : 
                   	int LA115_24 = input.LA(1);

                   	 
                   	int index115_24 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred229_AS3_ex()) ) { s = 26; }

                   	else if ( (true) ) { s = 29; }

                   	 
                   	input.Seek(index115_24);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 24 : 
                   	int LA115_25 = input.LA(1);

                   	 
                   	int index115_25 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred229_AS3_ex()) ) { s = 26; }

                   	else if ( (true) ) { s = 29; }

                   	 
                   	input.Seek(index115_25);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 25 : 
                   	int LA115_27 = input.LA(1);

                   	 
                   	int index115_27 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred229_AS3_ex()) ) { s = 26; }

                   	else if ( (true) ) { s = 29; }

                   	 
                   	input.Seek(index115_27);
                   	if ( s >= 0 ) return s;
                   	break;
        }
        if (state.backtracking > 0) {state.failed = true; return -1;}
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 115, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA116_eotS =
        "\x11\uffff";
    const string DFA116_eofS =
        "\x11\uffff";
    const string DFA116_minS =
        "\x01\x44\x07\uffff\x01\x44\x05\uffff\x01\x44\x02\uffff";
    const string DFA116_maxS =
        "\x01\x6c\x07\uffff\x01\x44\x05\uffff\x01\x5e\x02\uffff";
    const string DFA116_acceptS =
        "\x01\uffff\x01\x01\x01\x02\x01\x03\x01\x04\x01\x05\x01\x06\x01"+
        "\x07\x01\uffff\x01\x0a\x01\x0b\x01\x0c\x01\x0d\x01\x0e\x01\uffff"+
        "\x01\x08\x01\x09";
    const string DFA116_specialS =
        "\x11\uffff}>";
    static readonly string[] DFA116_transitionS = {
            "\x01\x08\x08\uffff\x01\x02\x10\uffff\x01\x01\x02\uffff\x01"+
            "\x03\x01\x04\x01\x05\x01\x06\x01\x07\x02\uffff\x01\x0d\x01\x0c"+
            "\x01\x09\x01\x0a\x01\x0b",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "\x01\x0e",
            "",
            "",
            "",
            "",
            "",
            "\x01\x10\x19\uffff\x01\x0f",
            "",
            ""
    };

    static readonly short[] DFA116_eot = DFA.UnpackEncodedString(DFA116_eotS);
    static readonly short[] DFA116_eof = DFA.UnpackEncodedString(DFA116_eofS);
    static readonly char[] DFA116_min = DFA.UnpackEncodedStringToUnsignedChars(DFA116_minS);
    static readonly char[] DFA116_max = DFA.UnpackEncodedStringToUnsignedChars(DFA116_maxS);
    static readonly short[] DFA116_accept = DFA.UnpackEncodedString(DFA116_acceptS);
    static readonly short[] DFA116_special = DFA.UnpackEncodedString(DFA116_specialS);
    static readonly short[][] DFA116_transition = DFA.UnpackEncodedStringArray(DFA116_transitionS);

    protected class DFA116 : DFA
    {
        public DFA116(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 116;
            this.eot = DFA116_eot;
            this.eof = DFA116_eof;
            this.min = DFA116_min;
            this.max = DFA116_max;
            this.accept = DFA116_accept;
            this.special = DFA116_special;
            this.transition = DFA116_transition;

        }

        override public string Description
        {
            get { return "2216:1: assignmentOperator_int : ( ASSIGN | s= STAR a= ASSIGN | DIV_ASSIGN | MOD_ASSIGN | ADD_ASSIGN | SUB_ASSIGN | SHL_ASSIGN | ( ( '>' '>' '=' )=>t1= '>' t2= '>' t3= '=' {...}? -> SHR_ASSIGN ) | ( ( '>' '>' '>' '=' )=>t1= '>' t2= '>' t3= '>' t4= '=' {...}? -> SHU_ASSIGN ) | AND_ASSIGN | XOR_ASSIGN | OR_ASSIGN | LOR_ASSIGN | LAND_ASSIGN );"; }
        }

    }

    const string DFA133_eotS =
        "\x47\uffff";
    const string DFA133_eofS =
        "\x01\x01\x46\uffff";
    const string DFA133_minS =
        "\x01\x04\x2a\uffff\x01\x00\x14\uffff\x01\x00\x02\uffff\x01\x00"+
        "\x03\uffff";
    const string DFA133_maxS =
        "\x01\u0092\x2a\uffff\x01\x00\x14\uffff\x01\x00\x02\uffff\x01\x00"+
        "\x03\uffff";
    const string DFA133_acceptS =
        "\x01\uffff\x01\x02\x42\uffff\x01\x01\x02\uffff";
    const string DFA133_specialS =
        "\x2b\uffff\x01\x00\x14\uffff\x01\x01\x02\uffff\x01\x02\x03\uffff}>";
    static readonly string[] DFA133_transitionS = {
            "\x01\x43\x12\x01\x01\x40\x01\x43\x02\x01\x01\x43\x25\x01\x01"+
            "\uffff\x01\x01\x01\x2b\x02\x44\x01\uffff\x07\x01\x02\uffff\x02"+
            "\x01\x03\uffff\x09\x01\x14\uffff\x02\x01\x0c\uffff\x02\x01\x02"+
            "\uffff\x01\x01\x04\uffff\x01\x01\x02\uffff\x01\x01\x01\uffff"+
            "\x01\x01\x01\uffff\x03\x01",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "\x01\uffff",
            "",
            "",
            "\x01\uffff",
            "",
            "",
            ""
    };

    static readonly short[] DFA133_eot = DFA.UnpackEncodedString(DFA133_eotS);
    static readonly short[] DFA133_eof = DFA.UnpackEncodedString(DFA133_eofS);
    static readonly char[] DFA133_min = DFA.UnpackEncodedStringToUnsignedChars(DFA133_minS);
    static readonly char[] DFA133_max = DFA.UnpackEncodedStringToUnsignedChars(DFA133_maxS);
    static readonly short[] DFA133_accept = DFA.UnpackEncodedString(DFA133_acceptS);
    static readonly short[] DFA133_special = DFA.UnpackEncodedString(DFA133_specialS);
    static readonly short[][] DFA133_transition = DFA.UnpackEncodedStringArray(DFA133_transitionS);

    protected class DFA133 : DFA
    {
        public DFA133(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 133;
            this.eot = DFA133_eot;
            this.eof = DFA133_eof;
            this.min = DFA133_min;
            this.max = DFA133_max;
            this.accept = DFA133_accept;
            this.special = DFA133_special;
            this.transition = DFA133_transition;

        }

        override public string Description
        {
            get { return "()* loopback of 2312:6: ( (g= GT (assign= ASSIGN )? | eq= ( IN | LT | LTE | INSTANCEOF | IS | AS ) ) shiftExpression )*"; }
        }

    }


    protected internal int DFA133_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
            ITokenStream input = (ITokenStream)_input;
    	int _s = s;
        switch ( s )
        {
               	case 0 : 
                   	int LA133_43 = input.LA(1);

                   	 
                   	int index133_43 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred272_AS3_ex()) ) { s = 68; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index133_43);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 1 : 
                   	int LA133_64 = input.LA(1);

                   	 
                   	int index133_64 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred272_AS3_ex()) ) { s = 68; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index133_64);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 2 : 
                   	int LA133_67 = input.LA(1);

                   	 
                   	int index133_67 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred272_AS3_ex()) ) { s = 68; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index133_67);
                   	if ( s >= 0 ) return s;
                   	break;
        }
        if (state.backtracking > 0) {state.failed = true; return -1;}
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 133, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA139_eotS =
        "\x4a\uffff";
    const string DFA139_eofS =
        "\x01\x01\x49\uffff";
    const string DFA139_minS =
        "\x01\x04\x34\uffff\x01\x00\x14\uffff";
    const string DFA139_maxS =
        "\x01\u0092\x34\uffff\x01\x00\x14\uffff";
    const string DFA139_acceptS =
        "\x01\uffff\x01\x02\x47\uffff\x01\x01";
    const string DFA139_specialS =
        "\x35\uffff\x01\x00\x14\uffff}>";
    static readonly string[] DFA139_transitionS = {
            "\x3d\x01\x01\uffff\x04\x01\x01\uffff\x04\x01\x02\x35\x01\x01"+
            "\x02\uffff\x03\x01\x02\uffff\x09\x01\x14\uffff\x02\x01\x0c\uffff"+
            "\x02\x01\x02\uffff\x01\x01\x04\uffff\x01\x01\x02\uffff\x01\x01"+
            "\x01\uffff\x01\x01\x01\uffff\x03\x01",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
    };

    static readonly short[] DFA139_eot = DFA.UnpackEncodedString(DFA139_eotS);
    static readonly short[] DFA139_eof = DFA.UnpackEncodedString(DFA139_eofS);
    static readonly char[] DFA139_min = DFA.UnpackEncodedStringToUnsignedChars(DFA139_minS);
    static readonly char[] DFA139_max = DFA.UnpackEncodedStringToUnsignedChars(DFA139_maxS);
    static readonly short[] DFA139_accept = DFA.UnpackEncodedString(DFA139_acceptS);
    static readonly short[] DFA139_special = DFA.UnpackEncodedString(DFA139_specialS);
    static readonly short[][] DFA139_transition = DFA.UnpackEncodedStringArray(DFA139_transitionS);

    protected class DFA139 : DFA
    {
        public DFA139(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 139;
            this.eot = DFA139_eot;
            this.eof = DFA139_eof;
            this.min = DFA139_min;
            this.max = DFA139_max;
            this.accept = DFA139_accept;
            this.special = DFA139_special;
            this.transition = DFA139_transition;

        }

        override public string Description
        {
            get { return "()* loopback of 2366:34: (op= ( PLUS | SUB ) multiplicativeExpression )*"; }
        }

    }


    protected internal int DFA139_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
            ITokenStream input = (ITokenStream)_input;
    	int _s = s;
        switch ( s )
        {
               	case 0 : 
                   	int LA139_53 = input.LA(1);

                   	 
                   	int index139_53 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred286_AS3_ex()) ) { s = 73; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index139_53);
                   	if ( s >= 0 ) return s;
                   	break;
        }
        if (state.backtracking > 0) {state.failed = true; return -1;}
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 139, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA140_eotS =
        "\x4a\uffff";
    const string DFA140_eofS =
        "\x01\x01\x49\uffff";
    const string DFA140_minS =
        "\x01\x04\x2b\uffff\x01\x00\x1d\uffff";
    const string DFA140_maxS =
        "\x01\u0092\x2b\uffff\x01\x00\x1d\uffff";
    const string DFA140_acceptS =
        "\x01\uffff\x01\x02\x47\uffff\x01\x01";
    const string DFA140_specialS =
        "\x2c\uffff\x01\x00\x1d\uffff}>";
    static readonly string[] DFA140_transitionS = {
            "\x3d\x01\x01\uffff\x04\x01\x01\uffff\x06\x01\x01\x2c\x02\x49"+
            "\x03\x01\x02\uffff\x09\x01\x14\uffff\x02\x01\x0c\uffff\x02\x01"+
            "\x02\uffff\x01\x01\x04\uffff\x01\x01\x02\uffff\x01\x01\x01\uffff"+
            "\x01\x01\x01\uffff\x03\x01",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
    };

    static readonly short[] DFA140_eot = DFA.UnpackEncodedString(DFA140_eotS);
    static readonly short[] DFA140_eof = DFA.UnpackEncodedString(DFA140_eofS);
    static readonly char[] DFA140_min = DFA.UnpackEncodedStringToUnsignedChars(DFA140_minS);
    static readonly char[] DFA140_max = DFA.UnpackEncodedStringToUnsignedChars(DFA140_maxS);
    static readonly short[] DFA140_accept = DFA.UnpackEncodedString(DFA140_acceptS);
    static readonly short[] DFA140_special = DFA.UnpackEncodedString(DFA140_specialS);
    static readonly short[][] DFA140_transition = DFA.UnpackEncodedStringArray(DFA140_transitionS);

    protected class DFA140 : DFA
    {
        public DFA140(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 140;
            this.eot = DFA140_eot;
            this.eof = DFA140_eof;
            this.min = DFA140_min;
            this.max = DFA140_max;
            this.accept = DFA140_accept;
            this.special = DFA140_special;
            this.transition = DFA140_transition;

        }

        override public string Description
        {
            get { return "()* loopback of 2371:25: (op= ( STAR | DIV | MOD ) unaryExpression )*"; }
        }

    }


    protected internal int DFA140_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
            ITokenStream input = (ITokenStream)_input;
    	int _s = s;
        switch ( s )
        {
               	case 0 : 
                   	int LA140_44 = input.LA(1);

                   	 
                   	int index140_44 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred289_AS3_ex()) ) { s = 73; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index140_44);
                   	if ( s >= 0 ) return s;
                   	break;
        }
        if (state.backtracking > 0) {state.failed = true; return -1;}
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 140, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA141_eotS =
        "\x1e\uffff";
    const string DFA141_eofS =
        "\x1e\uffff";
    const string DFA141_minS =
        "\x01\x04\x18\uffff\x02\x00\x03\uffff";
    const string DFA141_maxS =
        "\x01\u0092\x18\uffff\x02\x00\x03\uffff";
    const string DFA141_acceptS =
        "\x01\uffff\x01\x01\x1a\uffff\x01\x03\x01\x02";
    const string DFA141_specialS =
        "\x19\uffff\x01\x00\x01\x01\x03\uffff}>";
    static readonly string[] DFA141_transitionS = {
            "\x08\x01\x01\x19\x1e\x01\x01\x19\x02\x01\x01\x19\x0b\x01\x01"+
            "\uffff\x01\x01\x01\uffff\x01\x01\x01\uffff\x01\x01\x03\uffff"+
            "\x01\x01\x07\uffff\x02\x1c\x01\x01\x02\uffff\x02\x1c\x06\uffff"+
            "\x02\x1a\x18\uffff\x02\x01\x0c\uffff\x02\x01\x02\uffff\x01\x01"+
            "\x04\uffff\x01\x01\x02\uffff\x01\x01\x01\uffff\x01\x01\x01\uffff"+
            "\x03\x01",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "",
            ""
    };

    static readonly short[] DFA141_eot = DFA.UnpackEncodedString(DFA141_eotS);
    static readonly short[] DFA141_eof = DFA.UnpackEncodedString(DFA141_eofS);
    static readonly char[] DFA141_min = DFA.UnpackEncodedStringToUnsignedChars(DFA141_minS);
    static readonly char[] DFA141_max = DFA.UnpackEncodedStringToUnsignedChars(DFA141_maxS);
    static readonly short[] DFA141_accept = DFA.UnpackEncodedString(DFA141_acceptS);
    static readonly short[] DFA141_special = DFA.UnpackEncodedString(DFA141_specialS);
    static readonly short[][] DFA141_transition = DFA.UnpackEncodedStringArray(DFA141_transitionS);

    protected class DFA141 : DFA
    {
        public DFA141(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 141;
            this.eot = DFA141_eot;
            this.eof = DFA141_eof;
            this.min = DFA141_min;
            this.max = DFA141_max;
            this.accept = DFA141_accept;
            this.special = DFA141_special;
            this.transition = DFA141_transition;

        }

        override public string Description
        {
            get { return "2375:1: unaryExpression : ( postfixExpression | op= ( NOT | INV ) unaryExpression | unaryOp postfixExpression );"; }
        }

    }


    protected internal int DFA141_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
            ITokenStream input = (ITokenStream)_input;
    	int _s = s;
        switch ( s )
        {
               	case 0 : 
                   	int LA141_25 = input.LA(1);

                   	 
                   	int index141_25 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred290_AS3_ex()) ) { s = 1; }

                   	else if ( (true) ) { s = 28; }

                   	 
                   	input.Seek(index141_25);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 1 : 
                   	int LA141_26 = input.LA(1);

                   	 
                   	int index141_26 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred292_AS3_ex()) ) { s = 29; }

                   	else if ( (true) ) { s = 28; }

                   	 
                   	input.Seek(index141_26);
                   	if ( s >= 0 ) return s;
                   	break;
        }
        if (state.backtracking > 0) {state.failed = true; return -1;}
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 141, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA142_eotS =
        "\x4b\uffff";
    const string DFA142_eofS =
        "\x01\x02\x4a\uffff";
    const string DFA142_minS =
        "\x01\x04\x01\x00\x49\uffff";
    const string DFA142_maxS =
        "\x01\u0092\x01\x00\x49\uffff";
    const string DFA142_acceptS =
        "\x02\uffff\x01\x02\x47\uffff\x01\x01";
    const string DFA142_specialS =
        "\x01\uffff\x01\x00\x49\uffff}>";
    static readonly string[] DFA142_transitionS = {
            "\x3d\x02\x01\uffff\x04\x02\x01\uffff\x09\x02\x02\x01\x01\x02"+
            "\x02\uffff\x09\x02\x14\uffff\x02\x02\x0c\uffff\x02\x02\x02\uffff"+
            "\x01\x02\x04\uffff\x01\x02\x02\uffff\x01\x02\x01\uffff\x01\x02"+
            "\x01\uffff\x03\x02",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
    };

    static readonly short[] DFA142_eot = DFA.UnpackEncodedString(DFA142_eotS);
    static readonly short[] DFA142_eof = DFA.UnpackEncodedString(DFA142_eofS);
    static readonly char[] DFA142_min = DFA.UnpackEncodedStringToUnsignedChars(DFA142_minS);
    static readonly char[] DFA142_max = DFA.UnpackEncodedStringToUnsignedChars(DFA142_maxS);
    static readonly short[] DFA142_accept = DFA.UnpackEncodedString(DFA142_acceptS);
    static readonly short[] DFA142_special = DFA.UnpackEncodedString(DFA142_specialS);
    static readonly short[][] DFA142_transition = DFA.UnpackEncodedStringArray(DFA142_transitionS);

    protected class DFA142 : DFA
    {
        public DFA142(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 142;
            this.eot = DFA142_eot;
            this.eof = DFA142_eof;
            this.min = DFA142_min;
            this.max = DFA142_max;
            this.accept = DFA142_accept;
            this.special = DFA142_special;
            this.transition = DFA142_transition;

        }

        override public string Description
        {
            get { return "2390:32: ( postfixOp )?"; }
        }

    }


    protected internal int DFA142_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
            ITokenStream input = (ITokenStream)_input;
    	int _s = s;
        switch ( s )
        {
               	case 0 : 
                   	int LA142_1 = input.LA(1);

                   	 
                   	int index142_1 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred301_AS3_ex()) ) { s = 74; }

                   	else if ( (true) ) { s = 2; }

                   	 
                   	input.Seek(index142_1);
                   	if ( s >= 0 ) return s;
                   	break;
        }
        if (state.backtracking > 0) {state.failed = true; return -1;}
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 142, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA146_eotS =
        "\x5c\uffff";
    const string DFA146_eofS =
        "\x01\x01\x5b\uffff";
    const string DFA146_minS =
        "\x01\x04\x28\uffff\x01\x00\x16\uffff\x01\x00\x14\uffff\x01\x00"+
        "\x06\uffff";
    const string DFA146_maxS =
        "\x01\u0092\x28\uffff\x01\x00\x16\uffff\x01\x00\x14\uffff\x01\x00"+
        "\x06\uffff";
    const string DFA146_acceptS =
        "\x01\uffff\x01\x07\x54\uffff\x01\x04\x01\x02\x01\x01\x01\x03\x01"+
        "\x05\x01\x06";
    const string DFA146_specialS =
        "\x29\uffff\x01\x00\x16\uffff\x01\x01\x14\uffff\x01\x02\x06\uffff}>";
    static readonly string[] DFA146_transitionS = {
            "\x39\x01\x01\x40\x01\x01\x01\x29\x01\x01\x01\x55\x04\x01\x01"+
            "\uffff\x0c\x01\x02\uffff\x0a\x01\x02\uffff\x05\x01\x02\uffff"+
            "\x05\x01\x01\uffff\x01\x56\x03\uffff\x02\x01\x0c\uffff\x02\x01"+
            "\x02\uffff\x01\x01\x04\uffff\x01\x01\x02\uffff\x01\x01\x01\uffff"+
            "\x01\x01\x01\uffff\x03\x01",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            ""
    };

    static readonly short[] DFA146_eot = DFA.UnpackEncodedString(DFA146_eotS);
    static readonly short[] DFA146_eof = DFA.UnpackEncodedString(DFA146_eofS);
    static readonly char[] DFA146_min = DFA.UnpackEncodedStringToUnsignedChars(DFA146_minS);
    static readonly char[] DFA146_max = DFA.UnpackEncodedStringToUnsignedChars(DFA146_maxS);
    static readonly short[] DFA146_accept = DFA.UnpackEncodedString(DFA146_acceptS);
    static readonly short[] DFA146_special = DFA.UnpackEncodedString(DFA146_specialS);
    static readonly short[][] DFA146_transition = DFA.UnpackEncodedStringArray(DFA146_transitionS);

    protected class DFA146 : DFA
    {
        public DFA146(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 146;
            this.eot = DFA146_eot;
            this.eof = DFA146_eof;
            this.min = DFA146_min;
            this.max = DFA146_max;
            this.accept = DFA146_accept;
            this.special = DFA146_special;
            this.transition = DFA146_transition;

        }

        override public string Description
        {
            get { return "()* loopback of 2411:5: ( arguments | L= LBRACK expression R= RBRACK | D= DOT ( eitherIdentifier op= XML_NS_OP )? eitherIdentifier | E= XML_ELLIPSIS ( eitherIdentifier op= XML_NS_OP )? eitherIdentifier | D= DOT parExpression | typePostfixSyntax )*"; }
        }

    }


    protected internal int DFA146_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
            ITokenStream input = (ITokenStream)_input;
    	int _s = s;
        switch ( s )
        {
               	case 0 : 
                   	int LA146_41 = input.LA(1);

                   	 
                   	int index146_41 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred306_AS3_ex()) ) { s = 87; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index146_41);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 1 : 
                   	int LA146_64 = input.LA(1);

                   	 
                   	int index146_64 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred305_AS3_ex()) ) { s = 88; }

                   	else if ( (true) ) { s = 1; }

                   	 
                   	input.Seek(index146_64);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 2 : 
                   	int LA146_85 = input.LA(1);

                   	 
                   	int index146_85 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred308_AS3_ex()) ) { s = 89; }

                   	else if ( (synpred311_AS3_ex()) ) { s = 90; }

                   	else if ( (synpred312_AS3_ex()) ) { s = 91; }

                   	 
                   	input.Seek(index146_85);
                   	if ( s >= 0 ) return s;
                   	break;
        }
        if (state.backtracking > 0) {state.failed = true; return -1;}
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 146, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA155_eotS =
        "\x1d\uffff";
    const string DFA155_eofS =
        "\x1d\uffff";
    const string DFA155_minS =
        "\x01\x04\x05\x00\x07\uffff\x02\x00\x06\uffff\x01\x00\x07\uffff";
    const string DFA155_maxS =
        "\x01\u0092\x05\x00\x07\uffff\x02\x00\x06\uffff\x01\x00\x07\uffff";
    const string DFA155_acceptS =
        "\x06\uffff\x01\x03\x04\uffff\x01\x04\x01\x05\x02\uffff\x01\x07"+
        "\x07\uffff\x01\x08\x01\x01\x01\x02\x01\x06\x01\x09\x01\x0a";
    const string DFA155_specialS =
        "\x01\uffff\x01\x00\x01\x01\x01\x02\x01\x03\x01\x04\x07\uffff\x01"+
        "\x05\x01\x06\x06\uffff\x01\x07\x07\uffff}>";
    static readonly string[] DFA155_transitionS = {
            "\x0c\x0f\x01\x05\x0b\x0f\x01\x0e\x01\x0f\x01\x03\x05\x0f\x01"+
            "\x02\x01\x0f\x01\x01\x01\x0f\x01\x0e\x01\x04\x07\x0f\x04\x0e"+
            "\x01\x0f\x04\x0e\x01\uffff\x01\x0c\x01\uffff\x01\x17\x01\uffff"+
            "\x01\x0b\x03\uffff\x01\x15\x09\uffff\x01\x0f\x24\uffff\x02\x0f"+
            "\x0c\uffff\x02\x06\x02\uffff\x01\x06\x04\uffff\x01\x06\x02\uffff"+
            "\x01\x06\x01\uffff\x01\x0d\x01\uffff\x03\x0f",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
    };

    static readonly short[] DFA155_eot = DFA.UnpackEncodedString(DFA155_eotS);
    static readonly short[] DFA155_eof = DFA.UnpackEncodedString(DFA155_eofS);
    static readonly char[] DFA155_min = DFA.UnpackEncodedStringToUnsignedChars(DFA155_minS);
    static readonly char[] DFA155_max = DFA.UnpackEncodedStringToUnsignedChars(DFA155_maxS);
    static readonly short[] DFA155_accept = DFA.UnpackEncodedString(DFA155_acceptS);
    static readonly short[] DFA155_special = DFA.UnpackEncodedString(DFA155_specialS);
    static readonly short[][] DFA155_transition = DFA.UnpackEncodedStringArray(DFA155_transitionS);

    protected class DFA155 : DFA
    {
        public DFA155(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 155;
            this.eot = DFA155_eot;
            this.eof = DFA155_eof;
            this.min = DFA155_min;
            this.max = DFA155_max;
            this.accept = DFA155_accept;
            this.special = DFA155_special;
            this.transition = DFA155_transition;

        }

        override public string Description
        {
            get { return "2548:1: primaryExpressionHelper : (T= THIS | S= SUPER | literal | arrayLiteral | objectLiteral | identifierLiteral | xmlPrimaryExpression | parExpression | conditionalCompilerOption | l= LT type g= GT ( arrayLiteral )? );"; }
        }

    }


    protected internal int DFA155_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
            ITokenStream input = (ITokenStream)_input;
    	int _s = s;
        switch ( s )
        {
               	case 0 : 
                   	int LA155_1 = input.LA(1);

                   	 
                   	int index155_1 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred376_AS3_ex()) ) { s = 24; }

                   	else if ( (synpred382_AS3_ex()) ) { s = 15; }

                   	 
                   	input.Seek(index155_1);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 1 : 
                   	int LA155_2 = input.LA(1);

                   	 
                   	int index155_2 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred377_AS3_ex()) ) { s = 25; }

                   	else if ( (synpred382_AS3_ex()) ) { s = 15; }

                   	 
                   	input.Seek(index155_2);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 2 : 
                   	int LA155_3 = input.LA(1);

                   	 
                   	int index155_3 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred378_AS3_ex()) ) { s = 6; }

                   	else if ( (synpred382_AS3_ex()) ) { s = 15; }

                   	 
                   	input.Seek(index155_3);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 3 : 
                   	int LA155_4 = input.LA(1);

                   	 
                   	int index155_4 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred378_AS3_ex()) ) { s = 6; }

                   	else if ( (synpred382_AS3_ex()) ) { s = 15; }

                   	 
                   	input.Seek(index155_4);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 4 : 
                   	int LA155_5 = input.LA(1);

                   	 
                   	int index155_5 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred378_AS3_ex()) ) { s = 6; }

                   	else if ( (synpred382_AS3_ex()) ) { s = 15; }

                   	 
                   	input.Seek(index155_5);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 5 : 
                   	int LA155_13 = input.LA(1);

                   	 
                   	int index155_13 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred381_AS3_ex()) ) { s = 26; }

                   	else if ( (synpred382_AS3_ex()) ) { s = 15; }

                   	else if ( (synpred384_AS3_ex()) ) { s = 27; }

                   	 
                   	input.Seek(index155_13);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 6 : 
                   	int LA155_14 = input.LA(1);

                   	 
                   	int index155_14 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred381_AS3_ex()) ) { s = 26; }

                   	else if ( (synpred382_AS3_ex()) ) { s = 15; }

                   	else if ( (synpred384_AS3_ex()) ) { s = 27; }

                   	 
                   	input.Seek(index155_14);
                   	if ( s >= 0 ) return s;
                   	break;
               	case 7 : 
                   	int LA155_21 = input.LA(1);

                   	 
                   	int index155_21 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred382_AS3_ex()) ) { s = 15; }

                   	else if ( (true) ) { s = 28; }

                   	 
                   	input.Seek(index155_21);
                   	if ( s >= 0 ) return s;
                   	break;
        }
        if (state.backtracking > 0) {state.failed = true; return -1;}
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 155, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA154_eotS =
        "\x58\uffff";
    const string DFA154_eofS =
        "\x01\x02\x57\uffff";
    const string DFA154_minS =
        "\x01\x04\x01\x00\x56\uffff";
    const string DFA154_maxS =
        "\x01\u0092\x01\x00\x56\uffff";
    const string DFA154_acceptS =
        "\x02\uffff\x01\x02\x54\uffff\x01\x01";
    const string DFA154_specialS =
        "\x01\uffff\x01\x00\x56\uffff}>";
    static readonly string[] DFA154_transitionS = {
            "\x3b\x02\x01\x01\x06\x02\x01\uffff\x0c\x02\x02\uffff\x0a\x02"+
            "\x02\uffff\x05\x02\x02\uffff\x05\x02\x01\uffff\x01\x02\x03\uffff"+
            "\x02\x02\x0c\uffff\x02\x02\x02\uffff\x01\x02\x04\uffff\x01\x02"+
            "\x02\uffff\x01\x02\x01\uffff\x01\x02\x01\uffff\x03\x02",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
    };

    static readonly short[] DFA154_eot = DFA.UnpackEncodedString(DFA154_eotS);
    static readonly short[] DFA154_eof = DFA.UnpackEncodedString(DFA154_eofS);
    static readonly char[] DFA154_min = DFA.UnpackEncodedStringToUnsignedChars(DFA154_minS);
    static readonly char[] DFA154_max = DFA.UnpackEncodedStringToUnsignedChars(DFA154_maxS);
    static readonly short[] DFA154_accept = DFA.UnpackEncodedString(DFA154_acceptS);
    static readonly short[] DFA154_special = DFA.UnpackEncodedString(DFA154_specialS);
    static readonly short[][] DFA154_transition = DFA.UnpackEncodedStringArray(DFA154_transitionS);

    protected class DFA154 : DFA
    {
        public DFA154(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 154;
            this.eot = DFA154_eot;
            this.eof = DFA154_eof;
            this.min = DFA154_min;
            this.max = DFA154_max;
            this.accept = DFA154_accept;
            this.special = DFA154_special;
            this.transition = DFA154_transition;

        }

        override public string Description
        {
            get { return "2558:71: ( arrayLiteral )?"; }
        }

    }


    protected internal int DFA154_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
            ITokenStream input = (ITokenStream)_input;
    	int _s = s;
        switch ( s )
        {
               	case 0 : 
                   	int LA154_1 = input.LA(1);

                   	 
                   	int index154_1 = input.Index();
                   	input.Rewind();
                   	s = -1;
                   	if ( (synpred385_AS3_ex()) ) { s = 87; }

                   	else if ( (true) ) { s = 2; }

                   	 
                   	input.Seek(index154_1);
                   	if ( s >= 0 ) return s;
                   	break;
        }
        if (state.backtracking > 0) {state.failed = true; return -1;}
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 154, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
 

    public static readonly BitSet FOLLOW_TRUE_in_booleanLiteral3614 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_FALSE_in_booleanLiteral3622 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DEC_NUMBER_LITERAL_in_numericLiteral3656 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_HEX_NUMBER_LITERAL_in_numericLiteral3664 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_SINGLE_QUOTE_LITERAL_in_stringLiteral3699 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DOUBLE_QUOTE_LITERAL_in_stringLiteral3706 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_REGULAR_EXPR_LITERAL_in_regularExpresionLiteral3731 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_IDENTIFIER_in_identifierLiteral3764 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_notQuiteReservedWord_in_identifierLiteral3769 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_IDENTIFIER_in_xmlNameLiteral3804 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000020001002UL});
    public static readonly BitSet FOLLOW_allKeywords_in_xmlNameLiteral3809 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000020001002UL});
    public static readonly BitSet FOLLOW_SUB_in_xmlNameLiteral3820 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_DOT_in_xmlNameLiteral3828 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_COLON_in_xmlNameLiteral3836 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_IDENTIFIER_in_xmlNameLiteral3847 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000020001002UL});
    public static readonly BitSet FOLLOW_allKeywords_in_xmlNameLiteral3853 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000020001002UL});
    public static readonly BitSet FOLLOW_NULL_in_literal3906 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_booleanLiteral_in_literal3912 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_numericLiteral_in_literal3916 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_stringLiteral_in_literal3920 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_regularExpresionLiteral_in_literal3924 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlComment_in_xmlMarkup3960 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlCDATA_in_xmlMarkup3964 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlPI_in_xmlMarkup3968 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_XML_COMMENT_in_xmlComment4003 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_XML_CDATA_in_xmlCDATA4045 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_XML_PI_in_xmlPI4088 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LCURLY_in_xmlExprEval4126 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_expression_in_xmlExprEval4130 = new BitSet(new ulong[]{0x1000000000000000UL});
    public static readonly BitSet FOLLOW_RCURLY_in_xmlExprEval4134 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_allKeywords_in_xmlTextElement4152 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_set_in_xmlTextElement4165 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_XML_TEXT_in_xmlText4895 = new BitSet(new ulong[]{0xF7FFFFFFFFFFFFF2UL,0x00067F3E7FE7FFB7UL,0x0000000000085203UL});
    public static readonly BitSet FOLLOW_xmlTextElement_in_xmlText4901 = new BitSet(new ulong[]{0xF7FFFFFFFFFFFFF2UL,0x00067F3E7FE7FFB7UL,0x0000000000085203UL});
    public static readonly BitSet FOLLOW_xmlPropertyIdentifier_in_xmlPrimaryExpression5003 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlInitialiser_in_xmlPrimaryExpression5013 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlListInitialiser_in_xmlPrimaryExpression5023 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlAttributeIdentifier_in_xmlPropertyIdentifier5116 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlQualifiedIdentifier_in_xmlPropertyIdentifier5128 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_STAR_in_xmlPropertyIdentifier5142 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_XML_AT_in_xmlAttributeIdentifier5207 = new BitSet(new ulong[]{0x83FFFFFFFFFFFFF0UL,0x0000000000002000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_xmlQualifiedIdentifier_in_xmlAttributeIdentifier5233 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlPropertySelector_in_xmlAttributeIdentifier5248 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_indexSuffix_in_xmlAttributeIdentifier5263 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlNameLiteral_in_xmlPropertySelector5353 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_STAR_in_xmlPropertySelector5366 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlPropertySelector_in_xmlQualifiedIdentifier5387 = new BitSet(new ulong[]{0x0000000000000000UL,0x0002000000000000UL});
    public static readonly BitSet FOLLOW_XML_NS_OP_in_xmlQualifiedIdentifier5392 = new BitSet(new ulong[]{0x83FFFFFFFFFFFFF0UL,0x0000000000002000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_xmlPropertySelector_in_xmlQualifiedIdentifier5427 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_indexSuffix_in_xmlQualifiedIdentifier5439 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlMarkup_in_xmlInitialiser5464 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlElement_in_xmlInitialiser5474 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LT_in_xmlElement5518 = new BitSet(new ulong[]{0x0BFFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_xmlTagName_in_xmlElement5523 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000800000000010UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_xmlAttributes_in_xmlElement5525 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000800000000010UL});
    public static readonly BitSet FOLLOW_XML_TEND_in_xmlElement5545 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_GT_in_xmlElement5590 = new BitSet(new ulong[]{0xFFFFFFFFFFFFFFF0UL,0x00077F3E7FE7FFBFUL,0x00000000000F5203UL});
    public static readonly BitSet FOLLOW_xmlElementContent_in_xmlElement5594 = new BitSet(new ulong[]{0x0000000000000000UL,0x0001000000000000UL});
    public static readonly BitSet FOLLOW_XML_E_TEND_in_xmlElement5608 = new BitSet(new ulong[]{0x0BFFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_xmlTagName_in_xmlElement5622 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000010UL});
    public static readonly BitSet FOLLOW_GT_in_xmlElement5626 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlAttribute_in_xmlAttributes5665 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF2UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_xmlExprEval_in_xmlTagName5695 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlNameLiteral_in_xmlTagName5700 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlNameLiteral_in_xmlAttribute5723 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000040000000UL});
    public static readonly BitSet FOLLOW_ASSIGN_in_xmlAttribute5727 = new BitSet(new ulong[]{0x0800000000000000UL,0x0000000000000000UL,0x0000000000000003UL});
    public static readonly BitSet FOLLOW_xmlExprEval_in_xmlAttribute5746 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_stringLiteral_in_xmlAttribute5758 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlElementContentHelper_in_xmlElementContent5789 = new BitSet(new ulong[]{0xFFFFFFFFFFFFFFF2UL,0x00067F3E7FE7FFBFUL,0x00000000000F5203UL});
    public static readonly BitSet FOLLOW_xmlExprEval_in_xmlElementContentHelper5807 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlMarkup_in_xmlElementContentHelper5816 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlElement_in_xmlElementContentHelper5825 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlText_in_xmlElementContentHelper5835 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_XML_LS_STD_in_xmlListInitialiser5856 = new BitSet(new ulong[]{0xFFFFFFFFFFFFFFF0UL,0x00167F3E7FE7FFBFUL,0x00000000000F5203UL});
    public static readonly BitSet FOLLOW_xmlElementContent_in_xmlListInitialiser5871 = new BitSet(new ulong[]{0x0000000000000000UL,0x0010000000000000UL});
    public static readonly BitSet FOLLOW_XML_LS_END_in_xmlListInitialiser5883 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_SEMI_in_semic5914 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_EOF_in_semic5928 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_RCURLY_in_semic5942 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_packageDeclaration_in_fileContents5962 = new BitSet(new ulong[]{0xAFFFFFFFFFFFFFF2UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_packageElement_in_fileContents5965 = new BitSet(new ulong[]{0xAFFFFFFFFFFFFFF2UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_EOF_in_fileContents5971 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_PACKAGE_in_packageDeclaration5988 = new BitSet(new ulong[]{0x0BFFFFFFFFFFFFF0UL,0x0000000000002000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_type_in_packageDeclaration5993 = new BitSet(new ulong[]{0x0800000000000000UL});
    public static readonly BitSet FOLLOW_LCURLY_in_packageDeclaration6007 = new BitSet(new ulong[]{0xBFFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_packageElement_in_packageDeclaration6023 = new BitSet(new ulong[]{0xBFFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_RCURLY_in_packageDeclaration6042 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_propertyDeclaration_in_mxmlEmbedded6067 = new BitSet(new ulong[]{0xAFFFFFFFFFFFFFF2UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_functionDeclaration_in_mxmlEmbedded6071 = new BitSet(new ulong[]{0xAFFFFFFFFFFFFFF2UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_statement_in_mxmlEmbedded6075 = new BitSet(new ulong[]{0xAFFFFFFFFFFFFFF2UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_directive_in_mxmlEmbedded6079 = new BitSet(new ulong[]{0xAFFFFFFFFFFFFFF2UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_interfaceFunctionDeclaration_in_mxmlEmbedded6083 = new BitSet(new ulong[]{0xAFFFFFFFFFFFFFF2UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_EOF_in_mxmlEmbedded6089 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_classOrInterfaceDecl_in_packageElement6109 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_propertyDeclaration_in_packageElement6113 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_functionDeclaration_in_packageElement6117 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_interfaceFunctionDeclaration_in_packageElement6121 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_statement_in_packageElement6125 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_directive_in_packageElement6129 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_IMPORT_in_importDeclaration6149 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000002000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_type_in_importDeclaration6153 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DOT_in_importDeclaration6158 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000002000UL});
    public static readonly BitSet FOLLOW_STAR_in_importDeclaration6164 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_semic_in_importDeclaration6170 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_conditionalDirAndBindingDecls_in_classOrInterfaceDecl6185 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_memberModifiers_in_classOrInterfaceDecl6193 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_interfaceDeclaration_in_classOrInterfaceDecl6197 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_classDeclaration_in_classOrInterfaceDecl6201 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_bindingDecl_in_directive6217 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_includeDirective_in_directive6221 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_useNamespaceDirective_in_directive6225 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_importDeclaration_in_directive6229 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_defaultXMLNamespaceDirective_in_directive6235 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_conditionalCompilerOption_in_conditionalDirAndBindingDecls6261 = new BitSet(new ulong[]{0x8000000000000002UL});
    public static readonly BitSet FOLLOW_bindingDecl_in_conditionalDirAndBindingDecls6278 = new BitSet(new ulong[]{0x8000000000000002UL});
    public static readonly BitSet FOLLOW_IDENTIFIER_in_xmlKeyword6296 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_identifierLiteral_in_conditionalCompilerOption6312 = new BitSet(new ulong[]{0x0000000000000000UL,0x0002000000000000UL});
    public static readonly BitSet FOLLOW_XML_NS_OP_in_conditionalCompilerOption6316 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_identifierLiteral_in_conditionalCompilerOption6320 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DEFAULT_in_defaultXMLNamespaceDirective6334 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_xmlKeyword_in_defaultXMLNamespaceDirective6338 = new BitSet(new ulong[]{0x0010000000000000UL});
    public static readonly BitSet FOLLOW_NAMESPACE_in_defaultXMLNamespaceDirective6346 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000040000000UL});
    public static readonly BitSet FOLLOW_ASSIGN_in_defaultXMLNamespaceDirective6354 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_IDENTIFIER_in_defaultXMLNamespaceDirective6360 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_semic_in_defaultXMLNamespaceDirective6364 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LBRACK_in_bindingDecl6384 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_IDENTIFIER_in_bindingDecl6394 = new BitSet(new ulong[]{0x2000000000000000UL,0x0000000000000001UL});
    public static readonly BitSet FOLLOW_LPAREN_in_bindingDecl6420 = new BitSet(new ulong[]{0x43FFFFFFFFFFFFF0UL,0x0004000000002000UL,0x0000000000005203UL});
    public static readonly BitSet FOLLOW_bindingDeclArg_in_bindingDecl6433 = new BitSet(new ulong[]{0x4000000000000000UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_COMMA_in_bindingDecl6438 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0004000000002000UL,0x0000000000005203UL});
    public static readonly BitSet FOLLOW_bindingDeclArg_in_bindingDecl6442 = new BitSet(new ulong[]{0x4000000000000000UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_RPAREN_in_bindingDecl6456 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000001UL});
    public static readonly BitSet FOLLOW_RBRACK_in_bindingDecl6478 = new BitSet(new ulong[]{0x0400000000000002UL});
    public static readonly BitSet FOLLOW_SEMI_in_bindingDecl6484 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_INCLUDE_in_includeDirective6509 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000000UL,0x0000000000000003UL});
    public static readonly BitSet FOLLOW_stringLiteral_in_includeDirective6512 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_semic_in_includeDirective6514 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_IDENTIFIER_in_bindingDeclArg6545 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000040000000UL});
    public static readonly BitSet FOLLOW_ASSIGN_in_bindingDeclArg6551 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0004000000002000UL,0x0000000000005203UL});
    public static readonly BitSet FOLLOW_stringLiteral_in_bindingDeclArg6564 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_numericLiteral_in_bindingDeclArg6568 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_eitherIdentifier_in_bindingDeclArg6572 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_INTERFACE_in_interfaceDeclaration6594 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000002000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_type_in_interfaceDeclaration6598 = new BitSet(new ulong[]{0x0800000000008000UL});
    public static readonly BitSet FOLLOW_EXTENDS_in_interfaceDeclaration6603 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000002000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_typeList_in_interfaceDeclaration6607 = new BitSet(new ulong[]{0x0800000000008000UL});
    public static readonly BitSet FOLLOW_interfaceBody_in_interfaceDeclaration6621 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LCURLY_in_interfaceBody6637 = new BitSet(new ulong[]{0xBFFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_interfaceElement_in_interfaceBody6653 = new BitSet(new ulong[]{0xBFFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_RCURLY_in_interfaceBody6672 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_CLASS_in_classDeclaration6690 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000002000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_type_in_classDeclaration6694 = new BitSet(new ulong[]{0x0800000000208000UL});
    public static readonly BitSet FOLLOW_EXTENDS_in_classDeclaration6700 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000002000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_type_in_classDeclaration6704 = new BitSet(new ulong[]{0x0800000000208000UL});
    public static readonly BitSet FOLLOW_IMPLEMENTS_in_classDeclaration6712 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000002000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_typeList_in_classDeclaration6716 = new BitSet(new ulong[]{0x0800000000208000UL});
    public static readonly BitSet FOLLOW_classBody_in_classDeclaration6730 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LCURLY_in_classBody6759 = new BitSet(new ulong[]{0xBFFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_classBodyElement_in_classBody6769 = new BitSet(new ulong[]{0xBFFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_RCURLY_in_classBody6782 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_propertyDeclaration_in_classBodyElement6806 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_functionDeclaration_in_classBodyElement6810 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_statement_in_classBodyElement6814 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_directive_in_classBodyElement6818 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_propertyDeclaration_in_interfaceElement6835 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_interfaceFunctionDeclaration_in_interfaceElement6839 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_statement_in_interfaceElement6843 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_directive_in_interfaceElement6846 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_conditionalDirAndBindingDecls_in_interfaceFunctionDeclaration6876 = new BitSet(new ulong[]{0x03C0000714080000UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_memberModifiers_in_interfaceFunctionDeclaration6882 = new BitSet(new ulong[]{0x0000000000080000UL});
    public static readonly BitSet FOLLOW_FUNCTION_in_interfaceFunctionDeclaration6887 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_SET_in_interfaceFunctionDeclaration6906 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_GET_in_interfaceFunctionDeclaration6913 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_IDENTIFIER_in_interfaceFunctionDeclaration6927 = new BitSet(new ulong[]{0x2000000000000000UL});
    public static readonly BitSet FOLLOW_notQuiteReservedWord_in_interfaceFunctionDeclaration6933 = new BitSet(new ulong[]{0x2000000000000000UL});
    public static readonly BitSet FOLLOW_formalParameterList_in_interfaceFunctionDeclaration6936 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000020000002UL});
    public static readonly BitSet FOLLOW_COLON_in_interfaceFunctionDeclaration6941 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000002000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_type_in_interfaceFunctionDeclaration6945 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_semic_in_interfaceFunctionDeclaration6949 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_conditionalDirAndBindingDecls_in_propertyDeclaration6973 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_memberModifiers_in_propertyDeclaration6980 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_variableStatement_in_propertyDeclaration6984 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_constantVarStatement_in_propertyDeclaration6988 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_namespaceDirective_in_propertyDeclaration6992 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_conditionalDirAndBindingDecls_in_functionDeclaration7017 = new BitSet(new ulong[]{0x03C0000714080000UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_memberModifiers_in_functionDeclaration7024 = new BitSet(new ulong[]{0x0000000000080000UL});
    public static readonly BitSet FOLLOW_FUNCTION_in_functionDeclaration7029 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_set_in_functionDeclaration7041 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_IDENTIFIER_in_functionDeclaration7058 = new BitSet(new ulong[]{0x2000000000000000UL});
    public static readonly BitSet FOLLOW_notQuiteReservedWord_in_functionDeclaration7064 = new BitSet(new ulong[]{0x2000000000000000UL});
    public static readonly BitSet FOLLOW_formalParameterList_in_functionDeclaration7067 = new BitSet(new ulong[]{0x0800000000000000UL,0x0000000020000000UL});
    public static readonly BitSet FOLLOW_COLON_in_functionDeclaration7072 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000002000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_type_in_functionDeclaration7076 = new BitSet(new ulong[]{0x0800000000000000UL,0x0000000020000000UL});
    public static readonly BitSet FOLLOW_functionBody_in_functionDeclaration7082 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_FUNCTION_in_functionExpression7110 = new BitSet(new ulong[]{0x2000000000000000UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_IDENTIFIER_in_functionExpression7117 = new BitSet(new ulong[]{0x2000000000000000UL});
    public static readonly BitSet FOLLOW_formalParameterList_in_functionExpression7122 = new BitSet(new ulong[]{0x0800000000000000UL,0x0000000020000000UL});
    public static readonly BitSet FOLLOW_COLON_in_functionExpression7127 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000002000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_type_in_functionExpression7131 = new BitSet(new ulong[]{0x0800000000000000UL,0x0000000020000000UL});
    public static readonly BitSet FOLLOW_functionBody_in_functionExpression7137 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LPAREN_in_formalParameterList7180 = new BitSet(new ulong[]{0x43FFFFFFFFFFFFF0UL,0x0000200000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_variableDeclaration_in_formalParameterList7199 = new BitSet(new ulong[]{0x4000000000000000UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_COMMA_in_formalParameterList7234 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_variableDeclaration_in_formalParameterList7269 = new BitSet(new ulong[]{0x4000000000000000UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_COMMA_in_formalParameterList7306 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000200000000000UL});
    public static readonly BitSet FOLLOW_formalEllipsisParameter_in_formalParameterList7312 = new BitSet(new ulong[]{0x4000000000000000UL});
    public static readonly BitSet FOLLOW_formalEllipsisParameter_in_formalParameterList7344 = new BitSet(new ulong[]{0x4000000000000000UL});
    public static readonly BitSet FOLLOW_RPAREN_in_formalParameterList7368 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ELLIPSIS_in_formalEllipsisParameter7415 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_variableIdentifierDecl_in_formalEllipsisParameter7420 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LCURLY_in_functionBody7444 = new BitSet(new ulong[]{0xBFFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_statement_in_functionBody7462 = new BitSet(new ulong[]{0xBFFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_functionDeclaration_in_functionBody7464 = new BitSet(new ulong[]{0xBFFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_RCURLY_in_functionBody7478 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_memberModifier_in_memberModifiers7506 = new BitSet(new ulong[]{0x03C0000714000002UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_set_in_memberModifier7533 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_blockStatement_in_statement7673 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_directive_in_statement7684 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_namespaceDirective_in_statement7695 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_expression_in_statement7708 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_semic_in_statement7710 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_constantVarStatement_in_statement7725 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_tryStatement_in_statement7738 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_labelledStatement_in_statement7750 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_switchStatement_in_statement7763 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_withStatement_in_statement7775 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_returnStatement_in_statement7789 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_breakStatement_in_statement7805 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_continueStatement_in_statement7821 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_forStatement_in_statement7835 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_forInStatement_in_statement7847 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_forEachInStatement_in_statement7859 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_doWhileStatement_in_statement7871 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_whileStatement_in_statement7883 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ifStatement_in_statement7894 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_emptyStatement_in_statement7905 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_variableStatement_in_statement7919 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_throwStatement_in_statement7935 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_conditionalCompilerOption_in_blockStatement7966 = new BitSet(new ulong[]{0x0800000000000000UL});
    public static readonly BitSet FOLLOW_LCURLY_in_blockStatement7972 = new BitSet(new ulong[]{0xBFFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_statement_in_blockStatement7989 = new BitSet(new ulong[]{0xBFFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_RCURLY_in_blockStatement8002 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_THROW_in_throwStatement8023 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_expression_in_throwStatement8027 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_semic_in_throwStatement8029 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_CONST_in_constantVarStatement8049 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_variableDeclarationList_in_constantVarStatement8054 = new BitSet(new ulong[]{0x0400000000000002UL});
    public static readonly BitSet FOLLOW_SEMI_in_constantVarStatement8059 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_USE_in_useNamespaceDirective8161 = new BitSet(new ulong[]{0x0010000000000000UL});
    public static readonly BitSet FOLLOW_NAMESPACE_in_useNamespaceDirective8170 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_qualifiedIdentifier_in_useNamespaceDirective8177 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000000000006UL});
    public static readonly BitSet FOLLOW_COMMA_in_useNamespaceDirective8182 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_qualifiedIdentifier_in_useNamespaceDirective8186 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000000000006UL});
    public static readonly BitSet FOLLOW_semic_in_useNamespaceDirective8190 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_NAMESPACE_in_namespaceDirective8220 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_qualifiedIdentifier_in_namespaceDirective8231 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000040000002UL});
    public static readonly BitSet FOLLOW_ASSIGN_in_namespaceDirective8237 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000000UL,0x0000000000000003UL});
    public static readonly BitSet FOLLOW_stringLiteral_in_namespaceDirective8242 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_semic_in_namespaceDirective8247 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_TRY_in_tryStatement8275 = new BitSet(new ulong[]{0x0BFFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_blockStatement_in_tryStatement8281 = new BitSet(new ulong[]{0x0000000000020080UL});
    public static readonly BitSet FOLLOW_catchClause_in_tryStatement8295 = new BitSet(new ulong[]{0x0000000000020080UL});
    public static readonly BitSet FOLLOW_finallyClause_in_tryStatement8298 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_catchClause_in_tryStatement8310 = new BitSet(new ulong[]{0x0000000000000082UL});
    public static readonly BitSet FOLLOW_finallyClause_in_tryStatement8323 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_CATCH_in_catchClause8355 = new BitSet(new ulong[]{0x2000000000000000UL});
    public static readonly BitSet FOLLOW_LPAREN_in_catchClause8362 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_variableIdentifierDecl_in_catchClause8366 = new BitSet(new ulong[]{0x4000000000000000UL});
    public static readonly BitSet FOLLOW_RPAREN_in_catchClause8370 = new BitSet(new ulong[]{0x0BFFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_blockStatement_in_catchClause8374 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_FINALLY_in_finallyClause8398 = new BitSet(new ulong[]{0x0BFFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_blockStatement_in_finallyClause8403 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_IDENTIFIER_in_labelledStatement8429 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000020000000UL});
    public static readonly BitSet FOLLOW_COLON_in_labelledStatement8442 = new BitSet(new ulong[]{0xAFFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_statement_in_labelledStatement8458 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_SWITCH_in_switchStatement8493 = new BitSet(new ulong[]{0x2000000000000000UL});
    public static readonly BitSet FOLLOW_parExpression_in_switchStatement8498 = new BitSet(new ulong[]{0x0800000000000000UL});
    public static readonly BitSet FOLLOW_LCURLY_in_switchStatement8510 = new BitSet(new ulong[]{0x1000000000000840UL});
    public static readonly BitSet FOLLOW_switchBlockStatementGroup_in_switchStatement8526 = new BitSet(new ulong[]{0x1000000000000840UL});
    public static readonly BitSet FOLLOW_RCURLY_in_switchStatement8539 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_switchLabel_in_switchBlockStatementGroup8572 = new BitSet(new ulong[]{0xAFFFFFFFFFFFFFF2UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_statement_in_switchBlockStatementGroup8576 = new BitSet(new ulong[]{0xAFFFFFFFFFFFFFF2UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_breakStatement_in_switchBlockStatementGroup8582 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_CASE_in_switchLabel8608 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_expression_in_switchLabel8612 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000020000000UL});
    public static readonly BitSet FOLLOW_COLON_in_switchLabel8616 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DEFAULT_in_switchLabel8637 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000020000000UL});
    public static readonly BitSet FOLLOW_COLON_in_switchLabel8643 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_WITH_in_withStatement8677 = new BitSet(new ulong[]{0x2000000000000000UL});
    public static readonly BitSet FOLLOW_LPAREN_in_withStatement8685 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_expression_in_withStatement8690 = new BitSet(new ulong[]{0x4000000000000000UL});
    public static readonly BitSet FOLLOW_RPAREN_in_withStatement8695 = new BitSet(new ulong[]{0xAFFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_statement_in_withStatement8703 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_RETURN_in_returnStatement8730 = new BitSet(new ulong[]{0xBFFFFFFFFFFFFFF0UL,0x000C00000303380AUL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_expression_in_returnStatement8738 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_semic_in_returnStatement8742 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_BREAK_in_breakStatement8769 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000000000002UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_IDENTIFIER_in_breakStatement8779 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_semic_in_breakStatement8784 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_CONTINUE_in_continueStatement8810 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000000000002UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_IDENTIFIER_in_continueStatement8817 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_semic_in_continueStatement8822 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_FOR_in_forStatement8848 = new BitSet(new ulong[]{0x2000000000000000UL});
    public static readonly BitSet FOLLOW_LPAREN_in_forStatement8856 = new BitSet(new ulong[]{0xBFFFFFFFFFFFFFF0UL,0x000C00000303380AUL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_forControl_in_forStatement8860 = new BitSet(new ulong[]{0x4000000000000000UL});
    public static readonly BitSet FOLLOW_RPAREN_in_forStatement8864 = new BitSet(new ulong[]{0xAFFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_statement_in_forStatement8870 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_FOR_in_forInStatement8897 = new BitSet(new ulong[]{0x2000000000000000UL});
    public static readonly BitSet FOLLOW_LPAREN_in_forInStatement8905 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000000002008UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_forInControl_in_forInStatement8909 = new BitSet(new ulong[]{0x4000000000000000UL});
    public static readonly BitSet FOLLOW_RPAREN_in_forInStatement8913 = new BitSet(new ulong[]{0xAFFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_statement_in_forInStatement8921 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_FOR_in_forEachInStatement8950 = new BitSet(new ulong[]{0x0002000000000000UL});
    public static readonly BitSet FOLLOW_EACH_in_forEachInStatement8968 = new BitSet(new ulong[]{0x2000000000000000UL});
    public static readonly BitSet FOLLOW_LPAREN_in_forEachInStatement8979 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000000002008UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_forInControl_in_forEachInStatement8983 = new BitSet(new ulong[]{0x4000000000000000UL});
    public static readonly BitSet FOLLOW_RPAREN_in_forEachInStatement8987 = new BitSet(new ulong[]{0xAFFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_statement_in_forEachInStatement8993 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_forInit_in_forControl9023 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_semic_in_forControl9028 = new BitSet(new ulong[]{0xBFFFFFFFFFFFFFF0UL,0x000C00000303380AUL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_expression_in_forControl9033 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_semic_in_forControl9037 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF2UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_forUpdate_in_forControl9041 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_forInDecl_in_forInControl9069 = new BitSet(new ulong[]{0x0000000000800000UL});
    public static readonly BitSet FOLLOW_IN_in_forInControl9073 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_expression_in_forInControl9077 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_leftHandSideExpression_in_forInDecl9096 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_VAR_in_forInDecl9108 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_variableDeclarationNoIn_in_forInDecl9112 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_variableDeclarationNoInList_in_forInit9131 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_expressionNoIn_in_forInit9141 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_expression_in_forUpdate9160 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DO_in_doWhileStatement9186 = new BitSet(new ulong[]{0xAFFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_statement_in_doWhileStatement9192 = new BitSet(new ulong[]{0x0000800000000000UL});
    public static readonly BitSet FOLLOW_WHILE_in_doWhileStatement9201 = new BitSet(new ulong[]{0x2000000000000000UL});
    public static readonly BitSet FOLLOW_parExpression_in_doWhileStatement9205 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_semic_in_doWhileStatement9207 = new BitSet(new ulong[]{0x0400000000000002UL});
    public static readonly BitSet FOLLOW_SEMI_in_doWhileStatement9212 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_WHILE_in_whileStatement9242 = new BitSet(new ulong[]{0x2000000000000000UL});
    public static readonly BitSet FOLLOW_parExpression_in_whileStatement9247 = new BitSet(new ulong[]{0xAFFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_statement_in_whileStatement9253 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_IF_in_ifStatement9316 = new BitSet(new ulong[]{0x2000000000000000UL});
    public static readonly BitSet FOLLOW_parExpression_in_ifStatement9351 = new BitSet(new ulong[]{0xAFFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_statement_in_ifStatement9396 = new BitSet(new ulong[]{0x0000000000004002UL});
    public static readonly BitSet FOLLOW_ELSE_in_ifStatement9451 = new BitSet(new ulong[]{0xAFFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_statement_in_ifStatement9492 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_SEMI_in_emptyStatement9550 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_IDENTIFIER_in_variableStatement9597 = new BitSet(new ulong[]{0x0000200000000000UL});
    public static readonly BitSet FOLLOW_VAR_in_variableStatement9605 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_variableDeclaration_in_variableStatement9609 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000000000006UL});
    public static readonly BitSet FOLLOW_COMMA_in_variableStatement9616 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_variableDeclaration_in_variableStatement9621 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000000000006UL});
    public static readonly BitSet FOLLOW_semic_in_variableStatement9626 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_variableDeclaration_in_variableDeclarationList9668 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_COMMA_in_variableDeclarationList9676 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_variableDeclaration_in_variableDeclarationList9681 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_VAR_in_variableDeclarationNoInList9710 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_variableDeclarationNoIn_in_variableDeclarationNoInList9716 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_COMMA_in_variableDeclarationNoInList9724 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_variableDeclarationNoIn_in_variableDeclarationNoInList9729 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_variableIdentifierDecl_in_variableDeclaration9754 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000040000000UL});
    public static readonly BitSet FOLLOW_ASSIGN_in_variableDeclaration9760 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_variableDeclaration9776 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_variableIdentifierDecl_in_variableDeclarationNoIn9799 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000040000000UL});
    public static readonly BitSet FOLLOW_ASSIGN_in_variableDeclarationNoIn9805 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_assignmentExpressionNoIn_in_variableDeclarationNoIn9829 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_identifierLiteral_in_variableIdentifierDecl9856 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000020000000UL});
    public static readonly BitSet FOLLOW_COLON_in_variableIdentifierDecl9862 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000002000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_type_in_variableIdentifierDecl9866 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_qualifiedName_in_type9890 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_STAR_in_type9896 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_VOID_in_type9904 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_type_in_typeList9921 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_COMMA_in_typeList9927 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000002000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_type_in_typeList9932 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_typeSpecifier_in_standardQualifiedName9956 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DOT_in_standardQualifiedName9961 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_typeSpecifier_in_standardQualifiedName9965 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_standardQualifiedName_in_qualifiedName9993 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_typePostfixSyntax_in_qualifiedName9996 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DOT_in_typePostfixSyntax10018 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000008UL});
    public static readonly BitSet FOLLOW_LT_in_typePostfixSyntax10024 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_standardQualifiedName_in_typePostfixSyntax10028 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000012UL});
    public static readonly BitSet FOLLOW_typePostfixSyntax_in_typePostfixSyntax10031 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000010UL});
    public static readonly BitSet FOLLOW_GT_in_typePostfixSyntax10037 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_IDENTIFIER_in_qualifiedIdentifier10061 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LPAREN_in_parExpression10086 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_expression_in_parExpression10093 = new BitSet(new ulong[]{0x4000000000000000UL});
    public static readonly BitSet FOLLOW_RPAREN_in_parExpression10098 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_expression10139 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_COMMA_in_expression10147 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_expression10153 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_assignmentExpressionNoIn_in_expressionNoIn10181 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_COMMA_in_expressionNoIn10189 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_assignmentExpressionNoIn_in_expressionNoIn10195 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_leftHandSideExpression_in_assignmentExpression10224 = new BitSet(new ulong[]{0x0000000000000000UL,0x00001F3E40002010UL});
    public static readonly BitSet FOLLOW_assignmentOperator_in_assignmentExpression10227 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_assignmentExpression10230 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_conditionalExpression_in_assignmentExpression10238 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_conditionalExpressionNoIn_in_assignmentExpressionNoIn10258 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_leftHandSideExpression_in_assignmentExpressionNoIn10268 = new BitSet(new ulong[]{0x0000000000000000UL,0x00001F3E40002010UL});
    public static readonly BitSet FOLLOW_assignmentOperator_in_assignmentExpressionNoIn10271 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_assignmentExpressionNoIn_in_assignmentExpressionNoIn10274 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_assignmentOperator_int_in_assignmentOperator10290 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ASSIGN_in_assignmentOperator_int10316 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_STAR_in_assignmentOperator_int10325 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000040000000UL});
    public static readonly BitSet FOLLOW_ASSIGN_in_assignmentOperator_int10329 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DIV_ASSIGN_in_assignmentOperator_int10340 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_MOD_ASSIGN_in_assignmentOperator_int10349 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ADD_ASSIGN_in_assignmentOperator_int10358 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_SUB_ASSIGN_in_assignmentOperator_int10367 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_SHL_ASSIGN_in_assignmentOperator_int10375 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_GT_in_assignmentOperator_int10399 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000010UL});
    public static readonly BitSet FOLLOW_GT_in_assignmentOperator_int10403 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000040000000UL});
    public static readonly BitSet FOLLOW_ASSIGN_in_assignmentOperator_int10407 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_GT_in_assignmentOperator_int10453 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000010UL});
    public static readonly BitSet FOLLOW_GT_in_assignmentOperator_int10457 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000010UL});
    public static readonly BitSet FOLLOW_GT_in_assignmentOperator_int10461 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000040000000UL});
    public static readonly BitSet FOLLOW_ASSIGN_in_assignmentOperator_int10465 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_AND_ASSIGN_in_assignmentOperator_int10496 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_XOR_ASSIGN_in_assignmentOperator_int10505 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_OR_ASSIGN_in_assignmentOperator_int10514 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LOR_ASSIGN_in_assignmentOperator_int10522 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LAND_ASSIGN_in_assignmentOperator_int10530 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_logicalORExpression_in_conditionalExpression10550 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000010000000UL});
    public static readonly BitSet FOLLOW_QUE_in_conditionalExpression10556 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_conditionalExpression10561 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000020000000UL});
    public static readonly BitSet FOLLOW_COLON_in_conditionalExpression10568 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_conditionalExpression10573 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_logicalORExpressionNoIn_in_conditionalExpressionNoIn10600 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000010000000UL});
    public static readonly BitSet FOLLOW_QUE_in_conditionalExpressionNoIn10606 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_conditionalExpressionNoIn10610 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000020000000UL});
    public static readonly BitSet FOLLOW_COLON_in_conditionalExpressionNoIn10617 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_conditionalExpressionNoIn10622 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_logicalANDExpression_in_logicalORExpression10654 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000008000000UL});
    public static readonly BitSet FOLLOW_LOR_in_logicalORExpression10660 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_logicalANDExpression_in_logicalORExpression10664 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000008000000UL});
    public static readonly BitSet FOLLOW_logicalANDExpressionNoIn_in_logicalORExpressionNoIn10692 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000008000000UL});
    public static readonly BitSet FOLLOW_LOR_in_logicalORExpressionNoIn10698 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_logicalANDExpressionNoIn_in_logicalORExpressionNoIn10702 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000008000000UL});
    public static readonly BitSet FOLLOW_bitwiseORExpression_in_logicalANDExpression10734 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000004000000UL});
    public static readonly BitSet FOLLOW_LAND_in_logicalANDExpression10740 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_bitwiseORExpression_in_logicalANDExpression10744 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000004000000UL});
    public static readonly BitSet FOLLOW_bitwiseORExpressionNoIn_in_logicalANDExpressionNoIn10771 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000004000000UL});
    public static readonly BitSet FOLLOW_LAND_in_logicalANDExpressionNoIn10777 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_bitwiseORExpressionNoIn_in_logicalANDExpressionNoIn10781 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000004000000UL});
    public static readonly BitSet FOLLOW_bitwiseXORExpression_in_bitwiseORExpression10813 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000400000UL});
    public static readonly BitSet FOLLOW_OR_in_bitwiseORExpression10819 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_bitwiseXORExpression_in_bitwiseORExpression10823 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000400000UL});
    public static readonly BitSet FOLLOW_bitwiseXORExpressionNoIn_in_bitwiseORExpressionNoIn10850 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000400000UL});
    public static readonly BitSet FOLLOW_OR_in_bitwiseORExpressionNoIn10856 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_bitwiseXORExpressionNoIn_in_bitwiseORExpressionNoIn10860 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000400000UL});
    public static readonly BitSet FOLLOW_bitwiseANDExpression_in_bitwiseXORExpression10891 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000800000UL});
    public static readonly BitSet FOLLOW_XOR_in_bitwiseXORExpression10897 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_bitwiseANDExpression_in_bitwiseXORExpression10901 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000800000UL});
    public static readonly BitSet FOLLOW_bitwiseANDExpressionNoIn_in_bitwiseXORExpressionNoIn10928 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000800000UL});
    public static readonly BitSet FOLLOW_XOR_in_bitwiseXORExpressionNoIn10934 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_bitwiseANDExpressionNoIn_in_bitwiseXORExpressionNoIn10938 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000800000UL});
    public static readonly BitSet FOLLOW_equalityExpression_in_bitwiseANDExpression10965 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000200000UL});
    public static readonly BitSet FOLLOW_AND_in_bitwiseANDExpression10971 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_equalityExpression_in_bitwiseANDExpression10975 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000200000UL});
    public static readonly BitSet FOLLOW_equalityExpressionNoIn_in_bitwiseANDExpressionNoIn11002 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000200000UL});
    public static readonly BitSet FOLLOW_AND_in_bitwiseANDExpressionNoIn11008 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_equalityExpressionNoIn_in_bitwiseANDExpressionNoIn11012 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000200000UL});
    public static readonly BitSet FOLLOW_relationalExpression_in_equalityExpression11040 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000780UL});
    public static readonly BitSet FOLLOW_set_in_equalityExpression11046 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_relationalExpression_in_equalityExpression11058 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000780UL});
    public static readonly BitSet FOLLOW_relationalExpressionNoIn_in_equalityExpressionNoIn11085 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000780UL});
    public static readonly BitSet FOLLOW_set_in_equalityExpressionNoIn11091 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_relationalExpressionNoIn_in_equalityExpressionNoIn11104 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000780UL});
    public static readonly BitSet FOLLOW_shiftExpression_in_relationalExpression11132 = new BitSet(new ulong[]{0x0000000009800012UL,0x0000000000000038UL});
    public static readonly BitSet FOLLOW_GT_in_relationalExpression11152 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000043033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_ASSIGN_in_relationalExpression11157 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_set_in_relationalExpression11190 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_shiftExpression_in_relationalExpression11228 = new BitSet(new ulong[]{0x0000000009800012UL,0x0000000000000038UL});
    public static readonly BitSet FOLLOW_shiftExpression_in_relationalExpressionNoIn11264 = new BitSet(new ulong[]{0x0000000009000012UL,0x0000000000000038UL});
    public static readonly BitSet FOLLOW_GT_in_relationalExpressionNoIn11284 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000043033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_ASSIGN_in_relationalExpressionNoIn11289 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_set_in_relationalExpressionNoIn11322 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_shiftExpression_in_relationalExpressionNoIn11358 = new BitSet(new ulong[]{0x0000000009000012UL,0x0000000000000038UL});
    public static readonly BitSet FOLLOW_additiveExpression_in_shiftExpression11391 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000040010UL});
    public static readonly BitSet FOLLOW_SHL_in_shiftExpression11413 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_GT_in_shiftExpression11435 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000010UL});
    public static readonly BitSet FOLLOW_GT_in_shiftExpression11439 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_GT_in_shiftExpression11490 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000010UL});
    public static readonly BitSet FOLLOW_GT_in_shiftExpression11494 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000010UL});
    public static readonly BitSet FOLLOW_GT_in_shiftExpression11498 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_additiveExpression_in_shiftExpression11545 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000040010UL});
    public static readonly BitSet FOLLOW_multiplicativeExpression_in_additiveExpression11575 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000001800UL});
    public static readonly BitSet FOLLOW_set_in_additiveExpression11581 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_multiplicativeExpression_in_additiveExpression11589 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000001800UL});
    public static readonly BitSet FOLLOW_unaryExpression_in_multiplicativeExpression11613 = new BitSet(new ulong[]{0x0000000000000002UL,0x000000000000E000UL});
    public static readonly BitSet FOLLOW_set_in_multiplicativeExpression11619 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_unaryExpression_in_multiplicativeExpression11628 = new BitSet(new ulong[]{0x0000000000000002UL,0x000000000000E000UL});
    public static readonly BitSet FOLLOW_postfixExpression_in_unaryExpression11652 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_set_in_unaryExpression11663 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_unaryExpression_in_unaryExpression11673 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_unaryOp_in_unaryExpression11683 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000000002008UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_postfixExpression_in_unaryExpression11685 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_set_in_unaryOp11716 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_leftHandSideExpression_in_postfixExpression11773 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000030000UL});
    public static readonly BitSet FOLLOW_postfixOp_in_postfixExpression11775 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_set_in_postfixOp11801 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_primaryExpression_in_memberExpression11823 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_functionExpression_in_memberExpression11828 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_newExpression_in_memberExpression11833 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_NEW_in_newExpression11846 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000000002008UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_primaryExpression_in_newExpression11851 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_memberExpression_in_leftHandSideExpression11868 = new BitSet(new ulong[]{0xA000000000000002UL,0x0000400000000002UL});
    public static readonly BitSet FOLLOW_arguments_in_leftHandSideExpression11883 = new BitSet(new ulong[]{0xA000000000000002UL,0x0000400000000002UL});
    public static readonly BitSet FOLLOW_LBRACK_in_leftHandSideExpression11895 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_expression_in_leftHandSideExpression11899 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000001UL});
    public static readonly BitSet FOLLOW_RBRACK_in_leftHandSideExpression11903 = new BitSet(new ulong[]{0xA000000000000002UL,0x0000400000000002UL});
    public static readonly BitSet FOLLOW_DOT_in_leftHandSideExpression11918 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0004000000002000UL,0x0000000000005203UL});
    public static readonly BitSet FOLLOW_eitherIdentifier_in_leftHandSideExpression11923 = new BitSet(new ulong[]{0x0000000000000000UL,0x0002000000000000UL});
    public static readonly BitSet FOLLOW_XML_NS_OP_in_leftHandSideExpression11927 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0004000000002000UL,0x0000000000005203UL});
    public static readonly BitSet FOLLOW_eitherIdentifier_in_leftHandSideExpression11934 = new BitSet(new ulong[]{0xA000000000000002UL,0x0000400000000002UL});
    public static readonly BitSet FOLLOW_XML_ELLIPSIS_in_leftHandSideExpression11946 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0004000000002000UL,0x0000000000005203UL});
    public static readonly BitSet FOLLOW_eitherIdentifier_in_leftHandSideExpression11950 = new BitSet(new ulong[]{0x0000000000000000UL,0x0002000000000000UL});
    public static readonly BitSet FOLLOW_XML_NS_OP_in_leftHandSideExpression11954 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0004000000002000UL,0x0000000000005203UL});
    public static readonly BitSet FOLLOW_eitherIdentifier_in_leftHandSideExpression11961 = new BitSet(new ulong[]{0xA000000000000002UL,0x0000400000000002UL});
    public static readonly BitSet FOLLOW_DOT_in_leftHandSideExpression11973 = new BitSet(new ulong[]{0x2000000000000000UL});
    public static readonly BitSet FOLLOW_parExpression_in_leftHandSideExpression11977 = new BitSet(new ulong[]{0xA000000000000002UL,0x0000400000000002UL});
    public static readonly BitSet FOLLOW_typePostfixSyntax_in_leftHandSideExpression11987 = new BitSet(new ulong[]{0xA000000000000002UL,0x0000400000000002UL});
    public static readonly BitSet FOLLOW_IDENTIFIER_in_eitherIdentifier12017 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlPropertyIdentifier_in_eitherIdentifier12027 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_allKeywords_in_eitherIdentifier12033 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_IDENTIFIER_in_typeSpecifier12046 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_notQuiteReservedWord_in_typeSpecifier12052 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_INTERNAL_in_typeSpecifier12058 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DEFAULT_in_typeSpecifier12066 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_set_in_notQuiteReservedWord12084 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_reservedWord_in_allKeywords12137 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_notQuiteReservedWord_in_allKeywords12141 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_set_in_reservedWord12158 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LPAREN_in_arguments12722 = new BitSet(new ulong[]{0xEBFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_arguments12734 = new BitSet(new ulong[]{0x4000000000000000UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_COMMA_in_arguments12762 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_arguments12787 = new BitSet(new ulong[]{0x4000000000000000UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_RPAREN_in_arguments12815 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_indexSuffix_in_suffix12854 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_propertyReferenceSuffix_in_suffix12858 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LBRACK_in_indexSuffix12899 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_expression_in_indexSuffix12904 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000001UL});
    public static readonly BitSet FOLLOW_RBRACK_in_indexSuffix12909 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DOT_in_propertyReferenceSuffix12937 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_IDENTIFIER_in_propertyReferenceSuffix12944 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DOT_in_propertyReferenceSuffix12959 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0004000000002000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_xmlPropertyIdentifier_in_propertyReferenceSuffix12964 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DOT_in_propertyReferenceSuffix12977 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_primaryExpressionHelper_in_primaryExpression13010 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_THIS_in_primaryExpressionHelper13037 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_SUPER_in_primaryExpressionHelper13051 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_literal_in_primaryExpressionHelper13063 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_arrayLiteral_in_primaryExpressionHelper13075 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_objectLiteral_in_primaryExpressionHelper13086 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_identifierLiteral_in_primaryExpressionHelper13098 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlPrimaryExpression_in_primaryExpressionHelper13109 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_parExpression_in_primaryExpressionHelper13119 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_conditionalCompilerOption_in_primaryExpressionHelper13130 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LT_in_primaryExpressionHelper13139 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000002000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_type_in_primaryExpressionHelper13143 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000010UL});
    public static readonly BitSet FOLLOW_GT_in_primaryExpressionHelper13147 = new BitSet(new ulong[]{0x8000000000000002UL});
    public static readonly BitSet FOLLOW_arrayLiteral_in_primaryExpressionHelper13152 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LCURLY_in_objectLiteral13177 = new BitSet(new ulong[]{0x13FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000005203UL});
    public static readonly BitSet FOLLOW_propertyNameAndValueList_in_objectLiteral13181 = new BitSet(new ulong[]{0x1000000000000000UL});
    public static readonly BitSet FOLLOW_RCURLY_in_objectLiteral13186 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_propertyNameAndValue_in_propertyNameAndValueList13208 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_COMMA_in_propertyNameAndValueList13214 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000005203UL});
    public static readonly BitSet FOLLOW_propertyNameAndValue_in_propertyNameAndValueList13219 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_propertyName_in_propertyNameAndValue13240 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000020000000UL});
    public static readonly BitSet FOLLOW_COLON_in_propertyNameAndValue13244 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_propertyNameAndValue13262 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_identifierLiteral_in_propertyName13281 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_stringLiteral_in_propertyName13292 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_numericLiteral_in_propertyName13303 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LBRACK_in_arrayLiteral13326 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033809UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_elementList_in_arrayLiteral13330 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000001UL});
    public static readonly BitSet FOLLOW_RBRACK_in_arrayLiteral13335 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_elementList13381 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_COMMA_in_elementList13399 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_elementList13416 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_COMMA_in_elementList13429 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_SUB_in_synpred9_AS3_ex3820 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_DOT_in_synpred9_AS3_ex3828 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_COLON_in_synpred9_AS3_ex3836 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_IDENTIFIER_in_synpred9_AS3_ex3847 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_allKeywords_in_synpred9_AS3_ex3853 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_XML_TEXT_in_synpred68_AS3_ex4895 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlTextElement_in_synpred69_AS3_ex4901 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlQualifiedIdentifier_in_synpred73_AS3_ex5128 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlQualifiedIdentifier_in_synpred74_AS3_ex5233 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlPropertySelector_in_synpred75_AS3_ex5248 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_propertyDeclaration_in_synpred97_AS3_ex6067 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_functionDeclaration_in_synpred98_AS3_ex6071 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_statement_in_synpred99_AS3_ex6075 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_directive_in_synpred100_AS3_ex6079 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_interfaceFunctionDeclaration_in_synpred101_AS3_ex6083 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_classOrInterfaceDecl_in_synpred103_AS3_ex6109 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_propertyDeclaration_in_synpred104_AS3_ex6113 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_functionDeclaration_in_synpred105_AS3_ex6117 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_interfaceFunctionDeclaration_in_synpred106_AS3_ex6121 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_statement_in_synpred107_AS3_ex6125 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_SEMI_in_synpred120_AS3_ex6484 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_propertyDeclaration_in_synpred129_AS3_ex6806 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_functionDeclaration_in_synpred130_AS3_ex6810 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_statement_in_synpred131_AS3_ex6814 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_propertyDeclaration_in_synpred132_AS3_ex6835 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_interfaceFunctionDeclaration_in_synpred133_AS3_ex6839 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_statement_in_synpred134_AS3_ex6843 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_memberModifiers_in_synpred142_AS3_ex6980 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_statement_in_synpred157_AS3_ex7462 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_functionDeclaration_in_synpred158_AS3_ex7464 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_memberModifier_in_synpred159_AS3_ex7506 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_blockStatement_in_synpred169_AS3_ex7673 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_directive_in_synpred170_AS3_ex7684 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_namespaceDirective_in_synpred171_AS3_ex7695 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_expression_in_synpred172_AS3_ex7708 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_semic_in_synpred172_AS3_ex7710 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_constantVarStatement_in_synpred173_AS3_ex7725 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_tryStatement_in_synpred174_AS3_ex7738 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_labelledStatement_in_synpred175_AS3_ex7750 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_switchStatement_in_synpred176_AS3_ex7763 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_withStatement_in_synpred177_AS3_ex7775 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_returnStatement_in_synpred178_AS3_ex7789 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_breakStatement_in_synpred179_AS3_ex7805 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_continueStatement_in_synpred180_AS3_ex7821 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_forStatement_in_synpred181_AS3_ex7835 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_forInStatement_in_synpred182_AS3_ex7847 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_forEachInStatement_in_synpred183_AS3_ex7859 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_doWhileStatement_in_synpred184_AS3_ex7871 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_whileStatement_in_synpred185_AS3_ex7883 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ifStatement_in_synpred186_AS3_ex7894 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_variableStatement_in_synpred188_AS3_ex7919 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_SEMI_in_synpred191_AS3_ex8059 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_catchClause_in_synpred195_AS3_ex8295 = new BitSet(new ulong[]{0x0000000000020080UL});
    public static readonly BitSet FOLLOW_finallyClause_in_synpred195_AS3_ex8298 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_catchClause_in_synpred197_AS3_ex8310 = new BitSet(new ulong[]{0x0000000000000082UL});
    public static readonly BitSet FOLLOW_statement_in_synpred199_AS3_ex8576 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_variableDeclarationNoInList_in_synpred209_AS3_ex9131 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_SEMI_in_synpred210_AS3_ex9212 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ELSE_in_synpred211_AS3_ex9451 = new BitSet(new ulong[]{0xAFFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_statement_in_synpred211_AS3_ex9492 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_leftHandSideExpression_in_synpred228_AS3_ex10224 = new BitSet(new ulong[]{0x0000000000000000UL,0x00001F3E40002010UL});
    public static readonly BitSet FOLLOW_assignmentOperator_in_synpred228_AS3_ex10227 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_synpred228_AS3_ex10230 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_conditionalExpressionNoIn_in_synpred229_AS3_ex10258 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_GT_in_synpred272_AS3_ex11152 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000043033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_ASSIGN_in_synpred272_AS3_ex11157 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_set_in_synpred272_AS3_ex11190 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_shiftExpression_in_synpred272_AS3_ex11228 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_GT_in_synpred283_AS3_ex11480 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000010UL});
    public static readonly BitSet FOLLOW_GT_in_synpred283_AS3_ex11482 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000010UL});
    public static readonly BitSet FOLLOW_GT_in_synpred283_AS3_ex11484 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_set_in_synpred286_AS3_ex11581 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_multiplicativeExpression_in_synpred286_AS3_ex11589 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_set_in_synpred289_AS3_ex11619 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_unaryExpression_in_synpred289_AS3_ex11628 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_postfixExpression_in_synpred290_AS3_ex11652 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_set_in_synpred292_AS3_ex11663 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_unaryExpression_in_synpred292_AS3_ex11673 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_postfixOp_in_synpred301_AS3_ex11775 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_arguments_in_synpred305_AS3_ex11883 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LBRACK_in_synpred306_AS3_ex11895 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x000C000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_expression_in_synpred306_AS3_ex11899 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000001UL});
    public static readonly BitSet FOLLOW_RBRACK_in_synpred306_AS3_ex11903 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_eitherIdentifier_in_synpred307_AS3_ex11923 = new BitSet(new ulong[]{0x0000000000000000UL,0x0002000000000000UL});
    public static readonly BitSet FOLLOW_XML_NS_OP_in_synpred307_AS3_ex11927 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DOT_in_synpred308_AS3_ex11918 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0004000000002000UL,0x0000000000005203UL});
    public static readonly BitSet FOLLOW_eitherIdentifier_in_synpred308_AS3_ex11923 = new BitSet(new ulong[]{0x0000000000000000UL,0x0002000000000000UL});
    public static readonly BitSet FOLLOW_XML_NS_OP_in_synpred308_AS3_ex11927 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0004000000002000UL,0x0000000000005203UL});
    public static readonly BitSet FOLLOW_eitherIdentifier_in_synpred308_AS3_ex11934 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_eitherIdentifier_in_synpred309_AS3_ex11950 = new BitSet(new ulong[]{0x0000000000000000UL,0x0002000000000000UL});
    public static readonly BitSet FOLLOW_XML_NS_OP_in_synpred309_AS3_ex11954 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DOT_in_synpred311_AS3_ex11973 = new BitSet(new ulong[]{0x2000000000000000UL});
    public static readonly BitSet FOLLOW_parExpression_in_synpred311_AS3_ex11977 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_typePostfixSyntax_in_synpred312_AS3_ex11987 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_IDENTIFIER_in_synpred313_AS3_ex12017 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlPropertyIdentifier_in_synpred314_AS3_ex12027 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_THIS_in_synpred376_AS3_ex13037 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_SUPER_in_synpred377_AS3_ex13051 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_literal_in_synpred378_AS3_ex13063 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_identifierLiteral_in_synpred381_AS3_ex13098 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlPrimaryExpression_in_synpred382_AS3_ex13109 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_conditionalCompilerOption_in_synpred384_AS3_ex13130 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_arrayLiteral_in_synpred385_AS3_ex13152 = new BitSet(new ulong[]{0x0000000000000002UL});

}
