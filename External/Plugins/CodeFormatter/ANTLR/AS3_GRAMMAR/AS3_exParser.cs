// $ANTLR 3.1.1 AS3_ex.g3 2015-02-17 22:17:17

using System.Linq;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using CodeFormatter.InfoCollector;
using CodeFormatter.Handlers;
using PluginCore.Managers;

#pragma warning disable 162
#pragma warning disable 414
#pragma warning disable 219


using System;
using Antlr.Runtime;
using IList         = System.Collections.IList;
using ArrayList     = System.Collections.ArrayList;
using Stack         = Antlr.Runtime.Collections.StackList;

using IDictionary   = System.Collections.IDictionary;
using Hashtable     = System.Collections.Hashtable;


using Antlr.Runtime.Tree;

public class AS3_exParser : Parser 
{
    public static readonly string[] tokenNames = new string[] 
    {
        "<invalid>", 
        "<EOR>", 
        "<DOWN>", 
        "<UP>", 
        "AS", 
        "BREAK", 
        "CASE", 
        "CATCH", 
        "CLASS", 
        "CONST", 
        "CONTINUE", 
        "DEFAULT", 
        "DELETE", 
        "DO", 
        "ELSE", 
        "EXTENDS", 
        "FALSE", 
        "FINALLY", 
        "FOR", 
        "FUNCTION", 
        "IF", 
        "IMPLEMENTS", 
        "IMPORT", 
        "IN", 
        "INSTANCEOF", 
        "INTERFACE", 
        "INTERNAL", 
        "IS", 
        "NATIVE", 
        "NEW", 
        "NULL", 
        "PACKAGE", 
        "PRIVATE", 
        "PROTECTED", 
        "PUBLIC", 
        "RETURN", 
        "SUPER", 
        "SWITCH", 
        "THIS", 
        "THROW", 
        "TO", 
        "TRUE", 
        "TRY", 
        "TYPEOF", 
        "USE", 
        "VAR", 
        "VOID", 
        "WHILE", 
        "WITH", 
        "EACH", 
        "GET", 
        "SET", 
        "NAMESPACE", 
        "INCLUDE", 
        "DYNAMIC", 
        "FINAL", 
        "OVERRIDE", 
        "STATIC", 
        "SEMI", 
        "LCURLY", 
        "RCURLY", 
        "LPAREN", 
        "RPAREN", 
        "LBRACK", 
        "RBRACK", 
        "DOT", 
        "COMMA", 
        "LT", 
        "GT", 
        "LTE", 
        "GTE", 
        "EQ", 
        "NEQ", 
        "SAME", 
        "NSAME", 
        "PLUS", 
        "SUB", 
        "STAR", 
        "DIV", 
        "MOD", 
        "INC", 
        "DEC", 
        "SHL", 
        "SHR", 
        "SHU", 
        "AND", 
        "OR", 
        "XOR", 
        "NOT", 
        "INV", 
        "LAND", 
        "LOR", 
        "QUE", 
        "COLON", 
        "ASSIGN", 
        "DIV_ASSIGN", 
        "MOD_ASSIGN", 
        "ADD_ASSIGN", 
        "SUB_ASSIGN", 
        "SHL_ASSIGN", 
        "SHR_ASSIGN", 
        "SHU_ASSIGN", 
        "LAND_ASSIGN", 
        "LOR_ASSIGN", 
        "AND_ASSIGN", 
        "XOR_ASSIGN", 
        "OR_ASSIGN", 
        "ELLIPSIS", 
        "XML_ELLIPSIS", 
        "XML_TEND", 
        "XML_E_TEND", 
        "XML_NS_OP", 
        "XML_AT", 
        "XML_LS_STD", 
        "XML_LS_END", 
        "UNDERSCORE", 
        "DOLLAR", 
        "ALPHABET", 
        "NUMBER", 
        "HEX_DIGIT", 
        "CR", 
        "LF", 
        "UNICODE_ESCAPE", 
        "ESCAPE_SEQUENCE", 
        "EOL", 
        "WHITESPACE", 
        "COMMENT_MULTILINE", 
        "COMMENT_SINGLELINE", 
        "SINGLE_QUOTE_LITERAL", 
        "DOUBLE_QUOTE_LITERAL", 
        "REGULAR_EXPR_BODY", 
        "REGULAR_EXPR_FLAG", 
        "REGULAR_EXPR_LITERAL", 
        "REGULAR_EXPR_FIRST_CHAR", 
        "REGULAR_EXPR_CHAR", 
        "BACKSLASH_SEQUENCE", 
        "IDENT_PART", 
        "HEX_NUMBER_LITERAL", 
        "DEC_NUMBER", 
        "EXPONENT", 
        "DEC_NUMBER_LITERAL", 
        "IDENT_NAME_ASCII_START", 
        "IDENTIFIER", 
        "IDENT_ASCII_START", 
        "XML_COMMENT", 
        "XML_CDATA", 
        "XML_PI", 
        "XML_TEXT"
    };

    public const int UNDERSCORE = 115;
    public const int REGULAR_EXPR_FIRST_CHAR = 133;
    public const int VAR = 45;
    public const int THROW = 39;
    public const int STATIC = 57;
    public const int INTERFACE = 25;
    public const int AND_ASSIGN = 104;
    public const int WHITESPACE = 125;
    public const int BREAK = 5;
    public const int INTERNAL = 26;
    public const int XML_LS_STD = 113;
    public const int DEC_NUMBER_LITERAL = 140;
    public const int ELSE = 14;
    public const int INCLUDE = 53;
    public const int IF = 20;
    public const int EACH = 49;
    public const int SUB = 76;
    public const int IN = 23;
    public const int LPAREN = 61;
    public const int DOT = 65;
    public const int IS = 27;
    public const int FUNCTION = 19;
    public const int LOR = 91;
    public const int CASE = 6;
    public const int AS = 4;
    public const int ELLIPSIS = 107;
    public const int LBRACK = 63;
    public const int GET = 50;
    public const int PUBLIC = 34;
    public const int UNICODE_ESCAPE = 122;
    public const int XOR = 87;
    public const int DOLLAR = 116;
    public const int SAME = 73;
    public const int SET = 51;
    public const int IDENT_NAME_ASCII_START = 141;
    public const int SUB_ASSIGN = 98;
    public const int SEMI = 58;
    public const int ASSIGN = 94;
    public const int IMPORT = 22;
    public const int DELETE = 12;
    public const int CATCH = 7;
    public const int PROTECTED = 33;
    public const int RCURLY = 60;
    public const int COMMA = 66;
    public const int USE = 44;
    public const int REGULAR_EXPR_BODY = 130;
    public const int LCURLY = 59;
    public const int SHL_ASSIGN = 99;
    public const int ALPHABET = 117;
    public const int PRIVATE = 32;
    public const int DYNAMIC = 54;
    public const int CR = 120;
    public const int BACKSLASH_SEQUENCE = 135;
    public const int CONTINUE = 10;
    public const int DIV = 78;
    public const int STAR = 77;
    public const int DEC_NUMBER = 138;
    public const int EXPONENT = 139;
    public const int LF = 121;
    public const int TO = 40;
    public const int NEQ = 72;
    public const int XML_NS_OP = 111;
    public const int NAMESPACE = 52;
    public const int EXTENDS = 15;
    public const int INSTANCEOF = 24;
    public const int NEW = 29;
    public const int COMMENT_SINGLELINE = 127;
    public const int LAND_ASSIGN = 102;
    public const int LT = 67;
    public const int SHU_ASSIGN = 101;
    public const int IDENT_ASCII_START = 143;
    public const int CLASS = 8;
    public const int DO = 13;
    public const int FINALLY = 17;
    public const int ESCAPE_SEQUENCE = 123;
    public const int COMMENT_MULTILINE = 126;
    public const int HEX_NUMBER_LITERAL = 137;
    public const int SHR_ASSIGN = 100;
    public const int REGULAR_EXPR_CHAR = 134;
    public const int CONST = 9;
    public const int PACKAGE = 31;
    public const int SHL = 82;
    public const int XML_TEND = 109;
    public const int OR_ASSIGN = 106;
    public const int TRY = 42;
    public const int SHR = 83;
    public const int QUE = 92;
    public const int SHU = 84;
    public const int NUMBER = 118;
    public const int NULL = 30;
    public const int REGULAR_EXPR_FLAG = 131;
    public const int XML_CDATA = 145;
    public const int FOR = 18;
    public const int TRUE = 41;
    public const int FINAL = 55;
    public const int RPAREN = 62;
    public const int EQ = 71;
    public const int IDENT_PART = 136;
    public const int RBRACK = 64;
    public const int NOT = 88;
    public const int AND = 85;
    public const int THIS = 38;
    public const int SWITCH = 37;
    public const int VOID = 46;
    public const int LTE = 69;
    public const int PLUS = 75;
    public const int INC = 80;
    public const int XML_LS_END = 114;
    public const int NATIVE = 28;
    public const int DIV_ASSIGN = 95;
    public const int NSAME = 74;
    public const int LAND = 90;
    public const int XML_PI = 146;
    public const int XML_TEXT = 147;
    public const int REGULAR_EXPR_LITERAL = 132;
    public const int INV = 89;
    public const int RETURN = 35;
    public const int SINGLE_QUOTE_LITERAL = 128;
    public const int XML_E_TEND = 110;
    public const int HEX_DIGIT = 119;
    public const int ADD_ASSIGN = 97;
    public const int IDENTIFIER = 142;
    public const int EOF = -1;
    public const int LOR_ASSIGN = 103;
    public const int SUPER = 36;
    public const int MOD = 79;
    public const int DEC = 81;
    public const int OR = 86;
    public const int XOR_ASSIGN = 105;
    public const int EOL = 124;
    public const int DOUBLE_QUOTE_LITERAL = 129;
    public const int IMPLEMENTS = 21;
    public const int COLON = 93;
    public const int XML_ELLIPSIS = 108;
    public const int GT = 68;
    public const int WITH = 48;
    public const int XML_AT = 112;
    public const int OVERRIDE = 56;
    public const int XML_COMMENT = 144;
    public const int TYPEOF = 43;
    public const int MOD_ASSIGN = 96;
    public const int GTE = 70;
    public const int FALSE = 16;
    public const int WHILE = 47;
    public const int DEFAULT = 11;

    // delegates
    // delegators



        public AS3_exParser(ITokenStream input)
            : this(input, new RecognizerSharedState()) {
        }

        public AS3_exParser(ITokenStream input, RecognizerSharedState state)
            : base(input, state) {
            InitializeCyclicDFAs();
            this.state.ruleMemo = new Hashtable[549+1];
             
             
       }
        
    protected ITreeAdaptor adaptor = new CommonTreeAdaptor();

    public ITreeAdaptor TreeAdaptor
    {
        get { return this.adaptor; }
        set {
        this.adaptor = value;
        }
    }

    override public string[] TokenNames {
        get { return AS3_exParser.tokenNames; }
    }

    override public string GrammarFileName {
        get { return "AS3_ex.g3"; }
    }


       
            //options
    private List<Exception> mParseErrors;
            
    private ASPrettyPrinter mPrinter;
    private CommonTokenStream mRawTokens;
    private int mStatementCount=0;

    private List<Int32> mCodeBlockStack=new List<Int32>(); //this is used for tracking which block I'm in so that I can handle the open brace differently depending on context
    private bool mIsFunctionDecl; //flag that tells me whether the function body is associated with an expression or a declaration
    private List<IfElseBlockTracker> mIfElseBlocks=new List<IfElseBlockTracker>();
    private List<bool> mXMLTextContentStack=new List<bool>();

    private bool mInFunctionParameterDecl=false; //set during formal parameter list so that I know where variable decls came from
    private bool mInEqualAlignDecl=false; //only set to true for variable statement declarations (not ones in the parameter list, for loops, etc.)

    public AS3_exParser(ASPrettyPrinter printer, CommonTokenStream tokenStream) : this(tokenStream, new RecognizerSharedState())
    {
        mRawTokens=tokenStream;
        mPrinter=printer;
        mStatementCount=0;
    }

    public class IfElseBlockTracker
    {
        public bool mBlockFlag=false;
        public bool mBlockFlagSet=false;
    }

    public void addIfElseBlockTracker()
    {
        mIfElseBlocks.Add(new IfElseBlockTracker());
    }

    public void popIfElseBlockTracker()
    {
        if (mIfElseBlocks.Count>0)
            mIfElseBlocks.RemoveAt(mIfElseBlocks.Count-1);
    }

    public IfElseBlockTracker getCurrentIfElseTracker()
    {
        if (mIfElseBlocks.Count>0)
            return mIfElseBlocks[mIfElseBlocks.Count-1];
            
        return null;
    }

    public void setBlockFlag(bool flag)
    {
        IfElseBlockTracker tracker=getCurrentIfElseTracker();
        if (tracker!=null)
        {
            //don't set if already set
            if (tracker.mBlockFlagSet)
                return;
                
            tracker.mBlockFlag=flag;
            tracker.mBlockFlagSet=true;
        }
    }

    public void markBlockFlag()
    {
        IfElseBlockTracker tracker=getCurrentIfElseTracker();
        if (tracker!=null)
            tracker.mBlockFlagSet=true;
    }

    public void clearBlockFlag()
    {
        IfElseBlockTracker tracker=getCurrentIfElseTracker();
        if (tracker!=null)
            tracker.mBlockFlagSet=false;
    }

    public bool isBlockFlag()
    {
        IfElseBlockTracker tracker=getCurrentIfElseTracker();
        if (tracker!=null)
            return tracker.mBlockFlag;
            
        return false;
    }

    private void popBlockStack()
    {
        if (mCodeBlockStack.Count>0)
        {
            mCodeBlockStack.RemoveAt(mCodeBlockStack.Count-1);
        }
    }

    private void setXMLTextContentFlag()
    {
        if (mXMLTextContentStack.Count>0)
        {
            mXMLTextContentStack[mXMLTextContentStack.Count-1] = true;
        }
    }

    private void pushXMLTextContentFlag()
    {
        mXMLTextContentStack.Add(false);
    }

    private bool popXMLTextContentFlag()
    {
        if (mXMLTextContentStack.Count>0)
        {
            int index=mXMLTextContentStack.Count-1;
            bool value=mXMLTextContentStack[index];
            mXMLTextContentStack.RemoveAt(index);
            return value;
        }
        return false;
    }

    private void emitXMLBreak(IToken tok, bool before)
    {
        WrapOptions options=mPrinter.getXMLWrapOptions();
        if ((options.getWrapType()==WrapOptions.WRAP_BY_COLUMN || options.getWrapType()==WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS))
        {
            mPrinter.saveWrapChar(tok, ASPrettyPrinter.Break_XML_code, before, false, -1, "");
        }
    }

    public bool foundNextLT()
    {
       int i=1;
       while (true)
       {
           IToken token=input.LT(i);
           if (token.Text!=null && token.Text.StartsWith("<"))
              return (i>1);
           if (token.Type==EOF)
              return false;
           i++;   
       }
    }

    public void changeTokensUpToNextLT()
    {
       int i=1;
       while (true)
       {
           IToken t=input.LT(i);
           if (t.Text!=null && t.Text.StartsWith("<"))
              return;
           if (t.Type==EOF)
              return;
           t.Type = XML_TEXT;          
              
           i++;   
       }
    }

    //this is for '.' and other similar characters that might cause a break
    private void wrapEmit(IToken item, int breakType)
    {
        pushExpressionIndent(); //needs to be matched with a popIndent later
        WrapOptions options=mPrinter.getExpressionWrapOptions();
        bool breakBefore=options.isBeforeSeparator();
        if (breakType==ASPrettyPrinter.Break_Assignment_code || breakType==ASPrettyPrinter.Break_Parameter_Assignment_code)
            breakBefore=options.isBeforeAssignmentOperator();
        if ((options.getWrapType()==WrapOptions.WRAP_BY_COLUMN || options.getWrapType()==WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS) && breakBefore)
        {
            insertMaxColumnCR();
        }
        emit(item);
        if ((options.getWrapType()==WrapOptions.WRAP_BY_COLUMN || options.getWrapType()==WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS) && !breakBefore)
        {
            insertMaxColumnCR();
        }
        
        if ((options.getWrapType()==WrapOptions.WRAP_BY_COLUMN || options.getWrapType()==WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS))
        {
            mPrinter.saveWrapChar(item, breakType, (breakType==ASPrettyPrinter.Break_Keyword_code) ? true : breakBefore, false, -1, "");
        }
    }

    //this is for binary operators
    private void indentEmit(IToken operatoR, int breakType)
    {
        pushExpressionIndent(); //needs to be matched with a popIndent later
        WrapOptions options=mPrinter.getExpressionWrapOptions();
        bool breakBefore=options.isBeforeSeparator();
        if (breakType==ASPrettyPrinter.Break_Arithmetic_Ops_code)
            breakBefore=options.isBeforeArithmeticOperator();
        else if (breakType==ASPrettyPrinter.Break_Logical_Ops_code || breakType==ASPrettyPrinter.Break_Ternary_code)
            breakBefore=options.isBeforeLogicalOperator();
        if ((options.getWrapType()==WrapOptions.WRAP_BY_COLUMN || options.getWrapType()==WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS) && breakBefore)
        {
            insertMaxColumnCR();
        }
        char firstChar=Convert.ToChar(0);
        if (operatoR.Text.Length>0)
            firstChar=operatoR.Text[0];
        if (firstChar!=0)
        {
            if (Utilities.isJavaIdentifierPart(firstChar.ToString()))
                insertWS(1); //add 1 space around text operators (ex. 'as', 'instanceof')
            else
                insertWS(mPrinter.getExpressionSpacesAroundSymbolicOperators()); //add configurable symbolic operator value
        }   
        emit(operatoR);
        if ((options.getWrapType()==WrapOptions.WRAP_BY_COLUMN || options.getWrapType()==WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS) && !breakBefore)
        {
            insertMaxColumnCR();
        }
        
        if ((options.getWrapType()==WrapOptions.WRAP_BY_COLUMN || options.getWrapType()==WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS))
        {
            mPrinter.saveWrapChar(operatoR, breakType, breakBefore, false, -1, "");
        }
        
        if (firstChar!=0)
        {
            if (Utilities.isJavaIdentifierPart(firstChar.ToString()))
                insertWS(1); //add 1 space around text operators (ex. 'as', 'instanceof')
            else
                insertWS(mPrinter.getExpressionSpacesAroundSymbolicOperators()); //add configurable symbolic operator value
        }   
    }

    private bool pushWrapInfo(WrapOptions options, bool newLevel)
    {
        if (mPrinter.isDoFormat())
        {
            if (options.getWrapType()==WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS || options.getWrapType()==WrapOptions.WRAP_BY_COLUMN)
            {
                mPrinter.createWrapContext(newLevel);
                return true;
            }
        }
        
        return false;
    }

    private bool pushFormatType(WrapOptions options, bool lazy)
    {
        if (mPrinter.isDoFormat())
        {
            int formatMode=0;
            if (options.getWrapType()==WrapOptions.WRAP_DONT_PROCESS)
            {
                formatMode=ASPrettyPrinter.FORMAT_INDENT;
            }
            else if (options.getWrapType()==WrapOptions.WRAP_FORMAT_NO_CRs)
            {
                formatMode=ASPrettyPrinter.FORMAT_NOCRs;
            }
            else if (options.getWrapType()==WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS)
            {
                formatMode=ASPrettyPrinter.FORMAT_OnlyAddCRs;
            }
            else
            {
                //if we didn't have a restrictive format, we want to make sure we're using the full format
                formatMode=ASPrettyPrinter.FORMAT_ALL;
            }

            if (formatMode>0)
            {
    //          if (formatMode==mPrinter.getFormatMode())
    //              return false; //no need to nest format modes of the same type
                    
                if (lazy)
                    mPrinter.pushLazyFormat(formatMode);
                else
                    mPrinter.pushFormatMode(formatMode);
                return true;
            }
            
        } 
        
        return false;
    }

    private void emitCRForTag(WrapOptions options)
    {
        if (options.getWrapType()==WrapOptions.WRAP_BY_COLUMN || options.getWrapType()==WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS)
        {
            insertMaxColumnCR();
        }
        else if (options.getWrapType()==WrapOptions.WRAP_BY_TAG)
        {
            insertCR(false);
        }

    }

    private bool emitCommaWithSpacingAndCRs(WrapOptions options, IToken comma, bool pushedIndent, int firstParmLocation, String contextType)
    {
        if ((options.getWrapType()==WrapOptions.WRAP_BY_COLUMN || options.getWrapType()==WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS) && options.isBeforeSeparator())
        {
            insertMaxColumnCR();
        }
        
        if (!pushedIndent)
        {
            pushedIndent=true;
            pushExpressionIndent();
        }
        
        insertWS(mPrinter.getSpacesBeforeComma());
        emit(comma); 
        if ((options.getWrapType()==WrapOptions.WRAP_BY_COLUMN || options.getWrapType()==WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS) && !options.isBeforeSeparator())
        {
            insertMaxColumnCR();
        }
        if ((options.getWrapType()==WrapOptions.WRAP_BY_COLUMN || options.getWrapType()==WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS))
        {
            mPrinter.saveWrapChar(comma, ASPrettyPrinter.Break_Commas_code, options.isBeforeSeparator(), options.getIndentStyle()==WrapOptions.WRAP_STYLE_INDENT_TO_WRAP_ELEMENT, firstParmLocation, contextType);
        }
        insertWS(mPrinter.getSpacesAfterComma());
        return pushedIndent;
    }

        public bool findVirtualHiddenToken(ParserRuleReturnScope retval)
        {
                //the point of this method is to look for something that can serve as a semicolon.  So a carriage return
                //or a comment containing a carriage return will fit the bill.
                int index = ((IToken)retval.Start).TokenIndex;
                if(index<0){
                    index = input.Count;
                }
                else
                {
                    IToken lt=input.Get(index);
                    if (lt.Type==EOF || lt.Type==SEMI || lt.Type==RCURLY)
                        return false;
                }
                
    /*            //we are on the next regular channel token after the rule.  So we walk backward to determine if between
                //the rule and this token is a single line comment, multiline comment, or new line that can serve as the
                //end token.  If so, then we 'promote' that token by returning it as the 'end' token of the rule (in place
                //of the semi colon).
                for (int ix = index - 1; ix >= 0; ix--){
                    IToken lt = input.Get(ix);
                    int type = lt.Type;
                    if(lt.Channel == Token.DEFAULT_CHANNEL)
                        break;
                    if (type == EOL || type==COMMENT_SINGLELINE || (type == COMMENT_MULTILINE && Regex.Matches(lt.Text, "/.*\r\n|\r|\n").Count > 0))
                    {
                        retval.Start=lt;
                        return true;
                    }
                }*/
                
                
                //the token index is pointing to the next default channel token, which is not what we want.
                //We want to walk backward to the previous default channel token (first loop), and then walk forward
                //again looking for EOL/comments (2nd loop)
                int ix=index-1;
                for (; ix >= 0; ix--){
                    IToken lt = input.Get(ix);
                    if(lt.Channel == Token.DEFAULT_CHANNEL)
                        break;
                }
                
                //walk forward again
                ix++; //to move to next token that's not default channel
                for (;ix<input.Count;ix++) //now search for the next "statement ender"
                {
                    IToken lt = input.Get(ix);
                    int type = lt.Type;
                    if (lt.Channel == Token.DEFAULT_CHANNEL)
                        break;
                    if (type == EOL || type==COMMENT_SINGLELINE || (type == COMMENT_MULTILINE && Regex.Matches(lt.Text, "/.*\r\n|\r|\n").Count > 0))
                    {
                        retval.Start=lt;
                        return true;
                    }
                }

                return false;

        }

    public void reportError(RecognitionException e)
    {
        if (mParseErrors==null)
            mParseErrors=new List<Exception>();
        mParseErrors.Add(e);
        //base.reportError(e);
    }
            
    private void insertWS(int amt)
    {
        mPrinter.insertWS(amt);
    }

    private void insertLines(int amt)
    {
        insertLines(amt, true);
    }

    private void insertVariableDeclAssignmentWhitespace(IToken equalToken, bool before)
    {
        if (mPrinter.isDoFormat() && !mPrinter.isInParameterDecl() && mPrinter.isKeepingExcessDeclWhitespace())
        {
            int spaceCount=0;
            if (before)
            {
                IToken testToken=mRawTokens.Get(equalToken.TokenIndex-1);
                if (testToken.Channel==CHANNEL_WHITESPACE)
                {
                    //if the token before the whitespace is a carriage return, we *don't* want to apply this "preserve whitespace" logic
                    IToken prevTok=mRawTokens.Get(equalToken.TokenIndex-2);
                    if (!(prevTok.Channel==CHANNEL_SLCOMMENT || prevTok.Channel==CHANNEL_EOL))
                    {
                        if (testToken.Text.IndexOf('\t')>=0)
                        {
                            spaceCount=mPrinter.getColumnForIndex(equalToken, 0)-mPrinter.getColumnForIndex(testToken, 0);
                        }
                        else
                        {
                            spaceCount=testToken.Text.Length;
                        }
                    }
                }
            }
            else
            {
                IToken testToken=mRawTokens.Get(equalToken.TokenIndex+1);
                if (testToken.Channel==CHANNEL_WHITESPACE)
                {
                    //if the token after the whitespace is a carriage return, we *don't* want to apply this "preserve whitespace" logic
                    //I think we only care about actual EOL here, not sl comment or ml comment, since there is actual text before the CR,
                    //even if it's not 'code' text.
                    IToken nextTok=mRawTokens.Get(equalToken.TokenIndex+2);
                    if (!(nextTok.Channel==CHANNEL_EOL))
                    {
                        if (testToken.Text.IndexOf('\t')>=0)
                        {
                            spaceCount=mPrinter.getColumnForIndex(testToken, testToken.Text.Length)-mPrinter.getColumnForIndex(equalToken, equalToken.Text.Length);
                        }
                        else
                        {
                            spaceCount=testToken.Text.Length;
                        }
                    }
                }
            }
            
            if (spaceCount>mPrinter.getSpacesAroundAssignment())
            {
                insertWS(spaceCount);
                return;
            }
        }
        
        insertWS(mPrinter.isInParameterDecl() ? mPrinter.getAdvancedSpacesAroundAssignmentInOptionalParameters() : mPrinter.getSpacesAroundAssignment());
    }

    //this method is for inserting blank lines before elements, based on the format settings
    private void insertLines(int amt, bool inCodeBlock)
    {
        //don't add blank lines if not inside a block
        if (!mPrinter.isHardIndent())
            return;
        //don't add blank lines if the wrapper is a labeled statement indent
        if (mPrinter.isLabeledIndent())
            return;
            
        //don't add blank lines if we are at start of block
        if (inCodeBlock)
        {
            if (!mPrinter.isCanAddCRsAtBlockStart() && mPrinter.isAtBlockStart())
            {
                return;
            }
        }
        
        for (int i=0;i<amt;i++)
        {
            mPrinter.insertCR(true);
        }
    }

    private void insertMaxColumnCR()
    {
        mPrinter.insertCRBeyondMaxCol();
    }

    private void insertStatementCR()
    {
        if (!mPrinter.isLabeledIndent())
            insertCR(false);
    }

    bool isFirstImport=true;
    bool isFirstClassSeen=false;
    bool isSeenPackage=false;
    private void addBlankLinesBeforeFirstImport()
    {
        //only add blank lines for before first import in 'package' area.  The assumption is that all the 
        // imports are together, or this setting doesn't really make sense.
        int linesToAdd=mPrinter.getBlankLinesBeforeImports();
        if (isFirstImport && !isFirstClassSeen && isSeenPackage)
        {
            isFirstImport=false;
            for (int i=0;i<linesToAdd;i++)
            {
                insertCR(true);
            }
        }
    }
            
    private void insertCR(bool overridE)
    {
        mPrinter.insertCR(overridE);
    }
        
    private void pushLabeledIndent()
    {
        pushExpressionIndent(); //push an expression indent so that it won't further indent the nested statement 
        mPrinter.makeLabeledIndent();
    }
        
    private void pushIndent(bool hardIndent)
    {
        mPrinter.pushIndent(hardIndent ? ASPrettyPrinter.BRACE_INDENT : ASPrettyPrinter.STATEMENT_INDENT);
    }

    private void pushExpressionIndent()
    {
        mPrinter.pushIndent(ASPrettyPrinter.EXPRESSION_INDENT);
    }

    private bool pushLazyParmIndent(bool alreadyPushed, int indentStyle)
    {
        if (!alreadyPushed)
        {
            if (!mPrinter.isUseAdvancedWrapping() && indentStyle==WrapOptions.WRAP_STYLE_INDENT_TO_WRAP_ELEMENT)
                mPrinter.pushLazyIndent(ASPrettyPrinter.EXPRESSION_INDENT_NEXTITEM);
            else
                pushLazyIndent();
        }
        return true;
    }

    private void pushLazyIndent()
    {
        mPrinter.pushLazyIndent(ASPrettyPrinter.EXPRESSION_INDENT);
    }

    private void popIndent()
    {
        mPrinter.popIndent();
    }
            
    private void leftCurlyNewlineHandler(bool checkBraceIndent)
    {
       if (mPrinter.isCRBeforeOpenBrace(mCodeBlockStack) || (checkBraceIndent && mPrinter.getIndentType(0)==ASPrettyPrinter.BRACE_INDENT))
       {
           insertCR(false);
           insertWS(1); //add a space here just in case newlines can't be added
       }
       else
           insertWS(1);
    }
            
    private void emit(IToken tok)
    {
        mPrinter.emit(tok);
    }
                
            
    public List<Exception> getParseErrors()
    {
        return mParseErrors;
    }
            
    /*        bool isNotReservedWord(String name) {
            String[] reserveWords = new String[]
                {
                    "as",
                    "break",
                    "case",
                    "catch",
                    "class",
                    "const",
                    "continue",
                    "default",
                    "delete",
                    "do",
                    "else",
                    "extends",
                    "false",
                    "finally",
                    "for",
                    "function",
                    "if",
                    "implements",
                    "import",
                    "in",
                    "instanceof",
                    "interface",
                    "internal",
                    "is",
                    "native",
                    "new",
                    "null",
                    "package",
                    "private",
                    "protected",
                    "public",
                    "return",
                    "super",
                    "switch",
                    "this",
                    "throw",
                    "to",
                    "true",
                    "try",
                    "typeof",
                    "use",
                    "var",
                    "void",
                    "while",
                    "with"
                };
            for (int i = 0; i<reserveWords.Length; i++) {
                if ( reserveWords[i] == name) {
                    return false;
                }
            }
            return true;
        }
        */
        
    /*    private void promoteEOL(ParserRuleReturnScope rule)
        {
            //System.out.println("start promoteEOL <<let HIDDENT IToken EOL be visible>>");
            IToken lt = input.LT(1);
            int index = lt.TokenIndex;
            if(index<0){
                index = input.Count;
            }
            int la = lt.Type;
            
            for (int ix = index - 1; ix >= 0; ix--){
                lt = input.Get(ix);
                int type = lt.Type;
                if (type == EOL || (type == COMMENT_MULTILINE && Regex.Matches(lt.Text, "/.*\r\n|\r|\n").Count > 0)){
                    lt.setChannel(Token.DEFAULT_CHANNEL);
                    input.seek(lt.TokenIndex);
                    //System.out.println("promoteEOL : HIDDEN IToken ("+lt+") is set to DEFAULT");
                    if (rule != null){
                        //System.out.println("promoteEOL :  startToken set as "+lt);
                        rule.Start = lt;
                    }
                    return;
                }else if(lt.Channel == Token.DEFAULT_CHANNEL){
                    break;
                }
            }
            //System.out.println("");
        }
      */
        
        public const int CHANNEL_SLCOMMENT=43;
        public const int CHANNEL_MLCOMMENT=42;
        public const int CHANNEL_WHITESPACE=41;
        public const int CHANNEL_EOL=40;
        
        private bool promoteWhitespace()
        {
            //find the current lookahead token
            IToken lt = input.LT(1);
            int index = lt.TokenIndex;
            if(index<0){
                index = input.Count;
            }

            //walk backward through tokens to see if the previous token is whitespace.
            for (int ix = index - 1; ix >= 0; ix--){
                lt = input.Get(ix);
                int channel=lt.Channel;
                if (channel == CHANNEL_EOL || channel ==  CHANNEL_WHITESPACE){
                    return true;
                } else if(channel == Token.DEFAULT_CHANNEL){
                    break;
                }
            }
            return false;
        }


    public class booleanLiteral_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "booleanLiteral"
    // AS3_ex.g3:1538:1: booleanLiteral : (T= TRUE | F= FALSE );
    public AS3_exParser.booleanLiteral_return booleanLiteral() // throws RecognitionException [1]
    {   
        AS3_exParser.booleanLiteral_return retval = new AS3_exParser.booleanLiteral_return();
        retval.Start = input.LT(1);
        int booleanLiteral_StartIndex = input.Index();
        object root_0 = null;

        IToken T = null;
        IToken F = null;

        object T_tree=null;
        object F_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 1) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:1538:36: (T= TRUE | F= FALSE )
            int alt1 = 2;
            int LA1_0 = input.LA(1);

            if ( (LA1_0 == TRUE) )
            {
                alt1 = 1;
            }
            else if ( (LA1_0 == FALSE) )
            {
                alt1 = 2;
            }
            else 
            {
                if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                NoViableAltException nvae_d1s0 =
                    new NoViableAltException("", 1, 0, input);

                throw nvae_d1s0;
            }
            switch (alt1) 
            {
                case 1 :
                    // AS3_ex.g3:1538:40: T= TRUE
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        T=(IToken)Match(input,TRUE,FOLLOW_TRUE_in_booleanLiteral3643); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {T_tree = (object)adaptor.Create(T);
                            adaptor.AddChild(root_0, T_tree);
                        }
                        if ( state.backtracking == 0 ) 
                        {
                          emit(T);
                        }

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:1538:61: F= FALSE
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        F=(IToken)Match(input,FALSE,FOLLOW_FALSE_in_booleanLiteral3651); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {F_tree = (object)adaptor.Create(F);
                            adaptor.AddChild(root_0, F_tree);
                        }
                        if ( state.backtracking == 0 ) 
                        {
                          emit(F);
                        }

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 1, booleanLiteral_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "booleanLiteral"

    public class numericLiteral_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "numericLiteral"
    // AS3_ex.g3:1540:1: numericLiteral : (D= DEC_NUMBER_LITERAL | H= HEX_NUMBER_LITERAL );
    public AS3_exParser.numericLiteral_return numericLiteral() // throws RecognitionException [1]
    {   
        AS3_exParser.numericLiteral_return retval = new AS3_exParser.numericLiteral_return();
        retval.Start = input.LT(1);
        int numericLiteral_StartIndex = input.Index();
        object root_0 = null;

        IToken D = null;
        IToken H = null;

        object D_tree=null;
        object H_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 2) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:1540:36: (D= DEC_NUMBER_LITERAL | H= HEX_NUMBER_LITERAL )
            int alt2 = 2;
            int LA2_0 = input.LA(1);

            if ( (LA2_0 == DEC_NUMBER_LITERAL) )
            {
                alt2 = 1;
            }
            else if ( (LA2_0 == HEX_NUMBER_LITERAL) )
            {
                alt2 = 2;
            }
            else 
            {
                if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                NoViableAltException nvae_d2s0 =
                    new NoViableAltException("", 2, 0, input);

                throw nvae_d2s0;
            }
            switch (alt2) 
            {
                case 1 :
                    // AS3_ex.g3:1540:40: D= DEC_NUMBER_LITERAL
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        D=(IToken)Match(input,DEC_NUMBER_LITERAL,FOLLOW_DEC_NUMBER_LITERAL_in_numericLiteral3685); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {D_tree = (object)adaptor.Create(D);
                            adaptor.AddChild(root_0, D_tree);
                        }
                        if ( state.backtracking == 0 ) 
                        {
                          emit(D);
                        }

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:1540:75: H= HEX_NUMBER_LITERAL
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        H=(IToken)Match(input,HEX_NUMBER_LITERAL,FOLLOW_HEX_NUMBER_LITERAL_in_numericLiteral3693); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {H_tree = (object)adaptor.Create(H);
                            adaptor.AddChild(root_0, H_tree);
                        }
                        if ( state.backtracking == 0 ) 
                        {
                          emit(H);
                        }

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 2, numericLiteral_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "numericLiteral"

    public class stringLiteral_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "stringLiteral"
    // AS3_ex.g3:1542:1: stringLiteral : (S= SINGLE_QUOTE_LITERAL | D= DOUBLE_QUOTE_LITERAL );
    public AS3_exParser.stringLiteral_return stringLiteral() // throws RecognitionException [1]
    {   
        AS3_exParser.stringLiteral_return retval = new AS3_exParser.stringLiteral_return();
        retval.Start = input.LT(1);
        int stringLiteral_StartIndex = input.Index();
        object root_0 = null;

        IToken S = null;
        IToken D = null;

        object S_tree=null;
        object D_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 3) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:1542:36: (S= SINGLE_QUOTE_LITERAL | D= DOUBLE_QUOTE_LITERAL )
            int alt3 = 2;
            int LA3_0 = input.LA(1);

            if ( (LA3_0 == SINGLE_QUOTE_LITERAL) )
            {
                alt3 = 1;
            }
            else if ( (LA3_0 == DOUBLE_QUOTE_LITERAL) )
            {
                alt3 = 2;
            }
            else 
            {
                if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                NoViableAltException nvae_d3s0 =
                    new NoViableAltException("", 3, 0, input);

                throw nvae_d3s0;
            }
            switch (alt3) 
            {
                case 1 :
                    // AS3_ex.g3:1542:40: S= SINGLE_QUOTE_LITERAL
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        S=(IToken)Match(input,SINGLE_QUOTE_LITERAL,FOLLOW_SINGLE_QUOTE_LITERAL_in_stringLiteral3728); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {S_tree = (object)adaptor.Create(S);
                            adaptor.AddChild(root_0, S_tree);
                        }
                        if ( state.backtracking == 0 ) 
                        {
                          emit(S);
                        }

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:1542:76: D= DOUBLE_QUOTE_LITERAL
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        D=(IToken)Match(input,DOUBLE_QUOTE_LITERAL,FOLLOW_DOUBLE_QUOTE_LITERAL_in_stringLiteral3735); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {D_tree = (object)adaptor.Create(D);
                            adaptor.AddChild(root_0, D_tree);
                        }
                        if ( state.backtracking == 0 ) 
                        {
                          emit(D);
                        }

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 3, stringLiteral_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "stringLiteral"

    public class regularExpresionLiteral_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "regularExpresionLiteral"
    // AS3_ex.g3:1544:1: regularExpresionLiteral : R= REGULAR_EXPR_LITERAL ;
    public AS3_exParser.regularExpresionLiteral_return regularExpresionLiteral() // throws RecognitionException [1]
    {   
        AS3_exParser.regularExpresionLiteral_return retval = new AS3_exParser.regularExpresionLiteral_return();
        retval.Start = input.LT(1);
        int regularExpresionLiteral_StartIndex = input.Index();
        object root_0 = null;

        IToken R = null;

        object R_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 4) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:1544:36: (R= REGULAR_EXPR_LITERAL )
            // AS3_ex.g3:1544:40: R= REGULAR_EXPR_LITERAL
            {
                root_0 = (object)adaptor.GetNilNode();

                R=(IToken)Match(input,REGULAR_EXPR_LITERAL,FOLLOW_REGULAR_EXPR_LITERAL_in_regularExpresionLiteral3760); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {R_tree = (object)adaptor.Create(R);
                    adaptor.AddChild(root_0, R_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(R);
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 4, regularExpresionLiteral_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "regularExpresionLiteral"

    public class identifierLiteral_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "identifierLiteral"
    // AS3_ex.g3:1546:1: identifierLiteral : (I= IDENTIFIER | notQuiteReservedWord );
    public AS3_exParser.identifierLiteral_return identifierLiteral() // throws RecognitionException [1]
    {   
        AS3_exParser.identifierLiteral_return retval = new AS3_exParser.identifierLiteral_return();
        retval.Start = input.LT(1);
        int identifierLiteral_StartIndex = input.Index();
        object root_0 = null;

        IToken I = null;
        AS3_exParser.notQuiteReservedWord_return notQuiteReservedWord1 = null;


        object I_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 5) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:1546:36: (I= IDENTIFIER | notQuiteReservedWord )
            int alt4 = 2;
            int LA4_0 = input.LA(1);

            if ( (LA4_0 == IDENTIFIER) )
            {
                alt4 = 1;
            }
            else if ( (LA4_0 == NATIVE || LA4_0 == TO || (LA4_0 >= EACH && LA4_0 <= NAMESPACE) || (LA4_0 >= DYNAMIC && LA4_0 <= STATIC)) )
            {
                alt4 = 2;
            }
            else 
            {
                if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                NoViableAltException nvae_d4s0 =
                    new NoViableAltException("", 4, 0, input);

                throw nvae_d4s0;
            }
            switch (alt4) 
            {
                case 1 :
                    // AS3_ex.g3:1546:83: I= IDENTIFIER
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        I=(IToken)Match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_identifierLiteral3793); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {I_tree = (object)adaptor.Create(I);
                            adaptor.AddChild(root_0, I_tree);
                        }
                        if ( state.backtracking == 0 ) 
                        {
                          emit(I);
                        }

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:1546:109: notQuiteReservedWord
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_notQuiteReservedWord_in_identifierLiteral3798);
                        notQuiteReservedWord1 = notQuiteReservedWord();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, notQuiteReservedWord1.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 5, identifierLiteral_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "identifierLiteral"

    public class xmlNameLiteral_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "xmlNameLiteral"
    // AS3_ex.g3:1548:1: xmlNameLiteral : (I= IDENTIFIER | allKeywords ) ({...}? => (s= SUB | d= DOT | c= COLON ) {...}? => (I2= IDENTIFIER | allKeywords ) )* ;
    public AS3_exParser.xmlNameLiteral_return xmlNameLiteral() // throws RecognitionException [1]
    {   
        AS3_exParser.xmlNameLiteral_return retval = new AS3_exParser.xmlNameLiteral_return();
        retval.Start = input.LT(1);
        int xmlNameLiteral_StartIndex = input.Index();
        object root_0 = null;

        IToken I = null;
        IToken s = null;
        IToken d = null;
        IToken c = null;
        IToken I2 = null;
        AS3_exParser.allKeywords_return allKeywords2 = null;

        AS3_exParser.allKeywords_return allKeywords3 = null;


        object I_tree=null;
        object s_tree=null;
        object d_tree=null;
        object c_tree=null;
        object I2_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 6) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:1548:36: ( (I= IDENTIFIER | allKeywords ) ({...}? => (s= SUB | d= DOT | c= COLON ) {...}? => (I2= IDENTIFIER | allKeywords ) )* )
            // AS3_ex.g3:1548:40: (I= IDENTIFIER | allKeywords ) ({...}? => (s= SUB | d= DOT | c= COLON ) {...}? => (I2= IDENTIFIER | allKeywords ) )*
            {
                root_0 = (object)adaptor.GetNilNode();

                // AS3_ex.g3:1548:40: (I= IDENTIFIER | allKeywords )
                int alt5 = 2;
                int LA5_0 = input.LA(1);

                if ( (LA5_0 == IDENTIFIER) )
                {
                    alt5 = 1;
                }
                else if ( ((LA5_0 >= AS && LA5_0 <= STATIC)) )
                {
                    alt5 = 2;
                }
                else 
                {
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    NoViableAltException nvae_d5s0 =
                        new NoViableAltException("", 5, 0, input);

                    throw nvae_d5s0;
                }
                switch (alt5) 
                {
                    case 1 :
                        // AS3_ex.g3:1548:41: I= IDENTIFIER
                        {
                            I=(IToken)Match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_xmlNameLiteral3833); if (state.failed) return retval;
                            if ( state.backtracking == 0 )
                            {I_tree = (object)adaptor.Create(I);
                                adaptor.AddChild(root_0, I_tree);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              emit(I);
                            }

                        }
                        break;
                    case 2 :
                        // AS3_ex.g3:1548:67: allKeywords
                        {
                            PushFollow(FOLLOW_allKeywords_in_xmlNameLiteral3838);
                            allKeywords2 = allKeywords();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, allKeywords2.Tree);

                        }
                        break;

                }

                // AS3_ex.g3:1548:80: ({...}? => (s= SUB | d= DOT | c= COLON ) {...}? => (I2= IDENTIFIER | allKeywords ) )*
                do 
                {
                    int alt8 = 2;
                    alt8 = dfa8.Predict(input);
                    switch (alt8) 
                    {
                        case 1 :
                            // AS3_ex.g3:1548:82: {...}? => (s= SUB | d= DOT | c= COLON ) {...}? => (I2= IDENTIFIER | allKeywords )
                            {
                                if ( !((!promoteWhitespace())) ) 
                                {
                                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                                    throw new FailedPredicateException(input, "xmlNameLiteral", "!promoteWhitespace()");
                                }
                                // AS3_ex.g3:1548:108: (s= SUB | d= DOT | c= COLON )
                                int alt6 = 3;
                                switch ( input.LA(1) ) 
                                {
                                case SUB:
                                    {
                                    alt6 = 1;
                                    }
                                    break;
                                case DOT:
                                    {
                                    alt6 = 2;
                                    }
                                    break;
                                case COLON:
                                    {
                                    alt6 = 3;
                                    }
                                    break;
                                    default:
                                        if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                                        NoViableAltException nvae_d6s0 =
                                            new NoViableAltException("", 6, 0, input);

                                        throw nvae_d6s0;
                                }

                                switch (alt6) 
                                {
                                    case 1 :
                                        // AS3_ex.g3:1548:109: s= SUB
                                        {
                                            s=(IToken)Match(input,SUB,FOLLOW_SUB_in_xmlNameLiteral3849); if (state.failed) return retval;
                                            if ( state.backtracking == 0 )
                                            {s_tree = (object)adaptor.Create(s);
                                                adaptor.AddChild(root_0, s_tree);
                                            }
                                            if ( state.backtracking == 0 ) 
                                            {
                                              emit(s);
                                            }

                                        }
                                        break;
                                    case 2 :
                                        // AS3_ex.g3:1548:129: d= DOT
                                        {
                                            d=(IToken)Match(input,DOT,FOLLOW_DOT_in_xmlNameLiteral3857); if (state.failed) return retval;
                                            if ( state.backtracking == 0 )
                                            {d_tree = (object)adaptor.Create(d);
                                                adaptor.AddChild(root_0, d_tree);
                                            }
                                            if ( state.backtracking == 0 ) 
                                            {
                                              emit(d);
                                            }

                                        }
                                        break;
                                    case 3 :
                                        // AS3_ex.g3:1548:149: c= COLON
                                        {
                                            c=(IToken)Match(input,COLON,FOLLOW_COLON_in_xmlNameLiteral3865); if (state.failed) return retval;
                                            if ( state.backtracking == 0 )
                                            {c_tree = (object)adaptor.Create(c);
                                                adaptor.AddChild(root_0, c_tree);
                                            }
                                            if ( state.backtracking == 0 ) 
                                            {
                                              emit(c);
                                            }

                                        }
                                        break;

                                }

                                if ( !((!promoteWhitespace())) ) 
                                {
                                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                                    throw new FailedPredicateException(input, "xmlNameLiteral", "!promoteWhitespace()");
                                }
                                // AS3_ex.g3:1548:196: (I2= IDENTIFIER | allKeywords )
                                int alt7 = 2;
                                int LA7_0 = input.LA(1);

                                if ( (LA7_0 == IDENTIFIER) )
                                {
                                    alt7 = 1;
                                }
                                else if ( ((LA7_0 >= AS && LA7_0 <= STATIC)) )
                                {
                                    alt7 = 2;
                                }
                                else 
                                {
                                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                                    NoViableAltException nvae_d7s0 =
                                        new NoViableAltException("", 7, 0, input);

                                    throw nvae_d7s0;
                                }
                                switch (alt7) 
                                {
                                    case 1 :
                                        // AS3_ex.g3:1548:197: I2= IDENTIFIER
                                        {
                                            I2=(IToken)Match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_xmlNameLiteral3876); if (state.failed) return retval;
                                            if ( state.backtracking == 0 )
                                            {I2_tree = (object)adaptor.Create(I2);
                                                adaptor.AddChild(root_0, I2_tree);
                                            }
                                            if ( state.backtracking == 0 ) 
                                            {
                                              emit(I2);
                                            }

                                        }
                                        break;
                                    case 2 :
                                        // AS3_ex.g3:1548:226: allKeywords
                                        {
                                            PushFollow(FOLLOW_allKeywords_in_xmlNameLiteral3882);
                                            allKeywords3 = allKeywords();
                                            state.followingStackPointer--;
                                            if (state.failed) return retval;
                                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, allKeywords3.Tree);

                                        }
                                        break;

                                }


                            }
                            break;

                        default:
                            goto loop8;
                    }
                } while (true);

                loop8:
                    ;   // Stops C# compiler whining that label 'loop8' has no statements


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 6, xmlNameLiteral_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "xmlNameLiteral"

    public class literal_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "literal"
    // AS3_ex.g3:1551:1: literal : (N= NULL | booleanLiteral | numericLiteral | stringLiteral | regularExpresionLiteral );
    public AS3_exParser.literal_return literal() // throws RecognitionException [1]
    {   
        AS3_exParser.literal_return retval = new AS3_exParser.literal_return();
        retval.Start = input.LT(1);
        int literal_StartIndex = input.Index();
        object root_0 = null;

        IToken N = null;
        AS3_exParser.booleanLiteral_return booleanLiteral4 = null;

        AS3_exParser.numericLiteral_return numericLiteral5 = null;

        AS3_exParser.stringLiteral_return stringLiteral6 = null;

        AS3_exParser.regularExpresionLiteral_return regularExpresionLiteral7 = null;


        object N_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 7) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:1551:36: (N= NULL | booleanLiteral | numericLiteral | stringLiteral | regularExpresionLiteral )
            int alt9 = 5;
            switch ( input.LA(1) ) 
            {
            case NULL:
                {
                alt9 = 1;
                }
                break;
            case FALSE:
            case TRUE:
                {
                alt9 = 2;
                }
                break;
            case HEX_NUMBER_LITERAL:
            case DEC_NUMBER_LITERAL:
                {
                alt9 = 3;
                }
                break;
            case SINGLE_QUOTE_LITERAL:
            case DOUBLE_QUOTE_LITERAL:
                {
                alt9 = 4;
                }
                break;
            case REGULAR_EXPR_LITERAL:
                {
                alt9 = 5;
                }
                break;
                default:
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    NoViableAltException nvae_d9s0 =
                        new NoViableAltException("", 9, 0, input);

                    throw nvae_d9s0;
            }

            switch (alt9) 
            {
                case 1 :
                    // AS3_ex.g3:1551:40: N= NULL
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        N=(IToken)Match(input,NULL,FOLLOW_NULL_in_literal3935); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {N_tree = (object)adaptor.Create(N);
                            adaptor.AddChild(root_0, N_tree);
                        }
                        if ( state.backtracking == 0 ) 
                        {
                          emit(N);
                        }

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:1551:61: booleanLiteral
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_booleanLiteral_in_literal3941);
                        booleanLiteral4 = booleanLiteral();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, booleanLiteral4.Tree);

                    }
                    break;
                case 3 :
                    // AS3_ex.g3:1551:78: numericLiteral
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_numericLiteral_in_literal3945);
                        numericLiteral5 = numericLiteral();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, numericLiteral5.Tree);

                    }
                    break;
                case 4 :
                    // AS3_ex.g3:1551:95: stringLiteral
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_stringLiteral_in_literal3949);
                        stringLiteral6 = stringLiteral();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, stringLiteral6.Tree);

                    }
                    break;
                case 5 :
                    // AS3_ex.g3:1551:111: regularExpresionLiteral
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_regularExpresionLiteral_in_literal3953);
                        regularExpresionLiteral7 = regularExpresionLiteral();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, regularExpresionLiteral7.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 7, literal_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "literal"

    public class xmlMarkup_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "xmlMarkup"
    // AS3_ex.g3:1554:1: xmlMarkup : ( xmlComment | xmlCDATA | xmlPI );
    public AS3_exParser.xmlMarkup_return xmlMarkup() // throws RecognitionException [1]
    {   
        AS3_exParser.xmlMarkup_return retval = new AS3_exParser.xmlMarkup_return();
        retval.Start = input.LT(1);
        int xmlMarkup_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.xmlComment_return xmlComment8 = null;

        AS3_exParser.xmlCDATA_return xmlCDATA9 = null;

        AS3_exParser.xmlPI_return xmlPI10 = null;



        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 8) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:1554:36: ( xmlComment | xmlCDATA | xmlPI )
            int alt10 = 3;
            switch ( input.LA(1) ) 
            {
            case XML_COMMENT:
                {
                alt10 = 1;
                }
                break;
            case XML_CDATA:
                {
                alt10 = 2;
                }
                break;
            case XML_PI:
                {
                alt10 = 3;
                }
                break;
                default:
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    NoViableAltException nvae_d10s0 =
                        new NoViableAltException("", 10, 0, input);

                    throw nvae_d10s0;
            }

            switch (alt10) 
            {
                case 1 :
                    // AS3_ex.g3:1554:40: xmlComment
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_xmlComment_in_xmlMarkup3989);
                        xmlComment8 = xmlComment();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlComment8.Tree);

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:1554:53: xmlCDATA
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_xmlCDATA_in_xmlMarkup3993);
                        xmlCDATA9 = xmlCDATA();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlCDATA9.Tree);

                    }
                    break;
                case 3 :
                    // AS3_ex.g3:1554:64: xmlPI
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_xmlPI_in_xmlMarkup3997);
                        xmlPI10 = xmlPI();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlPI10.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 8, xmlMarkup_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "xmlMarkup"

    public class xmlComment_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "xmlComment"
    // AS3_ex.g3:1555:1: xmlComment : x= XML_COMMENT ;
    public AS3_exParser.xmlComment_return xmlComment() // throws RecognitionException [1]
    {   
        AS3_exParser.xmlComment_return retval = new AS3_exParser.xmlComment_return();
        retval.Start = input.LT(1);
        int xmlComment_StartIndex = input.Index();
        object root_0 = null;

        IToken x = null;

        object x_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 9) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:1555:36: (x= XML_COMMENT )
            // AS3_ex.g3:1555:40: x= XML_COMMENT
            {
                root_0 = (object)adaptor.GetNilNode();

                x=(IToken)Match(input,XML_COMMENT,FOLLOW_XML_COMMENT_in_xmlComment4032); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {x_tree = (object)adaptor.Create(x);
                    adaptor.AddChild(root_0, x_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(x);
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 9, xmlComment_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "xmlComment"

    public class xmlCDATA_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "xmlCDATA"
    // AS3_ex.g3:1556:1: xmlCDATA : x= XML_CDATA ;
    public AS3_exParser.xmlCDATA_return xmlCDATA() // throws RecognitionException [1]
    {   
        AS3_exParser.xmlCDATA_return retval = new AS3_exParser.xmlCDATA_return();
        retval.Start = input.LT(1);
        int xmlCDATA_StartIndex = input.Index();
        object root_0 = null;

        IToken x = null;

        object x_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 10) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:1556:36: (x= XML_CDATA )
            // AS3_ex.g3:1556:40: x= XML_CDATA
            {
                root_0 = (object)adaptor.GetNilNode();

                x=(IToken)Match(input,XML_CDATA,FOLLOW_XML_CDATA_in_xmlCDATA4074); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {x_tree = (object)adaptor.Create(x);
                    adaptor.AddChild(root_0, x_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(x);
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 10, xmlCDATA_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "xmlCDATA"

    public class xmlPI_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "xmlPI"
    // AS3_ex.g3:1557:1: xmlPI : x= XML_PI ;
    public AS3_exParser.xmlPI_return xmlPI() // throws RecognitionException [1]
    {   
        AS3_exParser.xmlPI_return retval = new AS3_exParser.xmlPI_return();
        retval.Start = input.LT(1);
        int xmlPI_StartIndex = input.Index();
        object root_0 = null;

        IToken x = null;

        object x_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 11) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:1557:36: (x= XML_PI )
            // AS3_ex.g3:1557:40: x= XML_PI
            {
                root_0 = (object)adaptor.GetNilNode();

                x=(IToken)Match(input,XML_PI,FOLLOW_XML_PI_in_xmlPI4117); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {x_tree = (object)adaptor.Create(x);
                    adaptor.AddChild(root_0, x_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(x);
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 11, xmlPI_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "xmlPI"

    public class xmlExprEval_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "xmlExprEval"
    // AS3_ex.g3:1558:1: xmlExprEval : L= LCURLY expression R= RCURLY ;
    public AS3_exParser.xmlExprEval_return xmlExprEval() // throws RecognitionException [1]
    {   
        AS3_exParser.xmlExprEval_return retval = new AS3_exParser.xmlExprEval_return();
        retval.Start = input.LT(1);
        int xmlExprEval_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        IToken R = null;
        AS3_exParser.expression_return expression11 = null;


        object L_tree=null;
        object R_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 12) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:1558:36: (L= LCURLY expression R= RCURLY )
            // AS3_ex.g3:1558:40: L= LCURLY expression R= RCURLY
            {
                root_0 = (object)adaptor.GetNilNode();

                L=(IToken)Match(input,LCURLY,FOLLOW_LCURLY_in_xmlExprEval4155); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {L_tree = (object)adaptor.Create(L);
                    adaptor.AddChild(root_0, L_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(L);pushIndent(true);
                }
                PushFollow(FOLLOW_expression_in_xmlExprEval4159);
                expression11 = expression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, expression11.Tree);
                R=(IToken)Match(input,RCURLY,FOLLOW_RCURLY_in_xmlExprEval4163); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {R_tree = (object)adaptor.Create(R);
                    adaptor.AddChild(root_0, R_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  popIndent();emit(R);
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 12, xmlExprEval_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "xmlExprEval"

    public class xmlTextElement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "xmlTextElement"
    // AS3_ex.g3:1561:1: xmlTextElement : ( allKeywords | lexToken= ( DEC_NUMBER_LITERAL | HEX_NUMBER_LITERAL | SINGLE_QUOTE_LITERAL | DOUBLE_QUOTE_LITERAL | IDENTIFIER | XML_TEXT | DIV | SEMI | RCURLY | LPAREN | RPAREN | LBRACK | RBRACK | DOT | COMMA | GT | LTE | EQ | NEQ | SAME | NSAME | PLUS | SUB | STAR | MOD | INC | DEC | SHL | AND | OR | XOR | NOT | INV | LAND | LOR | QUE | COLON | ASSIGN | DIV_ASSIGN | MOD_ASSIGN | ADD_ASSIGN | SUB_ASSIGN | SHL_ASSIGN | AND_ASSIGN | XOR_ASSIGN | OR_ASSIGN | LOR_ASSIGN | LAND_ASSIGN | ELLIPSIS | XML_ELLIPSIS | XML_NS_OP | XML_AT ) );
    public AS3_exParser.xmlTextElement_return xmlTextElement() // throws RecognitionException [1]
    {   
        AS3_exParser.xmlTextElement_return retval = new AS3_exParser.xmlTextElement_return();
        retval.Start = input.LT(1);
        int xmlTextElement_StartIndex = input.Index();
        object root_0 = null;

        IToken lexToken = null;
        AS3_exParser.allKeywords_return allKeywords12 = null;


        object lexToken_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 13) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:1562:5: ( allKeywords | lexToken= ( DEC_NUMBER_LITERAL | HEX_NUMBER_LITERAL | SINGLE_QUOTE_LITERAL | DOUBLE_QUOTE_LITERAL | IDENTIFIER | XML_TEXT | DIV | SEMI | RCURLY | LPAREN | RPAREN | LBRACK | RBRACK | DOT | COMMA | GT | LTE | EQ | NEQ | SAME | NSAME | PLUS | SUB | STAR | MOD | INC | DEC | SHL | AND | OR | XOR | NOT | INV | LAND | LOR | QUE | COLON | ASSIGN | DIV_ASSIGN | MOD_ASSIGN | ADD_ASSIGN | SUB_ASSIGN | SHL_ASSIGN | AND_ASSIGN | XOR_ASSIGN | OR_ASSIGN | LOR_ASSIGN | LAND_ASSIGN | ELLIPSIS | XML_ELLIPSIS | XML_NS_OP | XML_AT ) )
            int alt11 = 2;
            int LA11_0 = input.LA(1);

            if ( ((LA11_0 >= AS && LA11_0 <= STATIC)) )
            {
                alt11 = 1;
            }
            else if ( (LA11_0 == SEMI || (LA11_0 >= RCURLY && LA11_0 <= COMMA) || (LA11_0 >= GT && LA11_0 <= LTE) || (LA11_0 >= EQ && LA11_0 <= SHL) || (LA11_0 >= AND && LA11_0 <= SHL_ASSIGN) || (LA11_0 >= LAND_ASSIGN && LA11_0 <= XML_ELLIPSIS) || (LA11_0 >= XML_NS_OP && LA11_0 <= XML_AT) || (LA11_0 >= SINGLE_QUOTE_LITERAL && LA11_0 <= DOUBLE_QUOTE_LITERAL) || LA11_0 == HEX_NUMBER_LITERAL || LA11_0 == DEC_NUMBER_LITERAL || LA11_0 == IDENTIFIER || LA11_0 == XML_TEXT) )
            {
                alt11 = 2;
            }
            else 
            {
                if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                NoViableAltException nvae_d11s0 =
                    new NoViableAltException("", 11, 0, input);

                throw nvae_d11s0;
            }
            switch (alt11) 
            {
                case 1 :
                    // AS3_ex.g3:1563:3: allKeywords
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_allKeywords_in_xmlTextElement4181);
                        allKeywords12 = allKeywords();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, allKeywords12.Tree);
                        if ( state.backtracking == 0 ) 
                        {
                          /*TODO: see if I can change token type*/
                        }

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:1564:7: lexToken= ( DEC_NUMBER_LITERAL | HEX_NUMBER_LITERAL | SINGLE_QUOTE_LITERAL | DOUBLE_QUOTE_LITERAL | IDENTIFIER | XML_TEXT | DIV | SEMI | RCURLY | LPAREN | RPAREN | LBRACK | RBRACK | DOT | COMMA | GT | LTE | EQ | NEQ | SAME | NSAME | PLUS | SUB | STAR | MOD | INC | DEC | SHL | AND | OR | XOR | NOT | INV | LAND | LOR | QUE | COLON | ASSIGN | DIV_ASSIGN | MOD_ASSIGN | ADD_ASSIGN | SUB_ASSIGN | SHL_ASSIGN | AND_ASSIGN | XOR_ASSIGN | OR_ASSIGN | LOR_ASSIGN | LAND_ASSIGN | ELLIPSIS | XML_ELLIPSIS | XML_NS_OP | XML_AT )
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        lexToken = (IToken)input.LT(1);
                        if ( input.LA(1) == SEMI || (input.LA(1) >= RCURLY && input.LA(1) <= COMMA) || (input.LA(1) >= GT && input.LA(1) <= LTE) || (input.LA(1) >= EQ && input.LA(1) <= SHL) || (input.LA(1) >= AND && input.LA(1) <= SHL_ASSIGN) || (input.LA(1) >= LAND_ASSIGN && input.LA(1) <= XML_ELLIPSIS) || (input.LA(1) >= XML_NS_OP && input.LA(1) <= XML_AT) || (input.LA(1) >= SINGLE_QUOTE_LITERAL && input.LA(1) <= DOUBLE_QUOTE_LITERAL) || input.LA(1) == HEX_NUMBER_LITERAL || input.LA(1) == DEC_NUMBER_LITERAL || input.LA(1) == IDENTIFIER || input.LA(1) == XML_TEXT ) 
                        {
                            input.Consume();
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, (object)adaptor.Create(lexToken));
                            state.errorRecovery = false;state.failed = false;
                        }
                        else 
                        {
                            if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                            MismatchedSetException mse = new MismatchedSetException(null,input);
                            throw mse;
                        }

                        if ( state.backtracking == 0 ) 
                        {

                                  lexToken.Type = XML_TEXT; 
                                  emit(lexToken);
                              
                        }

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 13, xmlTextElement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "xmlTextElement"

    public class xmlText_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "xmlText"
    // AS3_ex.g3:1635:1: xmlText : ( xmlTextElement )+ ;
    public AS3_exParser.xmlText_return xmlText() // throws RecognitionException [1]
    {   
        AS3_exParser.xmlText_return retval = new AS3_exParser.xmlText_return();
        retval.Start = input.LT(1);
        int xmlText_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.xmlTextElement_return xmlTextElement13 = null;



        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 14) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:1636:5: ( ( xmlTextElement )+ )
            // AS3_ex.g3:1637:5: ( xmlTextElement )+
            {
                root_0 = (object)adaptor.GetNilNode();

                // AS3_ex.g3:1637:5: ( xmlTextElement )+
                int cnt12 = 0;
                do 
                {
                    int alt12 = 2;
                    switch ( input.LA(1) ) 
                    {
                    case AS:
                    case BREAK:
                    case CASE:
                    case CATCH:
                    case CLASS:
                    case CONST:
                    case CONTINUE:
                    case DEFAULT:
                    case DELETE:
                    case DO:
                    case ELSE:
                    case EXTENDS:
                    case FALSE:
                    case FINALLY:
                    case FOR:
                    case FUNCTION:
                    case IF:
                    case IMPLEMENTS:
                    case IMPORT:
                    case IN:
                    case INSTANCEOF:
                    case INTERFACE:
                    case INTERNAL:
                    case IS:
                    case NEW:
                    case NULL:
                    case PACKAGE:
                    case PRIVATE:
                    case PROTECTED:
                    case PUBLIC:
                    case RETURN:
                    case SUPER:
                    case SWITCH:
                    case THIS:
                    case THROW:
                    case TRUE:
                    case TRY:
                    case TYPEOF:
                    case USE:
                    case VAR:
                    case VOID:
                    case WHILE:
                    case WITH:
                    case INCLUDE:
                        {
                        int LA12_2 = input.LA(2);

                        if ( (synpred68_AS3_ex()) )
                        {
                            alt12 = 1;
                        }


                        }
                        break;
                    case NATIVE:
                    case TO:
                    case EACH:
                    case GET:
                    case SET:
                    case NAMESPACE:
                    case DYNAMIC:
                    case FINAL:
                    case OVERRIDE:
                    case STATIC:
                        {
                        int LA12_3 = input.LA(2);

                        if ( (synpred68_AS3_ex()) )
                        {
                            alt12 = 1;
                        }


                        }
                        break;
                    case SEMI:
                    case RCURLY:
                    case LPAREN:
                    case RPAREN:
                    case LBRACK:
                    case RBRACK:
                    case DOT:
                    case COMMA:
                    case GT:
                    case LTE:
                    case EQ:
                    case NEQ:
                    case SAME:
                    case NSAME:
                    case PLUS:
                    case SUB:
                    case STAR:
                    case DIV:
                    case MOD:
                    case INC:
                    case DEC:
                    case SHL:
                    case AND:
                    case OR:
                    case XOR:
                    case NOT:
                    case INV:
                    case LAND:
                    case LOR:
                    case QUE:
                    case COLON:
                    case ASSIGN:
                    case DIV_ASSIGN:
                    case MOD_ASSIGN:
                    case ADD_ASSIGN:
                    case SUB_ASSIGN:
                    case SHL_ASSIGN:
                    case LAND_ASSIGN:
                    case LOR_ASSIGN:
                    case AND_ASSIGN:
                    case XOR_ASSIGN:
                    case OR_ASSIGN:
                    case ELLIPSIS:
                    case XML_ELLIPSIS:
                    case XML_NS_OP:
                    case XML_AT:
                    case SINGLE_QUOTE_LITERAL:
                    case DOUBLE_QUOTE_LITERAL:
                    case HEX_NUMBER_LITERAL:
                    case DEC_NUMBER_LITERAL:
                    case IDENTIFIER:
                    case XML_TEXT:
                        {
                        int LA12_4 = input.LA(2);

                        if ( (synpred68_AS3_ex()) )
                        {
                            alt12 = 1;
                        }


                        }
                        break;

                    }

                    switch (alt12) 
                    {
                        case 1 :
                            // AS3_ex.g3:1637:6: xmlTextElement
                            {
                                PushFollow(FOLLOW_xmlTextElement_in_xmlText4909);
                                xmlTextElement13 = xmlTextElement();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlTextElement13.Tree);

                            }
                            break;

                        default:
                            if ( cnt12 >= 1 ) goto loop12;
                            if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                                EarlyExitException eee =
                                    new EarlyExitException(12, input);
                                throw eee;
                    }
                    cnt12++;
                } while (true);

                loop12:
                    ;   // Stops C# compiler whinging that label 'loop12' has no statements


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 14, xmlText_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "xmlText"

    public class xmlPrimaryExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "xmlPrimaryExpression"
    // AS3_ex.g3:1641:1: xmlPrimaryExpression : ( xmlPropertyIdentifier | xmlInitialiser | xmlListInitialiser );
    public AS3_exParser.xmlPrimaryExpression_return xmlPrimaryExpression() // throws RecognitionException [1]
    {   
        AS3_exParser.xmlPrimaryExpression_return retval = new AS3_exParser.xmlPrimaryExpression_return();
        retval.Start = input.LT(1);
        int xmlPrimaryExpression_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.xmlPropertyIdentifier_return xmlPropertyIdentifier14 = null;

        AS3_exParser.xmlInitialiser_return xmlInitialiser15 = null;

        AS3_exParser.xmlListInitialiser_return xmlListInitialiser16 = null;



        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 15) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:1642:5: ( xmlPropertyIdentifier | xmlInitialiser | xmlListInitialiser )
            int alt13 = 3;
            switch ( input.LA(1) ) 
            {
            case AS:
            case BREAK:
            case CASE:
            case CATCH:
            case CLASS:
            case CONST:
            case CONTINUE:
            case DEFAULT:
            case DELETE:
            case DO:
            case ELSE:
            case EXTENDS:
            case FALSE:
            case FINALLY:
            case FOR:
            case FUNCTION:
            case IF:
            case IMPLEMENTS:
            case IMPORT:
            case IN:
            case INSTANCEOF:
            case INTERFACE:
            case INTERNAL:
            case IS:
            case NATIVE:
            case NEW:
            case NULL:
            case PACKAGE:
            case PRIVATE:
            case PROTECTED:
            case PUBLIC:
            case RETURN:
            case SUPER:
            case SWITCH:
            case THIS:
            case THROW:
            case TO:
            case TRUE:
            case TRY:
            case TYPEOF:
            case USE:
            case VAR:
            case VOID:
            case WHILE:
            case WITH:
            case EACH:
            case GET:
            case SET:
            case NAMESPACE:
            case INCLUDE:
            case DYNAMIC:
            case FINAL:
            case OVERRIDE:
            case STATIC:
            case STAR:
            case XML_AT:
            case IDENTIFIER:
                {
                alt13 = 1;
                }
                break;
            case LT:
            case XML_COMMENT:
            case XML_CDATA:
            case XML_PI:
                {
                alt13 = 2;
                }
                break;
            case XML_LS_STD:
                {
                alt13 = 3;
                }
                break;
                default:
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    NoViableAltException nvae_d13s0 =
                        new NoViableAltException("", 13, 0, input);

                    throw nvae_d13s0;
            }

            switch (alt13) 
            {
                case 1 :
                    // AS3_ex.g3:1642:9: xmlPropertyIdentifier
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_xmlPropertyIdentifier_in_xmlPrimaryExpression4933);
                        xmlPropertyIdentifier14 = xmlPropertyIdentifier();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlPropertyIdentifier14.Tree);

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:1643:9: xmlInitialiser
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_xmlInitialiser_in_xmlPrimaryExpression4943);
                        xmlInitialiser15 = xmlInitialiser();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlInitialiser15.Tree);

                    }
                    break;
                case 3 :
                    // AS3_ex.g3:1644:9: xmlListInitialiser
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_xmlListInitialiser_in_xmlPrimaryExpression4953);
                        xmlListInitialiser16 = xmlListInitialiser();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlListInitialiser16.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 15, xmlPrimaryExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "xmlPrimaryExpression"

    public class xmlPropertyIdentifier_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "xmlPropertyIdentifier"
    // AS3_ex.g3:1657:1: xmlPropertyIdentifier : ( xmlAttributeIdentifier | xmlQualifiedIdentifier | s= STAR );
    public AS3_exParser.xmlPropertyIdentifier_return xmlPropertyIdentifier() // throws RecognitionException [1]
    {   
        AS3_exParser.xmlPropertyIdentifier_return retval = new AS3_exParser.xmlPropertyIdentifier_return();
        retval.Start = input.LT(1);
        int xmlPropertyIdentifier_StartIndex = input.Index();
        object root_0 = null;

        IToken s = null;
        AS3_exParser.xmlAttributeIdentifier_return xmlAttributeIdentifier17 = null;

        AS3_exParser.xmlQualifiedIdentifier_return xmlQualifiedIdentifier18 = null;


        object s_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 16) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:1658:7: ( xmlAttributeIdentifier | xmlQualifiedIdentifier | s= STAR )
            int alt14 = 3;
            switch ( input.LA(1) ) 
            {
            case XML_AT:
                {
                alt14 = 1;
                }
                break;
            case AS:
            case BREAK:
            case CASE:
            case CATCH:
            case CLASS:
            case CONST:
            case CONTINUE:
            case DEFAULT:
            case DELETE:
            case DO:
            case ELSE:
            case EXTENDS:
            case FALSE:
            case FINALLY:
            case FOR:
            case FUNCTION:
            case IF:
            case IMPLEMENTS:
            case IMPORT:
            case IN:
            case INSTANCEOF:
            case INTERFACE:
            case INTERNAL:
            case IS:
            case NATIVE:
            case NEW:
            case NULL:
            case PACKAGE:
            case PRIVATE:
            case PROTECTED:
            case PUBLIC:
            case RETURN:
            case SUPER:
            case SWITCH:
            case THIS:
            case THROW:
            case TO:
            case TRUE:
            case TRY:
            case TYPEOF:
            case USE:
            case VAR:
            case VOID:
            case WHILE:
            case WITH:
            case EACH:
            case GET:
            case SET:
            case NAMESPACE:
            case INCLUDE:
            case DYNAMIC:
            case FINAL:
            case OVERRIDE:
            case STATIC:
            case IDENTIFIER:
                {
                alt14 = 2;
                }
                break;
            case STAR:
                {
                int LA14_5 = input.LA(2);

                if ( (synpred72_AS3_ex()) )
                {
                    alt14 = 2;
                }
                else if ( (true) )
                {
                    alt14 = 3;
                }
                else 
                {
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    NoViableAltException nvae_d14s5 =
                        new NoViableAltException("", 14, 5, input);

                    throw nvae_d14s5;
                }
                }
                break;
                default:
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    NoViableAltException nvae_d14s0 =
                        new NoViableAltException("", 14, 0, input);

                    throw nvae_d14s0;
            }

            switch (alt14) 
            {
                case 1 :
                    // AS3_ex.g3:1658:11: xmlAttributeIdentifier
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_xmlAttributeIdentifier_in_xmlPropertyIdentifier5046);
                        xmlAttributeIdentifier17 = xmlAttributeIdentifier();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlAttributeIdentifier17.Tree);

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:1659:11: xmlQualifiedIdentifier
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_xmlQualifiedIdentifier_in_xmlPropertyIdentifier5058);
                        xmlQualifiedIdentifier18 = xmlQualifiedIdentifier();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlQualifiedIdentifier18.Tree);

                    }
                    break;
                case 3 :
                    // AS3_ex.g3:1660:11: s= STAR
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        s=(IToken)Match(input,STAR,FOLLOW_STAR_in_xmlPropertyIdentifier5072); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {s_tree = (object)adaptor.Create(s);
                            adaptor.AddChild(root_0, s_tree);
                        }
                        if ( state.backtracking == 0 ) 
                        {
                          emit(s);
                        }

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 16, xmlPropertyIdentifier_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "xmlPropertyIdentifier"

    public class xmlAttributeIdentifier_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "xmlAttributeIdentifier"
    // AS3_ex.g3:1663:1: xmlAttributeIdentifier : at= XML_AT ( xmlQualifiedIdentifier | xmlPropertySelector | indexSuffix ) ;
    public AS3_exParser.xmlAttributeIdentifier_return xmlAttributeIdentifier() // throws RecognitionException [1]
    {   
        AS3_exParser.xmlAttributeIdentifier_return retval = new AS3_exParser.xmlAttributeIdentifier_return();
        retval.Start = input.LT(1);
        int xmlAttributeIdentifier_StartIndex = input.Index();
        object root_0 = null;

        IToken at = null;
        AS3_exParser.xmlQualifiedIdentifier_return xmlQualifiedIdentifier19 = null;

        AS3_exParser.xmlPropertySelector_return xmlPropertySelector20 = null;

        AS3_exParser.indexSuffix_return indexSuffix21 = null;


        object at_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 17) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:1664:5: (at= XML_AT ( xmlQualifiedIdentifier | xmlPropertySelector | indexSuffix ) )
            // AS3_ex.g3:1664:9: at= XML_AT ( xmlQualifiedIdentifier | xmlPropertySelector | indexSuffix )
            {
                root_0 = (object)adaptor.GetNilNode();

                at=(IToken)Match(input,XML_AT,FOLLOW_XML_AT_in_xmlAttributeIdentifier5137); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {at_tree = (object)adaptor.Create(at);
                    adaptor.AddChild(root_0, at_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(at);
                }
                // AS3_ex.g3:1665:9: ( xmlQualifiedIdentifier | xmlPropertySelector | indexSuffix )
                int alt15 = 3;
                switch ( input.LA(1) ) 
                {
                case IDENTIFIER:
                    {
                    int LA15_1 = input.LA(2);

                    if ( (synpred73_AS3_ex()) )
                    {
                        alt15 = 1;
                    }
                    else if ( (synpred74_AS3_ex()) )
                    {
                        alt15 = 2;
                    }
                    else 
                    {
                        if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                        NoViableAltException nvae_d15s1 =
                            new NoViableAltException("", 15, 1, input);

                        throw nvae_d15s1;
                    }
                    }
                    break;
                case AS:
                case BREAK:
                case CASE:
                case CATCH:
                case CLASS:
                case CONST:
                case CONTINUE:
                case DEFAULT:
                case DELETE:
                case DO:
                case ELSE:
                case EXTENDS:
                case FALSE:
                case FINALLY:
                case FOR:
                case FUNCTION:
                case IF:
                case IMPLEMENTS:
                case IMPORT:
                case IN:
                case INSTANCEOF:
                case INTERFACE:
                case INTERNAL:
                case IS:
                case NEW:
                case NULL:
                case PACKAGE:
                case PRIVATE:
                case PROTECTED:
                case PUBLIC:
                case RETURN:
                case SUPER:
                case SWITCH:
                case THIS:
                case THROW:
                case TRUE:
                case TRY:
                case TYPEOF:
                case USE:
                case VAR:
                case VOID:
                case WHILE:
                case WITH:
                case INCLUDE:
                    {
                    int LA15_2 = input.LA(2);

                    if ( (synpred73_AS3_ex()) )
                    {
                        alt15 = 1;
                    }
                    else if ( (synpred74_AS3_ex()) )
                    {
                        alt15 = 2;
                    }
                    else 
                    {
                        if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                        NoViableAltException nvae_d15s2 =
                            new NoViableAltException("", 15, 2, input);

                        throw nvae_d15s2;
                    }
                    }
                    break;
                case NATIVE:
                case TO:
                case EACH:
                case GET:
                case SET:
                case NAMESPACE:
                case DYNAMIC:
                case FINAL:
                case OVERRIDE:
                case STATIC:
                    {
                    int LA15_3 = input.LA(2);

                    if ( (synpred73_AS3_ex()) )
                    {
                        alt15 = 1;
                    }
                    else if ( (synpred74_AS3_ex()) )
                    {
                        alt15 = 2;
                    }
                    else 
                    {
                        if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                        NoViableAltException nvae_d15s3 =
                            new NoViableAltException("", 15, 3, input);

                        throw nvae_d15s3;
                    }
                    }
                    break;
                case STAR:
                    {
                    int LA15_4 = input.LA(2);

                    if ( (synpred73_AS3_ex()) )
                    {
                        alt15 = 1;
                    }
                    else if ( (synpred74_AS3_ex()) )
                    {
                        alt15 = 2;
                    }
                    else 
                    {
                        if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                        NoViableAltException nvae_d15s4 =
                            new NoViableAltException("", 15, 4, input);

                        throw nvae_d15s4;
                    }
                    }
                    break;
                case LBRACK:
                    {
                    alt15 = 3;
                    }
                    break;
                    default:
                        if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                        NoViableAltException nvae_d15s0 =
                            new NoViableAltException("", 15, 0, input);

                        throw nvae_d15s0;
                }

                switch (alt15) 
                {
                    case 1 :
                        // AS3_ex.g3:1666:12: xmlQualifiedIdentifier
                        {
                            PushFollow(FOLLOW_xmlQualifiedIdentifier_in_xmlAttributeIdentifier5163);
                            xmlQualifiedIdentifier19 = xmlQualifiedIdentifier();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlQualifiedIdentifier19.Tree);

                        }
                        break;
                    case 2 :
                        // AS3_ex.g3:1667:14: xmlPropertySelector
                        {
                            PushFollow(FOLLOW_xmlPropertySelector_in_xmlAttributeIdentifier5178);
                            xmlPropertySelector20 = xmlPropertySelector();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlPropertySelector20.Tree);

                        }
                        break;
                    case 3 :
                        // AS3_ex.g3:1668:14: indexSuffix
                        {
                            PushFollow(FOLLOW_indexSuffix_in_xmlAttributeIdentifier5193);
                            indexSuffix21 = indexSuffix();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, indexSuffix21.Tree);

                        }
                        break;

                }


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 17, xmlAttributeIdentifier_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "xmlAttributeIdentifier"

    public class xmlPropertySelector_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "xmlPropertySelector"
    // AS3_ex.g3:1672:1: xmlPropertySelector : ( xmlNameLiteral | s= STAR );
    public AS3_exParser.xmlPropertySelector_return xmlPropertySelector() // throws RecognitionException [1]
    {   
        AS3_exParser.xmlPropertySelector_return retval = new AS3_exParser.xmlPropertySelector_return();
        retval.Start = input.LT(1);
        int xmlPropertySelector_StartIndex = input.Index();
        object root_0 = null;

        IToken s = null;
        AS3_exParser.xmlNameLiteral_return xmlNameLiteral22 = null;


        object s_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 18) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:1673:5: ( xmlNameLiteral | s= STAR )
            int alt16 = 2;
            int LA16_0 = input.LA(1);

            if ( ((LA16_0 >= AS && LA16_0 <= STATIC) || LA16_0 == IDENTIFIER) )
            {
                alt16 = 1;
            }
            else if ( (LA16_0 == STAR) )
            {
                alt16 = 2;
            }
            else 
            {
                if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                NoViableAltException nvae_d16s0 =
                    new NoViableAltException("", 16, 0, input);

                throw nvae_d16s0;
            }
            switch (alt16) 
            {
                case 1 :
                    // AS3_ex.g3:1673:9: xmlNameLiteral
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_xmlNameLiteral_in_xmlPropertySelector5283);
                        xmlNameLiteral22 = xmlNameLiteral();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlNameLiteral22.Tree);

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:1674:9: s= STAR
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        s=(IToken)Match(input,STAR,FOLLOW_STAR_in_xmlPropertySelector5296); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {s_tree = (object)adaptor.Create(s);
                            adaptor.AddChild(root_0, s_tree);
                        }
                        if ( state.backtracking == 0 ) 
                        {
                          emit(s);
                        }

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 18, xmlPropertySelector_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "xmlPropertySelector"

    public class xmlQualifiedIdentifier_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "xmlQualifiedIdentifier"
    // AS3_ex.g3:1677:1: xmlQualifiedIdentifier : xmlPropertySelector x= XML_NS_OP ( xmlPropertySelector | indexSuffix ) ;
    public AS3_exParser.xmlQualifiedIdentifier_return xmlQualifiedIdentifier() // throws RecognitionException [1]
    {   
        AS3_exParser.xmlQualifiedIdentifier_return retval = new AS3_exParser.xmlQualifiedIdentifier_return();
        retval.Start = input.LT(1);
        int xmlQualifiedIdentifier_StartIndex = input.Index();
        object root_0 = null;

        IToken x = null;
        AS3_exParser.xmlPropertySelector_return xmlPropertySelector23 = null;

        AS3_exParser.xmlPropertySelector_return xmlPropertySelector24 = null;

        AS3_exParser.indexSuffix_return indexSuffix25 = null;


        object x_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 19) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:1678:5: ( xmlPropertySelector x= XML_NS_OP ( xmlPropertySelector | indexSuffix ) )
            // AS3_ex.g3:1678:9: xmlPropertySelector x= XML_NS_OP ( xmlPropertySelector | indexSuffix )
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_xmlPropertySelector_in_xmlQualifiedIdentifier5317);
                xmlPropertySelector23 = xmlPropertySelector();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlPropertySelector23.Tree);
                x=(IToken)Match(input,XML_NS_OP,FOLLOW_XML_NS_OP_in_xmlQualifiedIdentifier5322); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {x_tree = (object)adaptor.Create(x);
                    adaptor.AddChild(root_0, x_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  wrapEmit(x, ASPrettyPrinter.Break_Other_Connectors_code);
                }
                // AS3_ex.g3:1679:5: ( xmlPropertySelector | indexSuffix )
                int alt17 = 2;
                int LA17_0 = input.LA(1);

                if ( ((LA17_0 >= AS && LA17_0 <= STATIC) || LA17_0 == STAR || LA17_0 == IDENTIFIER) )
                {
                    alt17 = 1;
                }
                else if ( (LA17_0 == LBRACK) )
                {
                    alt17 = 2;
                }
                else 
                {
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    NoViableAltException nvae_d17s0 =
                        new NoViableAltException("", 17, 0, input);

                    throw nvae_d17s0;
                }
                switch (alt17) 
                {
                    case 1 :
                        // AS3_ex.g3:1680:9: xmlPropertySelector
                        {
                            PushFollow(FOLLOW_xmlPropertySelector_in_xmlQualifiedIdentifier5357);
                            xmlPropertySelector24 = xmlPropertySelector();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlPropertySelector24.Tree);

                        }
                        break;
                    case 2 :
                        // AS3_ex.g3:1681:11: indexSuffix
                        {
                            PushFollow(FOLLOW_indexSuffix_in_xmlQualifiedIdentifier5369);
                            indexSuffix25 = indexSuffix();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, indexSuffix25.Tree);

                        }
                        break;

                }

                if ( state.backtracking == 0 ) 
                {
                  popIndent();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 19, xmlQualifiedIdentifier_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "xmlQualifiedIdentifier"

    public class xmlInitialiser_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "xmlInitialiser"
    // AS3_ex.g3:1686:1: xmlInitialiser : ( xmlMarkup | xmlElement );
    public AS3_exParser.xmlInitialiser_return xmlInitialiser() // throws RecognitionException [1]
    {   
        AS3_exParser.xmlInitialiser_return retval = new AS3_exParser.xmlInitialiser_return();
        retval.Start = input.LT(1);
        int xmlInitialiser_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.xmlMarkup_return xmlMarkup26 = null;

        AS3_exParser.xmlElement_return xmlElement27 = null;



        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 20) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:1687:5: ( xmlMarkup | xmlElement )
            int alt18 = 2;
            int LA18_0 = input.LA(1);

            if ( ((LA18_0 >= XML_COMMENT && LA18_0 <= XML_PI)) )
            {
                alt18 = 1;
            }
            else if ( (LA18_0 == LT) )
            {
                alt18 = 2;
            }
            else 
            {
                if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                NoViableAltException nvae_d18s0 =
                    new NoViableAltException("", 18, 0, input);

                throw nvae_d18s0;
            }
            switch (alt18) 
            {
                case 1 :
                    // AS3_ex.g3:1687:9: xmlMarkup
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_xmlMarkup_in_xmlInitialiser5400);
                        xmlMarkup26 = xmlMarkup();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlMarkup26.Tree);

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:1688:9: xmlElement
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_xmlElement_in_xmlInitialiser5410);
                        xmlElement27 = xmlElement();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlElement27.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 20, xmlInitialiser_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "xmlInitialiser"

    public class xmlElement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "xmlElement"
    // AS3_ex.g3:1699:1: xmlElement : L= LT xmlTagName ( xmlAttributes )? (x= XML_TEND | G= GT ( xmlElementContent[false] )? x= XML_E_TEND xmlTagName G= GT ) ;
    public AS3_exParser.xmlElement_return xmlElement() // throws RecognitionException [1]
    {   
        AS3_exParser.xmlElement_return retval = new AS3_exParser.xmlElement_return();
        retval.Start = input.LT(1);
        int xmlElement_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        IToken x = null;
        IToken G = null;
        AS3_exParser.xmlTagName_return xmlTagName28 = null;

        AS3_exParser.xmlAttributes_return xmlAttributes29 = null;

        AS3_exParser.xmlElementContent_return xmlElementContent30 = null;

        AS3_exParser.xmlTagName_return xmlTagName31 = null;


        object L_tree=null;
        object x_tree=null;
        object G_tree=null;


            WrapOptions options=mPrinter.getXMLWrapOptions();
            bool pushedFormat=false;
            bool pushedWrapInfo=false;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 21) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:1706:5: (L= LT xmlTagName ( xmlAttributes )? (x= XML_TEND | G= GT ( xmlElementContent[false] )? x= XML_E_TEND xmlTagName G= GT ) )
            // AS3_ex.g3:1707:5: L= LT xmlTagName ( xmlAttributes )? (x= XML_TEND | G= GT ( xmlElementContent[false] )? x= XML_E_TEND xmlTagName G= GT )
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  pushedFormat=pushFormatType(options, true);
                }
                if ( state.backtracking == 0 ) 
                {
                  pushedWrapInfo=pushWrapInfo(options, true);
                }
                if ( state.backtracking == 0 ) 
                {
                  emitCRForTag(options);
                }
                L=(IToken)Match(input,LT,FOLLOW_LT_in_xmlElement5476); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {L_tree = (object)adaptor.Create(L);
                    adaptor.AddChild(root_0, L_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(L);
                }
                if ( state.backtracking == 0 ) 
                {
                  emitXMLBreak(L, true);
                }
                if ( state.backtracking == 0 ) 
                {
                  pushIndent(true);
                }
                PushFollow(FOLLOW_xmlTagName_in_xmlElement5482);
                xmlTagName28 = xmlTagName();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlTagName28.Tree);
                // AS3_ex.g3:1710:77: ( xmlAttributes )?
                int alt19 = 2;
                int LA19_0 = input.LA(1);

                if ( ((LA19_0 >= AS && LA19_0 <= STATIC) || LA19_0 == LCURLY || LA19_0 == IDENTIFIER) )
                {
                    alt19 = 1;
                }
                switch (alt19) 
                {
                    case 1 :
                        // AS3_ex.g3:0:0: xmlAttributes
                        {
                            PushFollow(FOLLOW_xmlAttributes_in_xmlElement5484);
                            xmlAttributes29 = xmlAttributes();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlAttributes29.Tree);

                        }
                        break;

                }

                // AS3_ex.g3:1711:5: (x= XML_TEND | G= GT ( xmlElementContent[false] )? x= XML_E_TEND xmlTagName G= GT )
                int alt21 = 2;
                int LA21_0 = input.LA(1);

                if ( (LA21_0 == XML_TEND) )
                {
                    alt21 = 1;
                }
                else if ( (LA21_0 == GT) )
                {
                    alt21 = 2;
                }
                else 
                {
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    NoViableAltException nvae_d21s0 =
                        new NoViableAltException("", 21, 0, input);

                    throw nvae_d21s0;
                }
                switch (alt21) 
                {
                    case 1 :
                        // AS3_ex.g3:1712:9: x= XML_TEND
                        {
                            x=(IToken)Match(input,XML_TEND,FOLLOW_XML_TEND_in_xmlElement5504); if (state.failed) return retval;
                            if ( state.backtracking == 0 )
                            {x_tree = (object)adaptor.Create(x);
                                adaptor.AddChild(root_0, x_tree);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              emit(x);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              emitCRForTag(options);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              popIndent();
                            }

                        }
                        break;
                    case 2 :
                        // AS3_ex.g3:1718:9: G= GT ( xmlElementContent[false] )? x= XML_E_TEND xmlTagName G= GT
                        {
                            G=(IToken)Match(input,GT,FOLLOW_GT_in_xmlElement5560); if (state.failed) return retval;
                            if ( state.backtracking == 0 )
                            {G_tree = (object)adaptor.Create(G);
                                adaptor.AddChild(root_0, G_tree);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              emit(G);pushXMLTextContentFlag();
                            }
                            // AS3_ex.g3:1718:51: ( xmlElementContent[false] )?
                            int alt20 = 2;
                            int LA20_0 = input.LA(1);

                            if ( ((LA20_0 >= AS && LA20_0 <= LTE) || (LA20_0 >= EQ && LA20_0 <= SHL) || (LA20_0 >= AND && LA20_0 <= SHL_ASSIGN) || (LA20_0 >= LAND_ASSIGN && LA20_0 <= XML_ELLIPSIS) || (LA20_0 >= XML_NS_OP && LA20_0 <= XML_AT) || (LA20_0 >= SINGLE_QUOTE_LITERAL && LA20_0 <= DOUBLE_QUOTE_LITERAL) || LA20_0 == HEX_NUMBER_LITERAL || LA20_0 == DEC_NUMBER_LITERAL || LA20_0 == IDENTIFIER || (LA20_0 >= XML_COMMENT && LA20_0 <= XML_TEXT)) )
                            {
                                alt20 = 1;
                            }
                            switch (alt20) 
                            {
                                case 1 :
                                    // AS3_ex.g3:0:0: xmlElementContent[false]
                                    {
                                        PushFollow(FOLLOW_xmlElementContent_in_xmlElement5564);
                                        xmlElementContent30 = xmlElementContent(false);
                                        state.followingStackPointer--;
                                        if (state.failed) return retval;
                                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlElementContent30.Tree);

                                    }
                                    break;

                            }

                            x=(IToken)Match(input,XML_E_TEND,FOLLOW_XML_E_TEND_in_xmlElement5579); if (state.failed) return retval;
                            if ( state.backtracking == 0 )
                            {x_tree = (object)adaptor.Create(x);
                                adaptor.AddChild(root_0, x_tree);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              popIndent();
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              emit(x);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              if (!popXMLTextContentFlag()) emitXMLBreak(x, true);
                            }
                            PushFollow(FOLLOW_xmlTagName_in_xmlElement5594);
                            xmlTagName31 = xmlTagName();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlTagName31.Tree);
                            G=(IToken)Match(input,GT,FOLLOW_GT_in_xmlElement5598); if (state.failed) return retval;
                            if ( state.backtracking == 0 )
                            {G_tree = (object)adaptor.Create(G);
                                adaptor.AddChild(root_0, G_tree);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              emit(G);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              emitCRForTag(options);
                            }

                        }
                        break;

                }

                if ( state.backtracking == 0 ) 
                {

                        if (pushedWrapInfo) mPrinter.popWrapContext();
                        if (pushedFormat)
                            mPrinter.popFormatMode();
                      
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 21, xmlElement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "xmlElement"

    public class xmlAttributes_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "xmlAttributes"
    // AS3_ex.g3:1729:1: xmlAttributes : ( xmlAttribute )+ ;
    public AS3_exParser.xmlAttributes_return xmlAttributes() // throws RecognitionException [1]
    {   
        AS3_exParser.xmlAttributes_return retval = new AS3_exParser.xmlAttributes_return();
        retval.Start = input.LT(1);
        int xmlAttributes_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.xmlAttribute_return xmlAttribute32 = null;



        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 22) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:1730:5: ( ( xmlAttribute )+ )
            // AS3_ex.g3:1730:9: ( xmlAttribute )+
            {
                root_0 = (object)adaptor.GetNilNode();

                // AS3_ex.g3:1730:9: ( xmlAttribute )+
                int cnt22 = 0;
                do 
                {
                    int alt22 = 2;
                    int LA22_0 = input.LA(1);

                    if ( ((LA22_0 >= AS && LA22_0 <= STATIC) || LA22_0 == LCURLY || LA22_0 == IDENTIFIER) )
                    {
                        alt22 = 1;
                    }


                    switch (alt22) 
                    {
                        case 1 :
                            // AS3_ex.g3:0:0: xmlAttribute
                            {
                                PushFollow(FOLLOW_xmlAttribute_in_xmlAttributes5637);
                                xmlAttribute32 = xmlAttribute();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlAttribute32.Tree);

                            }
                            break;

                        default:
                            if ( cnt22 >= 1 ) goto loop22;
                            if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                                EarlyExitException eee =
                                    new EarlyExitException(22, input);
                                throw eee;
                    }
                    cnt22++;
                } while (true);

                loop22:
                    ;   // Stops C# compiler whinging that label 'loop22' has no statements


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 22, xmlAttributes_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "xmlAttributes"

    public class xmlTagName_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "xmlTagName"
    // AS3_ex.g3:1733:1: xmlTagName : ( xmlExprEval | xmlNameLiteral );
    public AS3_exParser.xmlTagName_return xmlTagName() // throws RecognitionException [1]
    {   
        AS3_exParser.xmlTagName_return retval = new AS3_exParser.xmlTagName_return();
        retval.Start = input.LT(1);
        int xmlTagName_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.xmlExprEval_return xmlExprEval33 = null;

        AS3_exParser.xmlNameLiteral_return xmlNameLiteral34 = null;



        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 23) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:1734:5: ( xmlExprEval | xmlNameLiteral )
            int alt23 = 2;
            int LA23_0 = input.LA(1);

            if ( (LA23_0 == LCURLY) )
            {
                alt23 = 1;
            }
            else if ( ((LA23_0 >= AS && LA23_0 <= STATIC) || LA23_0 == IDENTIFIER) )
            {
                alt23 = 2;
            }
            else 
            {
                if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                NoViableAltException nvae_d23s0 =
                    new NoViableAltException("", 23, 0, input);

                throw nvae_d23s0;
            }
            switch (alt23) 
            {
                case 1 :
                    // AS3_ex.g3:1734:9: xmlExprEval
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_xmlExprEval_in_xmlTagName5667);
                        xmlExprEval33 = xmlExprEval();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlExprEval33.Tree);

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:1735:4: xmlNameLiteral
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_xmlNameLiteral_in_xmlTagName5672);
                        xmlNameLiteral34 = xmlNameLiteral();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlNameLiteral34.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 23, xmlTagName_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "xmlTagName"

    public class xmlAttribute_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "xmlAttribute"
    // AS3_ex.g3:1738:1: xmlAttribute : {...}? xmlTagName A= ASSIGN ( xmlExprEval | stringLiteral ) ;
    public AS3_exParser.xmlAttribute_return xmlAttribute() // throws RecognitionException [1]
    {   
        AS3_exParser.xmlAttribute_return retval = new AS3_exParser.xmlAttribute_return();
        retval.Start = input.LT(1);
        int xmlAttribute_StartIndex = input.Index();
        object root_0 = null;

        IToken A = null;
        AS3_exParser.xmlTagName_return xmlTagName35 = null;

        AS3_exParser.xmlExprEval_return xmlExprEval36 = null;

        AS3_exParser.stringLiteral_return stringLiteral37 = null;


        object A_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 24) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:1739:5: ({...}? xmlTagName A= ASSIGN ( xmlExprEval | stringLiteral ) )
            // AS3_ex.g3:1739:8: {...}? xmlTagName A= ASSIGN ( xmlExprEval | stringLiteral )
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( !((promoteWhitespace())) ) 
                {
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    throw new FailedPredicateException(input, "xmlAttribute", "promoteWhitespace()");
                }
                if ( state.backtracking == 0 ) 
                {
                  insertWS(1);
                }
                PushFollow(FOLLOW_xmlTagName_in_xmlAttribute5695);
                xmlTagName35 = xmlTagName();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlTagName35.Tree);
                A=(IToken)Match(input,ASSIGN,FOLLOW_ASSIGN_in_xmlAttribute5699); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {A_tree = (object)adaptor.Create(A);
                    adaptor.AddChild(root_0, A_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(A);
                }
                // AS3_ex.g3:1740:5: ( xmlExprEval | stringLiteral )
                int alt24 = 2;
                int LA24_0 = input.LA(1);

                if ( (LA24_0 == LCURLY) )
                {
                    alt24 = 1;
                }
                else if ( ((LA24_0 >= SINGLE_QUOTE_LITERAL && LA24_0 <= DOUBLE_QUOTE_LITERAL)) )
                {
                    alt24 = 2;
                }
                else 
                {
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    NoViableAltException nvae_d24s0 =
                        new NoViableAltException("", 24, 0, input);

                    throw nvae_d24s0;
                }
                switch (alt24) 
                {
                    case 1 :
                        // AS3_ex.g3:1741:9: xmlExprEval
                        {
                            PushFollow(FOLLOW_xmlExprEval_in_xmlAttribute5718);
                            xmlExprEval36 = xmlExprEval();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlExprEval36.Tree);

                        }
                        break;
                    case 2 :
                        // AS3_ex.g3:1742:11: stringLiteral
                        {
                            PushFollow(FOLLOW_stringLiteral_in_xmlAttribute5730);
                            stringLiteral37 = stringLiteral();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, stringLiteral37.Tree);

                        }
                        break;

                }


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 24, xmlAttribute_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "xmlAttribute"

    public class xmlElementContent_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "xmlElementContent"
    // AS3_ex.g3:1746:1: xmlElementContent[bool crAfterTags] : ( xmlElementContentHelper[crAfterTags] )+ ;
    public AS3_exParser.xmlElementContent_return xmlElementContent(bool crAfterTags) // throws RecognitionException [1]
    {   
        AS3_exParser.xmlElementContent_return retval = new AS3_exParser.xmlElementContent_return();
        retval.Start = input.LT(1);
        int xmlElementContent_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.xmlElementContentHelper_return xmlElementContentHelper38 = null;



        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 25) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:1747:5: ( ( xmlElementContentHelper[crAfterTags] )+ )
            // AS3_ex.g3:1747:8: ( xmlElementContentHelper[crAfterTags] )+
            {
                root_0 = (object)adaptor.GetNilNode();

                // AS3_ex.g3:1747:8: ( xmlElementContentHelper[crAfterTags] )+
                int cnt25 = 0;
                do 
                {
                    int alt25 = 2;
                    int LA25_0 = input.LA(1);

                    if ( ((LA25_0 >= AS && LA25_0 <= LTE) || (LA25_0 >= EQ && LA25_0 <= SHL) || (LA25_0 >= AND && LA25_0 <= SHL_ASSIGN) || (LA25_0 >= LAND_ASSIGN && LA25_0 <= XML_ELLIPSIS) || (LA25_0 >= XML_NS_OP && LA25_0 <= XML_AT) || (LA25_0 >= SINGLE_QUOTE_LITERAL && LA25_0 <= DOUBLE_QUOTE_LITERAL) || LA25_0 == HEX_NUMBER_LITERAL || LA25_0 == DEC_NUMBER_LITERAL || LA25_0 == IDENTIFIER || (LA25_0 >= XML_COMMENT && LA25_0 <= XML_TEXT)) )
                    {
                        alt25 = 1;
                    }


                    switch (alt25) 
                    {
                        case 1 :
                            // AS3_ex.g3:0:0: xmlElementContentHelper[crAfterTags]
                            {
                                PushFollow(FOLLOW_xmlElementContentHelper_in_xmlElementContent5762);
                                xmlElementContentHelper38 = xmlElementContentHelper(crAfterTags);
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlElementContentHelper38.Tree);

                            }
                            break;

                        default:
                            if ( cnt25 >= 1 ) goto loop25;
                            if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                                EarlyExitException eee =
                                    new EarlyExitException(25, input);
                                throw eee;
                    }
                    cnt25++;
                } while (true);

                loop25:
                    ;   // Stops C# compiler whinging that label 'loop25' has no statements


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 25, xmlElementContent_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "xmlElementContent"

    public class xmlElementContentHelper_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "xmlElementContentHelper"
    // AS3_ex.g3:1750:1: xmlElementContentHelper[bool crAfterTags] : ( xmlExprEval | xmlMarkup | xmlElement | xmlText );
    public AS3_exParser.xmlElementContentHelper_return xmlElementContentHelper(bool crAfterTags) // throws RecognitionException [1]
    {   
        AS3_exParser.xmlElementContentHelper_return retval = new AS3_exParser.xmlElementContentHelper_return();
        retval.Start = input.LT(1);
        int xmlElementContentHelper_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.xmlExprEval_return xmlExprEval39 = null;

        AS3_exParser.xmlMarkup_return xmlMarkup40 = null;

        AS3_exParser.xmlElement_return xmlElement41 = null;

        AS3_exParser.xmlText_return xmlText42 = null;



        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 26) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:1751:5: ( xmlExprEval | xmlMarkup | xmlElement | xmlText )
            int alt26 = 4;
            switch ( input.LA(1) ) 
            {
            case LCURLY:
                {
                alt26 = 1;
                }
                break;
            case XML_COMMENT:
            case XML_CDATA:
            case XML_PI:
                {
                alt26 = 2;
                }
                break;
            case LT:
                {
                alt26 = 3;
                }
                break;
            case AS:
            case BREAK:
            case CASE:
            case CATCH:
            case CLASS:
            case CONST:
            case CONTINUE:
            case DEFAULT:
            case DELETE:
            case DO:
            case ELSE:
            case EXTENDS:
            case FALSE:
            case FINALLY:
            case FOR:
            case FUNCTION:
            case IF:
            case IMPLEMENTS:
            case IMPORT:
            case IN:
            case INSTANCEOF:
            case INTERFACE:
            case INTERNAL:
            case IS:
            case NATIVE:
            case NEW:
            case NULL:
            case PACKAGE:
            case PRIVATE:
            case PROTECTED:
            case PUBLIC:
            case RETURN:
            case SUPER:
            case SWITCH:
            case THIS:
            case THROW:
            case TO:
            case TRUE:
            case TRY:
            case TYPEOF:
            case USE:
            case VAR:
            case VOID:
            case WHILE:
            case WITH:
            case EACH:
            case GET:
            case SET:
            case NAMESPACE:
            case INCLUDE:
            case DYNAMIC:
            case FINAL:
            case OVERRIDE:
            case STATIC:
            case SEMI:
            case RCURLY:
            case LPAREN:
            case RPAREN:
            case LBRACK:
            case RBRACK:
            case DOT:
            case COMMA:
            case GT:
            case LTE:
            case EQ:
            case NEQ:
            case SAME:
            case NSAME:
            case PLUS:
            case SUB:
            case STAR:
            case DIV:
            case MOD:
            case INC:
            case DEC:
            case SHL:
            case AND:
            case OR:
            case XOR:
            case NOT:
            case INV:
            case LAND:
            case LOR:
            case QUE:
            case COLON:
            case ASSIGN:
            case DIV_ASSIGN:
            case MOD_ASSIGN:
            case ADD_ASSIGN:
            case SUB_ASSIGN:
            case SHL_ASSIGN:
            case LAND_ASSIGN:
            case LOR_ASSIGN:
            case AND_ASSIGN:
            case XOR_ASSIGN:
            case OR_ASSIGN:
            case ELLIPSIS:
            case XML_ELLIPSIS:
            case XML_NS_OP:
            case XML_AT:
            case SINGLE_QUOTE_LITERAL:
            case DOUBLE_QUOTE_LITERAL:
            case HEX_NUMBER_LITERAL:
            case DEC_NUMBER_LITERAL:
            case IDENTIFIER:
            case XML_TEXT:
                {
                alt26 = 4;
                }
                break;
                default:
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    NoViableAltException nvae_d26s0 =
                        new NoViableAltException("", 26, 0, input);

                    throw nvae_d26s0;
            }

            switch (alt26) 
            {
                case 1 :
                    // AS3_ex.g3:1751:7: xmlExprEval
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_xmlExprEval_in_xmlElementContentHelper5782);
                        xmlExprEval39 = xmlExprEval();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlExprEval39.Tree);
                        if ( state.backtracking == 0 ) 
                        {
                          if (crAfterTags) insertCR(false);setXMLTextContentFlag();
                        }

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:1752:7: xmlMarkup
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_xmlMarkup_in_xmlElementContentHelper5792);
                        xmlMarkup40 = xmlMarkup();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlMarkup40.Tree);
                        if ( state.backtracking == 0 ) 
                        {
                          if (crAfterTags) insertCR(false);
                        }

                    }
                    break;
                case 3 :
                    // AS3_ex.g3:1753:7: xmlElement
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_xmlElement_in_xmlElementContentHelper5802);
                        xmlElement41 = xmlElement();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlElement41.Tree);
                        if ( state.backtracking == 0 ) 
                        {
                          if (crAfterTags) insertCR(false);
                        }

                    }
                    break;
                case 4 :
                    // AS3_ex.g3:1754:7: xmlText
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        if ( state.backtracking == 0 ) 
                        {
                          mPrinter.pushFormatMode(ASPrettyPrinter.FORMAT_INDENT);
                        }
                        PushFollow(FOLLOW_xmlText_in_xmlElementContentHelper5813);
                        xmlText42 = xmlText();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlText42.Tree);
                        if ( state.backtracking == 0 ) 
                        {
                          mPrinter.popFormatMode();
                        }
                        if ( state.backtracking == 0 ) 
                        {
                          if (crAfterTags) insertCR(false);setXMLTextContentFlag();
                        }

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 26, xmlElementContentHelper_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "xmlElementContentHelper"

    public class xmlListInitialiser_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "xmlListInitialiser"
    // AS3_ex.g3:1757:1: xmlListInitialiser : x= XML_LS_STD ( xmlElementContent[true] )? x= XML_LS_END ;
    public AS3_exParser.xmlListInitialiser_return xmlListInitialiser() // throws RecognitionException [1]
    {   
        AS3_exParser.xmlListInitialiser_return retval = new AS3_exParser.xmlListInitialiser_return();
        retval.Start = input.LT(1);
        int xmlListInitialiser_StartIndex = input.Index();
        object root_0 = null;

        IToken x = null;
        AS3_exParser.xmlElementContent_return xmlElementContent43 = null;


        object x_tree=null;


            WrapOptions options=mPrinter.getXMLWrapOptions();
            bool pushedFormat=false;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 27) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:1763:5: (x= XML_LS_STD ( xmlElementContent[true] )? x= XML_LS_END )
            // AS3_ex.g3:1764:3: x= XML_LS_STD ( xmlElementContent[true] )? x= XML_LS_END
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  pushedFormat=pushFormatType(options, true);
                }
                if ( state.backtracking == 0 ) 
                {
                  insertCR(false);
                }
                x=(IToken)Match(input,XML_LS_STD,FOLLOW_XML_LS_STD_in_xmlListInitialiser5855); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {x_tree = (object)adaptor.Create(x);
                    adaptor.AddChild(root_0, x_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(x);
                }
                if ( state.backtracking == 0 ) 
                {
                  insertCR(false);
                }
                if ( state.backtracking == 0 ) 
                {
                  pushIndent(true);
                }
                // AS3_ex.g3:1767:5: ( xmlElementContent[true] )?
                int alt27 = 2;
                int LA27_0 = input.LA(1);

                if ( ((LA27_0 >= AS && LA27_0 <= LTE) || (LA27_0 >= EQ && LA27_0 <= SHL) || (LA27_0 >= AND && LA27_0 <= SHL_ASSIGN) || (LA27_0 >= LAND_ASSIGN && LA27_0 <= XML_ELLIPSIS) || (LA27_0 >= XML_NS_OP && LA27_0 <= XML_AT) || (LA27_0 >= SINGLE_QUOTE_LITERAL && LA27_0 <= DOUBLE_QUOTE_LITERAL) || LA27_0 == HEX_NUMBER_LITERAL || LA27_0 == DEC_NUMBER_LITERAL || LA27_0 == IDENTIFIER || (LA27_0 >= XML_COMMENT && LA27_0 <= XML_TEXT)) )
                {
                    alt27 = 1;
                }
                switch (alt27) 
                {
                    case 1 :
                        // AS3_ex.g3:0:0: xmlElementContent[true]
                        {
                            PushFollow(FOLLOW_xmlElementContent_in_xmlListInitialiser5870);
                            xmlElementContent43 = xmlElementContent(true);
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlElementContent43.Tree);

                        }
                        break;

                }

                if ( state.backtracking == 0 ) 
                {
                  insertCR(false);
                }
                x=(IToken)Match(input,XML_LS_END,FOLLOW_XML_LS_END_in_xmlListInitialiser5883); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {x_tree = (object)adaptor.Create(x);
                    adaptor.AddChild(root_0, x_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  popIndent();
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(x);
                }
                if ( state.backtracking == 0 ) 
                {
                  insertCR(false);
                }
                if ( state.backtracking == 0 ) 
                {

                            if (pushedFormat)
                                mPrinter.popFormatMode();
                        
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 27, xmlListInitialiser_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "xmlListInitialiser"

    public class semic_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "semic"
    // AS3_ex.g3:1776:1: semic : (S= SEMI | E= EOF | R= RCURLY );
    public AS3_exParser.semic_return semic() // throws RecognitionException [1]
    {   
        AS3_exParser.semic_return retval = new AS3_exParser.semic_return();
        retval.Start = input.LT(1);
        int semic_StartIndex = input.Index();
        object root_0 = null;

        IToken S = null;
        IToken E = null;
        IToken R = null;

        object S_tree=null;
        object E_tree=null;
        object R_tree=null;


            // Mark current position so we can unconsume a RBRACE.
            int marker = input.Mark();
            // Promote EOL if appropriate
            bool onBrace=false;
            if (((IToken)retval.Start).Text != null && ((IToken)retval.Start).Text == "}")
            {
                onBrace=true;
                if (state.backtracking>0)
                {
                    retval.Stop=retval.Start;
                    return retval; //we don't want to consume the '}' during the prediction phase
                }       
            }
                
            if (findVirtualHiddenToken(retval))
            {
               retval.Stop=retval.Start;
               return retval;
            }
               
         //   promoteEOL(retval);

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 28) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:1801:5: (S= SEMI | E= EOF | R= RCURLY )
            int alt28 = 3;
            switch ( input.LA(1) ) 
            {
            case SEMI:
                {
                alt28 = 1;
                }
                break;
            case EOF:
                {
                alt28 = 2;
                }
                break;
            case RCURLY:
                {
                alt28 = 3;
                }
                break;
                default:
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    NoViableAltException nvae_d28s0 =
                        new NoViableAltException("", 28, 0, input);

                    throw nvae_d28s0;
            }

            switch (alt28) 
            {
                case 1 :
                    // AS3_ex.g3:1801:9: S= SEMI
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        S=(IToken)Match(input,SEMI,FOLLOW_SEMI_in_semic5921); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {S_tree = (object)adaptor.Create(S);
                            adaptor.AddChild(root_0, S_tree);
                        }
                        if ( state.backtracking == 0 ) 
                        {
                          emit(S);
                        }

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:1802:9: E= EOF
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        E=(IToken)Match(input,EOF,FOLLOW_EOF_in_semic5935); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {E_tree = (object)adaptor.Create(E);
                            adaptor.AddChild(root_0, E_tree);
                        }
                        if ( state.backtracking == 0 ) 
                        {
                          emit(E);
                        }

                    }
                    break;
                case 3 :
                    // AS3_ex.g3:1803:9: R= RCURLY
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        R=(IToken)Match(input,RCURLY,FOLLOW_RCURLY_in_semic5949); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {R_tree = (object)adaptor.Create(R);
                            adaptor.AddChild(root_0, R_tree);
                        }
                        if ( state.backtracking == 0 ) 
                        {
                           input.Rewind(marker); 
                                              if (onBrace)
                                              {
                                                   retval.Start=input.LT(-1);
                                                   retval.Stop=retval.Start;
                                                   retval.Tree=null;
                                                   return retval;
                                              }
                                           
                        }

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 28, semic_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "semic"

    public class fileContents_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "fileContents"
    // AS3_ex.g3:1817:1: fileContents : ( ( ( packageDeclaration )? ( packageElement )* ) | EOF );
    public AS3_exParser.fileContents_return fileContents() // throws RecognitionException [1]
    {   
        AS3_exParser.fileContents_return retval = new AS3_exParser.fileContents_return();
        retval.Start = input.LT(1);
        int fileContents_StartIndex = input.Index();
        object root_0 = null;

        IToken EOF46 = null;
        AS3_exParser.packageDeclaration_return packageDeclaration44 = null;

        AS3_exParser.packageElement_return packageElement45 = null;


        object EOF46_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 29) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:1818:2: ( ( ( packageDeclaration )? ( packageElement )* ) | EOF )
            int alt31 = 2;
            int LA31_0 = input.LA(1);

            if ( ((LA31_0 >= AS && LA31_0 <= LCURLY) || LA31_0 == LPAREN || LA31_0 == LBRACK || LA31_0 == LT || (LA31_0 >= PLUS && LA31_0 <= STAR) || (LA31_0 >= INC && LA31_0 <= DEC) || (LA31_0 >= NOT && LA31_0 <= INV) || (LA31_0 >= XML_AT && LA31_0 <= XML_LS_STD) || (LA31_0 >= SINGLE_QUOTE_LITERAL && LA31_0 <= DOUBLE_QUOTE_LITERAL) || LA31_0 == REGULAR_EXPR_LITERAL || LA31_0 == HEX_NUMBER_LITERAL || LA31_0 == DEC_NUMBER_LITERAL || LA31_0 == IDENTIFIER || (LA31_0 >= XML_COMMENT && LA31_0 <= XML_PI)) )
            {
                alt31 = 1;
            }
            else if ( (LA31_0 == EOF) )
            {
                int LA31_2 = input.LA(2);

                if ( (LA31_2 == EOF) )
                {
                    alt31 = 2;
                }
                else 
                {
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    NoViableAltException nvae_d31s2 =
                        new NoViableAltException("", 31, 2, input);

                    throw nvae_d31s2;
                }
            }
            else 
            {
                if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                NoViableAltException nvae_d31s0 =
                    new NoViableAltException("", 31, 0, input);

                throw nvae_d31s0;
            }
            switch (alt31) 
            {
                case 1 :
                    // AS3_ex.g3:1818:4: ( ( packageDeclaration )? ( packageElement )* )
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        // AS3_ex.g3:1818:4: ( ( packageDeclaration )? ( packageElement )* )
                        // AS3_ex.g3:1818:5: ( packageDeclaration )? ( packageElement )*
                        {
                            // AS3_ex.g3:1818:5: ( packageDeclaration )?
                            int alt29 = 2;
                            int LA29_0 = input.LA(1);

                            if ( (LA29_0 == PACKAGE) )
                            {
                                int LA29_1 = input.LA(2);

                                if ( (LA29_1 == DEFAULT || LA29_1 == INTERNAL || LA29_1 == NATIVE || LA29_1 == TO || LA29_1 == VOID || (LA29_1 >= EACH && LA29_1 <= NAMESPACE) || (LA29_1 >= DYNAMIC && LA29_1 <= STATIC) || LA29_1 == LCURLY || LA29_1 == STAR || LA29_1 == IDENTIFIER) )
                                {
                                    alt29 = 1;
                                }
                            }
                            switch (alt29) 
                            {
                                case 1 :
                                    // AS3_ex.g3:0:0: packageDeclaration
                                    {
                                        PushFollow(FOLLOW_packageDeclaration_in_fileContents5969);
                                        packageDeclaration44 = packageDeclaration();
                                        state.followingStackPointer--;
                                        if (state.failed) return retval;
                                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, packageDeclaration44.Tree);

                                    }
                                    break;

                            }

                            // AS3_ex.g3:1818:25: ( packageElement )*
                            do 
                            {
                                int alt30 = 2;
                                int LA30_0 = input.LA(1);

                                if ( ((LA30_0 >= AS && LA30_0 <= LCURLY) || LA30_0 == LPAREN || LA30_0 == LBRACK || LA30_0 == LT || (LA30_0 >= PLUS && LA30_0 <= STAR) || (LA30_0 >= INC && LA30_0 <= DEC) || (LA30_0 >= NOT && LA30_0 <= INV) || (LA30_0 >= XML_AT && LA30_0 <= XML_LS_STD) || (LA30_0 >= SINGLE_QUOTE_LITERAL && LA30_0 <= DOUBLE_QUOTE_LITERAL) || LA30_0 == REGULAR_EXPR_LITERAL || LA30_0 == HEX_NUMBER_LITERAL || LA30_0 == DEC_NUMBER_LITERAL || LA30_0 == IDENTIFIER || (LA30_0 >= XML_COMMENT && LA30_0 <= XML_PI)) )
                                {
                                    alt30 = 1;
                                }


                                switch (alt30) 
                                {
                                    case 1 :
                                        // AS3_ex.g3:0:0: packageElement
                                        {
                                            PushFollow(FOLLOW_packageElement_in_fileContents5972);
                                            packageElement45 = packageElement();
                                            state.followingStackPointer--;
                                            if (state.failed) return retval;
                                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, packageElement45.Tree);

                                        }
                                        break;

                                    default:
                                        goto loop30;
                                }
                            } while (true);

                            loop30:
                                ;   // Stops C# compiler whining that label 'loop30' has no statements


                        }


                    }
                    break;
                case 2 :
                    // AS3_ex.g3:1818:44: EOF
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        EOF46=(IToken)Match(input,EOF,FOLLOW_EOF_in_fileContents5978); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {EOF46_tree = (object)adaptor.Create(EOF46);
                            adaptor.AddChild(root_0, EOF46_tree);
                        }

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 29, fileContents_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "fileContents"

    public class packageDeclaration_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "packageDeclaration"
    // AS3_ex.g3:1823:1: packageDeclaration : p= PACKAGE ( type )? l= LCURLY ( packageElement )* r= RCURLY ;
    public AS3_exParser.packageDeclaration_return packageDeclaration() // throws RecognitionException [1]
    {   
        AS3_exParser.packageDeclaration_return retval = new AS3_exParser.packageDeclaration_return();
        retval.Start = input.LT(1);
        int packageDeclaration_StartIndex = input.Index();
        object root_0 = null;

        IToken p = null;
        IToken l = null;
        IToken r = null;
        AS3_exParser.type_return type47 = null;

        AS3_exParser.packageElement_return packageElement48 = null;


        object p_tree=null;
        object l_tree=null;
        object r_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 30) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:1824:2: (p= PACKAGE ( type )? l= LCURLY ( packageElement )* r= RCURLY )
            // AS3_ex.g3:1824:6: p= PACKAGE ( type )? l= LCURLY ( packageElement )* r= RCURLY
            {
                root_0 = (object)adaptor.GetNilNode();

                p=(IToken)Match(input,PACKAGE,FOLLOW_PACKAGE_in_packageDeclaration5995); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {p_tree = (object)adaptor.Create(p);
                    adaptor.AddChild(root_0, p_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  isSeenPackage=true;{insertCR(false);}emit(p);pushExpressionIndent();
                }
                // AS3_ex.g3:1824:88: ( type )?
                int alt32 = 2;
                int LA32_0 = input.LA(1);

                if ( (LA32_0 == DEFAULT || LA32_0 == INTERNAL || LA32_0 == NATIVE || LA32_0 == TO || LA32_0 == VOID || (LA32_0 >= EACH && LA32_0 <= NAMESPACE) || (LA32_0 >= DYNAMIC && LA32_0 <= STATIC) || LA32_0 == STAR || LA32_0 == IDENTIFIER) )
                {
                    alt32 = 1;
                }
                switch (alt32) 
                {
                    case 1 :
                        // AS3_ex.g3:1824:89: type
                        {
                            if ( state.backtracking == 0 ) 
                            {
                              insertWS(1);
                            }
                            PushFollow(FOLLOW_type_in_packageDeclaration6002);
                            type47 = type();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, type47.Tree);

                        }
                        break;

                }

                if ( state.backtracking == 0 ) 
                {
                  popIndent();
                }
                l=(IToken)Match(input,LCURLY,FOLLOW_LCURLY_in_packageDeclaration6016); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {l_tree = (object)adaptor.Create(l);
                    adaptor.AddChild(root_0, l_tree);
                }
                if ( state.backtracking == 0 ) 
                {

                           mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_package_code);
                           leftCurlyNewlineHandler(false);
                           emit(l);
                           {mPrinter.addDeclEqualsBlock();}
                           if (mPrinter.isIndentAtPackageLevel())
                              pushIndent(true);
                           mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_block_code);
                        
                }
                // AS3_ex.g3:1835:6: ( packageElement )*
                do 
                {
                    int alt33 = 2;
                    int LA33_0 = input.LA(1);

                    if ( ((LA33_0 >= AS && LA33_0 <= LCURLY) || LA33_0 == LPAREN || LA33_0 == LBRACK || LA33_0 == LT || (LA33_0 >= PLUS && LA33_0 <= STAR) || (LA33_0 >= INC && LA33_0 <= DEC) || (LA33_0 >= NOT && LA33_0 <= INV) || (LA33_0 >= XML_AT && LA33_0 <= XML_LS_STD) || (LA33_0 >= SINGLE_QUOTE_LITERAL && LA33_0 <= DOUBLE_QUOTE_LITERAL) || LA33_0 == REGULAR_EXPR_LITERAL || LA33_0 == HEX_NUMBER_LITERAL || LA33_0 == DEC_NUMBER_LITERAL || LA33_0 == IDENTIFIER || (LA33_0 >= XML_COMMENT && LA33_0 <= XML_PI)) )
                    {
                        alt33 = 1;
                    }


                    switch (alt33) 
                    {
                        case 1 :
                            // AS3_ex.g3:0:0: packageElement
                            {
                                PushFollow(FOLLOW_packageElement_in_packageDeclaration6032);
                                packageElement48 = packageElement();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, packageElement48.Tree);

                            }
                            break;

                        default:
                            goto loop33;
                    }
                } while (true);

                loop33:
                    ;   // Stops C# compiler whining that label 'loop33' has no statements

                if ( state.backtracking == 0 ) 
                {

                            if (mPrinter.isIndentAtPackageLevel())
                                popIndent();
                        
                }
                if ( state.backtracking == 0 ) 
                {
                  mPrinter.popDeclEqualsBlock();
                }
                r=(IToken)Match(input,RCURLY,FOLLOW_RCURLY_in_packageDeclaration6058); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {r_tree = (object)adaptor.Create(r);
                    adaptor.AddChild(root_0, r_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  insertCR(false);emit(r);popBlockStack();popBlockStack();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 30, packageDeclaration_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "packageDeclaration"

    public class mxmlEmbedded_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "mxmlEmbedded"
    // AS3_ex.g3:1847:1: mxmlEmbedded : ( conditionalCompilerOption l= LCURLY mxmlEmbedded r= RCURLY | propertyDeclaration | functionDeclaration | statement | directive | interfaceFunctionDeclaration )* ( EOF )? ;
    public AS3_exParser.mxmlEmbedded_return mxmlEmbedded() // throws RecognitionException [1]
    {   
        AS3_exParser.mxmlEmbedded_return retval = new AS3_exParser.mxmlEmbedded_return();
        retval.Start = input.LT(1);
        int mxmlEmbedded_StartIndex = input.Index();
        object root_0 = null;

        IToken l = null;
        IToken r = null;
        IToken EOF56 = null;
        AS3_exParser.conditionalCompilerOption_return conditionalCompilerOption49 = null;

        AS3_exParser.mxmlEmbedded_return mxmlEmbedded50 = null;

        AS3_exParser.propertyDeclaration_return propertyDeclaration51 = null;

        AS3_exParser.functionDeclaration_return functionDeclaration52 = null;

        AS3_exParser.statement_return statement53 = null;

        AS3_exParser.directive_return directive54 = null;

        AS3_exParser.interfaceFunctionDeclaration_return interfaceFunctionDeclaration55 = null;


        object l_tree=null;
        object r_tree=null;
        object EOF56_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 31) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:1848:2: ( ( conditionalCompilerOption l= LCURLY mxmlEmbedded r= RCURLY | propertyDeclaration | functionDeclaration | statement | directive | interfaceFunctionDeclaration )* ( EOF )? )
            // AS3_ex.g3:1849:3: ( conditionalCompilerOption l= LCURLY mxmlEmbedded r= RCURLY | propertyDeclaration | functionDeclaration | statement | directive | interfaceFunctionDeclaration )* ( EOF )?
            {
                root_0 = (object)adaptor.GetNilNode();

                // AS3_ex.g3:1849:3: ( conditionalCompilerOption l= LCURLY mxmlEmbedded r= RCURLY | propertyDeclaration | functionDeclaration | statement | directive | interfaceFunctionDeclaration )*
                do 
                {
                    int alt34 = 7;
                    alt34 = dfa34.Predict(input);
                    switch (alt34) 
                    {
                        case 1 :
                            // AS3_ex.g3:1849:4: conditionalCompilerOption l= LCURLY mxmlEmbedded r= RCURLY
                            {
                                if ( state.backtracking == 0 ) 
                                {
                                  insertCR(false);
                                }
                                PushFollow(FOLLOW_conditionalCompilerOption_in_mxmlEmbedded6082);
                                conditionalCompilerOption49 = conditionalCompilerOption();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, conditionalCompilerOption49.Tree);
                                l=(IToken)Match(input,LCURLY,FOLLOW_LCURLY_in_mxmlEmbedded6090); if (state.failed) return retval;
                                if ( state.backtracking == 0 )
                                {l_tree = (object)adaptor.Create(l);
                                    adaptor.AddChild(root_0, l_tree);
                                }
                                if ( state.backtracking == 0 ) 
                                {
                                   
                                                mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_Conditional_code);
                                                leftCurlyNewlineHandler(false);
                                                emit(l);pushIndent(true);
                                                mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_block_code);
                                            
                                }
                                PushFollow(FOLLOW_mxmlEmbedded_in_mxmlEmbedded6100);
                                mxmlEmbedded50 = mxmlEmbedded();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, mxmlEmbedded50.Tree);
                                if ( state.backtracking == 0 ) 
                                {
                                  popIndent();
                                }
                                r=(IToken)Match(input,RCURLY,FOLLOW_RCURLY_in_mxmlEmbedded6109); if (state.failed) return retval;
                                if ( state.backtracking == 0 )
                                {r_tree = (object)adaptor.Create(r);
                                    adaptor.AddChild(root_0, r_tree);
                                }
                                if ( state.backtracking == 0 ) 
                                {
                                  insertCR(false);emit(r);popBlockStack();popBlockStack();
                                }

                            }
                            break;
                        case 2 :
                            // AS3_ex.g3:1859:9: propertyDeclaration
                            {
                                PushFollow(FOLLOW_propertyDeclaration_in_mxmlEmbedded6122);
                                propertyDeclaration51 = propertyDeclaration();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, propertyDeclaration51.Tree);

                            }
                            break;
                        case 3 :
                            // AS3_ex.g3:1859:31: functionDeclaration
                            {
                                PushFollow(FOLLOW_functionDeclaration_in_mxmlEmbedded6126);
                                functionDeclaration52 = functionDeclaration();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, functionDeclaration52.Tree);

                            }
                            break;
                        case 4 :
                            // AS3_ex.g3:1859:53: statement
                            {
                                PushFollow(FOLLOW_statement_in_mxmlEmbedded6130);
                                statement53 = statement();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, statement53.Tree);

                            }
                            break;
                        case 5 :
                            // AS3_ex.g3:1859:65: directive
                            {
                                PushFollow(FOLLOW_directive_in_mxmlEmbedded6134);
                                directive54 = directive();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, directive54.Tree);

                            }
                            break;
                        case 6 :
                            // AS3_ex.g3:1859:77: interfaceFunctionDeclaration
                            {
                                PushFollow(FOLLOW_interfaceFunctionDeclaration_in_mxmlEmbedded6138);
                                interfaceFunctionDeclaration55 = interfaceFunctionDeclaration();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, interfaceFunctionDeclaration55.Tree);

                            }
                            break;

                        default:
                            goto loop34;
                    }
                } while (true);

                loop34:
                    ;   // Stops C# compiler whining that label 'loop34' has no statements

                // AS3_ex.g3:1861:6: ( EOF )?
                int alt35 = 2;
                int LA35_0 = input.LA(1);

                if ( (LA35_0 == EOF) )
                {
                    alt35 = 1;
                }
                switch (alt35) 
                {
                    case 1 :
                        // AS3_ex.g3:0:0: EOF
                        {
                            EOF56=(IToken)Match(input,EOF,FOLLOW_EOF_in_mxmlEmbedded6155); if (state.failed) return retval;
                            if ( state.backtracking == 0 )
                            {EOF56_tree = (object)adaptor.Create(EOF56);
                                adaptor.AddChild(root_0, EOF56_tree);
                            }

                        }
                        break;

                }


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 31, mxmlEmbedded_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "mxmlEmbedded"

    public class packageElement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "packageElement"
    // AS3_ex.g3:1864:1: packageElement : ( conditionalCompilerOption l= LCURLY ( packageElement )* r= RCURLY | classOrInterfaceDecl | propertyDeclaration | functionDeclaration | interfaceFunctionDeclaration | statement | directive );
    public AS3_exParser.packageElement_return packageElement() // throws RecognitionException [1]
    {   
        AS3_exParser.packageElement_return retval = new AS3_exParser.packageElement_return();
        retval.Start = input.LT(1);
        int packageElement_StartIndex = input.Index();
        object root_0 = null;

        IToken l = null;
        IToken r = null;
        AS3_exParser.conditionalCompilerOption_return conditionalCompilerOption57 = null;

        AS3_exParser.packageElement_return packageElement58 = null;

        AS3_exParser.classOrInterfaceDecl_return classOrInterfaceDecl59 = null;

        AS3_exParser.propertyDeclaration_return propertyDeclaration60 = null;

        AS3_exParser.functionDeclaration_return functionDeclaration61 = null;

        AS3_exParser.interfaceFunctionDeclaration_return interfaceFunctionDeclaration62 = null;

        AS3_exParser.statement_return statement63 = null;

        AS3_exParser.directive_return directive64 = null;


        object l_tree=null;
        object r_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 32) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:1865:5: ( conditionalCompilerOption l= LCURLY ( packageElement )* r= RCURLY | classOrInterfaceDecl | propertyDeclaration | functionDeclaration | interfaceFunctionDeclaration | statement | directive )
            int alt37 = 7;
            alt37 = dfa37.Predict(input);
            switch (alt37) 
            {
                case 1 :
                    // AS3_ex.g3:1866:6: conditionalCompilerOption l= LCURLY ( packageElement )* r= RCURLY
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        if ( state.backtracking == 0 ) 
                        {
                          insertCR(false);
                        }
                        PushFollow(FOLLOW_conditionalCompilerOption_in_packageElement6181);
                        conditionalCompilerOption57 = conditionalCompilerOption();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, conditionalCompilerOption57.Tree);
                        l=(IToken)Match(input,LCURLY,FOLLOW_LCURLY_in_packageElement6189); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {l_tree = (object)adaptor.Create(l);
                            adaptor.AddChild(root_0, l_tree);
                        }
                        if ( state.backtracking == 0 ) 
                        {
                           
                                        mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_Conditional_code);
                                        leftCurlyNewlineHandler(false);
                                        emit(l);pushIndent(true);
                                        {mPrinter.addDeclEqualsBlock();}
                                        mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_block_code);
                                    
                        }
                        // AS3_ex.g3:1875:4: ( packageElement )*
                        do 
                        {
                            int alt36 = 2;
                            int LA36_0 = input.LA(1);

                            if ( ((LA36_0 >= AS && LA36_0 <= LCURLY) || LA36_0 == LPAREN || LA36_0 == LBRACK || LA36_0 == LT || (LA36_0 >= PLUS && LA36_0 <= STAR) || (LA36_0 >= INC && LA36_0 <= DEC) || (LA36_0 >= NOT && LA36_0 <= INV) || (LA36_0 >= XML_AT && LA36_0 <= XML_LS_STD) || (LA36_0 >= SINGLE_QUOTE_LITERAL && LA36_0 <= DOUBLE_QUOTE_LITERAL) || LA36_0 == REGULAR_EXPR_LITERAL || LA36_0 == HEX_NUMBER_LITERAL || LA36_0 == DEC_NUMBER_LITERAL || LA36_0 == IDENTIFIER || (LA36_0 >= XML_COMMENT && LA36_0 <= XML_PI)) )
                            {
                                alt36 = 1;
                            }


                            switch (alt36) 
                            {
                                case 1 :
                                    // AS3_ex.g3:0:0: packageElement
                                    {
                                        PushFollow(FOLLOW_packageElement_in_packageElement6199);
                                        packageElement58 = packageElement();
                                        state.followingStackPointer--;
                                        if (state.failed) return retval;
                                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, packageElement58.Tree);

                                    }
                                    break;

                                default:
                                    goto loop36;
                            }
                        } while (true);

                        loop36:
                            ;   // Stops C# compiler whining that label 'loop36' has no statements

                        if ( state.backtracking == 0 ) 
                        {
                          mPrinter.popDeclEqualsBlock();
                        }
                        if ( state.backtracking == 0 ) 
                        {
                          popIndent();
                        }
                        r=(IToken)Match(input,RCURLY,FOLLOW_RCURLY_in_packageElement6214); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {r_tree = (object)adaptor.Create(r);
                            adaptor.AddChild(root_0, r_tree);
                        }
                        if ( state.backtracking == 0 ) 
                        {
                          insertCR(false);emit(r);popBlockStack();popBlockStack();
                        }

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:1878:8: classOrInterfaceDecl
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_classOrInterfaceDecl_in_packageElement6229);
                        classOrInterfaceDecl59 = classOrInterfaceDecl();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, classOrInterfaceDecl59.Tree);

                    }
                    break;
                case 3 :
                    // AS3_ex.g3:1878:31: propertyDeclaration
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_propertyDeclaration_in_packageElement6233);
                        propertyDeclaration60 = propertyDeclaration();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, propertyDeclaration60.Tree);

                    }
                    break;
                case 4 :
                    // AS3_ex.g3:1878:53: functionDeclaration
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_functionDeclaration_in_packageElement6237);
                        functionDeclaration61 = functionDeclaration();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, functionDeclaration61.Tree);

                    }
                    break;
                case 5 :
                    // AS3_ex.g3:1878:75: interfaceFunctionDeclaration
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_interfaceFunctionDeclaration_in_packageElement6241);
                        interfaceFunctionDeclaration62 = interfaceFunctionDeclaration();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, interfaceFunctionDeclaration62.Tree);

                    }
                    break;
                case 6 :
                    // AS3_ex.g3:1878:106: statement
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_statement_in_packageElement6245);
                        statement63 = statement();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, statement63.Tree);

                    }
                    break;
                case 7 :
                    // AS3_ex.g3:1878:118: directive
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_directive_in_packageElement6249);
                        directive64 = directive();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, directive64.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 32, packageElement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "packageElement"

    public class importDeclaration_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "importDeclaration"
    // AS3_ex.g3:1881:1: importDeclaration : i= IMPORT type (D= DOT S= STAR )? semic ;
    public AS3_exParser.importDeclaration_return importDeclaration() // throws RecognitionException [1]
    {   
        AS3_exParser.importDeclaration_return retval = new AS3_exParser.importDeclaration_return();
        retval.Start = input.LT(1);
        int importDeclaration_StartIndex = input.Index();
        object root_0 = null;

        IToken i = null;
        IToken D = null;
        IToken S = null;
        AS3_exParser.type_return type65 = null;

        AS3_exParser.semic_return semic66 = null;


        object i_tree=null;
        object D_tree=null;
        object S_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 33) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:1882:2: (i= IMPORT type (D= DOT S= STAR )? semic )
            // AS3_ex.g3:1883:2: i= IMPORT type (D= DOT S= STAR )? semic
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  mPrinter.markDeclEqualsContextChange();
                }
                if ( state.backtracking == 0 ) 
                {
                  insertCR(false);addBlankLinesBeforeFirstImport();
                }
                i=(IToken)Match(input,IMPORT,FOLLOW_IMPORT_in_importDeclaration6274); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {i_tree = (object)adaptor.Create(i);
                    adaptor.AddChild(root_0, i_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(i);
                }
                PushFollow(FOLLOW_type_in_importDeclaration6278);
                type65 = type();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, type65.Tree);
                // AS3_ex.g3:1884:80: (D= DOT S= STAR )?
                int alt38 = 2;
                int LA38_0 = input.LA(1);

                if ( (LA38_0 == DOT) )
                {
                    alt38 = 1;
                }
                switch (alt38) 
                {
                    case 1 :
                        // AS3_ex.g3:1884:81: D= DOT S= STAR
                        {
                            D=(IToken)Match(input,DOT,FOLLOW_DOT_in_importDeclaration6283); if (state.failed) return retval;
                            if ( state.backtracking == 0 )
                            {D_tree = (object)adaptor.Create(D);
                                adaptor.AddChild(root_0, D_tree);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              emit(D);
                            }
                            S=(IToken)Match(input,STAR,FOLLOW_STAR_in_importDeclaration6289); if (state.failed) return retval;
                            if ( state.backtracking == 0 )
                            {S_tree = (object)adaptor.Create(S);
                                adaptor.AddChild(root_0, S_tree);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              emit(S);
                            }

                        }
                        break;

                }

                PushFollow(FOLLOW_semic_in_importDeclaration6295);
                semic66 = semic();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, semic66.Tree);

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 33, importDeclaration_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "importDeclaration"

    public class classOrInterfaceDecl_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "classOrInterfaceDecl"
    // AS3_ex.g3:1887:1: classOrInterfaceDecl : ( conditionalDirAndBindingDecls )? ( memberModifiers )? ( interfaceDeclaration | classDeclaration ) ;
    public AS3_exParser.classOrInterfaceDecl_return classOrInterfaceDecl() // throws RecognitionException [1]
    {   
        AS3_exParser.classOrInterfaceDecl_return retval = new AS3_exParser.classOrInterfaceDecl_return();
        retval.Start = input.LT(1);
        int classOrInterfaceDecl_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.conditionalDirAndBindingDecls_return conditionalDirAndBindingDecls67 = null;

        AS3_exParser.memberModifiers_return memberModifiers68 = null;

        AS3_exParser.interfaceDeclaration_return interfaceDeclaration69 = null;

        AS3_exParser.classDeclaration_return classDeclaration70 = null;



        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 34) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:1888:2: ( ( conditionalDirAndBindingDecls )? ( memberModifiers )? ( interfaceDeclaration | classDeclaration ) )
            // AS3_ex.g3:1888:6: ( conditionalDirAndBindingDecls )? ( memberModifiers )? ( interfaceDeclaration | classDeclaration )
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  mPrinter.setBindingContext(ASPrettyPrinter.BindingContext_Class);
                }
                // AS3_ex.g3:1888:74: ( conditionalDirAndBindingDecls )?
                int alt39 = 2;
                switch ( input.LA(1) ) 
                {
                    case IDENTIFIER:
                        {
                        int LA39_1 = input.LA(2);

                        if ( (LA39_1 == XML_NS_OP) )
                        {
                            alt39 = 1;
                        }
                        }
                        break;
                    case NATIVE:
                    case DYNAMIC:
                    case FINAL:
                    case OVERRIDE:
                    case STATIC:
                        {
                        int LA39_2 = input.LA(2);

                        if ( (LA39_2 == XML_NS_OP) )
                        {
                            alt39 = 1;
                        }
                        }
                        break;
                    case TO:
                    case EACH:
                    case GET:
                    case SET:
                    case NAMESPACE:
                        {
                        alt39 = 1;
                        }
                        break;
                }

                switch (alt39) 
                {
                    case 1 :
                        // AS3_ex.g3:1888:75: conditionalDirAndBindingDecls
                        {
                            PushFollow(FOLLOW_conditionalDirAndBindingDecls_in_classOrInterfaceDecl6312);
                            conditionalDirAndBindingDecls67 = conditionalDirAndBindingDecls();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, conditionalDirAndBindingDecls67.Tree);

                        }
                        break;

                }

                if ( state.backtracking == 0 ) 
                {
                  pushLazyIndent();
                }
                if ( state.backtracking == 0 ) 
                {
                  insertCR(false);
                }
                if ( state.backtracking == 0 ) 
                {
                  insertLines(mPrinter.getBlankLinesBeforeClass(), false);isFirstClassSeen=true;
                }
                // AS3_ex.g3:1888:225: ( memberModifiers )?
                int alt40 = 2;
                int LA40_0 = input.LA(1);

                if ( (LA40_0 == INTERNAL || LA40_0 == NATIVE || (LA40_0 >= PRIVATE && LA40_0 <= PUBLIC) || (LA40_0 >= DYNAMIC && LA40_0 <= STATIC) || LA40_0 == IDENTIFIER) )
                {
                    alt40 = 1;
                }
                switch (alt40) 
                {
                    case 1 :
                        // AS3_ex.g3:0:0: memberModifiers
                        {
                            PushFollow(FOLLOW_memberModifiers_in_classOrInterfaceDecl6320);
                            memberModifiers68 = memberModifiers();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, memberModifiers68.Tree);

                        }
                        break;

                }

                // AS3_ex.g3:1888:242: ( interfaceDeclaration | classDeclaration )
                int alt41 = 2;
                int LA41_0 = input.LA(1);

                if ( (LA41_0 == INTERFACE) )
                {
                    alt41 = 1;
                }
                else if ( (LA41_0 == CLASS) )
                {
                    alt41 = 2;
                }
                else 
                {
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    NoViableAltException nvae_d41s0 =
                        new NoViableAltException("", 41, 0, input);

                    throw nvae_d41s0;
                }
                switch (alt41) 
                {
                    case 1 :
                        // AS3_ex.g3:1888:243: interfaceDeclaration
                        {
                            PushFollow(FOLLOW_interfaceDeclaration_in_classOrInterfaceDecl6324);
                            interfaceDeclaration69 = interfaceDeclaration();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, interfaceDeclaration69.Tree);

                        }
                        break;
                    case 2 :
                        // AS3_ex.g3:1888:266: classDeclaration
                        {
                            PushFollow(FOLLOW_classDeclaration_in_classOrInterfaceDecl6328);
                            classDeclaration70 = classDeclaration();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, classDeclaration70.Tree);

                        }
                        break;

                }


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 34, classOrInterfaceDecl_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "classOrInterfaceDecl"

    public class directive_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "directive"
    // AS3_ex.g3:1891:1: directive : ( bindingDecl | includeDirective | useNamespaceDirective | importDeclaration | defaultXMLNamespaceDirective ) ;
    public AS3_exParser.directive_return directive() // throws RecognitionException [1]
    {   
        AS3_exParser.directive_return retval = new AS3_exParser.directive_return();
        retval.Start = input.LT(1);
        int directive_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.bindingDecl_return bindingDecl71 = null;

        AS3_exParser.includeDirective_return includeDirective72 = null;

        AS3_exParser.useNamespaceDirective_return useNamespaceDirective73 = null;

        AS3_exParser.importDeclaration_return importDeclaration74 = null;

        AS3_exParser.defaultXMLNamespaceDirective_return defaultXMLNamespaceDirective75 = null;



        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 35) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:1892:2: ( ( bindingDecl | includeDirective | useNamespaceDirective | importDeclaration | defaultXMLNamespaceDirective ) )
            // AS3_ex.g3:1893:2: ( bindingDecl | includeDirective | useNamespaceDirective | importDeclaration | defaultXMLNamespaceDirective )
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  pushLazyIndent();
                }
                if ( state.backtracking == 0 ) 
                {
                  insertCR(false);
                }
                // AS3_ex.g3:1893:39: ( bindingDecl | includeDirective | useNamespaceDirective | importDeclaration | defaultXMLNamespaceDirective )
                int alt42 = 5;
                switch ( input.LA(1) ) 
                {
                case LBRACK:
                    {
                    alt42 = 1;
                    }
                    break;
                case INCLUDE:
                    {
                    alt42 = 2;
                    }
                    break;
                case USE:
                    {
                    alt42 = 3;
                    }
                    break;
                case IMPORT:
                    {
                    alt42 = 4;
                    }
                    break;
                case DEFAULT:
                    {
                    alt42 = 5;
                    }
                    break;
                    default:
                        if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                        NoViableAltException nvae_d42s0 =
                            new NoViableAltException("", 42, 0, input);

                        throw nvae_d42s0;
                }

                switch (alt42) 
                {
                    case 1 :
                        // AS3_ex.g3:1893:40: bindingDecl
                        {
                            PushFollow(FOLLOW_bindingDecl_in_directive6345);
                            bindingDecl71 = bindingDecl();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, bindingDecl71.Tree);

                        }
                        break;
                    case 2 :
                        // AS3_ex.g3:1893:54: includeDirective
                        {
                            PushFollow(FOLLOW_includeDirective_in_directive6349);
                            includeDirective72 = includeDirective();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, includeDirective72.Tree);

                        }
                        break;
                    case 3 :
                        // AS3_ex.g3:1893:73: useNamespaceDirective
                        {
                            PushFollow(FOLLOW_useNamespaceDirective_in_directive6353);
                            useNamespaceDirective73 = useNamespaceDirective();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, useNamespaceDirective73.Tree);

                        }
                        break;
                    case 4 :
                        // AS3_ex.g3:1893:97: importDeclaration
                        {
                            PushFollow(FOLLOW_importDeclaration_in_directive6357);
                            importDeclaration74 = importDeclaration();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, importDeclaration74.Tree);

                        }
                        break;
                    case 5 :
                        // AS3_ex.g3:1893:142: defaultXMLNamespaceDirective
                        {
                            PushFollow(FOLLOW_defaultXMLNamespaceDirective_in_directive6363);
                            defaultXMLNamespaceDirective75 = defaultXMLNamespaceDirective();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, defaultXMLNamespaceDirective75.Tree);

                        }
                        break;

                }

                if ( state.backtracking == 0 ) 
                {
                  popIndent();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 35, directive_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "directive"

    public class conditionalDirAndBindingDecls_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "conditionalDirAndBindingDecls"
    // AS3_ex.g3:1896:1: conditionalDirAndBindingDecls : conditionalCompilerOption ( bindingDecl )* ;
    public AS3_exParser.conditionalDirAndBindingDecls_return conditionalDirAndBindingDecls() // throws RecognitionException [1]
    {   
        AS3_exParser.conditionalDirAndBindingDecls_return retval = new AS3_exParser.conditionalDirAndBindingDecls_return();
        retval.Start = input.LT(1);
        int conditionalDirAndBindingDecls_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.conditionalCompilerOption_return conditionalCompilerOption76 = null;

        AS3_exParser.bindingDecl_return bindingDecl77 = null;



        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 36) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:1897:2: ( conditionalCompilerOption ( bindingDecl )* )
            // AS3_ex.g3:1897:4: conditionalCompilerOption ( bindingDecl )*
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  insertCR(false);
                }
                if ( state.backtracking == 0 ) 
                {
                  mPrinter.markBindablePos(true);
                }
                PushFollow(FOLLOW_conditionalCompilerOption_in_conditionalDirAndBindingDecls6389);
                conditionalCompilerOption76 = conditionalCompilerOption();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, conditionalCompilerOption76.Tree);
                if ( state.backtracking == 0 ) 
                {
                  mPrinter.setBindableMode();
                }
                // AS3_ex.g3:1901:4: ( bindingDecl )*
                do 
                {
                    int alt43 = 2;
                    int LA43_0 = input.LA(1);

                    if ( (LA43_0 == LBRACK) )
                    {
                        alt43 = 1;
                    }


                    switch (alt43) 
                    {
                        case 1 :
                            // AS3_ex.g3:1901:5: bindingDecl
                            {
                                if ( state.backtracking == 0 ) 
                                {
                                  insertCR(false);
                                }
                                PushFollow(FOLLOW_bindingDecl_in_conditionalDirAndBindingDecls6406);
                                bindingDecl77 = bindingDecl();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, bindingDecl77.Tree);

                            }
                            break;

                        default:
                            goto loop43;
                    }
                } while (true);

                loop43:
                    ;   // Stops C# compiler whining that label 'loop43' has no statements


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 36, conditionalDirAndBindingDecls_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "conditionalDirAndBindingDecls"

    public class xmlKeyword_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "xmlKeyword"
    // AS3_ex.g3:1904:1: xmlKeyword : {...}?I= IDENTIFIER ;
    public AS3_exParser.xmlKeyword_return xmlKeyword() // throws RecognitionException [1]
    {   
        AS3_exParser.xmlKeyword_return retval = new AS3_exParser.xmlKeyword_return();
        retval.Start = input.LT(1);
        int xmlKeyword_StartIndex = input.Index();
        object root_0 = null;

        IToken I = null;

        object I_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 37) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:1905:2: ({...}?I= IDENTIFIER )
            // AS3_ex.g3:1905:4: {...}?I= IDENTIFIER
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( !((input.LT(1).Text.ToLower() == "xml")) ) 
                {
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    throw new FailedPredicateException(input, "xmlKeyword", "input.LT(1).Text.ToLower() == \"xml\"");
                }
                I=(IToken)Match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_xmlKeyword6424); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {I_tree = (object)adaptor.Create(I);
                    adaptor.AddChild(root_0, I_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(I);
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 37, xmlKeyword_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "xmlKeyword"

    public class conditionalCompilerOption_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "conditionalCompilerOption"
    // AS3_ex.g3:1908:1: conditionalCompilerOption : identifierLiteral x= XML_NS_OP identifierLiteral ;
    public AS3_exParser.conditionalCompilerOption_return conditionalCompilerOption() // throws RecognitionException [1]
    {   
        AS3_exParser.conditionalCompilerOption_return retval = new AS3_exParser.conditionalCompilerOption_return();
        retval.Start = input.LT(1);
        int conditionalCompilerOption_StartIndex = input.Index();
        object root_0 = null;

        IToken x = null;
        AS3_exParser.identifierLiteral_return identifierLiteral78 = null;

        AS3_exParser.identifierLiteral_return identifierLiteral79 = null;


        object x_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 38) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:1909:2: ( identifierLiteral x= XML_NS_OP identifierLiteral )
            // AS3_ex.g3:1910:2: identifierLiteral x= XML_NS_OP identifierLiteral
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_identifierLiteral_in_conditionalCompilerOption6440);
                identifierLiteral78 = identifierLiteral();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, identifierLiteral78.Tree);
                x=(IToken)Match(input,XML_NS_OP,FOLLOW_XML_NS_OP_in_conditionalCompilerOption6444); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {x_tree = (object)adaptor.Create(x);
                    adaptor.AddChild(root_0, x_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(x);
                }
                PushFollow(FOLLOW_identifierLiteral_in_conditionalCompilerOption6448);
                identifierLiteral79 = identifierLiteral();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, identifierLiteral79.Tree);

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 38, conditionalCompilerOption_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "conditionalCompilerOption"

    public class defaultXMLNamespaceDirective_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "defaultXMLNamespaceDirective"
    // AS3_ex.g3:1913:1: defaultXMLNamespaceDirective : D= DEFAULT xmlKeyword N= NAMESPACE A= ASSIGN assignmentExpression semic ;
    public AS3_exParser.defaultXMLNamespaceDirective_return defaultXMLNamespaceDirective() // throws RecognitionException [1]
    {   
        AS3_exParser.defaultXMLNamespaceDirective_return retval = new AS3_exParser.defaultXMLNamespaceDirective_return();
        retval.Start = input.LT(1);
        int defaultXMLNamespaceDirective_StartIndex = input.Index();
        object root_0 = null;

        IToken D = null;
        IToken N = null;
        IToken A = null;
        AS3_exParser.xmlKeyword_return xmlKeyword80 = null;

        AS3_exParser.assignmentExpression_return assignmentExpression81 = null;

        AS3_exParser.semic_return semic82 = null;


        object D_tree=null;
        object N_tree=null;
        object A_tree=null;


            bool pushedFormat=false;
            WrapOptions options=mPrinter.getExpressionWrapOptions();

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 39) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:1919:2: (D= DEFAULT xmlKeyword N= NAMESPACE A= ASSIGN assignmentExpression semic )
            // AS3_ex.g3:1920:2: D= DEFAULT xmlKeyword N= NAMESPACE A= ASSIGN assignmentExpression semic
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  mPrinter.markDeclEqualsContextChange();
                }
                if ( state.backtracking == 0 ) 
                {
                  pushedFormat=pushFormatType(options, true);
                }
                D=(IToken)Match(input,DEFAULT,FOLLOW_DEFAULT_in_defaultXMLNamespaceDirective6475); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {D_tree = (object)adaptor.Create(D);
                    adaptor.AddChild(root_0, D_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(D);
                }
                PushFollow(FOLLOW_xmlKeyword_in_defaultXMLNamespaceDirective6479);
                xmlKeyword80 = xmlKeyword();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlKeyword80.Tree);
                N=(IToken)Match(input,NAMESPACE,FOLLOW_NAMESPACE_in_defaultXMLNamespaceDirective6487); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {N_tree = (object)adaptor.Create(N);
                    adaptor.AddChild(root_0, N_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(N);
                }
                A=(IToken)Match(input,ASSIGN,FOLLOW_ASSIGN_in_defaultXMLNamespaceDirective6495); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {A_tree = (object)adaptor.Create(A);
                    adaptor.AddChild(root_0, A_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  insertWS(mPrinter.getSpacesAroundAssignment());emit(A);insertWS(mPrinter.getSpacesAroundAssignment());
                }
                PushFollow(FOLLOW_assignmentExpression_in_defaultXMLNamespaceDirective6499);
                assignmentExpression81 = assignmentExpression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, assignmentExpression81.Tree);
                PushFollow(FOLLOW_semic_in_defaultXMLNamespaceDirective6501);
                semic82 = semic();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, semic82.Tree);
                if ( state.backtracking == 0 ) 
                {

                            if (pushedFormat)
                            {
                                mPrinter.popFormatMode();
                            }
                    
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 39, defaultXMLNamespaceDirective_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "defaultXMLNamespaceDirective"

    public class bindingDecl_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "bindingDecl"
    // AS3_ex.g3:1934:1: bindingDecl : L= LBRACK (XA= XML_AT )? I= IDENTIFIER (L= LPAREN ( bindingDeclArg (C= COMMA bindingDeclArg )* )? R= RPAREN )? R= RBRACK (s= SEMI )? ;
    public AS3_exParser.bindingDecl_return bindingDecl() // throws RecognitionException [1]
    {   
        AS3_exParser.bindingDecl_return retval = new AS3_exParser.bindingDecl_return();
        retval.Start = input.LT(1);
        int bindingDecl_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        IToken XA = null;
        IToken I = null;
        IToken C = null;
        IToken R = null;
        IToken s = null;
        AS3_exParser.bindingDeclArg_return bindingDeclArg83 = null;

        AS3_exParser.bindingDeclArg_return bindingDeclArg84 = null;


        object L_tree=null;
        object XA_tree=null;
        object I_tree=null;
        object C_tree=null;
        object R_tree=null;
        object s_tree=null;

        bool bindable=false;
         bool pushedIndent=false;
            bool pushedFormat=false;
            bool pushedWrapInfo=false;
         WrapOptions options=mPrinter.getExpressionWrapOptions();

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 40) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:1942:2: (L= LBRACK (XA= XML_AT )? I= IDENTIFIER (L= LPAREN ( bindingDeclArg (C= COMMA bindingDeclArg )* )? R= RPAREN )? R= RBRACK (s= SEMI )? )
            // AS3_ex.g3:1943:6: L= LBRACK (XA= XML_AT )? I= IDENTIFIER (L= LPAREN ( bindingDeclArg (C= COMMA bindingDeclArg )* )? R= RPAREN )? R= RBRACK (s= SEMI )?
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  pushedFormat=pushFormatType(options, true);
                         pushedWrapInfo=pushWrapInfo(options, true);
                        
                }
                L=(IToken)Match(input,LBRACK,FOLLOW_LBRACK_in_bindingDecl6536); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {L_tree = (object)adaptor.Create(L);
                    adaptor.AddChild(root_0, L_tree);
                }
                // AS3_ex.g3:1947:5: (XA= XML_AT )?
                int alt44 = 2;
                int LA44_0 = input.LA(1);

                if ( (LA44_0 == XML_AT) )
                {
                    alt44 = 1;
                }
                switch (alt44) 
                {
                    case 1 :
                        // AS3_ex.g3:1947:6: XA= XML_AT
                        {
                            XA=(IToken)Match(input,XML_AT,FOLLOW_XML_AT_in_bindingDecl6547); if (state.failed) return retval;
                            if ( state.backtracking == 0 )
                            {XA_tree = (object)adaptor.Create(XA);
                                adaptor.AddChild(root_0, XA_tree);
                            }

                        }
                        break;

                }

                I=(IToken)Match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_bindingDecl6553); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {I_tree = (object)adaptor.Create(I);
                    adaptor.AddChild(root_0, I_tree);
                }
                if ( state.backtracking == 0 ) 
                {

                                bindable=mPrinter.isDirectiveForNextElement(I.Text);
                                if (bindable)
                                    mPrinter.markBindablePos(false); //call this to mark position *before* we send any of the tokens to the printer
                                emit(L); 
                }
                if ( state.backtracking == 0 ) 
                {
                  if (XA!=null)
                                    emit(XA); 
                                emit(I);
                                mPrinter.setLastBindableTagName(I.Text);
                            
                }
                // AS3_ex.g3:1958:3: (L= LPAREN ( bindingDeclArg (C= COMMA bindingDeclArg )* )? R= RPAREN )?
                int alt47 = 2;
                int LA47_0 = input.LA(1);

                if ( (LA47_0 == LPAREN) )
                {
                    alt47 = 1;
                }
                switch (alt47) 
                {
                    case 1 :
                        // AS3_ex.g3:1958:4: L= LPAREN ( bindingDeclArg (C= COMMA bindingDeclArg )* )? R= RPAREN
                        {
                            L=(IToken)Match(input,LPAREN,FOLLOW_LPAREN_in_bindingDecl6577); if (state.failed) return retval;
                            if ( state.backtracking == 0 )
                            {L_tree = (object)adaptor.Create(L);
                                adaptor.AddChild(root_0, L_tree);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              emit(L);insertWS(mPrinter.getAdvancedSpacesInsideParensInArgumentLists());
                            }
                            // AS3_ex.g3:1959:8: ( bindingDeclArg (C= COMMA bindingDeclArg )* )?
                            int alt46 = 2;
                            int LA46_0 = input.LA(1);

                            if ( ((LA46_0 >= AS && LA46_0 <= STATIC) || (LA46_0 >= PLUS && LA46_0 <= STAR) || LA46_0 == XML_AT || (LA46_0 >= SINGLE_QUOTE_LITERAL && LA46_0 <= DOUBLE_QUOTE_LITERAL) || LA46_0 == HEX_NUMBER_LITERAL || LA46_0 == DEC_NUMBER_LITERAL || LA46_0 == IDENTIFIER) )
                            {
                                alt46 = 1;
                            }
                            switch (alt46) 
                            {
                                case 1 :
                                    // AS3_ex.g3:1959:9: bindingDeclArg (C= COMMA bindingDeclArg )*
                                    {
                                        PushFollow(FOLLOW_bindingDeclArg_in_bindingDecl6589);
                                        bindingDeclArg83 = bindingDeclArg();
                                        state.followingStackPointer--;
                                        if (state.failed) return retval;
                                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, bindingDeclArg83.Tree);
                                        // AS3_ex.g3:1959:24: (C= COMMA bindingDeclArg )*
                                        do 
                                        {
                                            int alt45 = 2;
                                            int LA45_0 = input.LA(1);

                                            if ( (LA45_0 == COMMA) )
                                            {
                                                alt45 = 1;
                                            }


                                            switch (alt45) 
                                            {
                                                case 1 :
                                                    // AS3_ex.g3:1959:25: C= COMMA bindingDeclArg
                                                    {
                                                        C=(IToken)Match(input,COMMA,FOLLOW_COMMA_in_bindingDecl6594); if (state.failed) return retval;
                                                        if ( state.backtracking == 0 )
                                                        {C_tree = (object)adaptor.Create(C);
                                                            adaptor.AddChild(root_0, C_tree);
                                                        }
                                                        if ( state.backtracking == 0 ) 
                                                        {
                                                          pushedIndent=emitCommaWithSpacingAndCRs(options, C, pushedIndent, -1, ASPrettyPrinter.Break_SubType_Other);
                                                        }
                                                        PushFollow(FOLLOW_bindingDeclArg_in_bindingDecl6598);
                                                        bindingDeclArg84 = bindingDeclArg();
                                                        state.followingStackPointer--;
                                                        if (state.failed) return retval;
                                                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, bindingDeclArg84.Tree);

                                                    }
                                                    break;

                                                default:
                                                    goto loop45;
                                            }
                                        } while (true);

                                        loop45:
                                            ;   // Stops C# compiler whining that label 'loop45' has no statements


                                    }
                                    break;

                            }

                            R=(IToken)Match(input,RPAREN,FOLLOW_RPAREN_in_bindingDecl6609); if (state.failed) return retval;
                            if ( state.backtracking == 0 )
                            {R_tree = (object)adaptor.Create(R);
                                adaptor.AddChild(root_0, R_tree);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              insertWS(mPrinter.getAdvancedSpacesInsideParensInArgumentLists());emit(R);
                            }

                        }
                        break;

                }

                R=(IToken)Match(input,RBRACK,FOLLOW_RBRACK_in_bindingDecl6630); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {R_tree = (object)adaptor.Create(R);
                    adaptor.AddChild(root_0, R_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(R);
                }
                // AS3_ex.g3:1962:25: (s= SEMI )?
                int alt48 = 2;
                int LA48_0 = input.LA(1);

                if ( (LA48_0 == SEMI) )
                {
                    int LA48_1 = input.LA(2);

                    if ( (synpred123_AS3_ex()) )
                    {
                        alt48 = 1;
                    }
                }
                switch (alt48) 
                {
                    case 1 :
                        // AS3_ex.g3:1962:26: s= SEMI
                        {
                            s=(IToken)Match(input,SEMI,FOLLOW_SEMI_in_bindingDecl6636); if (state.failed) return retval;
                            if ( state.backtracking == 0 )
                            {s_tree = (object)adaptor.Create(s);
                                adaptor.AddChild(root_0, s_tree);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              emit(s);
                            }

                        }
                        break;

                }

                if ( state.backtracking == 0 ) 
                {

                            if (pushedWrapInfo)
                                mPrinter.popWrapContext();
                            if (pushedIndent)
                                popIndent();
                            if (pushedFormat)
                            {
                                mPrinter.popFormatMode();
                            }
                        if (bindable)
                        {
                            mPrinter.setBindableMode();
                        }
                       
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 40, bindingDecl_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "bindingDecl"

    public class includeDirective_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "includeDirective"
    // AS3_ex.g3:1979:1: includeDirective : I= INCLUDE stringLiteral semic ;
    public AS3_exParser.includeDirective_return includeDirective() // throws RecognitionException [1]
    {   
        AS3_exParser.includeDirective_return retval = new AS3_exParser.includeDirective_return();
        retval.Start = input.LT(1);
        int includeDirective_StartIndex = input.Index();
        object root_0 = null;

        IToken I = null;
        AS3_exParser.stringLiteral_return stringLiteral85 = null;

        AS3_exParser.semic_return semic86 = null;


        object I_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 41) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:1980:2: (I= INCLUDE stringLiteral semic )
            // AS3_ex.g3:1981:2: I= INCLUDE stringLiteral semic
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  mPrinter.markDeclEqualsContextChange();
                }
                I=(IToken)Match(input,INCLUDE,FOLLOW_INCLUDE_in_includeDirective6666); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {I_tree = (object)adaptor.Create(I);
                    adaptor.AddChild(root_0, I_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(I);
                }
                PushFollow(FOLLOW_stringLiteral_in_includeDirective6669);
                stringLiteral85 = stringLiteral();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, stringLiteral85.Tree);
                PushFollow(FOLLOW_semic_in_includeDirective6671);
                semic86 = semic();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, semic86.Tree);

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 41, includeDirective_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "includeDirective"

    public class bindingDeclArg_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "bindingDeclArg"
    // AS3_ex.g3:1985:1: bindingDeclArg : ( eitherIdentifier E= ASSIGN )? ( stringLiteral | (P= PLUS | S= SUB )? numericLiteral | ( eitherIdentifier (D= DOT eitherIdentifier )* ) ) ;
    public AS3_exParser.bindingDeclArg_return bindingDeclArg() // throws RecognitionException [1]
    {   
        AS3_exParser.bindingDeclArg_return retval = new AS3_exParser.bindingDeclArg_return();
        retval.Start = input.LT(1);
        int bindingDeclArg_StartIndex = input.Index();
        object root_0 = null;

        IToken E = null;
        IToken P = null;
        IToken S = null;
        IToken D = null;
        AS3_exParser.eitherIdentifier_return eitherIdentifier87 = null;

        AS3_exParser.stringLiteral_return stringLiteral88 = null;

        AS3_exParser.numericLiteral_return numericLiteral89 = null;

        AS3_exParser.eitherIdentifier_return eitherIdentifier90 = null;

        AS3_exParser.eitherIdentifier_return eitherIdentifier91 = null;


        object E_tree=null;
        object P_tree=null;
        object S_tree=null;
        object D_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 42) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:1986:2: ( ( eitherIdentifier E= ASSIGN )? ( stringLiteral | (P= PLUS | S= SUB )? numericLiteral | ( eitherIdentifier (D= DOT eitherIdentifier )* ) ) )
            // AS3_ex.g3:1993:5: ( eitherIdentifier E= ASSIGN )? ( stringLiteral | (P= PLUS | S= SUB )? numericLiteral | ( eitherIdentifier (D= DOT eitherIdentifier )* ) )
            {
                root_0 = (object)adaptor.GetNilNode();

                // AS3_ex.g3:1993:5: ( eitherIdentifier E= ASSIGN )?
                int alt49 = 2;
                alt49 = dfa49.Predict(input);
                switch (alt49) 
                {
                    case 1 :
                        // AS3_ex.g3:1993:6: eitherIdentifier E= ASSIGN
                        {
                            PushFollow(FOLLOW_eitherIdentifier_in_bindingDeclArg6700);
                            eitherIdentifier87 = eitherIdentifier();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, eitherIdentifier87.Tree);
                            E=(IToken)Match(input,ASSIGN,FOLLOW_ASSIGN_in_bindingDeclArg6704); if (state.failed) return retval;
                            if ( state.backtracking == 0 )
                            {E_tree = (object)adaptor.Create(E);
                                adaptor.AddChild(root_0, E_tree);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              insertWS(mPrinter.getAdvancedSpacesAroundAssignmentInMetatags()); emit(E); insertWS(mPrinter.getAdvancedSpacesAroundAssignmentInMetatags());
                            }

                        }
                        break;

                }

                // AS3_ex.g3:1994:2: ( stringLiteral | (P= PLUS | S= SUB )? numericLiteral | ( eitherIdentifier (D= DOT eitherIdentifier )* ) )
                int alt52 = 3;
                switch ( input.LA(1) ) 
                {
                case SINGLE_QUOTE_LITERAL:
                case DOUBLE_QUOTE_LITERAL:
                    {
                    alt52 = 1;
                    }
                    break;
                case PLUS:
                case SUB:
                case HEX_NUMBER_LITERAL:
                case DEC_NUMBER_LITERAL:
                    {
                    alt52 = 2;
                    }
                    break;
                case AS:
                case BREAK:
                case CASE:
                case CATCH:
                case CLASS:
                case CONST:
                case CONTINUE:
                case DEFAULT:
                case DELETE:
                case DO:
                case ELSE:
                case EXTENDS:
                case FALSE:
                case FINALLY:
                case FOR:
                case FUNCTION:
                case IF:
                case IMPLEMENTS:
                case IMPORT:
                case IN:
                case INSTANCEOF:
                case INTERFACE:
                case INTERNAL:
                case IS:
                case NATIVE:
                case NEW:
                case NULL:
                case PACKAGE:
                case PRIVATE:
                case PROTECTED:
                case PUBLIC:
                case RETURN:
                case SUPER:
                case SWITCH:
                case THIS:
                case THROW:
                case TO:
                case TRUE:
                case TRY:
                case TYPEOF:
                case USE:
                case VAR:
                case VOID:
                case WHILE:
                case WITH:
                case EACH:
                case GET:
                case SET:
                case NAMESPACE:
                case INCLUDE:
                case DYNAMIC:
                case FINAL:
                case OVERRIDE:
                case STATIC:
                case STAR:
                case XML_AT:
                case IDENTIFIER:
                    {
                    alt52 = 3;
                    }
                    break;
                    default:
                        if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                        NoViableAltException nvae_d52s0 =
                            new NoViableAltException("", 52, 0, input);

                        throw nvae_d52s0;
                }

                switch (alt52) 
                {
                    case 1 :
                        // AS3_ex.g3:1995:3: stringLiteral
                        {
                            PushFollow(FOLLOW_stringLiteral_in_bindingDeclArg6717);
                            stringLiteral88 = stringLiteral();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, stringLiteral88.Tree);

                        }
                        break;
                    case 2 :
                        // AS3_ex.g3:1995:19: (P= PLUS | S= SUB )? numericLiteral
                        {
                            // AS3_ex.g3:1995:19: (P= PLUS | S= SUB )?
                            int alt50 = 3;
                            int LA50_0 = input.LA(1);

                            if ( (LA50_0 == PLUS) )
                            {
                                alt50 = 1;
                            }
                            else if ( (LA50_0 == SUB) )
                            {
                                alt50 = 2;
                            }
                            switch (alt50) 
                            {
                                case 1 :
                                    // AS3_ex.g3:1995:20: P= PLUS
                                    {
                                        P=(IToken)Match(input,PLUS,FOLLOW_PLUS_in_bindingDeclArg6724); if (state.failed) return retval;
                                        if ( state.backtracking == 0 )
                                        {P_tree = (object)adaptor.Create(P);
                                            adaptor.AddChild(root_0, P_tree);
                                        }
                                        if ( state.backtracking == 0 ) 
                                        {
                                          emit(P);
                                        }

                                    }
                                    break;
                                case 2 :
                                    // AS3_ex.g3:1995:41: S= SUB
                                    {
                                        S=(IToken)Match(input,SUB,FOLLOW_SUB_in_bindingDeclArg6732); if (state.failed) return retval;
                                        if ( state.backtracking == 0 )
                                        {S_tree = (object)adaptor.Create(S);
                                            adaptor.AddChild(root_0, S_tree);
                                        }
                                        if ( state.backtracking == 0 ) 
                                        {
                                          emit(S);
                                        }

                                    }
                                    break;

                            }

                            PushFollow(FOLLOW_numericLiteral_in_bindingDeclArg6739);
                            numericLiteral89 = numericLiteral();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, numericLiteral89.Tree);

                        }
                        break;
                    case 3 :
                        // AS3_ex.g3:1995:79: ( eitherIdentifier (D= DOT eitherIdentifier )* )
                        {
                            // AS3_ex.g3:1995:79: ( eitherIdentifier (D= DOT eitherIdentifier )* )
                            // AS3_ex.g3:1995:80: eitherIdentifier (D= DOT eitherIdentifier )*
                            {
                                PushFollow(FOLLOW_eitherIdentifier_in_bindingDeclArg6744);
                                eitherIdentifier90 = eitherIdentifier();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, eitherIdentifier90.Tree);
                                // AS3_ex.g3:1995:97: (D= DOT eitherIdentifier )*
                                do 
                                {
                                    int alt51 = 2;
                                    int LA51_0 = input.LA(1);

                                    if ( (LA51_0 == DOT) )
                                    {
                                        alt51 = 1;
                                    }


                                    switch (alt51) 
                                    {
                                        case 1 :
                                            // AS3_ex.g3:1995:98: D= DOT eitherIdentifier
                                            {
                                                D=(IToken)Match(input,DOT,FOLLOW_DOT_in_bindingDeclArg6749); if (state.failed) return retval;
                                                if ( state.backtracking == 0 )
                                                {D_tree = (object)adaptor.Create(D);
                                                    adaptor.AddChild(root_0, D_tree);
                                                }
                                                if ( state.backtracking == 0 ) 
                                                {
                                                  emit(D);
                                                }
                                                PushFollow(FOLLOW_eitherIdentifier_in_bindingDeclArg6753);
                                                eitherIdentifier91 = eitherIdentifier();
                                                state.followingStackPointer--;
                                                if (state.failed) return retval;
                                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, eitherIdentifier91.Tree);

                                            }
                                            break;

                                        default:
                                            goto loop51;
                                    }
                                } while (true);

                                loop51:
                                    ;   // Stops C# compiler whining that label 'loop51' has no statements


                            }


                        }
                        break;

                }


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 42, bindingDeclArg_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "bindingDeclArg"

    public class interfaceDeclaration_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "interfaceDeclaration"
    // AS3_ex.g3:2002:1: interfaceDeclaration : i= INTERFACE type (e= EXTENDS typeList )? interfaceBody ;
    public AS3_exParser.interfaceDeclaration_return interfaceDeclaration() // throws RecognitionException [1]
    {   
        AS3_exParser.interfaceDeclaration_return retval = new AS3_exParser.interfaceDeclaration_return();
        retval.Start = input.LT(1);
        int interfaceDeclaration_StartIndex = input.Index();
        object root_0 = null;

        IToken i = null;
        IToken e = null;
        AS3_exParser.type_return type92 = null;

        AS3_exParser.typeList_return typeList93 = null;

        AS3_exParser.interfaceBody_return interfaceBody94 = null;


        object i_tree=null;
        object e_tree=null;


            WrapOptions options=mPrinter.getExpressionWrapOptions();
            bool pushedWrapInfo=false;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 43) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2007:2: (i= INTERFACE type (e= EXTENDS typeList )? interfaceBody )
            // AS3_ex.g3:2008:6: i= INTERFACE type (e= EXTENDS typeList )? interfaceBody
            {
                root_0 = (object)adaptor.GetNilNode();

                i=(IToken)Match(input,INTERFACE,FOLLOW_INTERFACE_in_interfaceDeclaration6790); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {i_tree = (object)adaptor.Create(i);
                    adaptor.AddChild(root_0, i_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(i);
                }
                PushFollow(FOLLOW_type_in_interfaceDeclaration6794);
                type92 = type();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, type92.Tree);
                // AS3_ex.g3:2009:3: (e= EXTENDS typeList )?
                int alt53 = 2;
                int LA53_0 = input.LA(1);

                if ( (LA53_0 == EXTENDS) )
                {
                    alt53 = 1;
                }
                switch (alt53) 
                {
                    case 1 :
                        // AS3_ex.g3:2009:4: e= EXTENDS typeList
                        {
                            e=(IToken)Match(input,EXTENDS,FOLLOW_EXTENDS_in_interfaceDeclaration6802); if (state.failed) return retval;
                            if ( state.backtracking == 0 )
                            {e_tree = (object)adaptor.Create(e);
                                adaptor.AddChild(root_0, e_tree);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              pushedWrapInfo=pushWrapInfo(options, true);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              wrapEmit(e, ASPrettyPrinter.Break_Keyword_code);
                            }
                            PushFollow(FOLLOW_typeList_in_interfaceDeclaration6816);
                            typeList93 = typeList();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, typeList93.Tree);
                            if ( state.backtracking == 0 ) 
                            {
                              if (pushedWrapInfo) mPrinter.popWrapContext();
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              popIndent();
                            }

                        }
                        break;

                }

                if ( state.backtracking == 0 ) 
                {
                  popIndent();
                }
                PushFollow(FOLLOW_interfaceBody_in_interfaceDeclaration6843);
                interfaceBody94 = interfaceBody();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, interfaceBody94.Tree);

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 43, interfaceDeclaration_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "interfaceDeclaration"

    public class interfaceBody_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "interfaceBody"
    // AS3_ex.g3:2018:1: interfaceBody : l= LCURLY ( interfaceElement )* r= RCURLY ;
    public AS3_exParser.interfaceBody_return interfaceBody() // throws RecognitionException [1]
    {   
        AS3_exParser.interfaceBody_return retval = new AS3_exParser.interfaceBody_return();
        retval.Start = input.LT(1);
        int interfaceBody_StartIndex = input.Index();
        object root_0 = null;

        IToken l = null;
        IToken r = null;
        AS3_exParser.interfaceElement_return interfaceElement95 = null;


        object l_tree=null;
        object r_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 44) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2019:2: (l= LCURLY ( interfaceElement )* r= RCURLY )
            // AS3_ex.g3:2019:6: l= LCURLY ( interfaceElement )* r= RCURLY
            {
                root_0 = (object)adaptor.GetNilNode();

                l=(IToken)Match(input,LCURLY,FOLLOW_LCURLY_in_interfaceBody6859); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {l_tree = (object)adaptor.Create(l);
                    adaptor.AddChild(root_0, l_tree);
                }
                if ( state.backtracking == 0 ) 
                {

                            mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_interface_code);
                            leftCurlyNewlineHandler(false);
                            emit(l);pushIndent(true);
                            {mPrinter.addDeclEqualsBlock();}
                            mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_block_code);
                        
                }
                // AS3_ex.g3:2027:6: ( interfaceElement )*
                do 
                {
                    int alt54 = 2;
                    int LA54_0 = input.LA(1);

                    if ( ((LA54_0 >= AS && LA54_0 <= LCURLY) || LA54_0 == LPAREN || LA54_0 == LBRACK || LA54_0 == LT || (LA54_0 >= PLUS && LA54_0 <= STAR) || (LA54_0 >= INC && LA54_0 <= DEC) || (LA54_0 >= NOT && LA54_0 <= INV) || (LA54_0 >= XML_AT && LA54_0 <= XML_LS_STD) || (LA54_0 >= SINGLE_QUOTE_LITERAL && LA54_0 <= DOUBLE_QUOTE_LITERAL) || LA54_0 == REGULAR_EXPR_LITERAL || LA54_0 == HEX_NUMBER_LITERAL || LA54_0 == DEC_NUMBER_LITERAL || LA54_0 == IDENTIFIER || (LA54_0 >= XML_COMMENT && LA54_0 <= XML_PI)) )
                    {
                        alt54 = 1;
                    }


                    switch (alt54) 
                    {
                        case 1 :
                            // AS3_ex.g3:0:0: interfaceElement
                            {
                                PushFollow(FOLLOW_interfaceElement_in_interfaceBody6875);
                                interfaceElement95 = interfaceElement();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, interfaceElement95.Tree);

                            }
                            break;

                        default:
                            goto loop54;
                    }
                } while (true);

                loop54:
                    ;   // Stops C# compiler whining that label 'loop54' has no statements

                if ( state.backtracking == 0 ) 
                {
                  popIndent();
                }
                if ( state.backtracking == 0 ) 
                {
                  mPrinter.popDeclEqualsBlock();
                }
                r=(IToken)Match(input,RCURLY,FOLLOW_RCURLY_in_interfaceBody6901); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {r_tree = (object)adaptor.Create(r);
                    adaptor.AddChild(root_0, r_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  insertCR(false);emit(r);popBlockStack();popBlockStack();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 44, interfaceBody_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "interfaceBody"

    public class classDeclaration_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "classDeclaration"
    // AS3_ex.g3:2033:1: classDeclaration : c= CLASS type (E= EXTENDS type )? (I= IMPLEMENTS typeList )? classBody ;
    public AS3_exParser.classDeclaration_return classDeclaration() // throws RecognitionException [1]
    {   
        AS3_exParser.classDeclaration_return retval = new AS3_exParser.classDeclaration_return();
        retval.Start = input.LT(1);
        int classDeclaration_StartIndex = input.Index();
        object root_0 = null;

        IToken c = null;
        IToken E = null;
        IToken I = null;
        AS3_exParser.type_return type96 = null;

        AS3_exParser.type_return type97 = null;

        AS3_exParser.typeList_return typeList98 = null;

        AS3_exParser.classBody_return classBody99 = null;


        object c_tree=null;
        object E_tree=null;
        object I_tree=null;


            WrapOptions options=mPrinter.getExpressionWrapOptions();
            bool pushedWrapInfo=false;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 45) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2038:2: (c= CLASS type (E= EXTENDS type )? (I= IMPLEMENTS typeList )? classBody )
            // AS3_ex.g3:2039:6: c= CLASS type (E= EXTENDS type )? (I= IMPLEMENTS typeList )? classBody
            {
                root_0 = (object)adaptor.GetNilNode();

                c=(IToken)Match(input,CLASS,FOLLOW_CLASS_in_classDeclaration6928); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {c_tree = (object)adaptor.Create(c);
                    adaptor.AddChild(root_0, c_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(c);
                }
                PushFollow(FOLLOW_type_in_classDeclaration6932);
                type96 = type();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, type96.Tree);
                // AS3_ex.g3:2040:3: (E= EXTENDS type )?
                int alt55 = 2;
                int LA55_0 = input.LA(1);

                if ( (LA55_0 == EXTENDS) )
                {
                    alt55 = 1;
                }
                switch (alt55) 
                {
                    case 1 :
                        // AS3_ex.g3:2040:5: E= EXTENDS type
                        {
                            E=(IToken)Match(input,EXTENDS,FOLLOW_EXTENDS_in_classDeclaration6941); if (state.failed) return retval;
                            if ( state.backtracking == 0 )
                            {E_tree = (object)adaptor.Create(E);
                                adaptor.AddChild(root_0, E_tree);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              pushedWrapInfo=pushWrapInfo(options, true);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              wrapEmit(E, ASPrettyPrinter.Break_Keyword_code);
                            }
                            PushFollow(FOLLOW_type_in_classDeclaration6953);
                            type97 = type();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, type97.Tree);
                            if ( state.backtracking == 0 ) 
                            {
                              if (pushedWrapInfo) mPrinter.popWrapContext();
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              popIndent();
                            }

                        }
                        break;

                }

                // AS3_ex.g3:2045:3: (I= IMPLEMENTS typeList )?
                int alt56 = 2;
                int LA56_0 = input.LA(1);

                if ( (LA56_0 == IMPLEMENTS) )
                {
                    alt56 = 1;
                }
                switch (alt56) 
                {
                    case 1 :
                        // AS3_ex.g3:2045:5: I= IMPLEMENTS typeList
                        {
                            I=(IToken)Match(input,IMPLEMENTS,FOLLOW_IMPLEMENTS_in_classDeclaration6973); if (state.failed) return retval;
                            if ( state.backtracking == 0 )
                            {I_tree = (object)adaptor.Create(I);
                                adaptor.AddChild(root_0, I_tree);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              pushedWrapInfo=pushWrapInfo(options, true);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              wrapEmit(I, ASPrettyPrinter.Break_Keyword_code);
                            }
                            PushFollow(FOLLOW_typeList_in_classDeclaration6987);
                            typeList98 = typeList();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, typeList98.Tree);
                            if ( state.backtracking == 0 ) 
                            {
                              if (pushedWrapInfo) mPrinter.popWrapContext();
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              popIndent();
                            }

                        }
                        break;

                }

                if ( state.backtracking == 0 ) 
                {
                  popIndent();
                }
                PushFollow(FOLLOW_classBody_in_classDeclaration7013);
                classBody99 = classBody();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, classBody99.Tree);

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 45, classDeclaration_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "classDeclaration"

    public class classBody_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "classBody"
    // AS3_ex.g3:2056:1: classBody : L= LCURLY ( classBodyElement )* R= RCURLY ;
    public AS3_exParser.classBody_return classBody() // throws RecognitionException [1]
    {   
        AS3_exParser.classBody_return retval = new AS3_exParser.classBody_return();
        retval.Start = input.LT(1);
        int classBody_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        IToken R = null;
        AS3_exParser.classBodyElement_return classBodyElement100 = null;


        object L_tree=null;
        object R_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 46) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2057:2: (L= LCURLY ( classBodyElement )* R= RCURLY )
            // AS3_ex.g3:2057:6: L= LCURLY ( classBodyElement )* R= RCURLY
            {
                root_0 = (object)adaptor.GetNilNode();

                L=(IToken)Match(input,LCURLY,FOLLOW_LCURLY_in_classBody7042); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {L_tree = (object)adaptor.Create(L);
                    adaptor.AddChild(root_0, L_tree);
                }
                if ( state.backtracking == 0 ) 
                {

                            mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_class_code);
                            leftCurlyNewlineHandler(false);
                            emit(L);pushIndent(true);
                            {mPrinter.addDeclEqualsBlock();}
                            mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_block_code);
                        
                }
                // AS3_ex.g3:2065:3: ( classBodyElement )*
                do 
                {
                    int alt57 = 2;
                    int LA57_0 = input.LA(1);

                    if ( ((LA57_0 >= AS && LA57_0 <= LCURLY) || LA57_0 == LPAREN || LA57_0 == LBRACK || LA57_0 == LT || (LA57_0 >= PLUS && LA57_0 <= STAR) || (LA57_0 >= INC && LA57_0 <= DEC) || (LA57_0 >= NOT && LA57_0 <= INV) || (LA57_0 >= XML_AT && LA57_0 <= XML_LS_STD) || (LA57_0 >= SINGLE_QUOTE_LITERAL && LA57_0 <= DOUBLE_QUOTE_LITERAL) || LA57_0 == REGULAR_EXPR_LITERAL || LA57_0 == HEX_NUMBER_LITERAL || LA57_0 == DEC_NUMBER_LITERAL || LA57_0 == IDENTIFIER || (LA57_0 >= XML_COMMENT && LA57_0 <= XML_PI)) )
                    {
                        alt57 = 1;
                    }


                    switch (alt57) 
                    {
                        case 1 :
                            // AS3_ex.g3:0:0: classBodyElement
                            {
                                PushFollow(FOLLOW_classBodyElement_in_classBody7052);
                                classBodyElement100 = classBodyElement();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, classBodyElement100.Tree);

                            }
                            break;

                        default:
                            goto loop57;
                    }
                } while (true);

                loop57:
                    ;   // Stops C# compiler whining that label 'loop57' has no statements

                if ( state.backtracking == 0 ) 
                {
                  popIndent();
                }
                if ( state.backtracking == 0 ) 
                {
                  mPrinter.popDeclEqualsBlock();
                }
                R=(IToken)Match(input,RCURLY,FOLLOW_RCURLY_in_classBody7069); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {R_tree = (object)adaptor.Create(R);
                    adaptor.AddChild(root_0, R_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  insertCR(false);emit(R);popBlockStack();popBlockStack();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 46, classBody_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "classBody"

    public class classBodyElement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "classBodyElement"
    // AS3_ex.g3:2075:1: classBodyElement : ( ( conditionalCompilerOption LCURLY )=> conditionalCompilerOption l= LCURLY ( classBodyElement )* r= RCURLY | propertyDeclaration | functionDeclaration | statement | directive );
    public AS3_exParser.classBodyElement_return classBodyElement() // throws RecognitionException [1]
    {   
        AS3_exParser.classBodyElement_return retval = new AS3_exParser.classBodyElement_return();
        retval.Start = input.LT(1);
        int classBodyElement_StartIndex = input.Index();
        object root_0 = null;

        IToken l = null;
        IToken r = null;
        AS3_exParser.conditionalCompilerOption_return conditionalCompilerOption101 = null;

        AS3_exParser.classBodyElement_return classBodyElement102 = null;

        AS3_exParser.propertyDeclaration_return propertyDeclaration103 = null;

        AS3_exParser.functionDeclaration_return functionDeclaration104 = null;

        AS3_exParser.statement_return statement105 = null;

        AS3_exParser.directive_return directive106 = null;


        object l_tree=null;
        object r_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 47) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2076:5: ( ( conditionalCompilerOption LCURLY )=> conditionalCompilerOption l= LCURLY ( classBodyElement )* r= RCURLY | propertyDeclaration | functionDeclaration | statement | directive )
            int alt59 = 5;
            alt59 = dfa59.Predict(input);
            switch (alt59) 
            {
                case 1 :
                    // AS3_ex.g3:2076:7: ( conditionalCompilerOption LCURLY )=> conditionalCompilerOption l= LCURLY ( classBodyElement )* r= RCURLY
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        if ( state.backtracking == 0 ) 
                        {
                          insertCR(false);
                        }
                        PushFollow(FOLLOW_conditionalCompilerOption_in_classBodyElement7108);
                        conditionalCompilerOption101 = conditionalCompilerOption();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, conditionalCompilerOption101.Tree);
                        l=(IToken)Match(input,LCURLY,FOLLOW_LCURLY_in_classBodyElement7116); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {l_tree = (object)adaptor.Create(l);
                            adaptor.AddChild(root_0, l_tree);
                        }
                        if ( state.backtracking == 0 ) 
                        {
                           
                                        mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_Conditional_code);
                                        leftCurlyNewlineHandler(false);
                                        emit(l);pushIndent(true);
                                        {mPrinter.addDeclEqualsBlock();}
                                        mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_block_code);
                                    
                        }
                        // AS3_ex.g3:2086:4: ( classBodyElement )*
                        do 
                        {
                            int alt58 = 2;
                            int LA58_0 = input.LA(1);

                            if ( ((LA58_0 >= AS && LA58_0 <= LCURLY) || LA58_0 == LPAREN || LA58_0 == LBRACK || LA58_0 == LT || (LA58_0 >= PLUS && LA58_0 <= STAR) || (LA58_0 >= INC && LA58_0 <= DEC) || (LA58_0 >= NOT && LA58_0 <= INV) || (LA58_0 >= XML_AT && LA58_0 <= XML_LS_STD) || (LA58_0 >= SINGLE_QUOTE_LITERAL && LA58_0 <= DOUBLE_QUOTE_LITERAL) || LA58_0 == REGULAR_EXPR_LITERAL || LA58_0 == HEX_NUMBER_LITERAL || LA58_0 == DEC_NUMBER_LITERAL || LA58_0 == IDENTIFIER || (LA58_0 >= XML_COMMENT && LA58_0 <= XML_PI)) )
                            {
                                alt58 = 1;
                            }


                            switch (alt58) 
                            {
                                case 1 :
                                    // AS3_ex.g3:0:0: classBodyElement
                                    {
                                        PushFollow(FOLLOW_classBodyElement_in_classBodyElement7126);
                                        classBodyElement102 = classBodyElement();
                                        state.followingStackPointer--;
                                        if (state.failed) return retval;
                                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, classBodyElement102.Tree);

                                    }
                                    break;

                                default:
                                    goto loop58;
                            }
                        } while (true);

                        loop58:
                            ;   // Stops C# compiler whining that label 'loop58' has no statements

                        if ( state.backtracking == 0 ) 
                        {
                          popIndent();
                        }
                        if ( state.backtracking == 0 ) 
                        {
                          mPrinter.popDeclEqualsBlock();
                        }
                        r=(IToken)Match(input,RCURLY,FOLLOW_RCURLY_in_classBodyElement7145); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {r_tree = (object)adaptor.Create(r);
                            adaptor.AddChild(root_0, r_tree);
                        }
                        if ( state.backtracking == 0 ) 
                        {
                          insertCR(false);emit(r);popBlockStack();popBlockStack();
                        }

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:2090:7: propertyDeclaration
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_propertyDeclaration_in_classBodyElement7159);
                        propertyDeclaration103 = propertyDeclaration();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, propertyDeclaration103.Tree);

                    }
                    break;
                case 3 :
                    // AS3_ex.g3:2090:29: functionDeclaration
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_functionDeclaration_in_classBodyElement7163);
                        functionDeclaration104 = functionDeclaration();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, functionDeclaration104.Tree);

                    }
                    break;
                case 4 :
                    // AS3_ex.g3:2090:51: statement
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_statement_in_classBodyElement7167);
                        statement105 = statement();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, statement105.Tree);

                    }
                    break;
                case 5 :
                    // AS3_ex.g3:2090:63: directive
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_directive_in_classBodyElement7171);
                        directive106 = directive();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, directive106.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 47, classBodyElement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "classBodyElement"

    public class interfaceElement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "interfaceElement"
    // AS3_ex.g3:2093:1: interfaceElement : ( ( conditionalCompilerOption LCURLY )=> conditionalCompilerOption l= LCURLY ( interfaceElement )* r= RCURLY | propertyDeclaration | interfaceFunctionDeclaration | statement | directive );
    public AS3_exParser.interfaceElement_return interfaceElement() // throws RecognitionException [1]
    {   
        AS3_exParser.interfaceElement_return retval = new AS3_exParser.interfaceElement_return();
        retval.Start = input.LT(1);
        int interfaceElement_StartIndex = input.Index();
        object root_0 = null;

        IToken l = null;
        IToken r = null;
        AS3_exParser.conditionalCompilerOption_return conditionalCompilerOption107 = null;

        AS3_exParser.interfaceElement_return interfaceElement108 = null;

        AS3_exParser.propertyDeclaration_return propertyDeclaration109 = null;

        AS3_exParser.interfaceFunctionDeclaration_return interfaceFunctionDeclaration110 = null;

        AS3_exParser.statement_return statement111 = null;

        AS3_exParser.directive_return directive112 = null;


        object l_tree=null;
        object r_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 48) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2094:5: ( ( conditionalCompilerOption LCURLY )=> conditionalCompilerOption l= LCURLY ( interfaceElement )* r= RCURLY | propertyDeclaration | interfaceFunctionDeclaration | statement | directive )
            int alt61 = 5;
            alt61 = dfa61.Predict(input);
            switch (alt61) 
            {
                case 1 :
                    // AS3_ex.g3:2094:7: ( conditionalCompilerOption LCURLY )=> conditionalCompilerOption l= LCURLY ( interfaceElement )* r= RCURLY
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        if ( state.backtracking == 0 ) 
                        {
                          insertCR(false);
                        }
                        PushFollow(FOLLOW_conditionalCompilerOption_in_interfaceElement7203);
                        conditionalCompilerOption107 = conditionalCompilerOption();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, conditionalCompilerOption107.Tree);
                        l=(IToken)Match(input,LCURLY,FOLLOW_LCURLY_in_interfaceElement7211); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {l_tree = (object)adaptor.Create(l);
                            adaptor.AddChild(root_0, l_tree);
                        }
                        if ( state.backtracking == 0 ) 
                        {
                           
                                        mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_Conditional_code);
                                        leftCurlyNewlineHandler(false);
                                        emit(l);pushIndent(true);
                                        {mPrinter.addDeclEqualsBlock();}
                                        mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_block_code);
                                    
                        }
                        // AS3_ex.g3:2104:4: ( interfaceElement )*
                        do 
                        {
                            int alt60 = 2;
                            int LA60_0 = input.LA(1);

                            if ( ((LA60_0 >= AS && LA60_0 <= LCURLY) || LA60_0 == LPAREN || LA60_0 == LBRACK || LA60_0 == LT || (LA60_0 >= PLUS && LA60_0 <= STAR) || (LA60_0 >= INC && LA60_0 <= DEC) || (LA60_0 >= NOT && LA60_0 <= INV) || (LA60_0 >= XML_AT && LA60_0 <= XML_LS_STD) || (LA60_0 >= SINGLE_QUOTE_LITERAL && LA60_0 <= DOUBLE_QUOTE_LITERAL) || LA60_0 == REGULAR_EXPR_LITERAL || LA60_0 == HEX_NUMBER_LITERAL || LA60_0 == DEC_NUMBER_LITERAL || LA60_0 == IDENTIFIER || (LA60_0 >= XML_COMMENT && LA60_0 <= XML_PI)) )
                            {
                                alt60 = 1;
                            }


                            switch (alt60) 
                            {
                                case 1 :
                                    // AS3_ex.g3:0:0: interfaceElement
                                    {
                                        PushFollow(FOLLOW_interfaceElement_in_interfaceElement7221);
                                        interfaceElement108 = interfaceElement();
                                        state.followingStackPointer--;
                                        if (state.failed) return retval;
                                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, interfaceElement108.Tree);

                                    }
                                    break;

                                default:
                                    goto loop60;
                            }
                        } while (true);

                        loop60:
                            ;   // Stops C# compiler whining that label 'loop60' has no statements

                        if ( state.backtracking == 0 ) 
                        {
                          popIndent();
                        }
                        if ( state.backtracking == 0 ) 
                        {
                          mPrinter.popDeclEqualsBlock();
                        }
                        r=(IToken)Match(input,RCURLY,FOLLOW_RCURLY_in_interfaceElement7240); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {r_tree = (object)adaptor.Create(r);
                            adaptor.AddChild(root_0, r_tree);
                        }
                        if ( state.backtracking == 0 ) 
                        {
                          insertCR(false);emit(r);popBlockStack();popBlockStack();
                        }

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:2108:7: propertyDeclaration
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_propertyDeclaration_in_interfaceElement7254);
                        propertyDeclaration109 = propertyDeclaration();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, propertyDeclaration109.Tree);

                    }
                    break;
                case 3 :
                    // AS3_ex.g3:2108:29: interfaceFunctionDeclaration
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_interfaceFunctionDeclaration_in_interfaceElement7258);
                        interfaceFunctionDeclaration110 = interfaceFunctionDeclaration();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, interfaceFunctionDeclaration110.Tree);

                    }
                    break;
                case 4 :
                    // AS3_ex.g3:2108:60: statement
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_statement_in_interfaceElement7262);
                        statement111 = statement();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, statement111.Tree);

                    }
                    break;
                case 5 :
                    // AS3_ex.g3:2108:71: directive
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_directive_in_interfaceElement7265);
                        directive112 = directive();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, directive112.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 48, interfaceElement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "interfaceElement"

    public class interfaceFunctionDeclaration_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "interfaceFunctionDeclaration"
    // AS3_ex.g3:2117:1: interfaceFunctionDeclaration : ( conditionalDirAndBindingDecls )? ( memberModifiers )? F= FUNCTION (S= SET | G= GET )? (I= IDENTIFIER | notQuiteReservedWord ) formalParameterList (C= COLON type )? semic ;
    public AS3_exParser.interfaceFunctionDeclaration_return interfaceFunctionDeclaration() // throws RecognitionException [1]
    {   
        AS3_exParser.interfaceFunctionDeclaration_return retval = new AS3_exParser.interfaceFunctionDeclaration_return();
        retval.Start = input.LT(1);
        int interfaceFunctionDeclaration_StartIndex = input.Index();
        object root_0 = null;

        IToken F = null;
        IToken S = null;
        IToken G = null;
        IToken I = null;
        IToken C = null;
        AS3_exParser.conditionalDirAndBindingDecls_return conditionalDirAndBindingDecls113 = null;

        AS3_exParser.memberModifiers_return memberModifiers114 = null;

        AS3_exParser.notQuiteReservedWord_return notQuiteReservedWord115 = null;

        AS3_exParser.formalParameterList_return formalParameterList116 = null;

        AS3_exParser.type_return type117 = null;

        AS3_exParser.semic_return semic118 = null;


        object F_tree=null;
        object S_tree=null;
        object G_tree=null;
        object I_tree=null;
        object C_tree=null;


            WrapOptions options=mPrinter.getExpressionWrapOptions();
            bool pushedWrapInfo=false;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 49) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2122:5: ( ( conditionalDirAndBindingDecls )? ( memberModifiers )? F= FUNCTION (S= SET | G= GET )? (I= IDENTIFIER | notQuiteReservedWord ) formalParameterList (C= COLON type )? semic )
            // AS3_ex.g3:2122:10: ( conditionalDirAndBindingDecls )? ( memberModifiers )? F= FUNCTION (S= SET | G= GET )? (I= IDENTIFIER | notQuiteReservedWord ) formalParameterList (C= COLON type )? semic
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  mPrinter.setBindingContext(ASPrettyPrinter.BindingContext_Function);
                }
                // AS3_ex.g3:2122:81: ( conditionalDirAndBindingDecls )?
                int alt62 = 2;
                switch ( input.LA(1) ) 
                {
                    case IDENTIFIER:
                        {
                        int LA62_1 = input.LA(2);

                        if ( (LA62_1 == XML_NS_OP) )
                        {
                            alt62 = 1;
                        }
                        }
                        break;
                    case NATIVE:
                    case DYNAMIC:
                    case FINAL:
                    case OVERRIDE:
                    case STATIC:
                        {
                        int LA62_2 = input.LA(2);

                        if ( (LA62_2 == XML_NS_OP) )
                        {
                            alt62 = 1;
                        }
                        }
                        break;
                    case TO:
                    case EACH:
                    case GET:
                    case SET:
                    case NAMESPACE:
                        {
                        alt62 = 1;
                        }
                        break;
                }

                switch (alt62) 
                {
                    case 1 :
                        // AS3_ex.g3:2122:82: conditionalDirAndBindingDecls
                        {
                            PushFollow(FOLLOW_conditionalDirAndBindingDecls_in_interfaceFunctionDeclaration7300);
                            conditionalDirAndBindingDecls113 = conditionalDirAndBindingDecls();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, conditionalDirAndBindingDecls113.Tree);

                        }
                        break;

                }

                if ( state.backtracking == 0 ) 
                {
                  insertCR(false);
                }
                // AS3_ex.g3:2122:133: ( memberModifiers )?
                int alt63 = 2;
                int LA63_0 = input.LA(1);

                if ( (LA63_0 == INTERNAL || LA63_0 == NATIVE || (LA63_0 >= PRIVATE && LA63_0 <= PUBLIC) || (LA63_0 >= DYNAMIC && LA63_0 <= STATIC) || LA63_0 == IDENTIFIER) )
                {
                    alt63 = 1;
                }
                switch (alt63) 
                {
                    case 1 :
                        // AS3_ex.g3:0:0: memberModifiers
                        {
                            PushFollow(FOLLOW_memberModifiers_in_interfaceFunctionDeclaration7306);
                            memberModifiers114 = memberModifiers();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, memberModifiers114.Tree);

                        }
                        break;

                }

                F=(IToken)Match(input,FUNCTION,FOLLOW_FUNCTION_in_interfaceFunctionDeclaration7311); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {F_tree = (object)adaptor.Create(F);
                    adaptor.AddChild(root_0, F_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(F);
                }
                // AS3_ex.g3:2124:5: (S= SET | G= GET )?
                int alt64 = 3;
                int LA64_0 = input.LA(1);

                if ( (LA64_0 == SET) )
                {
                    int LA64_1 = input.LA(2);

                    if ( (LA64_1 == NATIVE || LA64_1 == TO || (LA64_1 >= EACH && LA64_1 <= NAMESPACE) || (LA64_1 >= DYNAMIC && LA64_1 <= STATIC) || LA64_1 == IDENTIFIER) )
                    {
                        alt64 = 1;
                    }
                }
                else if ( (LA64_0 == GET) )
                {
                    int LA64_2 = input.LA(2);

                    if ( (LA64_2 == NATIVE || LA64_2 == TO || (LA64_2 >= EACH && LA64_2 <= NAMESPACE) || (LA64_2 >= DYNAMIC && LA64_2 <= STATIC) || LA64_2 == IDENTIFIER) )
                    {
                        alt64 = 2;
                    }
                }
                switch (alt64) 
                {
                    case 1 :
                        // AS3_ex.g3:2124:6: S= SET
                        {
                            S=(IToken)Match(input,SET,FOLLOW_SET_in_interfaceFunctionDeclaration7330); if (state.failed) return retval;
                            if ( state.backtracking == 0 )
                            {S_tree = (object)adaptor.Create(S);
                                adaptor.AddChild(root_0, S_tree);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              emit(S);
                            }

                        }
                        break;
                    case 2 :
                        // AS3_ex.g3:2124:25: G= GET
                        {
                            G=(IToken)Match(input,GET,FOLLOW_GET_in_interfaceFunctionDeclaration7337); if (state.failed) return retval;
                            if ( state.backtracking == 0 )
                            {G_tree = (object)adaptor.Create(G);
                                adaptor.AddChild(root_0, G_tree);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              emit(G);
                            }

                        }
                        break;

                }

                if ( state.backtracking == 0 ) 
                {
                  pushedWrapInfo=pushWrapInfo(options, true);
                }
                // AS3_ex.g3:2126:2: (I= IDENTIFIER | notQuiteReservedWord )
                int alt65 = 2;
                int LA65_0 = input.LA(1);

                if ( (LA65_0 == IDENTIFIER) )
                {
                    alt65 = 1;
                }
                else if ( (LA65_0 == NATIVE || LA65_0 == TO || (LA65_0 >= EACH && LA65_0 <= NAMESPACE) || (LA65_0 >= DYNAMIC && LA65_0 <= STATIC)) )
                {
                    alt65 = 2;
                }
                else 
                {
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    NoViableAltException nvae_d65s0 =
                        new NoViableAltException("", 65, 0, input);

                    throw nvae_d65s0;
                }
                switch (alt65) 
                {
                    case 1 :
                        // AS3_ex.g3:2126:3: I= IDENTIFIER
                        {
                            I=(IToken)Match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_interfaceFunctionDeclaration7354); if (state.failed) return retval;
                            if ( state.backtracking == 0 )
                            {I_tree = (object)adaptor.Create(I);
                                adaptor.AddChild(root_0, I_tree);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              emit(I);
                            }

                        }
                        break;
                    case 2 :
                        // AS3_ex.g3:2126:30: notQuiteReservedWord
                        {
                            PushFollow(FOLLOW_notQuiteReservedWord_in_interfaceFunctionDeclaration7360);
                            notQuiteReservedWord115 = notQuiteReservedWord();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, notQuiteReservedWord115.Tree);

                        }
                        break;

                }

                PushFollow(FOLLOW_formalParameterList_in_interfaceFunctionDeclaration7363);
                formalParameterList116 = formalParameterList();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, formalParameterList116.Tree);
                // AS3_ex.g3:2126:72: (C= COLON type )?
                int alt66 = 2;
                int LA66_0 = input.LA(1);

                if ( (LA66_0 == COLON) )
                {
                    alt66 = 1;
                }
                switch (alt66) 
                {
                    case 1 :
                        // AS3_ex.g3:2126:73: C= COLON type
                        {
                            C=(IToken)Match(input,COLON,FOLLOW_COLON_in_interfaceFunctionDeclaration7368); if (state.failed) return retval;
                            if ( state.backtracking == 0 )
                            {C_tree = (object)adaptor.Create(C);
                                adaptor.AddChild(root_0, C_tree);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              insertWS(mPrinter.getAdvancedSpacesBeforeColonsInFunctionTypes()); emit(C);insertWS(mPrinter.getAdvancedSpacesAfterColonsInFunctionTypes());
                            }
                            PushFollow(FOLLOW_type_in_interfaceFunctionDeclaration7372);
                            type117 = type();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, type117.Tree);

                        }
                        break;

                }

                PushFollow(FOLLOW_semic_in_interfaceFunctionDeclaration7376);
                semic118 = semic();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, semic118.Tree);
                if ( state.backtracking == 0 ) 
                {
                  if (pushedWrapInfo) mPrinter.popWrapContext();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 49, interfaceFunctionDeclaration_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "interfaceFunctionDeclaration"

    public class propertyDeclaration_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "propertyDeclaration"
    // AS3_ex.g3:2134:1: propertyDeclaration : ( conditionalDirAndBindingDecls )? ( memberModifiers )? ( variableStatement | constantVarStatement | namespaceDirective ) ;
    public AS3_exParser.propertyDeclaration_return propertyDeclaration() // throws RecognitionException [1]
    {   
        AS3_exParser.propertyDeclaration_return retval = new AS3_exParser.propertyDeclaration_return();
        retval.Start = input.LT(1);
        int propertyDeclaration_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.conditionalDirAndBindingDecls_return conditionalDirAndBindingDecls119 = null;

        AS3_exParser.memberModifiers_return memberModifiers120 = null;

        AS3_exParser.variableStatement_return variableStatement121 = null;

        AS3_exParser.constantVarStatement_return constantVarStatement122 = null;

        AS3_exParser.namespaceDirective_return namespaceDirective123 = null;



        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 50) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2135:2: ( ( conditionalDirAndBindingDecls )? ( memberModifiers )? ( variableStatement | constantVarStatement | namespaceDirective ) )
            // AS3_ex.g3:2135:7: ( conditionalDirAndBindingDecls )? ( memberModifiers )? ( variableStatement | constantVarStatement | namespaceDirective )
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  insertLines(mPrinter.getBlankLinesBeforeProperties());mPrinter.setBindingContext(ASPrettyPrinter.BindingContext_Property);
                }
                // AS3_ex.g3:2135:132: ( conditionalDirAndBindingDecls )?
                int alt67 = 2;
                switch ( input.LA(1) ) 
                {
                    case IDENTIFIER:
                        {
                        int LA67_1 = input.LA(2);

                        if ( (LA67_1 == XML_NS_OP) )
                        {
                            alt67 = 1;
                        }
                        }
                        break;
                    case NATIVE:
                    case DYNAMIC:
                    case FINAL:
                    case OVERRIDE:
                    case STATIC:
                        {
                        int LA67_2 = input.LA(2);

                        if ( (LA67_2 == XML_NS_OP) )
                        {
                            alt67 = 1;
                        }
                        }
                        break;
                    case NAMESPACE:
                        {
                        int LA67_3 = input.LA(2);

                        if ( (LA67_3 == XML_NS_OP) )
                        {
                            alt67 = 1;
                        }
                        }
                        break;
                    case TO:
                    case EACH:
                    case GET:
                    case SET:
                        {
                        alt67 = 1;
                        }
                        break;
                }

                switch (alt67) 
                {
                    case 1 :
                        // AS3_ex.g3:2135:133: conditionalDirAndBindingDecls
                        {
                            PushFollow(FOLLOW_conditionalDirAndBindingDecls_in_propertyDeclaration7406);
                            conditionalDirAndBindingDecls119 = conditionalDirAndBindingDecls();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, conditionalDirAndBindingDecls119.Tree);

                        }
                        break;

                }

                if ( state.backtracking == 0 ) 
                {
                  insertCR(false);
                }
                if ( state.backtracking == 0 ) 
                {
                  pushLazyIndent();
                }
                // AS3_ex.g3:2135:203: ( memberModifiers )?
                int alt68 = 2;
                int LA68_0 = input.LA(1);

                if ( (LA68_0 == IDENTIFIER) )
                {
                    int LA68_1 = input.LA(2);

                    if ( (synpred152_AS3_ex()) )
                    {
                        alt68 = 1;
                    }
                }
                else if ( (LA68_0 == INTERNAL || LA68_0 == NATIVE || (LA68_0 >= PRIVATE && LA68_0 <= PUBLIC) || (LA68_0 >= DYNAMIC && LA68_0 <= STATIC)) )
                {
                    alt68 = 1;
                }
                switch (alt68) 
                {
                    case 1 :
                        // AS3_ex.g3:0:0: memberModifiers
                        {
                            PushFollow(FOLLOW_memberModifiers_in_propertyDeclaration7413);
                            memberModifiers120 = memberModifiers();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, memberModifiers120.Tree);

                        }
                        break;

                }

                // AS3_ex.g3:2135:220: ( variableStatement | constantVarStatement | namespaceDirective )
                int alt69 = 3;
                switch ( input.LA(1) ) 
                {
                case VAR:
                case IDENTIFIER:
                    {
                    alt69 = 1;
                    }
                    break;
                case CONST:
                    {
                    alt69 = 2;
                    }
                    break;
                case NAMESPACE:
                    {
                    alt69 = 3;
                    }
                    break;
                    default:
                        if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                        NoViableAltException nvae_d69s0 =
                            new NoViableAltException("", 69, 0, input);

                        throw nvae_d69s0;
                }

                switch (alt69) 
                {
                    case 1 :
                        // AS3_ex.g3:2135:221: variableStatement
                        {
                            PushFollow(FOLLOW_variableStatement_in_propertyDeclaration7417);
                            variableStatement121 = variableStatement();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, variableStatement121.Tree);

                        }
                        break;
                    case 2 :
                        // AS3_ex.g3:2135:241: constantVarStatement
                        {
                            PushFollow(FOLLOW_constantVarStatement_in_propertyDeclaration7421);
                            constantVarStatement122 = constantVarStatement();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, constantVarStatement122.Tree);

                        }
                        break;
                    case 3 :
                        // AS3_ex.g3:2135:264: namespaceDirective
                        {
                            PushFollow(FOLLOW_namespaceDirective_in_propertyDeclaration7425);
                            namespaceDirective123 = namespaceDirective();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, namespaceDirective123.Tree);

                        }
                        break;

                }

                if ( state.backtracking == 0 ) 
                {
                  popIndent();
                }
                if ( state.backtracking == 0 ) 
                {
                  mPrinter.adjustLastLineIndent();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 50, propertyDeclaration_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "propertyDeclaration"

    public class functionDeclaration_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "functionDeclaration"
    // AS3_ex.g3:2142:1: functionDeclaration : ( conditionalDirAndBindingDecls )? ( memberModifiers )? F= FUNCTION (funcType= ( SET | GET ) )? (I= IDENTIFIER | notQuiteReservedWord ) formalParameterList (C= COLON type )? functionBody ;
    public AS3_exParser.functionDeclaration_return functionDeclaration() // throws RecognitionException [1]
    {   
        AS3_exParser.functionDeclaration_return retval = new AS3_exParser.functionDeclaration_return();
        retval.Start = input.LT(1);
        int functionDeclaration_StartIndex = input.Index();
        object root_0 = null;

        IToken F = null;
        IToken funcType = null;
        IToken I = null;
        IToken C = null;
        AS3_exParser.conditionalDirAndBindingDecls_return conditionalDirAndBindingDecls124 = null;

        AS3_exParser.memberModifiers_return memberModifiers125 = null;

        AS3_exParser.notQuiteReservedWord_return notQuiteReservedWord126 = null;

        AS3_exParser.formalParameterList_return formalParameterList127 = null;

        AS3_exParser.type_return type128 = null;

        AS3_exParser.functionBody_return functionBody129 = null;


        object F_tree=null;
        object funcType_tree=null;
        object I_tree=null;
        object C_tree=null;


            WrapOptions options=mPrinter.getExpressionWrapOptions();
            bool pushedWrapInfo=false;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 51) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2147:5: ( ( conditionalDirAndBindingDecls )? ( memberModifiers )? F= FUNCTION (funcType= ( SET | GET ) )? (I= IDENTIFIER | notQuiteReservedWord ) formalParameterList (C= COLON type )? functionBody )
            // AS3_ex.g3:2148:5: ( conditionalDirAndBindingDecls )? ( memberModifiers )? F= FUNCTION (funcType= ( SET | GET ) )? (I= IDENTIFIER | notQuiteReservedWord ) formalParameterList (C= COLON type )? functionBody
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  mPrinter.setBindingContext(ASPrettyPrinter.BindingContext_Function);
                }
                // AS3_ex.g3:2148:76: ( conditionalDirAndBindingDecls )?
                int alt70 = 2;
                switch ( input.LA(1) ) 
                {
                    case IDENTIFIER:
                        {
                        int LA70_1 = input.LA(2);

                        if ( (LA70_1 == XML_NS_OP) )
                        {
                            alt70 = 1;
                        }
                        }
                        break;
                    case NATIVE:
                    case DYNAMIC:
                    case FINAL:
                    case OVERRIDE:
                    case STATIC:
                        {
                        int LA70_2 = input.LA(2);

                        if ( (LA70_2 == XML_NS_OP) )
                        {
                            alt70 = 1;
                        }
                        }
                        break;
                    case TO:
                    case EACH:
                    case GET:
                    case SET:
                    case NAMESPACE:
                        {
                        alt70 = 1;
                        }
                        break;
                }

                switch (alt70) 
                {
                    case 1 :
                        // AS3_ex.g3:2148:77: conditionalDirAndBindingDecls
                        {
                            PushFollow(FOLLOW_conditionalDirAndBindingDecls_in_functionDeclaration7459);
                            conditionalDirAndBindingDecls124 = conditionalDirAndBindingDecls();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, conditionalDirAndBindingDecls124.Tree);

                        }
                        break;

                }

                if ( state.backtracking == 0 ) 
                {
                  pushLazyIndent();
                }
                if ( state.backtracking == 0 ) 
                {
                  insertCR(false);insertLines(mPrinter.getBlankLinesBeforeFunction());
                }
                // AS3_ex.g3:2148:199: ( memberModifiers )?
                int alt71 = 2;
                int LA71_0 = input.LA(1);

                if ( (LA71_0 == INTERNAL || LA71_0 == NATIVE || (LA71_0 >= PRIVATE && LA71_0 <= PUBLIC) || (LA71_0 >= DYNAMIC && LA71_0 <= STATIC) || LA71_0 == IDENTIFIER) )
                {
                    alt71 = 1;
                }
                switch (alt71) 
                {
                    case 1 :
                        // AS3_ex.g3:0:0: memberModifiers
                        {
                            PushFollow(FOLLOW_memberModifiers_in_functionDeclaration7466);
                            memberModifiers125 = memberModifiers();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, memberModifiers125.Tree);

                        }
                        break;

                }

                F=(IToken)Match(input,FUNCTION,FOLLOW_FUNCTION_in_functionDeclaration7471); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {F_tree = (object)adaptor.Create(F);
                    adaptor.AddChild(root_0, F_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(F);
                }
                if ( state.backtracking == 0 ) 
                {
                  mPrinter.checkForSingleLineFunctionMode(F);
                }
                // AS3_ex.g3:2150:5: (funcType= ( SET | GET ) )?
                int alt72 = 2;
                int LA72_0 = input.LA(1);

                if ( ((LA72_0 >= GET && LA72_0 <= SET)) )
                {
                    int LA72_1 = input.LA(2);

                    if ( (LA72_1 == NATIVE || LA72_1 == TO || (LA72_1 >= EACH && LA72_1 <= NAMESPACE) || (LA72_1 >= DYNAMIC && LA72_1 <= STATIC) || LA72_1 == IDENTIFIER) )
                    {
                        alt72 = 1;
                    }
                }
                switch (alt72) 
                {
                    case 1 :
                        // AS3_ex.g3:2150:6: funcType= ( SET | GET )
                        {
                            funcType = (IToken)input.LT(1);
                            if ( (input.LA(1) >= GET && input.LA(1) <= SET) ) 
                            {
                                input.Consume();
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, (object)adaptor.Create(funcType));
                                state.errorRecovery = false;state.failed = false;
                            }
                            else 
                            {
                                if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                                MismatchedSetException mse = new MismatchedSetException(null,input);
                                throw mse;
                            }

                            if ( state.backtracking == 0 ) 
                            {
                              emit(funcType);
                            }

                        }
                        break;

                }

                if ( state.backtracking == 0 ) 
                {
                  pushedWrapInfo=pushWrapInfo(options, true);
                }
                // AS3_ex.g3:2152:2: (I= IDENTIFIER | notQuiteReservedWord )
                int alt73 = 2;
                int LA73_0 = input.LA(1);

                if ( (LA73_0 == IDENTIFIER) )
                {
                    alt73 = 1;
                }
                else if ( (LA73_0 == NATIVE || LA73_0 == TO || (LA73_0 >= EACH && LA73_0 <= NAMESPACE) || (LA73_0 >= DYNAMIC && LA73_0 <= STATIC)) )
                {
                    alt73 = 2;
                }
                else 
                {
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    NoViableAltException nvae_d73s0 =
                        new NoViableAltException("", 73, 0, input);

                    throw nvae_d73s0;
                }
                switch (alt73) 
                {
                    case 1 :
                        // AS3_ex.g3:2152:3: I= IDENTIFIER
                        {
                            I=(IToken)Match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_functionDeclaration7513); if (state.failed) return retval;
                            if ( state.backtracking == 0 )
                            {I_tree = (object)adaptor.Create(I);
                                adaptor.AddChild(root_0, I_tree);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              emit(I);
                            }

                        }
                        break;
                    case 2 :
                        // AS3_ex.g3:2152:30: notQuiteReservedWord
                        {
                            PushFollow(FOLLOW_notQuiteReservedWord_in_functionDeclaration7519);
                            notQuiteReservedWord126 = notQuiteReservedWord();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, notQuiteReservedWord126.Tree);

                        }
                        break;

                }

                PushFollow(FOLLOW_formalParameterList_in_functionDeclaration7522);
                formalParameterList127 = formalParameterList();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, formalParameterList127.Tree);
                // AS3_ex.g3:2152:72: (C= COLON type )?
                int alt74 = 2;
                int LA74_0 = input.LA(1);

                if ( (LA74_0 == COLON) )
                {
                    alt74 = 1;
                }
                switch (alt74) 
                {
                    case 1 :
                        // AS3_ex.g3:2152:73: C= COLON type
                        {
                            C=(IToken)Match(input,COLON,FOLLOW_COLON_in_functionDeclaration7527); if (state.failed) return retval;
                            if ( state.backtracking == 0 )
                            {C_tree = (object)adaptor.Create(C);
                                adaptor.AddChild(root_0, C_tree);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              insertWS(mPrinter.getAdvancedSpacesBeforeColonsInFunctionTypes());emit(C);insertWS(mPrinter.getAdvancedSpacesAfterColonsInFunctionTypes());
                            }
                            PushFollow(FOLLOW_type_in_functionDeclaration7531);
                            type128 = type();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, type128.Tree);

                        }
                        break;

                }

                if ( state.backtracking == 0 ) 
                {
                  popIndent();mIsFunctionDecl=true;
                }
                if ( state.backtracking == 0 ) 
                {
                  if (pushedWrapInfo) mPrinter.popWrapContext();
                }
                PushFollow(FOLLOW_functionBody_in_functionDeclaration7547);
                functionBody129 = functionBody();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, functionBody129.Tree);
                if ( state.backtracking == 0 ) 
                {
                  mPrinter.endSingleLineFunctionMode();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 51, functionDeclaration_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "functionDeclaration"

    public class functionExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "functionExpression"
    // AS3_ex.g3:2158:1: functionExpression : F= FUNCTION (I= IDENTIFIER )? formalParameterList (C= COLON type )? functionBody ;
    public AS3_exParser.functionExpression_return functionExpression() // throws RecognitionException [1]
    {   
        AS3_exParser.functionExpression_return retval = new AS3_exParser.functionExpression_return();
        retval.Start = input.LT(1);
        int functionExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken F = null;
        IToken I = null;
        IToken C = null;
        AS3_exParser.formalParameterList_return formalParameterList130 = null;

        AS3_exParser.type_return type131 = null;

        AS3_exParser.functionBody_return functionBody132 = null;


        object F_tree=null;
        object I_tree=null;
        object C_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 52) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2161:2: (F= FUNCTION (I= IDENTIFIER )? formalParameterList (C= COLON type )? functionBody )
            // AS3_ex.g3:2161:6: F= FUNCTION (I= IDENTIFIER )? formalParameterList (C= COLON type )? functionBody
            {
                root_0 = (object)adaptor.GetNilNode();

                F=(IToken)Match(input,FUNCTION,FOLLOW_FUNCTION_in_functionExpression7582); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {F_tree = (object)adaptor.Create(F);
                    adaptor.AddChild(root_0, F_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(F);pushIndent(false);
                }
                // AS3_ex.g3:2161:47: (I= IDENTIFIER )?
                int alt75 = 2;
                int LA75_0 = input.LA(1);

                if ( (LA75_0 == IDENTIFIER) )
                {
                    alt75 = 1;
                }
                switch (alt75) 
                {
                    case 1 :
                        // AS3_ex.g3:2161:48: I= IDENTIFIER
                        {
                            I=(IToken)Match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_functionExpression7589); if (state.failed) return retval;
                            if ( state.backtracking == 0 )
                            {I_tree = (object)adaptor.Create(I);
                                adaptor.AddChild(root_0, I_tree);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              emit(I);
                            }

                        }
                        break;

                }

                PushFollow(FOLLOW_formalParameterList_in_functionExpression7594);
                formalParameterList130 = formalParameterList();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, formalParameterList130.Tree);
                // AS3_ex.g3:2161:94: (C= COLON type )?
                int alt76 = 2;
                int LA76_0 = input.LA(1);

                if ( (LA76_0 == COLON) )
                {
                    alt76 = 1;
                }
                switch (alt76) 
                {
                    case 1 :
                        // AS3_ex.g3:2161:95: C= COLON type
                        {
                            C=(IToken)Match(input,COLON,FOLLOW_COLON_in_functionExpression7599); if (state.failed) return retval;
                            if ( state.backtracking == 0 )
                            {C_tree = (object)adaptor.Create(C);
                                adaptor.AddChild(root_0, C_tree);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              insertWS(mPrinter.getAdvancedSpacesBeforeColonsInFunctionTypes());emit(C);insertWS(mPrinter.getAdvancedSpacesAfterColonsInFunctionTypes());
                            }
                            PushFollow(FOLLOW_type_in_functionExpression7603);
                            type131 = type();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, type131.Tree);

                        }
                        break;

                }

                if ( state.backtracking == 0 ) 
                {
                  mIsFunctionDecl=false;
                }
                if ( state.backtracking == 0 ) 
                {
                  popIndent();
                }
                if ( state.backtracking == 0 ) 
                {
                  mPrinter.pushFunctionExpressionStatementIndent();
                }
                PushFollow(FOLLOW_functionBody_in_functionExpression7617);
                functionBody132 = functionBody();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, functionBody132.Tree);
                if ( state.backtracking == 0 ) 
                {
                  popIndent();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 52, functionExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "functionExpression"

    public class formalParameterList_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "formalParameterList"
    // AS3_ex.g3:2165:1: formalParameterList : L= LPAREN ( ( variableDeclaration (C= COMMA variableDeclaration )* (C= COMMA formalEllipsisParameter )? ) | formalEllipsisParameter )? R= RPAREN ;
    public AS3_exParser.formalParameterList_return formalParameterList() // throws RecognitionException [1]
    {   
        AS3_exParser.formalParameterList_return retval = new AS3_exParser.formalParameterList_return();
        retval.Start = input.LT(1);
        int formalParameterList_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        IToken C = null;
        IToken R = null;
        AS3_exParser.variableDeclaration_return variableDeclaration133 = null;

        AS3_exParser.variableDeclaration_return variableDeclaration134 = null;

        AS3_exParser.formalEllipsisParameter_return formalEllipsisParameter135 = null;

        AS3_exParser.formalEllipsisParameter_return formalEllipsisParameter136 = null;


        object L_tree=null;
        object C_tree=null;
        object R_tree=null;


            WrapOptions options=mPrinter.getMethodDeclWrapOptions();
            bool pushedFormat=false;
            bool pushedIndent=false;
            bool pushedWrapInfo=false;
            int firstParm=0;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 53) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2174:5: (L= LPAREN ( ( variableDeclaration (C= COMMA variableDeclaration )* (C= COMMA formalEllipsisParameter )? ) | formalEllipsisParameter )? R= RPAREN )
            // AS3_ex.g3:2175:3: L= LPAREN ( ( variableDeclaration (C= COMMA variableDeclaration )* (C= COMMA formalEllipsisParameter )? ) | formalEllipsisParameter )? R= RPAREN
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {

                            mInFunctionParameterDecl=true;
                            pushedFormat=pushFormatType(options, true);
                            mPrinter.setInParameterDecl(true);
                            pushedWrapInfo=pushWrapInfo(options, true);
                        
                }
                L=(IToken)Match(input,LPAREN,FOLLOW_LPAREN_in_formalParameterList7653); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {L_tree = (object)adaptor.Create(L);
                    adaptor.AddChild(root_0, L_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  insertWS(mPrinter.getSpacesBeforeFormalParameters());
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(L);insertWS(mPrinter.getAdvancedSpacesInsideParensInParameterLists());
                }
                // AS3_ex.g3:2182:9: ( ( variableDeclaration (C= COMMA variableDeclaration )* (C= COMMA formalEllipsisParameter )? ) | formalEllipsisParameter )?
                int alt79 = 3;
                int LA79_0 = input.LA(1);

                if ( (LA79_0 == NATIVE || LA79_0 == TO || (LA79_0 >= EACH && LA79_0 <= NAMESPACE) || (LA79_0 >= DYNAMIC && LA79_0 <= STATIC) || LA79_0 == IDENTIFIER) )
                {
                    alt79 = 1;
                }
                else if ( (LA79_0 == ELLIPSIS) )
                {
                    alt79 = 2;
                }
                switch (alt79) 
                {
                    case 1 :
                        // AS3_ex.g3:2182:11: ( variableDeclaration (C= COMMA variableDeclaration )* (C= COMMA formalEllipsisParameter )? )
                        {
                            // AS3_ex.g3:2182:11: ( variableDeclaration (C= COMMA variableDeclaration )* (C= COMMA formalEllipsisParameter )? )
                            // AS3_ex.g3:2182:13: variableDeclaration (C= COMMA variableDeclaration )* (C= COMMA formalEllipsisParameter )?
                            {
                                if ( state.backtracking == 0 ) 
                                {
                                  pushedIndent=pushLazyParmIndent(pushedIndent, options.getIndentStyle());
                                }
                                if ( state.backtracking == 0 ) 
                                {
                                  mPrinter.captureNextTextPosition();
                                }
                                PushFollow(FOLLOW_variableDeclaration_in_formalParameterList7674);
                                variableDeclaration133 = variableDeclaration();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, variableDeclaration133.Tree);
                                if ( state.backtracking == 0 ) 
                                {
                                  firstParm=mPrinter.getLastCapturePosition();
                                }
                                // AS3_ex.g3:2183:13: (C= COMMA variableDeclaration )*
                                do 
                                {
                                    int alt77 = 2;
                                    int LA77_0 = input.LA(1);

                                    if ( (LA77_0 == COMMA) )
                                    {
                                        int LA77_1 = input.LA(2);

                                        if ( (LA77_1 == NATIVE || LA77_1 == TO || (LA77_1 >= EACH && LA77_1 <= NAMESPACE) || (LA77_1 >= DYNAMIC && LA77_1 <= STATIC) || LA77_1 == IDENTIFIER) )
                                        {
                                            alt77 = 1;
                                        }


                                    }


                                    switch (alt77) 
                                    {
                                        case 1 :
                                            // AS3_ex.g3:2184:16: C= COMMA variableDeclaration
                                            {
                                                C=(IToken)Match(input,COMMA,FOLLOW_COMMA_in_formalParameterList7711); if (state.failed) return retval;
                                                if ( state.backtracking == 0 )
                                                {C_tree = (object)adaptor.Create(C);
                                                    adaptor.AddChild(root_0, C_tree);
                                                }
                                                if ( state.backtracking == 0 ) 
                                                {
                                                  pushedIndent=emitCommaWithSpacingAndCRs(options, C, pushedIndent, firstParm, ASPrettyPrinter.Break_SubType_Parameters);
                                                }
                                                PushFollow(FOLLOW_variableDeclaration_in_formalParameterList7746);
                                                variableDeclaration134 = variableDeclaration();
                                                state.followingStackPointer--;
                                                if (state.failed) return retval;
                                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, variableDeclaration134.Tree);

                                            }
                                            break;

                                        default:
                                            goto loop77;
                                    }
                                } while (true);

                                loop77:
                                    ;   // Stops C# compiler whining that label 'loop77' has no statements

                                // AS3_ex.g3:2188:13: (C= COMMA formalEllipsisParameter )?
                                int alt78 = 2;
                                int LA78_0 = input.LA(1);

                                if ( (LA78_0 == COMMA) )
                                {
                                    alt78 = 1;
                                }
                                switch (alt78) 
                                {
                                    case 1 :
                                        // AS3_ex.g3:2188:15: C= COMMA formalEllipsisParameter
                                        {
                                            C=(IToken)Match(input,COMMA,FOLLOW_COMMA_in_formalParameterList7781); if (state.failed) return retval;
                                            if ( state.backtracking == 0 )
                                            {C_tree = (object)adaptor.Create(C);
                                                adaptor.AddChild(root_0, C_tree);
                                            }
                                            if ( state.backtracking == 0 ) 
                                            {
                                              pushedIndent=emitCommaWithSpacingAndCRs(options, C, pushedIndent, firstParm, ASPrettyPrinter.Break_SubType_Parameters);
                                            }
                                            PushFollow(FOLLOW_formalEllipsisParameter_in_formalParameterList7786);
                                            formalEllipsisParameter135 = formalEllipsisParameter();
                                            state.followingStackPointer--;
                                            if (state.failed) return retval;
                                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, formalEllipsisParameter135.Tree);

                                        }
                                        break;

                                }


                            }


                        }
                        break;
                    case 2 :
                        // AS3_ex.g3:2190:14: formalEllipsisParameter
                        {
                            if ( state.backtracking == 0 ) 
                            {
                              pushedIndent=pushLazyParmIndent(pushedIndent, options.getIndentStyle());
                            }
                            PushFollow(FOLLOW_formalEllipsisParameter_in_formalParameterList7818);
                            formalEllipsisParameter136 = formalEllipsisParameter();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, formalEllipsisParameter136.Tree);

                        }
                        break;

                }

                R=(IToken)Match(input,RPAREN,FOLLOW_RPAREN_in_formalParameterList7836); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {R_tree = (object)adaptor.Create(R);
                    adaptor.AddChild(root_0, R_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  insertWS(mPrinter.getAdvancedSpacesInsideParensInParameterLists());emit(R);
                }
                if ( state.backtracking == 0 ) 
                {

                             mPrinter.setInParameterDecl(false);
                            if (pushedWrapInfo)
                                mPrinter.popWrapContext();
                            if (pushedIndent)
                                popIndent();
                            if (pushedFormat)
                            {
                                mPrinter.popFormatMode();
                            }
                            mInFunctionParameterDecl=false;
                          
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 53, formalParameterList_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "formalParameterList"

    public class formalEllipsisParameter_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "formalEllipsisParameter"
    // AS3_ex.g3:2208:1: formalEllipsisParameter : E= ELLIPSIS variableIdentifierDecl ;
    public AS3_exParser.formalEllipsisParameter_return formalEllipsisParameter() // throws RecognitionException [1]
    {   
        AS3_exParser.formalEllipsisParameter_return retval = new AS3_exParser.formalEllipsisParameter_return();
        retval.Start = input.LT(1);
        int formalEllipsisParameter_StartIndex = input.Index();
        object root_0 = null;

        IToken E = null;
        AS3_exParser.variableIdentifierDecl_return variableIdentifierDecl137 = null;


        object E_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 54) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2209:5: (E= ELLIPSIS variableIdentifierDecl )
            // AS3_ex.g3:2209:9: E= ELLIPSIS variableIdentifierDecl
            {
                root_0 = (object)adaptor.GetNilNode();

                E=(IToken)Match(input,ELLIPSIS,FOLLOW_ELLIPSIS_in_formalEllipsisParameter7883); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {E_tree = (object)adaptor.Create(E);
                    adaptor.AddChild(root_0, E_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(E);insertWS(1);
                }
                PushFollow(FOLLOW_variableIdentifierDecl_in_formalEllipsisParameter7888);
                variableIdentifierDecl137 = variableIdentifierDecl();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, variableIdentifierDecl137.Tree);

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 54, formalEllipsisParameter_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "formalEllipsisParameter"

    public class functionBody_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "functionBody"
    // AS3_ex.g3:2212:1: functionBody : L= LCURLY ( ( statement | functionDeclaration ) )* R= RCURLY ;
    public AS3_exParser.functionBody_return functionBody() // throws RecognitionException [1]
    {   
        AS3_exParser.functionBody_return retval = new AS3_exParser.functionBody_return();
        retval.Start = input.LT(1);
        int functionBody_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        IToken R = null;
        AS3_exParser.statement_return statement138 = null;

        AS3_exParser.functionDeclaration_return functionDeclaration139 = null;


        object L_tree=null;
        object R_tree=null;


            bool containsStatements=false;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 55) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2217:5: (L= LCURLY ( ( statement | functionDeclaration ) )* R= RCURLY )
            // AS3_ex.g3:2217:9: L= LCURLY ( ( statement | functionDeclaration ) )* R= RCURLY
            {
                root_0 = (object)adaptor.GetNilNode();

                L=(IToken)Match(input,LCURLY,FOLLOW_LCURLY_in_functionBody7917); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {L_tree = (object)adaptor.Create(L);
                    adaptor.AddChild(root_0, L_tree);
                }
                if ( state.backtracking == 0 ) 
                {

                            mCodeBlockStack.Add(mIsFunctionDecl ? ASPrettyPrinter.BraceContext_functionDecl_code : ASPrettyPrinter.BraceContext_functionExpression_code);
                            leftCurlyNewlineHandler(false);
                            emit(L);pushIndent(true);
                            {mPrinter.addDeclEqualsBlock();}
                            mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_block_code);
                            insertLines(mPrinter.getBlankLinesToStartFunctions(), false);
                        
                }
                // AS3_ex.g3:2226:7: ( ( statement | functionDeclaration ) )*
                do 
                {
                    int alt81 = 2;
                    int LA81_0 = input.LA(1);

                    if ( ((LA81_0 >= AS && LA81_0 <= LCURLY) || LA81_0 == LPAREN || LA81_0 == LBRACK || LA81_0 == LT || (LA81_0 >= PLUS && LA81_0 <= STAR) || (LA81_0 >= INC && LA81_0 <= DEC) || (LA81_0 >= NOT && LA81_0 <= INV) || (LA81_0 >= XML_AT && LA81_0 <= XML_LS_STD) || (LA81_0 >= SINGLE_QUOTE_LITERAL && LA81_0 <= DOUBLE_QUOTE_LITERAL) || LA81_0 == REGULAR_EXPR_LITERAL || LA81_0 == HEX_NUMBER_LITERAL || LA81_0 == DEC_NUMBER_LITERAL || LA81_0 == IDENTIFIER || (LA81_0 >= XML_COMMENT && LA81_0 <= XML_PI)) )
                    {
                        alt81 = 1;
                    }


                    switch (alt81) 
                    {
                        case 1 :
                            // AS3_ex.g3:2226:8: ( statement | functionDeclaration )
                            {
                                // AS3_ex.g3:2226:8: ( statement | functionDeclaration )
                                int alt80 = 2;
                                alt80 = dfa80.Predict(input);
                                switch (alt80) 
                                {
                                    case 1 :
                                        // AS3_ex.g3:2226:9: statement
                                        {
                                            PushFollow(FOLLOW_statement_in_functionBody7936);
                                            statement138 = statement();
                                            state.followingStackPointer--;
                                            if (state.failed) return retval;
                                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, statement138.Tree);

                                        }
                                        break;
                                    case 2 :
                                        // AS3_ex.g3:2226:21: functionDeclaration
                                        {
                                            PushFollow(FOLLOW_functionDeclaration_in_functionBody7940);
                                            functionDeclaration139 = functionDeclaration();
                                            state.followingStackPointer--;
                                            if (state.failed) return retval;
                                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, functionDeclaration139.Tree);

                                        }
                                        break;

                                }

                                if ( state.backtracking == 0 ) 
                                {
                                  containsStatements=true;
                                }

                            }
                            break;

                        default:
                            goto loop81;
                    }
                } while (true);

                loop81:
                    ;   // Stops C# compiler whining that label 'loop81' has no statements

                if ( state.backtracking == 0 ) 
                {
                  popIndent();
                }
                if ( state.backtracking == 0 ) 
                {
                  if (containsStatements)
                                insertLines(mPrinter.getBlankLinesToEndFunctions(), false);
                             else
                                mPrinter.clearAddedWhitespace();                
                            
                }
                if ( state.backtracking == 0 ) 
                {
                  mPrinter.popDeclEqualsBlock();
                }
                R=(IToken)Match(input,RCURLY,FOLLOW_RCURLY_in_functionBody7973); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {R_tree = (object)adaptor.Create(R);
                    adaptor.AddChild(root_0, R_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  insertCR(false);emit(R);popBlockStack();popBlockStack();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 55, functionBody_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "functionBody"

    public class memberModifiers_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "memberModifiers"
    // AS3_ex.g3:2240:1: memberModifiers : ( memberModifier )+ ;
    public AS3_exParser.memberModifiers_return memberModifiers() // throws RecognitionException [1]
    {   
        AS3_exParser.memberModifiers_return retval = new AS3_exParser.memberModifiers_return();
        retval.Start = input.LT(1);
        int memberModifiers_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.memberModifier_return memberModifier140 = null;



        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 56) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2241:5: ( ( memberModifier )+ )
            // AS3_ex.g3:2241:9: ( memberModifier )+
            {
                root_0 = (object)adaptor.GetNilNode();

                // AS3_ex.g3:2241:9: ( memberModifier )+
                int cnt82 = 0;
                do 
                {
                    int alt82 = 2;
                    int LA82_0 = input.LA(1);

                    if ( (LA82_0 == IDENTIFIER) )
                    {
                        int LA82_2 = input.LA(2);

                        if ( (synpred169_AS3_ex()) )
                        {
                            alt82 = 1;
                        }


                    }
                    else if ( (LA82_0 == INTERNAL || LA82_0 == NATIVE || (LA82_0 >= PRIVATE && LA82_0 <= PUBLIC) || (LA82_0 >= DYNAMIC && LA82_0 <= STATIC)) )
                    {
                        alt82 = 1;
                    }


                    switch (alt82) 
                    {
                        case 1 :
                            // AS3_ex.g3:0:0: memberModifier
                            {
                                PushFollow(FOLLOW_memberModifier_in_memberModifiers8001);
                                memberModifier140 = memberModifier();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, memberModifier140.Tree);

                            }
                            break;

                        default:
                            if ( cnt82 >= 1 ) goto loop82;
                            if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                                EarlyExitException eee =
                                    new EarlyExitException(82, input);
                                throw eee;
                    }
                    cnt82++;
                } while (true);

                loop82:
                    ;   // Stops C# compiler whinging that label 'loop82' has no statements


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 56, memberModifiers_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "memberModifiers"

    public class memberModifier_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "memberModifier"
    // AS3_ex.g3:2248:1: memberModifier : x= ( DYNAMIC | FINAL | INTERNAL | NATIVE | OVERRIDE | PRIVATE | PROTECTED | PUBLIC | STATIC | IDENTIFIER ) ;
    public AS3_exParser.memberModifier_return memberModifier() // throws RecognitionException [1]
    {   
        AS3_exParser.memberModifier_return retval = new AS3_exParser.memberModifier_return();
        retval.Start = input.LT(1);
        int memberModifier_StartIndex = input.Index();
        object root_0 = null;

        IToken x = null;

        object x_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 57) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2249:5: (x= ( DYNAMIC | FINAL | INTERNAL | NATIVE | OVERRIDE | PRIVATE | PROTECTED | PUBLIC | STATIC | IDENTIFIER ) )
            // AS3_ex.g3:2249:9: x= ( DYNAMIC | FINAL | INTERNAL | NATIVE | OVERRIDE | PRIVATE | PROTECTED | PUBLIC | STATIC | IDENTIFIER )
            {
                root_0 = (object)adaptor.GetNilNode();

                x = (IToken)input.LT(1);
                if ( input.LA(1) == INTERNAL || input.LA(1) == NATIVE || (input.LA(1) >= PRIVATE && input.LA(1) <= PUBLIC) || (input.LA(1) >= DYNAMIC && input.LA(1) <= STATIC) || input.LA(1) == IDENTIFIER ) 
                {
                    input.Consume();
                    if ( state.backtracking == 0 ) adaptor.AddChild(root_0, (object)adaptor.Create(x));
                    state.errorRecovery = false;state.failed = false;
                }
                else 
                {
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    MismatchedSetException mse = new MismatchedSetException(null,input);
                    throw mse;
                }

                if ( state.backtracking == 0 ) 
                {
                  emit(x);
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 57, memberModifier_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "memberModifier"

    public class statement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "statement"
    // AS3_ex.g3:2270:1: statement : ( blockStatement | directive | namespaceDirective | constantVarStatement | tryStatement | switchStatement | withStatement | returnStatement | breakStatement | continueStatement | forStatement | forInStatement | forEachInStatement | doWhileStatement | whileStatement | ifStatement | variableStatement | throwStatement | labelledStatement | expression semic | emptyStatement ) ;
    public AS3_exParser.statement_return statement() // throws RecognitionException [1]
    {   
        AS3_exParser.statement_return retval = new AS3_exParser.statement_return();
        retval.Start = input.LT(1);
        int statement_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.blockStatement_return blockStatement141 = null;

        AS3_exParser.directive_return directive142 = null;

        AS3_exParser.namespaceDirective_return namespaceDirective143 = null;

        AS3_exParser.constantVarStatement_return constantVarStatement144 = null;

        AS3_exParser.tryStatement_return tryStatement145 = null;

        AS3_exParser.switchStatement_return switchStatement146 = null;

        AS3_exParser.withStatement_return withStatement147 = null;

        AS3_exParser.returnStatement_return returnStatement148 = null;

        AS3_exParser.breakStatement_return breakStatement149 = null;

        AS3_exParser.continueStatement_return continueStatement150 = null;

        AS3_exParser.forStatement_return forStatement151 = null;

        AS3_exParser.forInStatement_return forInStatement152 = null;

        AS3_exParser.forEachInStatement_return forEachInStatement153 = null;

        AS3_exParser.doWhileStatement_return doWhileStatement154 = null;

        AS3_exParser.whileStatement_return whileStatement155 = null;

        AS3_exParser.ifStatement_return ifStatement156 = null;

        AS3_exParser.variableStatement_return variableStatement157 = null;

        AS3_exParser.throwStatement_return throwStatement158 = null;

        AS3_exParser.labelledStatement_return labelledStatement159 = null;

        AS3_exParser.expression_return expression160 = null;

        AS3_exParser.semic_return semic161 = null;

        AS3_exParser.emptyStatement_return emptyStatement162 = null;



        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 58) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2271:5: ( ( blockStatement | directive | namespaceDirective | constantVarStatement | tryStatement | switchStatement | withStatement | returnStatement | breakStatement | continueStatement | forStatement | forInStatement | forEachInStatement | doWhileStatement | whileStatement | ifStatement | variableStatement | throwStatement | labelledStatement | expression semic | emptyStatement ) )
            // AS3_ex.g3:2272:6: ( blockStatement | directive | namespaceDirective | constantVarStatement | tryStatement | switchStatement | withStatement | returnStatement | breakStatement | continueStatement | forStatement | forInStatement | forEachInStatement | doWhileStatement | whileStatement | ifStatement | variableStatement | throwStatement | labelledStatement | expression semic | emptyStatement )
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  mStatementCount++;
                }
                // AS3_ex.g3:2273:5: ( blockStatement | directive | namespaceDirective | constantVarStatement | tryStatement | switchStatement | withStatement | returnStatement | breakStatement | continueStatement | forStatement | forInStatement | forEachInStatement | doWhileStatement | whileStatement | ifStatement | variableStatement | throwStatement | labelledStatement | expression semic | emptyStatement )
                int alt83 = 21;
                alt83 = dfa83.Predict(input);
                switch (alt83) 
                {
                    case 1 :
                        // AS3_ex.g3:2273:7: blockStatement
                        {
                            if ( state.backtracking == 0 ) 
                            {
                              mPrinter.inOther();
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              setBlockFlag(true);
                            }
                            PushFollow(FOLLOW_blockStatement_in_statement8177);
                            blockStatement141 = blockStatement();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, blockStatement141.Tree);

                        }
                        break;
                    case 2 :
                        // AS3_ex.g3:2274:9: directive
                        {
                            if ( state.backtracking == 0 ) 
                            {
                              insertStatementCR();
                            }
                            PushFollow(FOLLOW_directive_in_statement8188);
                            directive142 = directive();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, directive142.Tree);

                        }
                        break;
                    case 3 :
                        // AS3_ex.g3:2275:9: namespaceDirective
                        {
                            if ( state.backtracking == 0 ) 
                            {
                              insertStatementCR();
                            }
                            PushFollow(FOLLOW_namespaceDirective_in_statement8199);
                            namespaceDirective143 = namespaceDirective();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, namespaceDirective143.Tree);

                        }
                        break;
                    case 4 :
                        // AS3_ex.g3:2276:9: constantVarStatement
                        {
                            if ( state.backtracking == 0 ) 
                            {
                              insertStatementCR();
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              pushLazyIndent();
                            }
                            PushFollow(FOLLOW_constantVarStatement_in_statement8212);
                            constantVarStatement144 = constantVarStatement();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, constantVarStatement144.Tree);
                            if ( state.backtracking == 0 ) 
                            {
                              popIndent();
                            }

                        }
                        break;
                    case 5 :
                        // AS3_ex.g3:2277:9: tryStatement
                        {
                            if ( state.backtracking == 0 ) 
                            {
                              markBlockFlag();insertLines(mPrinter.getBlankLinesBeforeControlStatement());
                            }
                            PushFollow(FOLLOW_tryStatement_in_statement8225);
                            tryStatement145 = tryStatement();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, tryStatement145.Tree);

                        }
                        break;
                    case 6 :
                        // AS3_ex.g3:2278:9: switchStatement
                        {
                            if ( state.backtracking == 0 ) 
                            {
                              markBlockFlag();
                            }
                            PushFollow(FOLLOW_switchStatement_in_statement8237);
                            switchStatement146 = switchStatement();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, switchStatement146.Tree);

                        }
                        break;
                    case 7 :
                        // AS3_ex.g3:2279:9: withStatement
                        {
                            if ( state.backtracking == 0 ) 
                            {
                              markBlockFlag();insertLines(mPrinter.getBlankLinesBeforeControlStatement());
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              insertStatementCR();
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_controlStatement_code);
                            }
                            PushFollow(FOLLOW_withStatement_in_statement8251);
                            withStatement147 = withStatement();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, withStatement147.Tree);
                            if ( state.backtracking == 0 ) 
                            {
                              popBlockStack();
                            }

                        }
                        break;
                    case 8 :
                        // AS3_ex.g3:2280:9: returnStatement
                        {
                            if ( state.backtracking == 0 ) 
                            {
                              pushLazyIndent();
                            }
                            PushFollow(FOLLOW_returnStatement_in_statement8265);
                            returnStatement148 = returnStatement();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, returnStatement148.Tree);
                            if ( state.backtracking == 0 ) 
                            {
                              popIndent();
                            }

                        }
                        break;
                    case 9 :
                        // AS3_ex.g3:2281:9: breakStatement
                        {
                            if ( state.backtracking == 0 ) 
                            {
                              pushLazyIndent();
                            }
                            PushFollow(FOLLOW_breakStatement_in_statement8279);
                            breakStatement149 = breakStatement();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, breakStatement149.Tree);
                            if ( state.backtracking == 0 ) 
                            {
                              popIndent();
                            }

                        }
                        break;
                    case 10 :
                        // AS3_ex.g3:2282:9: continueStatement
                        {
                            if ( state.backtracking == 0 ) 
                            {
                              pushLazyIndent();
                            }
                            PushFollow(FOLLOW_continueStatement_in_statement8293);
                            continueStatement150 = continueStatement();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, continueStatement150.Tree);
                            if ( state.backtracking == 0 ) 
                            {
                              popIndent();
                            }

                        }
                        break;
                    case 11 :
                        // AS3_ex.g3:2283:9: forStatement
                        {
                            if ( state.backtracking == 0 ) 
                            {
                              mPrinter.inLoop();
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              markBlockFlag();insertLines(mPrinter.getBlankLinesBeforeControlStatement());
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              insertStatementCR();
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_controlStatement_code);
                            }
                            PushFollow(FOLLOW_forStatement_in_statement8310);
                            forStatement151 = forStatement();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, forStatement151.Tree);
                            if ( state.backtracking == 0 ) 
                            {
                              popBlockStack();
                            }

                        }
                        break;
                    case 12 :
                        // AS3_ex.g3:2284:9: forInStatement
                        {
                            if ( state.backtracking == 0 ) 
                            {
                              mPrinter.inLoop();
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              markBlockFlag();insertLines(mPrinter.getBlankLinesBeforeControlStatement());
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              insertStatementCR();
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_controlStatement_code);
                            }
                            PushFollow(FOLLOW_forInStatement_in_statement8327);
                            forInStatement152 = forInStatement();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, forInStatement152.Tree);
                            if ( state.backtracking == 0 ) 
                            {
                              popBlockStack();
                            }

                        }
                        break;
                    case 13 :
                        // AS3_ex.g3:2285:9: forEachInStatement
                        {
                            if ( state.backtracking == 0 ) 
                            {
                              mPrinter.inLoop();
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              markBlockFlag();insertLines(mPrinter.getBlankLinesBeforeControlStatement());
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              insertStatementCR();
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_controlStatement_code);
                            }
                            PushFollow(FOLLOW_forEachInStatement_in_statement8344);
                            forEachInStatement153 = forEachInStatement();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, forEachInStatement153.Tree);
                            if ( state.backtracking == 0 ) 
                            {
                              popBlockStack();
                            }

                        }
                        break;
                    case 14 :
                        // AS3_ex.g3:2286:9: doWhileStatement
                        {
                            if ( state.backtracking == 0 ) 
                            {
                              mPrinter.inLoop();
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              markBlockFlag();insertLines(mPrinter.getBlankLinesBeforeControlStatement());
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              insertStatementCR();
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_controlStatement_code);
                            }
                            PushFollow(FOLLOW_doWhileStatement_in_statement8361);
                            doWhileStatement154 = doWhileStatement();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, doWhileStatement154.Tree);
                            if ( state.backtracking == 0 ) 
                            {
                              popBlockStack();
                            }

                        }
                        break;
                    case 15 :
                        // AS3_ex.g3:2287:9: whileStatement
                        {
                            if ( state.backtracking == 0 ) 
                            {
                              mPrinter.inLoop();
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              markBlockFlag();insertLines(mPrinter.getBlankLinesBeforeControlStatement());
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              insertStatementCR();
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_controlStatement_code);
                            }
                            PushFollow(FOLLOW_whileStatement_in_statement8378);
                            whileStatement155 = whileStatement();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, whileStatement155.Tree);
                            if ( state.backtracking == 0 ) 
                            {
                              popBlockStack();
                            }

                        }
                        break;
                    case 16 :
                        // AS3_ex.g3:2288:9: ifStatement
                        {
                            if ( state.backtracking == 0 ) 
                            {
                              mPrinter.inCondition();
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              insertLines(mPrinter.getBlankLinesBeforeControlStatement());
                            }
                            PushFollow(FOLLOW_ifStatement_in_statement8393);
                            ifStatement156 = ifStatement();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, ifStatement156.Tree);

                        }
                        break;
                    case 17 :
                        // AS3_ex.g3:2289:9: variableStatement
                        {
                            if ( state.backtracking == 0 ) 
                            {
                              insertStatementCR();
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              pushLazyIndent();
                            }
                            PushFollow(FOLLOW_variableStatement_in_statement8407);
                            variableStatement157 = variableStatement();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, variableStatement157.Tree);
                            if ( state.backtracking == 0 ) 
                            {
                              popIndent();
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              mPrinter.adjustLastLineIndent();
                            }

                        }
                        break;
                    case 18 :
                        // AS3_ex.g3:2290:9: throwStatement
                        {
                            if ( state.backtracking == 0 ) 
                            {
                              pushLazyIndent();
                            }
                            PushFollow(FOLLOW_throwStatement_in_statement8422);
                            throwStatement158 = throwStatement();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, throwStatement158.Tree);
                            if ( state.backtracking == 0 ) 
                            {
                              popIndent();
                            }

                        }
                        break;
                    case 19 :
                        // AS3_ex.g3:2291:9: labelledStatement
                        {
                            if ( state.backtracking == 0 ) 
                            {
                              insertLines(mPrinter.getBlankLinesBeforeControlStatement());
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              insertStatementCR();
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_controlStatement_code);
                            }
                            PushFollow(FOLLOW_labelledStatement_in_statement8438);
                            labelledStatement159 = labelledStatement();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, labelledStatement159.Tree);
                            if ( state.backtracking == 0 ) 
                            {
                              popBlockStack();
                            }

                        }
                        break;
                    case 20 :
                        // AS3_ex.g3:2292:9: expression semic
                        {
                            if ( state.backtracking == 0 ) 
                            {
                              pushLazyIndent();
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              mPrinter.markDeclEqualsContextChange();
                            }
                            if ( state.backtracking == 0 ) 
                            {

                                            if (mPrinter.statementNeedsCR(input.LT(1)))
                                                insertStatementCR();
                                            else
                                                insertWS(1);
                                        
                            }
                            PushFollow(FOLLOW_expression_in_statement8470);
                            expression160 = expression();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, expression160.Tree);
                            PushFollow(FOLLOW_semic_in_statement8472);
                            semic161 = semic();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, semic161.Tree);
                            if ( state.backtracking == 0 ) 
                            {
                              popIndent();
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              mPrinter.adjustLastLineIndent();
                            }

                        }
                        break;
                    case 21 :
                        // AS3_ex.g3:2300:9: emptyStatement
                        {
                            if ( state.backtracking == 0 ) 
                            {
                              if (mPrinter.isEmptyStatementsOnNewLine())insertStatementCR();
                            }
                            PushFollow(FOLLOW_emptyStatement_in_statement8487);
                            emptyStatement162 = emptyStatement();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, emptyStatement162.Tree);

                        }
                        break;

                }

                if ( state.backtracking == 0 ) 
                {
                  mPrinter.inOther();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 58, statement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "statement"

    public class blockStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "blockStatement"
    // AS3_ex.g3:2310:1: blockStatement : (conditionalToken= conditionalCompilerOption )? L= LCURLY ( statement )* R= RCURLY ;
    public AS3_exParser.blockStatement_return blockStatement() // throws RecognitionException [1]
    {   
        AS3_exParser.blockStatement_return retval = new AS3_exParser.blockStatement_return();
        retval.Start = input.LT(1);
        int blockStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        IToken R = null;
        AS3_exParser.conditionalCompilerOption_return conditionalToken = null;

        AS3_exParser.statement_return statement163 = null;


        object L_tree=null;
        object R_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 59) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2311:5: ( (conditionalToken= conditionalCompilerOption )? L= LCURLY ( statement )* R= RCURLY )
            // AS3_ex.g3:2311:9: (conditionalToken= conditionalCompilerOption )? L= LCURLY ( statement )* R= RCURLY
            {
                root_0 = (object)adaptor.GetNilNode();

                // AS3_ex.g3:2311:9: (conditionalToken= conditionalCompilerOption )?
                int alt84 = 2;
                int LA84_0 = input.LA(1);

                if ( (LA84_0 == NATIVE || LA84_0 == TO || (LA84_0 >= EACH && LA84_0 <= NAMESPACE) || (LA84_0 >= DYNAMIC && LA84_0 <= STATIC) || LA84_0 == IDENTIFIER) )
                {
                    alt84 = 1;
                }
                switch (alt84) 
                {
                    case 1 :
                        // AS3_ex.g3:2311:10: conditionalToken= conditionalCompilerOption
                        {
                            if ( state.backtracking == 0 ) 
                            {
                              insertCR(false);
                            }
                            PushFollow(FOLLOW_conditionalCompilerOption_in_blockStatement8529);
                            conditionalToken = conditionalCompilerOption();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, conditionalToken.Tree);

                        }
                        break;

                }

                L=(IToken)Match(input,LCURLY,FOLLOW_LCURLY_in_blockStatement8535); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {L_tree = (object)adaptor.Create(L);
                    adaptor.AddChild(root_0, L_tree);
                }
                if ( state.backtracking == 0 ) 
                {

                            if (conditionalToken!=null)
                                mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_Conditional_code);
                            leftCurlyNewlineHandler(conditionalToken==null); //if we have a conditional setting, then we want to have the option of keeping the brace on the same line
                            emit(L);
                }
                if ( state.backtracking == 0 ) 
                {
                  pushIndent(true);
                            {mPrinter.addDeclEqualsBlock();}
                            mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_block_code);
                        
                }
                // AS3_ex.g3:2320:6: ( statement )*
                do 
                {
                    int alt85 = 2;
                    int LA85_0 = input.LA(1);

                    if ( ((LA85_0 >= AS && LA85_0 <= LCURLY) || LA85_0 == LPAREN || LA85_0 == LBRACK || LA85_0 == LT || (LA85_0 >= PLUS && LA85_0 <= STAR) || (LA85_0 >= INC && LA85_0 <= DEC) || (LA85_0 >= NOT && LA85_0 <= INV) || (LA85_0 >= XML_AT && LA85_0 <= XML_LS_STD) || (LA85_0 >= SINGLE_QUOTE_LITERAL && LA85_0 <= DOUBLE_QUOTE_LITERAL) || LA85_0 == REGULAR_EXPR_LITERAL || LA85_0 == HEX_NUMBER_LITERAL || LA85_0 == DEC_NUMBER_LITERAL || LA85_0 == IDENTIFIER || (LA85_0 >= XML_COMMENT && LA85_0 <= XML_PI)) )
                    {
                        alt85 = 1;
                    }


                    switch (alt85) 
                    {
                        case 1 :
                            // AS3_ex.g3:0:0: statement
                            {
                                PushFollow(FOLLOW_statement_in_blockStatement8552);
                                statement163 = statement();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, statement163.Tree);

                            }
                            break;

                        default:
                            goto loop85;
                    }
                } while (true);

                loop85:
                    ;   // Stops C# compiler whining that label 'loop85' has no statements

                if ( state.backtracking == 0 ) 
                {
                  popIndent();
                }
                if ( state.backtracking == 0 ) 
                {
                  mPrinter.popDeclEqualsBlock();
                }
                R=(IToken)Match(input,RCURLY,FOLLOW_RCURLY_in_blockStatement8572); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {R_tree = (object)adaptor.Create(R);
                    adaptor.AddChild(root_0, R_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  insertCR(false);emit(R);popBlockStack();if (conditionalToken!=null) popBlockStack();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 59, blockStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "blockStatement"

    public class throwStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "throwStatement"
    // AS3_ex.g3:2327:1: throwStatement : T= THROW expression semic ;
    public AS3_exParser.throwStatement_return throwStatement() // throws RecognitionException [1]
    {   
        AS3_exParser.throwStatement_return retval = new AS3_exParser.throwStatement_return();
        retval.Start = input.LT(1);
        int throwStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken T = null;
        AS3_exParser.expression_return expression164 = null;

        AS3_exParser.semic_return semic165 = null;


        object T_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 60) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2328:2: (T= THROW expression semic )
            // AS3_ex.g3:2328:5: T= THROW expression semic
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  mPrinter.markDeclEqualsContextChange();
                }
                T=(IToken)Match(input,THROW,FOLLOW_THROW_in_throwStatement8597); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {T_tree = (object)adaptor.Create(T);
                    adaptor.AddChild(root_0, T_tree);
                }
                if ( state.backtracking == 0 ) 
                {

                            if (mPrinter.statementNeedsCR(T))
                                insertStatementCR();
                            else
                                insertWS(1);
                        
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(T);
                }
                PushFollow(FOLLOW_expression_in_throwStatement8608);
                expression164 = expression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, expression164.Tree);
                PushFollow(FOLLOW_semic_in_throwStatement8610);
                semic165 = semic();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, semic165.Tree);

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 60, throwStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "throwStatement"

    public class constantVarStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "constantVarStatement"
    // AS3_ex.g3:2341:1: constantVarStatement : C= CONST variableDeclarationList (S= SEMI )? ;
    public AS3_exParser.constantVarStatement_return constantVarStatement() // throws RecognitionException [1]
    {   
        AS3_exParser.constantVarStatement_return retval = new AS3_exParser.constantVarStatement_return();
        retval.Start = input.LT(1);
        int constantVarStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken C = null;
        IToken S = null;
        AS3_exParser.variableDeclarationList_return variableDeclarationList166 = null;


        object C_tree=null;
        object S_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 61) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2342:5: (C= CONST variableDeclarationList (S= SEMI )? )
            // AS3_ex.g3:2343:5: C= CONST variableDeclarationList (S= SEMI )?
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  mInEqualAlignDecl=true;
                }
                C=(IToken)Match(input,CONST,FOLLOW_CONST_in_constantVarStatement8641); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {C_tree = (object)adaptor.Create(C);
                    adaptor.AddChild(root_0, C_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(C);
                }
                PushFollow(FOLLOW_variableDeclarationList_in_constantVarStatement8646);
                variableDeclarationList166 = variableDeclarationList();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, variableDeclarationList166.Tree);
                // AS3_ex.g3:2344:50: (S= SEMI )?
                int alt86 = 2;
                int LA86_0 = input.LA(1);

                if ( (LA86_0 == SEMI) )
                {
                    int LA86_1 = input.LA(2);

                    if ( (synpred201_AS3_ex()) )
                    {
                        alt86 = 1;
                    }
                }
                switch (alt86) 
                {
                    case 1 :
                        // AS3_ex.g3:2344:51: S= SEMI
                        {
                            S=(IToken)Match(input,SEMI,FOLLOW_SEMI_in_constantVarStatement8651); if (state.failed) return retval;
                            if ( state.backtracking == 0 )
                            {S_tree = (object)adaptor.Create(S);
                                adaptor.AddChild(root_0, S_tree);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              emit(S);
                            }

                        }
                        break;

                }

                if ( state.backtracking == 0 ) 
                {
                  mInEqualAlignDecl=false;
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 61, constantVarStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "constantVarStatement"

    public class useNamespaceDirective_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "useNamespaceDirective"
    // AS3_ex.g3:2350:1: useNamespaceDirective : U= USE N= NAMESPACE qualifiedIdentifier (C= COMMA qualifiedIdentifier )* semic ;
    public AS3_exParser.useNamespaceDirective_return useNamespaceDirective() // throws RecognitionException [1]
    {   
        AS3_exParser.useNamespaceDirective_return retval = new AS3_exParser.useNamespaceDirective_return();
        retval.Start = input.LT(1);
        int useNamespaceDirective_StartIndex = input.Index();
        object root_0 = null;

        IToken U = null;
        IToken N = null;
        IToken C = null;
        AS3_exParser.qualifiedIdentifier_return qualifiedIdentifier167 = null;

        AS3_exParser.qualifiedIdentifier_return qualifiedIdentifier168 = null;

        AS3_exParser.semic_return semic169 = null;


        object U_tree=null;
        object N_tree=null;
        object C_tree=null;


            bool pushedIndent=false;
            bool pushedFormat=false;
            bool pushedWrapInfo=false;
         WrapOptions options=mPrinter.getExpressionWrapOptions();

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 62) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2357:2: (U= USE N= NAMESPACE qualifiedIdentifier (C= COMMA qualifiedIdentifier )* semic )
            // AS3_ex.g3:2358:6: U= USE N= NAMESPACE qualifiedIdentifier (C= COMMA qualifiedIdentifier )* semic
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  pushedFormat=pushFormatType(options, true);
                         pushedWrapInfo=pushWrapInfo(options, true);
                        
                }
                if ( state.backtracking == 0 ) 
                {
                  mPrinter.markDeclEqualsContextChange();
                }
                U=(IToken)Match(input,USE,FOLLOW_USE_in_useNamespaceDirective8699); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {U_tree = (object)adaptor.Create(U);
                    adaptor.AddChild(root_0, U_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(U);
                }
                N=(IToken)Match(input,NAMESPACE,FOLLOW_NAMESPACE_in_useNamespaceDirective8708); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {N_tree = (object)adaptor.Create(N);
                    adaptor.AddChild(root_0, N_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(N);
                }
                PushFollow(FOLLOW_qualifiedIdentifier_in_useNamespaceDirective8715);
                qualifiedIdentifier167 = qualifiedIdentifier();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, qualifiedIdentifier167.Tree);
                // AS3_ex.g3:2364:22: (C= COMMA qualifiedIdentifier )*
                do 
                {
                    int alt87 = 2;
                    int LA87_0 = input.LA(1);

                    if ( (LA87_0 == COMMA) )
                    {
                        alt87 = 1;
                    }


                    switch (alt87) 
                    {
                        case 1 :
                            // AS3_ex.g3:2364:23: C= COMMA qualifiedIdentifier
                            {
                                C=(IToken)Match(input,COMMA,FOLLOW_COMMA_in_useNamespaceDirective8720); if (state.failed) return retval;
                                if ( state.backtracking == 0 )
                                {C_tree = (object)adaptor.Create(C);
                                    adaptor.AddChild(root_0, C_tree);
                                }
                                if ( state.backtracking == 0 ) 
                                {
                                  pushedIndent=emitCommaWithSpacingAndCRs(options, C, pushedIndent, -1, ASPrettyPrinter.Break_SubType_Other);
                                }
                                PushFollow(FOLLOW_qualifiedIdentifier_in_useNamespaceDirective8724);
                                qualifiedIdentifier168 = qualifiedIdentifier();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, qualifiedIdentifier168.Tree);

                            }
                            break;

                        default:
                            goto loop87;
                    }
                } while (true);

                loop87:
                    ;   // Stops C# compiler whining that label 'loop87' has no statements

                PushFollow(FOLLOW_semic_in_useNamespaceDirective8728);
                semic169 = semic();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, semic169.Tree);
                if ( state.backtracking == 0 ) 
                {

                        if (pushedWrapInfo)
                            mPrinter.popWrapContext();
                          if (pushedIndent)
                            popIndent();
                        if (pushedFormat)
                        {
                            mPrinter.popFormatMode();
                        }
                    
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 62, useNamespaceDirective_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "useNamespaceDirective"

    public class namespaceDirective_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "namespaceDirective"
    // AS3_ex.g3:2380:1: namespaceDirective : N= NAMESPACE qualifiedIdentifier (A= ASSIGN stringLiteral )? semic ;
    public AS3_exParser.namespaceDirective_return namespaceDirective() // throws RecognitionException [1]
    {   
        AS3_exParser.namespaceDirective_return retval = new AS3_exParser.namespaceDirective_return();
        retval.Start = input.LT(1);
        int namespaceDirective_StartIndex = input.Index();
        object root_0 = null;

        IToken N = null;
        IToken A = null;
        AS3_exParser.qualifiedIdentifier_return qualifiedIdentifier170 = null;

        AS3_exParser.stringLiteral_return stringLiteral171 = null;

        AS3_exParser.semic_return semic172 = null;


        object N_tree=null;
        object A_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 63) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2381:5: (N= NAMESPACE qualifiedIdentifier (A= ASSIGN stringLiteral )? semic )
            // AS3_ex.g3:2382:5: N= NAMESPACE qualifiedIdentifier (A= ASSIGN stringLiteral )? semic
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  mPrinter.markDeclEqualsContextChange();
                }
                N=(IToken)Match(input,NAMESPACE,FOLLOW_NAMESPACE_in_namespaceDirective8767); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {N_tree = (object)adaptor.Create(N);
                    adaptor.AddChild(root_0, N_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(N);
                }
                if ( state.backtracking == 0 ) 
                {
                  pushExpressionIndent();
                }
                PushFollow(FOLLOW_qualifiedIdentifier_in_namespaceDirective8778);
                qualifiedIdentifier170 = qualifiedIdentifier();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, qualifiedIdentifier170.Tree);
                // AS3_ex.g3:2384:25: (A= ASSIGN stringLiteral )?
                int alt88 = 2;
                int LA88_0 = input.LA(1);

                if ( (LA88_0 == ASSIGN) )
                {
                    alt88 = 1;
                }
                switch (alt88) 
                {
                    case 1 :
                        // AS3_ex.g3:2384:27: A= ASSIGN stringLiteral
                        {
                            A=(IToken)Match(input,ASSIGN,FOLLOW_ASSIGN_in_namespaceDirective8784); if (state.failed) return retval;
                            if ( state.backtracking == 0 )
                            {A_tree = (object)adaptor.Create(A);
                                adaptor.AddChild(root_0, A_tree);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              insertWS(mPrinter.getSpacesAroundAssignment());emit(A);insertWS(mPrinter.getSpacesAroundAssignment());
                            }
                            PushFollow(FOLLOW_stringLiteral_in_namespaceDirective8789);
                            stringLiteral171 = stringLiteral();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, stringLiteral171.Tree);

                        }
                        break;

                }

                PushFollow(FOLLOW_semic_in_namespaceDirective8794);
                semic172 = semic();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, semic172.Tree);
                if ( state.backtracking == 0 ) 
                {
                  popIndent();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 63, namespaceDirective_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "namespaceDirective"

    public class tryStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "tryStatement"
    // AS3_ex.g3:2392:1: tryStatement : T= TRY blockStatement ( ( catchClause )+ finallyClause | ( catchClause )+ | finallyClause ) ;
    public AS3_exParser.tryStatement_return tryStatement() // throws RecognitionException [1]
    {   
        AS3_exParser.tryStatement_return retval = new AS3_exParser.tryStatement_return();
        retval.Start = input.LT(1);
        int tryStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken T = null;
        AS3_exParser.blockStatement_return blockStatement173 = null;

        AS3_exParser.catchClause_return catchClause174 = null;

        AS3_exParser.finallyClause_return finallyClause175 = null;

        AS3_exParser.catchClause_return catchClause176 = null;

        AS3_exParser.finallyClause_return finallyClause177 = null;


        object T_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 64) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2393:5: (T= TRY blockStatement ( ( catchClause )+ finallyClause | ( catchClause )+ | finallyClause ) )
            // AS3_ex.g3:2394:5: T= TRY blockStatement ( ( catchClause )+ finallyClause | ( catchClause )+ | finallyClause )
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  mPrinter.markDeclEqualsContextChange();
                }
                if ( state.backtracking == 0 ) 
                {
                  insertStatementCR();
                }
                T=(IToken)Match(input,TRY,FOLLOW_TRY_in_tryStatement8833); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {T_tree = (object)adaptor.Create(T);
                    adaptor.AddChild(root_0, T_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(T);
                }
                if ( state.backtracking == 0 ) 
                {
                  pushIndent(false);mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_try_code);
                }
                PushFollow(FOLLOW_blockStatement_in_tryStatement8839);
                blockStatement173 = blockStatement();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, blockStatement173.Tree);
                if ( state.backtracking == 0 ) 
                {
                  popIndent();popBlockStack();
                }
                // AS3_ex.g3:2396:9: ( ( catchClause )+ finallyClause | ( catchClause )+ | finallyClause )
                int alt91 = 3;
                int LA91_0 = input.LA(1);

                if ( (LA91_0 == CATCH) )
                {
                    int LA91_1 = input.LA(2);

                    if ( (synpred205_AS3_ex()) )
                    {
                        alt91 = 1;
                    }
                    else if ( (synpred207_AS3_ex()) )
                    {
                        alt91 = 2;
                    }
                    else 
                    {
                        if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                        NoViableAltException nvae_d91s1 =
                            new NoViableAltException("", 91, 1, input);

                        throw nvae_d91s1;
                    }
                }
                else if ( (LA91_0 == FINALLY) )
                {
                    alt91 = 3;
                }
                else 
                {
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    NoViableAltException nvae_d91s0 =
                        new NoViableAltException("", 91, 0, input);

                    throw nvae_d91s0;
                }
                switch (alt91) 
                {
                    case 1 :
                        // AS3_ex.g3:2396:11: ( catchClause )+ finallyClause
                        {
                            // AS3_ex.g3:2396:11: ( catchClause )+
                            int cnt89 = 0;
                            do 
                            {
                                int alt89 = 2;
                                int LA89_0 = input.LA(1);

                                if ( (LA89_0 == CATCH) )
                                {
                                    alt89 = 1;
                                }


                                switch (alt89) 
                                {
                                    case 1 :
                                        // AS3_ex.g3:0:0: catchClause
                                        {
                                            PushFollow(FOLLOW_catchClause_in_tryStatement8853);
                                            catchClause174 = catchClause();
                                            state.followingStackPointer--;
                                            if (state.failed) return retval;
                                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, catchClause174.Tree);

                                        }
                                        break;

                                    default:
                                        if ( cnt89 >= 1 ) goto loop89;
                                        if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                                            EarlyExitException eee =
                                                new EarlyExitException(89, input);
                                            throw eee;
                                }
                                cnt89++;
                            } while (true);

                            loop89:
                                ;   // Stops C# compiler whinging that label 'loop89' has no statements

                            PushFollow(FOLLOW_finallyClause_in_tryStatement8856);
                            finallyClause175 = finallyClause();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, finallyClause175.Tree);

                        }
                        break;
                    case 2 :
                        // AS3_ex.g3:2397:11: ( catchClause )+
                        {
                            // AS3_ex.g3:2397:11: ( catchClause )+
                            int cnt90 = 0;
                            do 
                            {
                                int alt90 = 2;
                                int LA90_0 = input.LA(1);

                                if ( (LA90_0 == CATCH) )
                                {
                                    int LA90_2 = input.LA(2);

                                    if ( (LA90_2 == LPAREN) )
                                    {
                                        alt90 = 1;
                                    }


                                }


                                switch (alt90) 
                                {
                                    case 1 :
                                        // AS3_ex.g3:0:0: catchClause
                                        {
                                            PushFollow(FOLLOW_catchClause_in_tryStatement8868);
                                            catchClause176 = catchClause();
                                            state.followingStackPointer--;
                                            if (state.failed) return retval;
                                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, catchClause176.Tree);

                                        }
                                        break;

                                    default:
                                        if ( cnt90 >= 1 ) goto loop90;
                                        if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                                            EarlyExitException eee =
                                                new EarlyExitException(90, input);
                                            throw eee;
                                }
                                cnt90++;
                            } while (true);

                            loop90:
                                ;   // Stops C# compiler whinging that label 'loop90' has no statements


                        }
                        break;
                    case 3 :
                        // AS3_ex.g3:2398:11: finallyClause
                        {
                            PushFollow(FOLLOW_finallyClause_in_tryStatement8881);
                            finallyClause177 = finallyClause();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, finallyClause177.Tree);

                        }
                        break;

                }


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 64, tryStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "tryStatement"

    public class catchClause_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "catchClause"
    // AS3_ex.g3:2402:1: catchClause : C= CATCH L= LPAREN variableIdentifierDecl R= RPAREN blockStatement ;
    public AS3_exParser.catchClause_return catchClause() // throws RecognitionException [1]
    {   
        AS3_exParser.catchClause_return retval = new AS3_exParser.catchClause_return();
        retval.Start = input.LT(1);
        int catchClause_StartIndex = input.Index();
        object root_0 = null;

        IToken C = null;
        IToken L = null;
        IToken R = null;
        AS3_exParser.variableIdentifierDecl_return variableIdentifierDecl178 = null;

        AS3_exParser.blockStatement_return blockStatement179 = null;


        object C_tree=null;
        object L_tree=null;
        object R_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 65) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2403:2: (C= CATCH L= LPAREN variableIdentifierDecl R= RPAREN blockStatement )
            // AS3_ex.g3:2403:4: C= CATCH L= LPAREN variableIdentifierDecl R= RPAREN blockStatement
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  if (mPrinter.isCRBeforeCatch()) insertCR(false);
                }
                if ( state.backtracking == 0 ) 
                {
                  insertWS(1);
                }
                C=(IToken)Match(input,CATCH,FOLLOW_CATCH_in_catchClause8910); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {C_tree = (object)adaptor.Create(C);
                    adaptor.AddChild(root_0, C_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(C);insertWS(mPrinter.getSpacesBetweenControlKeywordsAndParens());
                }
                if ( state.backtracking == 0 ) 
                {
                  pushIndent(false);
                }
                L=(IToken)Match(input,LPAREN,FOLLOW_LPAREN_in_catchClause8917); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {L_tree = (object)adaptor.Create(L);
                    adaptor.AddChild(root_0, L_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(L);insertWS(mPrinter.getAdvancedSpacesInsideParensInParameterLists());
                }
                PushFollow(FOLLOW_variableIdentifierDecl_in_catchClause8921);
                variableIdentifierDecl178 = variableIdentifierDecl();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, variableIdentifierDecl178.Tree);
                R=(IToken)Match(input,RPAREN,FOLLOW_RPAREN_in_catchClause8925); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {R_tree = (object)adaptor.Create(R);
                    adaptor.AddChild(root_0, R_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  insertWS(mPrinter.getAdvancedSpacesInsideParensInParameterLists());emit(R);mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_catch_code);
                }
                PushFollow(FOLLOW_blockStatement_in_catchClause8929);
                blockStatement179 = blockStatement();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, blockStatement179.Tree);
                if ( state.backtracking == 0 ) 
                {
                  popIndent();popBlockStack();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 65, catchClause_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "catchClause"

    public class finallyClause_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "finallyClause"
    // AS3_ex.g3:2406:1: finallyClause : F= FINALLY blockStatement ;
    public AS3_exParser.finallyClause_return finallyClause() // throws RecognitionException [1]
    {   
        AS3_exParser.finallyClause_return retval = new AS3_exParser.finallyClause_return();
        retval.Start = input.LT(1);
        int finallyClause_StartIndex = input.Index();
        object root_0 = null;

        IToken F = null;
        AS3_exParser.blockStatement_return blockStatement180 = null;


        object F_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 66) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2407:5: (F= FINALLY blockStatement )
            // AS3_ex.g3:2407:7: F= FINALLY blockStatement
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  if (mPrinter.isCRBeforeCatch()) insertCR(false);
                }
                if ( state.backtracking == 0 ) 
                {
                  insertWS(1);
                }
                F=(IToken)Match(input,FINALLY,FOLLOW_FINALLY_in_finallyClause8953); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {F_tree = (object)adaptor.Create(F);
                    adaptor.AddChild(root_0, F_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(F);
                }
                if ( state.backtracking == 0 ) 
                {
                  pushIndent(false);mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_finally_code);
                }
                PushFollow(FOLLOW_blockStatement_in_finallyClause8958);
                blockStatement180 = blockStatement();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, blockStatement180.Tree);
                if ( state.backtracking == 0 ) 
                {
                  popIndent();popBlockStack();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 66, finallyClause_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "finallyClause"

    public class labelledStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "labelledStatement"
    // AS3_ex.g3:2414:1: labelledStatement : I= IDENTIFIER C= COLON statement ;
    public AS3_exParser.labelledStatement_return labelledStatement() // throws RecognitionException [1]
    {   
        AS3_exParser.labelledStatement_return retval = new AS3_exParser.labelledStatement_return();
        retval.Start = input.LT(1);
        int labelledStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken I = null;
        IToken C = null;
        AS3_exParser.statement_return statement181 = null;


        object I_tree=null;
        object C_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 67) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2415:5: (I= IDENTIFIER C= COLON statement )
            // AS3_ex.g3:2415:8: I= IDENTIFIER C= COLON statement
            {
                root_0 = (object)adaptor.GetNilNode();

                I=(IToken)Match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_labelledStatement8984); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {I_tree = (object)adaptor.Create(I);
                    adaptor.AddChild(root_0, I_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(I);
                }
                if ( state.backtracking == 0 ) 
                {
                  pushLabeledIndent();
                }
                C=(IToken)Match(input,COLON,FOLLOW_COLON_in_labelledStatement8997); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {C_tree = (object)adaptor.Create(C);
                    adaptor.AddChild(root_0, C_tree);
                }
                if ( state.backtracking == 0 ) 
                {

                            emit(C);
                            insertWS(mPrinter.getSpacesAfterLabel());
                        
                }
                PushFollow(FOLLOW_statement_in_labelledStatement9013);
                statement181 = statement();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, statement181.Tree);
                if ( state.backtracking == 0 ) 
                {
                  popIndent();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 67, labelledStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "labelledStatement"

    public class switchStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "switchStatement"
    // AS3_ex.g3:2429:1: switchStatement : S= SWITCH parExpression L= LCURLY ( switchBlockStatementGroup )* R= RCURLY ;
    public AS3_exParser.switchStatement_return switchStatement() // throws RecognitionException [1]
    {   
        AS3_exParser.switchStatement_return retval = new AS3_exParser.switchStatement_return();
        retval.Start = input.LT(1);
        int switchStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken S = null;
        IToken L = null;
        IToken R = null;
        AS3_exParser.parExpression_return parExpression182 = null;

        AS3_exParser.switchBlockStatementGroup_return switchBlockStatementGroup183 = null;


        object S_tree=null;
        object L_tree=null;
        object R_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 68) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2430:5: (S= SWITCH parExpression L= LCURLY ( switchBlockStatementGroup )* R= RCURLY )
            // AS3_ex.g3:2431:5: S= SWITCH parExpression L= LCURLY ( switchBlockStatementGroup )* R= RCURLY
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  mPrinter.markDeclEqualsContextChange();
                }
                if ( state.backtracking == 0 ) 
                {
                  insertLines(mPrinter.getBlankLinesBeforeControlStatement());
                }
                if ( state.backtracking == 0 ) 
                {
                  insertStatementCR();
                }
                S=(IToken)Match(input,SWITCH,FOLLOW_SWITCH_in_switchStatement9065); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {S_tree = (object)adaptor.Create(S);
                    adaptor.AddChild(root_0, S_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(S);
                       pushIndent(false);
                       insertWS(mPrinter.getSpacesBetweenControlKeywordsAndParens());
                }
                if ( state.backtracking == 0 ) 
                {
                  pushExpressionIndent();
                }
                PushFollow(FOLLOW_parExpression_in_switchStatement9076);
                parExpression182 = parExpression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, parExpression182.Tree);
                if ( state.backtracking == 0 ) 
                {
                  popIndent();
                }
                L=(IToken)Match(input,LCURLY,FOLLOW_LCURLY_in_switchStatement9088); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {L_tree = (object)adaptor.Create(L);
                    adaptor.AddChild(root_0, L_tree);
                }
                if ( state.backtracking == 0 ) 
                {

                            mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_controlStatement_code);
                            leftCurlyNewlineHandler(false);
                            emit(L);
                            if (mPrinter.isIndentSwitchCases())
                                pushIndent(true);
                            else
                                mPrinter.pushRelativeIndent(ASPrettyPrinter.BRACE_INDENT, -1);
                            {mPrinter.addDeclEqualsBlock();}
                            mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_block_code);
                        
                }
                // AS3_ex.g3:2449:6: ( switchBlockStatementGroup )*
                do 
                {
                    int alt92 = 2;
                    int LA92_0 = input.LA(1);

                    if ( (LA92_0 == CASE || LA92_0 == DEFAULT) )
                    {
                        alt92 = 1;
                    }


                    switch (alt92) 
                    {
                        case 1 :
                            // AS3_ex.g3:0:0: switchBlockStatementGroup
                            {
                                PushFollow(FOLLOW_switchBlockStatementGroup_in_switchStatement9104);
                                switchBlockStatementGroup183 = switchBlockStatementGroup();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, switchBlockStatementGroup183.Tree);

                            }
                            break;

                        default:
                            goto loop92;
                    }
                } while (true);

                loop92:
                    ;   // Stops C# compiler whining that label 'loop92' has no statements

                if ( state.backtracking == 0 ) 
                {
                  popIndent();
                }
                if ( state.backtracking == 0 ) 
                {
                  mPrinter.popDeclEqualsBlock();
                }
                R=(IToken)Match(input,RCURLY,FOLLOW_RCURLY_in_switchStatement9124); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {R_tree = (object)adaptor.Create(R);
                    adaptor.AddChild(root_0, R_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  insertCR(false);emit(R);popIndent();popBlockStack();popBlockStack();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 68, switchStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "switchStatement"

    public class switchBlockStatementGroup_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "switchBlockStatementGroup"
    // AS3_ex.g3:2458:1: switchBlockStatementGroup : switchLabel ( statement )* ( breakStatement )? ;
    public AS3_exParser.switchBlockStatementGroup_return switchBlockStatementGroup() // throws RecognitionException [1]
    {   
        AS3_exParser.switchBlockStatementGroup_return retval = new AS3_exParser.switchBlockStatementGroup_return();
        retval.Start = input.LT(1);
        int switchBlockStatementGroup_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.switchLabel_return switchLabel184 = null;

        AS3_exParser.statement_return statement185 = null;

        AS3_exParser.breakStatement_return breakStatement186 = null;




            int statementCount=0;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 69) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2463:5: ( switchLabel ( statement )* ( breakStatement )? )
            // AS3_ex.g3:2463:9: switchLabel ( statement )* ( breakStatement )?
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  insertCR(false);
                }
                PushFollow(FOLLOW_switchLabel_in_switchBlockStatementGroup9162);
                switchLabel184 = switchLabel();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, switchLabel184.Tree);
                if ( state.backtracking == 0 ) 
                {
                  pushIndent(false);
                }
                if ( state.backtracking == 0 ) 
                {
                  mPrinter.addOpenBrace(input, ASPrettyPrinter.BraceAdd_Switch);statementCount=mStatementCount;
                }
                // AS3_ex.g3:2465:6: ( statement )*
                do 
                {
                    int alt93 = 2;
                    alt93 = dfa93.Predict(input);
                    switch (alt93) 
                    {
                        case 1 :
                            // AS3_ex.g3:0:0: statement
                            {
                                PushFollow(FOLLOW_statement_in_switchBlockStatementGroup9179);
                                statement185 = statement();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, statement185.Tree);

                            }
                            break;

                        default:
                            goto loop93;
                    }
                } while (true);

                loop93:
                    ;   // Stops C# compiler whining that label 'loop93' has no statements

                if ( state.backtracking == 0 ) 
                {
                  mPrinter.addCloseBrace(input.LT(1), ASPrettyPrinter.BraceAdd_Switch, mStatementCount-statementCount);
                }
                if ( state.backtracking == 0 ) 
                {
                  popIndent();
                }
                if ( state.backtracking == 0 ) 
                {
                  insertCR(false);
                }
                // AS3_ex.g3:2467:39: ( breakStatement )?
                int alt94 = 2;
                int LA94_0 = input.LA(1);

                if ( (LA94_0 == BREAK) )
                {
                    alt94 = 1;
                }
                switch (alt94) 
                {
                    case 1 :
                        // AS3_ex.g3:0:0: breakStatement
                        {
                            PushFollow(FOLLOW_breakStatement_in_switchBlockStatementGroup9202);
                            breakStatement186 = breakStatement();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, breakStatement186.Tree);

                        }
                        break;

                }


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 69, switchBlockStatementGroup_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "switchBlockStatementGroup"

    public class switchLabel_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "switchLabel"
    // AS3_ex.g3:2470:1: switchLabel : (C= CASE expression O= COLON | D= DEFAULT C= COLON );
    public AS3_exParser.switchLabel_return switchLabel() // throws RecognitionException [1]
    {   
        AS3_exParser.switchLabel_return retval = new AS3_exParser.switchLabel_return();
        retval.Start = input.LT(1);
        int switchLabel_StartIndex = input.Index();
        object root_0 = null;

        IToken C = null;
        IToken O = null;
        IToken D = null;
        AS3_exParser.expression_return expression187 = null;


        object C_tree=null;
        object O_tree=null;
        object D_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 70) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2471:5: (C= CASE expression O= COLON | D= DEFAULT C= COLON )
            int alt95 = 2;
            int LA95_0 = input.LA(1);

            if ( (LA95_0 == CASE) )
            {
                alt95 = 1;
            }
            else if ( (LA95_0 == DEFAULT) )
            {
                alt95 = 2;
            }
            else 
            {
                if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                NoViableAltException nvae_d95s0 =
                    new NoViableAltException("", 95, 0, input);

                throw nvae_d95s0;
            }
            switch (alt95) 
            {
                case 1 :
                    // AS3_ex.g3:2471:9: C= CASE expression O= COLON
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        C=(IToken)Match(input,CASE,FOLLOW_CASE_in_switchLabel9228); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {C_tree = (object)adaptor.Create(C);
                            adaptor.AddChild(root_0, C_tree);
                        }
                        if ( state.backtracking == 0 ) 
                        {
                          emit(C);
                        }
                        if ( state.backtracking == 0 ) 
                        {
                          insertWS(1);
                        }
                        PushFollow(FOLLOW_expression_in_switchLabel9234);
                        expression187 = expression();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, expression187.Tree);
                        O=(IToken)Match(input,COLON,FOLLOW_COLON_in_switchLabel9238); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {O_tree = (object)adaptor.Create(O);
                            adaptor.AddChild(root_0, O_tree);
                        }
                        if ( state.backtracking == 0 ) 
                        {

                                emit(O);
                                insertWS(mPrinter.getSpacesAfterLabel());
                                
                        }

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:2476:9: D= DEFAULT C= COLON
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        D=(IToken)Match(input,DEFAULT,FOLLOW_DEFAULT_in_switchLabel9259); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {D_tree = (object)adaptor.Create(D);
                            adaptor.AddChild(root_0, D_tree);
                        }
                        if ( state.backtracking == 0 ) 
                        {
                          emit(D);
                        }
                        C=(IToken)Match(input,COLON,FOLLOW_COLON_in_switchLabel9265); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {C_tree = (object)adaptor.Create(C);
                            adaptor.AddChild(root_0, C_tree);
                        }
                        if ( state.backtracking == 0 ) 
                        {

                                        emit(C);
                                        insertWS(mPrinter.getSpacesAfterLabel());
                                    
                        }

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 70, switchLabel_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "switchLabel"

    public class withStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "withStatement"
    // AS3_ex.g3:2487:1: withStatement : W= WITH L= LPAREN expression R= RPAREN statement ;
    public AS3_exParser.withStatement_return withStatement() // throws RecognitionException [1]
    {   
        AS3_exParser.withStatement_return retval = new AS3_exParser.withStatement_return();
        retval.Start = input.LT(1);
        int withStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken W = null;
        IToken L = null;
        IToken R = null;
        AS3_exParser.expression_return expression188 = null;

        AS3_exParser.statement_return statement189 = null;


        object W_tree=null;
        object L_tree=null;
        object R_tree=null;


            int statementStartInOutput=(-1);
            int statementEndInOutput=(-1);
            int statementCount=0;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 71) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2494:5: (W= WITH L= LPAREN expression R= RPAREN statement )
            // AS3_ex.g3:2495:5: W= WITH L= LPAREN expression R= RPAREN statement
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  mPrinter.markDeclEqualsContextChange();
                }
                W=(IToken)Match(input,WITH,FOLLOW_WITH_in_withStatement9313); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {W_tree = (object)adaptor.Create(W);
                    adaptor.AddChild(root_0, W_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(W);statementStartInOutput=mPrinter.getCurrentOutputLength();insertWS(mPrinter.getSpacesBetweenControlKeywordsAndParens());
                }
                if ( state.backtracking == 0 ) 
                {
                  pushExpressionIndent();
                }
                L=(IToken)Match(input,LPAREN,FOLLOW_LPAREN_in_withStatement9321); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {L_tree = (object)adaptor.Create(L);
                    adaptor.AddChild(root_0, L_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(L);insertWS(mPrinter.getAdvancedSpacesInsideParensInOtherPlaces());
                }
                PushFollow(FOLLOW_expression_in_withStatement9326);
                expression188 = expression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, expression188.Tree);
                R=(IToken)Match(input,RPAREN,FOLLOW_RPAREN_in_withStatement9331); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {R_tree = (object)adaptor.Create(R);
                    adaptor.AddChild(root_0, R_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  insertWS(mPrinter.getAdvancedSpacesInsideParensInOtherPlaces());emit(R);statementEndInOutput=mPrinter.getCurrentOutputLength();
                }
                if ( state.backtracking == 0 ) 
                {
                  popIndent();
                }
                if ( state.backtracking == 0 ) 
                {
                  pushIndent(false);
                }
                if ( state.backtracking == 0 ) 
                {
                  mPrinter.addOpenBrace(input, ASPrettyPrinter.BraceAdd_Loop);
                             mPrinter.captureStatementStart(W, statementStartInOutput);
                         mPrinter.captureStatementEnd(R, statementEndInOutput);
                         statementCount=mStatementCount;
                        
                }
                PushFollow(FOLLOW_statement_in_withStatement9352);
                statement189 = statement();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, statement189.Tree);
                if ( state.backtracking == 0 ) 
                {
                  mPrinter.addCloseBrace(input.LT(1), ASPrettyPrinter.BraceAdd_Loop, mStatementCount-statementCount);
                }
                if ( state.backtracking == 0 ) 
                {
                  popIndent();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 71, withStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "withStatement"

    public class returnStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "returnStatement"
    // AS3_ex.g3:2511:1: returnStatement : R= RETURN ( expression )? semic ;
    public AS3_exParser.returnStatement_return returnStatement() // throws RecognitionException [1]
    {   
        AS3_exParser.returnStatement_return retval = new AS3_exParser.returnStatement_return();
        retval.Start = input.LT(1);
        int returnStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken R = null;
        AS3_exParser.expression_return expression190 = null;

        AS3_exParser.semic_return semic191 = null;


        object R_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 72) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2512:5: (R= RETURN ( expression )? semic )
            // AS3_ex.g3:2512:9: R= RETURN ( expression )? semic
            {
                root_0 = (object)adaptor.GetNilNode();

                R=(IToken)Match(input,RETURN,FOLLOW_RETURN_in_returnStatement9396); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {R_tree = (object)adaptor.Create(R);
                    adaptor.AddChild(root_0, R_tree);
                }
                if ( state.backtracking == 0 ) 
                {

                            if (mPrinter.statementNeedsCR(R))
                                insertStatementCR();
                            else
                                insertWS(1);
                        
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(R);
                }
                // AS3_ex.g3:2519:18: ( expression )?
                int alt96 = 2;
                int LA96_0 = input.LA(1);

                if ( ((LA96_0 >= AS && LA96_0 <= STATIC) || LA96_0 == LCURLY || LA96_0 == LPAREN || LA96_0 == LBRACK || LA96_0 == LT || (LA96_0 >= PLUS && LA96_0 <= STAR) || (LA96_0 >= INC && LA96_0 <= DEC) || (LA96_0 >= NOT && LA96_0 <= INV) || (LA96_0 >= XML_AT && LA96_0 <= XML_LS_STD) || (LA96_0 >= SINGLE_QUOTE_LITERAL && LA96_0 <= DOUBLE_QUOTE_LITERAL) || LA96_0 == REGULAR_EXPR_LITERAL || LA96_0 == HEX_NUMBER_LITERAL || LA96_0 == DEC_NUMBER_LITERAL || LA96_0 == IDENTIFIER || (LA96_0 >= XML_COMMENT && LA96_0 <= XML_PI)) )
                {
                    alt96 = 1;
                }
                switch (alt96) 
                {
                    case 1 :
                        // AS3_ex.g3:2519:20: expression
                        {
                            if ( state.backtracking == 0 ) 
                            {
                              insertWS(1);
                            }
                            PushFollow(FOLLOW_expression_in_returnStatement9417);
                            expression190 = expression();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, expression190.Tree);

                        }
                        break;

                }

                PushFollow(FOLLOW_semic_in_returnStatement9421);
                semic191 = semic();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, semic191.Tree);

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 72, returnStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "returnStatement"

    public class breakStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "breakStatement"
    // AS3_ex.g3:2527:1: breakStatement : B= BREAK (I= IDENTIFIER )? semic ;
    public AS3_exParser.breakStatement_return breakStatement() // throws RecognitionException [1]
    {   
        AS3_exParser.breakStatement_return retval = new AS3_exParser.breakStatement_return();
        retval.Start = input.LT(1);
        int breakStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken B = null;
        IToken I = null;
        AS3_exParser.semic_return semic192 = null;


        object B_tree=null;
        object I_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 73) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2528:5: (B= BREAK (I= IDENTIFIER )? semic )
            // AS3_ex.g3:2528:9: B= BREAK (I= IDENTIFIER )? semic
            {
                root_0 = (object)adaptor.GetNilNode();

                B=(IToken)Match(input,BREAK,FOLLOW_BREAK_in_breakStatement9448); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {B_tree = (object)adaptor.Create(B);
                    adaptor.AddChild(root_0, B_tree);
                }
                if ( state.backtracking == 0 ) 
                {

                            if (mPrinter.statementNeedsCR(B))
                                insertStatementCR();
                            else
                                insertWS(1);
                        
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(B);
                }
                // AS3_ex.g3:2535:18: (I= IDENTIFIER )?
                int alt97 = 2;
                int LA97_0 = input.LA(1);

                if ( (LA97_0 == IDENTIFIER) )
                {
                    alt97 = 1;
                }
                switch (alt97) 
                {
                    case 1 :
                        // AS3_ex.g3:2535:19: I= IDENTIFIER
                        {
                            I=(IToken)Match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_breakStatement9471); if (state.failed) return retval;
                            if ( state.backtracking == 0 )
                            {I_tree = (object)adaptor.Create(I);
                                adaptor.AddChild(root_0, I_tree);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              emit(I);
                            }

                        }
                        break;

                }

                PushFollow(FOLLOW_semic_in_breakStatement9476);
                semic192 = semic();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, semic192.Tree);

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 73, breakStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "breakStatement"

    public class continueStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "continueStatement"
    // AS3_ex.g3:2543:1: continueStatement : C= CONTINUE (I= IDENTIFIER )? semic ;
    public AS3_exParser.continueStatement_return continueStatement() // throws RecognitionException [1]
    {   
        AS3_exParser.continueStatement_return retval = new AS3_exParser.continueStatement_return();
        retval.Start = input.LT(1);
        int continueStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken C = null;
        IToken I = null;
        AS3_exParser.semic_return semic193 = null;


        object C_tree=null;
        object I_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 74) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2544:5: (C= CONTINUE (I= IDENTIFIER )? semic )
            // AS3_ex.g3:2544:9: C= CONTINUE (I= IDENTIFIER )? semic
            {
                root_0 = (object)adaptor.GetNilNode();

                C=(IToken)Match(input,CONTINUE,FOLLOW_CONTINUE_in_continueStatement9502); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {C_tree = (object)adaptor.Create(C);
                    adaptor.AddChild(root_0, C_tree);
                }
                if ( state.backtracking == 0 ) 
                {

                            if (mPrinter.statementNeedsCR(C))
                                insertStatementCR();
                            else
                                insertWS(1);
                        
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(C);
                }
                // AS3_ex.g3:2551:18: (I= IDENTIFIER )?
                int alt98 = 2;
                int LA98_0 = input.LA(1);

                if ( (LA98_0 == IDENTIFIER) )
                {
                    alt98 = 1;
                }
                switch (alt98) 
                {
                    case 1 :
                        // AS3_ex.g3:2551:19: I= IDENTIFIER
                        {
                            I=(IToken)Match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_continueStatement9522); if (state.failed) return retval;
                            if ( state.backtracking == 0 )
                            {I_tree = (object)adaptor.Create(I);
                                adaptor.AddChild(root_0, I_tree);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              emit(I);
                            }

                        }
                        break;

                }

                PushFollow(FOLLOW_semic_in_continueStatement9527);
                semic193 = semic();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, semic193.Tree);

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 74, continueStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "continueStatement"

    public class forStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "forStatement"
    // AS3_ex.g3:2559:1: forStatement : F= FOR L= LPAREN forControl R= RPAREN statement ;
    public AS3_exParser.forStatement_return forStatement() // throws RecognitionException [1]
    {   
        AS3_exParser.forStatement_return retval = new AS3_exParser.forStatement_return();
        retval.Start = input.LT(1);
        int forStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken F = null;
        IToken L = null;
        IToken R = null;
        AS3_exParser.forControl_return forControl194 = null;

        AS3_exParser.statement_return statement195 = null;


        object F_tree=null;
        object L_tree=null;
        object R_tree=null;


            int statementStartInOutput=(-1);
            int statementEndInOutput=(-1);
            int statementCount=0;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 75) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2566:5: (F= FOR L= LPAREN forControl R= RPAREN statement )
            // AS3_ex.g3:2567:6: F= FOR L= LPAREN forControl R= RPAREN statement
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  mPrinter.markDeclEqualsContextChange();
                }
                F=(IToken)Match(input,FOR,FOLLOW_FOR_in_forStatement9565); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {F_tree = (object)adaptor.Create(F);
                    adaptor.AddChild(root_0, F_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(F);statementStartInOutput=mPrinter.getCurrentOutputLength();insertWS(mPrinter.getSpacesBetweenControlKeywordsAndParens());
                }
                if ( state.backtracking == 0 ) 
                {
                  pushExpressionIndent();
                }
                L=(IToken)Match(input,LPAREN,FOLLOW_LPAREN_in_forStatement9573); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {L_tree = (object)adaptor.Create(L);
                    adaptor.AddChild(root_0, L_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(L);insertWS(mPrinter.getAdvancedSpacesInsideParensInOtherPlaces());
                }
                PushFollow(FOLLOW_forControl_in_forStatement9577);
                forControl194 = forControl();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, forControl194.Tree);
                R=(IToken)Match(input,RPAREN,FOLLOW_RPAREN_in_forStatement9581); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {R_tree = (object)adaptor.Create(R);
                    adaptor.AddChild(root_0, R_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  insertWS(mPrinter.getAdvancedSpacesInsideParensInOtherPlaces());emit(R);
                }
                if ( state.backtracking == 0 ) 
                {
                  popIndent();
                }
                if ( state.backtracking == 0 ) 
                {
                  pushIndent(false);statementEndInOutput=mPrinter.getCurrentOutputLength();
                }
                if ( state.backtracking == 0 ) 
                {
                  mPrinter.addOpenBrace(input, ASPrettyPrinter.BraceAdd_Loop);
                         mPrinter.captureStatementStart(F, statementStartInOutput);
                         mPrinter.captureStatementEnd(R, statementEndInOutput);
                         statementCount=mStatementCount;
                        
                }
                PushFollow(FOLLOW_statement_in_forStatement9600);
                statement195 = statement();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, statement195.Tree);
                if ( state.backtracking == 0 ) 
                {
                  mPrinter.addCloseBrace(input.LT(1), ASPrettyPrinter.BraceAdd_Loop, mStatementCount-statementCount);
                }
                if ( state.backtracking == 0 ) 
                {
                  popIndent();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 75, forStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "forStatement"

    public class forInStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "forInStatement"
    // AS3_ex.g3:2579:1: forInStatement : F= FOR L= LPAREN forInControl R= RPAREN statement ;
    public AS3_exParser.forInStatement_return forInStatement() // throws RecognitionException [1]
    {   
        AS3_exParser.forInStatement_return retval = new AS3_exParser.forInStatement_return();
        retval.Start = input.LT(1);
        int forInStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken F = null;
        IToken L = null;
        IToken R = null;
        AS3_exParser.forInControl_return forInControl196 = null;

        AS3_exParser.statement_return statement197 = null;


        object F_tree=null;
        object L_tree=null;
        object R_tree=null;


            int statementStartInOutput=(-1);
            int statementEndInOutput=(-1);
            int statementCount=0;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 76) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2586:5: (F= FOR L= LPAREN forInControl R= RPAREN statement )
            // AS3_ex.g3:2587:6: F= FOR L= LPAREN forInControl R= RPAREN statement
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  mPrinter.markDeclEqualsContextChange();
                }
                F=(IToken)Match(input,FOR,FOLLOW_FOR_in_forInStatement9656); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {F_tree = (object)adaptor.Create(F);
                    adaptor.AddChild(root_0, F_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(F);statementStartInOutput=mPrinter.getCurrentOutputLength();insertWS(mPrinter.getSpacesBetweenControlKeywordsAndParens());
                }
                if ( state.backtracking == 0 ) 
                {
                  pushExpressionIndent();
                }
                L=(IToken)Match(input,LPAREN,FOLLOW_LPAREN_in_forInStatement9664); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {L_tree = (object)adaptor.Create(L);
                    adaptor.AddChild(root_0, L_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(L);insertWS(mPrinter.getAdvancedSpacesInsideParensInOtherPlaces());
                }
                PushFollow(FOLLOW_forInControl_in_forInStatement9668);
                forInControl196 = forInControl();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, forInControl196.Tree);
                R=(IToken)Match(input,RPAREN,FOLLOW_RPAREN_in_forInStatement9672); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {R_tree = (object)adaptor.Create(R);
                    adaptor.AddChild(root_0, R_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  insertWS(mPrinter.getAdvancedSpacesInsideParensInOtherPlaces());emit(R);
                }
                if ( state.backtracking == 0 ) 
                {
                  popIndent();
                }
                if ( state.backtracking == 0 ) 
                {
                  pushIndent(false);statementEndInOutput=mPrinter.getCurrentOutputLength();
                }
                if ( state.backtracking == 0 ) 
                {
                  mPrinter.addOpenBrace(input, ASPrettyPrinter.BraceAdd_Loop);
                         mPrinter.captureStatementStart(F, statementStartInOutput);
                         mPrinter.captureStatementEnd(R, statementEndInOutput);
                         statementCount=mStatementCount;
                        
                }
                PushFollow(FOLLOW_statement_in_forInStatement9693);
                statement197 = statement();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, statement197.Tree);
                if ( state.backtracking == 0 ) 
                {
                  mPrinter.addCloseBrace(input.LT(1), ASPrettyPrinter.BraceAdd_Loop, mStatementCount-statementCount);
                }
                if ( state.backtracking == 0 ) 
                {
                  popIndent();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 76, forInStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "forInStatement"

    public class forEachInStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "forEachInStatement"
    // AS3_ex.g3:2599:1: forEachInStatement : F= FOR E= EACH L= LPAREN forInControl R= RPAREN statement ;
    public AS3_exParser.forEachInStatement_return forEachInStatement() // throws RecognitionException [1]
    {   
        AS3_exParser.forEachInStatement_return retval = new AS3_exParser.forEachInStatement_return();
        retval.Start = input.LT(1);
        int forEachInStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken F = null;
        IToken E = null;
        IToken L = null;
        IToken R = null;
        AS3_exParser.forInControl_return forInControl198 = null;

        AS3_exParser.statement_return statement199 = null;


        object F_tree=null;
        object E_tree=null;
        object L_tree=null;
        object R_tree=null;


            int statementStartInOutput=(-1);
            int statementEndInOutput=(-1);
            int statementCount=0;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 77) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2606:5: (F= FOR E= EACH L= LPAREN forInControl R= RPAREN statement )
            // AS3_ex.g3:2607:5: F= FOR E= EACH L= LPAREN forInControl R= RPAREN statement
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  mPrinter.markDeclEqualsContextChange();
                }
                F=(IToken)Match(input,FOR,FOLLOW_FOR_in_forEachInStatement9755); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {F_tree = (object)adaptor.Create(F);
                    adaptor.AddChild(root_0, F_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(F);statementStartInOutput=mPrinter.getCurrentOutputLength();
                }
                if ( state.backtracking == 0 ) 
                {
                  pushExpressionIndent();
                }
                E=(IToken)Match(input,EACH,FOLLOW_EACH_in_forEachInStatement9773); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {E_tree = (object)adaptor.Create(E);
                    adaptor.AddChild(root_0, E_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(E);insertWS(mPrinter.getSpacesBetweenControlKeywordsAndParens());
                }
                L=(IToken)Match(input,LPAREN,FOLLOW_LPAREN_in_forEachInStatement9781); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {L_tree = (object)adaptor.Create(L);
                    adaptor.AddChild(root_0, L_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(L);insertWS(mPrinter.getAdvancedSpacesInsideParensInOtherPlaces());
                }
                PushFollow(FOLLOW_forInControl_in_forEachInStatement9785);
                forInControl198 = forInControl();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, forInControl198.Tree);
                R=(IToken)Match(input,RPAREN,FOLLOW_RPAREN_in_forEachInStatement9789); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {R_tree = (object)adaptor.Create(R);
                    adaptor.AddChild(root_0, R_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  insertWS(mPrinter.getAdvancedSpacesInsideParensInOtherPlaces());emit(R);statementEndInOutput=mPrinter.getCurrentOutputLength();
                }
                if ( state.backtracking == 0 ) 
                {
                  popIndent();
                }
                if ( state.backtracking == 0 ) 
                {
                  pushIndent(false);
                }
                if ( state.backtracking == 0 ) 
                {
                  mPrinter.addOpenBrace(input, ASPrettyPrinter.BraceAdd_Loop);
                       mPrinter.captureStatementStart(F, statementStartInOutput);
                       mPrinter.captureStatementEnd(R, statementEndInOutput);
                       statementCount=mStatementCount;
                        
                }
                PushFollow(FOLLOW_statement_in_forEachInStatement9806);
                statement199 = statement();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, statement199.Tree);
                if ( state.backtracking == 0 ) 
                {
                  mPrinter.addCloseBrace(input.LT(1), ASPrettyPrinter.BraceAdd_Loop, mStatementCount-statementCount);
                }
                if ( state.backtracking == 0 ) 
                {
                  popIndent();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 77, forEachInStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "forEachInStatement"

    public class forControl_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "forControl"
    // AS3_ex.g3:2621:1: forControl options {k=3; } : ( forInit )? semic ( expression )? semic ( forUpdate )? ;
    public AS3_exParser.forControl_return forControl() // throws RecognitionException [1]
    {   
        AS3_exParser.forControl_return retval = new AS3_exParser.forControl_return();
        retval.Start = input.LT(1);
        int forControl_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.forInit_return forInit200 = null;

        AS3_exParser.semic_return semic201 = null;

        AS3_exParser.expression_return expression202 = null;

        AS3_exParser.semic_return semic203 = null;

        AS3_exParser.forUpdate_return forUpdate204 = null;



        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 78) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2623:5: ( ( forInit )? semic ( expression )? semic ( forUpdate )? )
            // AS3_ex.g3:2623:9: ( forInit )? semic ( expression )? semic ( forUpdate )?
            {
                root_0 = (object)adaptor.GetNilNode();

                // AS3_ex.g3:2623:9: ( forInit )?
                int alt99 = 2;
                int LA99_0 = input.LA(1);

                if ( ((LA99_0 >= AS && LA99_0 <= STATIC) || LA99_0 == LCURLY || LA99_0 == LPAREN || LA99_0 == LBRACK || LA99_0 == LT || (LA99_0 >= PLUS && LA99_0 <= STAR) || (LA99_0 >= INC && LA99_0 <= DEC) || (LA99_0 >= NOT && LA99_0 <= INV) || (LA99_0 >= XML_AT && LA99_0 <= XML_LS_STD) || (LA99_0 >= SINGLE_QUOTE_LITERAL && LA99_0 <= DOUBLE_QUOTE_LITERAL) || LA99_0 == REGULAR_EXPR_LITERAL || LA99_0 == HEX_NUMBER_LITERAL || LA99_0 == DEC_NUMBER_LITERAL || LA99_0 == IDENTIFIER || (LA99_0 >= XML_COMMENT && LA99_0 <= XML_PI)) )
                {
                    alt99 = 1;
                }
                switch (alt99) 
                {
                    case 1 :
                        // AS3_ex.g3:0:0: forInit
                        {
                            PushFollow(FOLLOW_forInit_in_forControl9848);
                            forInit200 = forInit();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, forInit200.Tree);

                        }
                        break;

                }

                if ( state.backtracking == 0 ) 
                {
                  insertWS(mPrinter.getSpacesBeforeComma());
                }
                PushFollow(FOLLOW_semic_in_forControl9853);
                semic201 = semic();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, semic201.Tree);
                if ( state.backtracking == 0 ) 
                {
                  insertWS(mPrinter.getSpacesAfterComma());
                }
                // AS3_ex.g3:2623:114: ( expression )?
                int alt100 = 2;
                int LA100_0 = input.LA(1);

                if ( ((LA100_0 >= AS && LA100_0 <= STATIC) || LA100_0 == LCURLY || LA100_0 == LPAREN || LA100_0 == LBRACK || LA100_0 == LT || (LA100_0 >= PLUS && LA100_0 <= STAR) || (LA100_0 >= INC && LA100_0 <= DEC) || (LA100_0 >= NOT && LA100_0 <= INV) || (LA100_0 >= XML_AT && LA100_0 <= XML_LS_STD) || (LA100_0 >= SINGLE_QUOTE_LITERAL && LA100_0 <= DOUBLE_QUOTE_LITERAL) || LA100_0 == REGULAR_EXPR_LITERAL || LA100_0 == HEX_NUMBER_LITERAL || LA100_0 == DEC_NUMBER_LITERAL || LA100_0 == IDENTIFIER || (LA100_0 >= XML_COMMENT && LA100_0 <= XML_PI)) )
                {
                    alt100 = 1;
                }
                switch (alt100) 
                {
                    case 1 :
                        // AS3_ex.g3:0:0: expression
                        {
                            PushFollow(FOLLOW_expression_in_forControl9858);
                            expression202 = expression();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, expression202.Tree);

                        }
                        break;

                }

                if ( state.backtracking == 0 ) 
                {
                  insertWS(mPrinter.getSpacesBeforeComma());
                }
                PushFollow(FOLLOW_semic_in_forControl9862);
                semic203 = semic();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, semic203.Tree);
                if ( state.backtracking == 0 ) 
                {
                  insertWS(mPrinter.getSpacesAfterComma());
                }
                // AS3_ex.g3:2623:220: ( forUpdate )?
                int alt101 = 2;
                int LA101_0 = input.LA(1);

                if ( ((LA101_0 >= AS && LA101_0 <= STATIC) || LA101_0 == LCURLY || LA101_0 == LPAREN || LA101_0 == LBRACK || LA101_0 == LT || (LA101_0 >= PLUS && LA101_0 <= STAR) || (LA101_0 >= INC && LA101_0 <= DEC) || (LA101_0 >= NOT && LA101_0 <= INV) || (LA101_0 >= XML_AT && LA101_0 <= XML_LS_STD) || (LA101_0 >= SINGLE_QUOTE_LITERAL && LA101_0 <= DOUBLE_QUOTE_LITERAL) || LA101_0 == REGULAR_EXPR_LITERAL || LA101_0 == HEX_NUMBER_LITERAL || LA101_0 == DEC_NUMBER_LITERAL || LA101_0 == IDENTIFIER || (LA101_0 >= XML_COMMENT && LA101_0 <= XML_PI)) )
                {
                    alt101 = 1;
                }
                switch (alt101) 
                {
                    case 1 :
                        // AS3_ex.g3:0:0: forUpdate
                        {
                            PushFollow(FOLLOW_forUpdate_in_forControl9866);
                            forUpdate204 = forUpdate();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, forUpdate204.Tree);

                        }
                        break;

                }


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 78, forControl_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "forControl"

    public class forInControl_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "forInControl"
    // AS3_ex.g3:2626:1: forInControl options {k=3; } : forInDecl I= IN expression ;
    public AS3_exParser.forInControl_return forInControl() // throws RecognitionException [1]
    {   
        AS3_exParser.forInControl_return retval = new AS3_exParser.forInControl_return();
        retval.Start = input.LT(1);
        int forInControl_StartIndex = input.Index();
        object root_0 = null;

        IToken I = null;
        AS3_exParser.forInDecl_return forInDecl205 = null;

        AS3_exParser.expression_return expression206 = null;


        object I_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 79) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2628:5: ( forInDecl I= IN expression )
            // AS3_ex.g3:2628:9: forInDecl I= IN expression
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_forInDecl_in_forInControl9894);
                forInDecl205 = forInDecl();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, forInDecl205.Tree);
                I=(IToken)Match(input,IN,FOLLOW_IN_in_forInControl9898); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {I_tree = (object)adaptor.Create(I);
                    adaptor.AddChild(root_0, I_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  insertWS(1);emit(I);
                }
                PushFollow(FOLLOW_expression_in_forInControl9902);
                expression206 = expression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, expression206.Tree);

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 79, forInControl_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "forInControl"

    public class forInDecl_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "forInDecl"
    // AS3_ex.g3:2631:1: forInDecl : ( leftHandSideExpression | V= VAR variableDeclarationNoIn );
    public AS3_exParser.forInDecl_return forInDecl() // throws RecognitionException [1]
    {   
        AS3_exParser.forInDecl_return retval = new AS3_exParser.forInDecl_return();
        retval.Start = input.LT(1);
        int forInDecl_StartIndex = input.Index();
        object root_0 = null;

        IToken V = null;
        AS3_exParser.leftHandSideExpression_return leftHandSideExpression207 = null;

        AS3_exParser.variableDeclarationNoIn_return variableDeclarationNoIn208 = null;


        object V_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 80) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2632:5: ( leftHandSideExpression | V= VAR variableDeclarationNoIn )
            int alt102 = 2;
            int LA102_0 = input.LA(1);

            if ( ((LA102_0 >= AS && LA102_0 <= USE) || (LA102_0 >= VOID && LA102_0 <= STATIC) || LA102_0 == LCURLY || LA102_0 == LPAREN || LA102_0 == LBRACK || LA102_0 == LT || LA102_0 == STAR || (LA102_0 >= XML_AT && LA102_0 <= XML_LS_STD) || (LA102_0 >= SINGLE_QUOTE_LITERAL && LA102_0 <= DOUBLE_QUOTE_LITERAL) || LA102_0 == REGULAR_EXPR_LITERAL || LA102_0 == HEX_NUMBER_LITERAL || LA102_0 == DEC_NUMBER_LITERAL || LA102_0 == IDENTIFIER || (LA102_0 >= XML_COMMENT && LA102_0 <= XML_PI)) )
            {
                alt102 = 1;
            }
            else if ( (LA102_0 == VAR) )
            {
                int LA102_2 = input.LA(2);

                if ( (LA102_2 == DOT || LA102_2 == SUB || LA102_2 == COLON || LA102_2 == XML_NS_OP) )
                {
                    alt102 = 1;
                }
                else if ( (LA102_2 == NATIVE || LA102_2 == TO || (LA102_2 >= EACH && LA102_2 <= NAMESPACE) || (LA102_2 >= DYNAMIC && LA102_2 <= STATIC) || LA102_2 == IDENTIFIER) )
                {
                    alt102 = 2;
                }
                else 
                {
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    NoViableAltException nvae_d102s2 =
                        new NoViableAltException("", 102, 2, input);

                    throw nvae_d102s2;
                }
            }
            else 
            {
                if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                NoViableAltException nvae_d102s0 =
                    new NoViableAltException("", 102, 0, input);

                throw nvae_d102s0;
            }
            switch (alt102) 
            {
                case 1 :
                    // AS3_ex.g3:2632:9: leftHandSideExpression
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_leftHandSideExpression_in_forInDecl9921);
                        leftHandSideExpression207 = leftHandSideExpression();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, leftHandSideExpression207.Tree);

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:2633:9: V= VAR variableDeclarationNoIn
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        V=(IToken)Match(input,VAR,FOLLOW_VAR_in_forInDecl9933); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {V_tree = (object)adaptor.Create(V);
                            adaptor.AddChild(root_0, V_tree);
                        }
                        if ( state.backtracking == 0 ) 
                        {
                          emit(V);
                        }
                        PushFollow(FOLLOW_variableDeclarationNoIn_in_forInDecl9937);
                        variableDeclarationNoIn208 = variableDeclarationNoIn();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, variableDeclarationNoIn208.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 80, forInDecl_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "forInDecl"

    public class forInit_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "forInit"
    // AS3_ex.g3:2636:1: forInit : (V= VAR variableDeclarationNoInList | expressionNoIn );
    public AS3_exParser.forInit_return forInit() // throws RecognitionException [1]
    {   
        AS3_exParser.forInit_return retval = new AS3_exParser.forInit_return();
        retval.Start = input.LT(1);
        int forInit_StartIndex = input.Index();
        object root_0 = null;

        IToken V = null;
        AS3_exParser.variableDeclarationNoInList_return variableDeclarationNoInList209 = null;

        AS3_exParser.expressionNoIn_return expressionNoIn210 = null;


        object V_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 81) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2637:5: (V= VAR variableDeclarationNoInList | expressionNoIn )
            int alt103 = 2;
            int LA103_0 = input.LA(1);

            if ( (LA103_0 == VAR) )
            {
                int LA103_1 = input.LA(2);

                if ( (LA103_1 == DOT || LA103_1 == SUB || LA103_1 == COLON || LA103_1 == XML_NS_OP) )
                {
                    alt103 = 2;
                }
                else if ( (LA103_1 == NATIVE || LA103_1 == TO || (LA103_1 >= EACH && LA103_1 <= NAMESPACE) || (LA103_1 >= DYNAMIC && LA103_1 <= STATIC) || LA103_1 == IDENTIFIER) )
                {
                    alt103 = 1;
                }
                else 
                {
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    NoViableAltException nvae_d103s1 =
                        new NoViableAltException("", 103, 1, input);

                    throw nvae_d103s1;
                }
            }
            else if ( ((LA103_0 >= AS && LA103_0 <= USE) || (LA103_0 >= VOID && LA103_0 <= STATIC) || LA103_0 == LCURLY || LA103_0 == LPAREN || LA103_0 == LBRACK || LA103_0 == LT || (LA103_0 >= PLUS && LA103_0 <= STAR) || (LA103_0 >= INC && LA103_0 <= DEC) || (LA103_0 >= NOT && LA103_0 <= INV) || (LA103_0 >= XML_AT && LA103_0 <= XML_LS_STD) || (LA103_0 >= SINGLE_QUOTE_LITERAL && LA103_0 <= DOUBLE_QUOTE_LITERAL) || LA103_0 == REGULAR_EXPR_LITERAL || LA103_0 == HEX_NUMBER_LITERAL || LA103_0 == DEC_NUMBER_LITERAL || LA103_0 == IDENTIFIER || (LA103_0 >= XML_COMMENT && LA103_0 <= XML_PI)) )
            {
                alt103 = 2;
            }
            else 
            {
                if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                NoViableAltException nvae_d103s0 =
                    new NoViableAltException("", 103, 0, input);

                throw nvae_d103s0;
            }
            switch (alt103) 
            {
                case 1 :
                    // AS3_ex.g3:2637:9: V= VAR variableDeclarationNoInList
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        V=(IToken)Match(input,VAR,FOLLOW_VAR_in_forInit9958); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {V_tree = (object)adaptor.Create(V);
                            adaptor.AddChild(root_0, V_tree);
                        }
                        if ( state.backtracking == 0 ) 
                        {
                          emit(V);
                        }
                        PushFollow(FOLLOW_variableDeclarationNoInList_in_forInit9961);
                        variableDeclarationNoInList209 = variableDeclarationNoInList();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, variableDeclarationNoInList209.Tree);

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:2638:9: expressionNoIn
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_expressionNoIn_in_forInit9971);
                        expressionNoIn210 = expressionNoIn();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, expressionNoIn210.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 81, forInit_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "forInit"

    public class forUpdate_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "forUpdate"
    // AS3_ex.g3:2641:1: forUpdate : expression ;
    public AS3_exParser.forUpdate_return forUpdate() // throws RecognitionException [1]
    {   
        AS3_exParser.forUpdate_return retval = new AS3_exParser.forUpdate_return();
        retval.Start = input.LT(1);
        int forUpdate_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.expression_return expression211 = null;



        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 82) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2642:5: ( expression )
            // AS3_ex.g3:2642:9: expression
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_expression_in_forUpdate9990);
                expression211 = expression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, expression211.Tree);

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 82, forUpdate_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "forUpdate"

    public class doWhileStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "doWhileStatement"
    // AS3_ex.g3:2650:1: doWhileStatement : D= DO statement W= WHILE parExpression semic (S= SEMI )? ;
    public AS3_exParser.doWhileStatement_return doWhileStatement() // throws RecognitionException [1]
    {   
        AS3_exParser.doWhileStatement_return retval = new AS3_exParser.doWhileStatement_return();
        retval.Start = input.LT(1);
        int doWhileStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken D = null;
        IToken W = null;
        IToken S = null;
        AS3_exParser.statement_return statement212 = null;

        AS3_exParser.parExpression_return parExpression213 = null;

        AS3_exParser.semic_return semic214 = null;


        object D_tree=null;
        object W_tree=null;
        object S_tree=null;


            int statementCount=0;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 83) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2655:5: (D= DO statement W= WHILE parExpression semic (S= SEMI )? )
            // AS3_ex.g3:2656:5: D= DO statement W= WHILE parExpression semic (S= SEMI )?
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  mPrinter.markDeclEqualsContextChange();
                }
                D=(IToken)Match(input,DO,FOLLOW_DO_in_doWhileStatement10032); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {D_tree = (object)adaptor.Create(D);
                    adaptor.AddChild(root_0, D_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(D);
                }
                if ( state.backtracking == 0 ) 
                {
                  pushIndent(false);
                }
                if ( state.backtracking == 0 ) 
                {
                  mPrinter.addOpenBrace(input, ASPrettyPrinter.BraceAdd_Loop);statementCount=mStatementCount;
                }
                PushFollow(FOLLOW_statement_in_doWhileStatement10052);
                statement212 = statement();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, statement212.Tree);
                if ( state.backtracking == 0 ) 
                {
                  mPrinter.addCloseBrace(input.LT(1), ASPrettyPrinter.BraceAdd_Loop, mStatementCount-statementCount);
                }
                if ( state.backtracking == 0 ) 
                {
                  popIndent();
                }
                if ( state.backtracking == 0 ) 
                {
                  insertWS(1);
                }
                if ( state.backtracking == 0 ) 
                {

                            if (mPrinter.isCRBeforeWhile() || !mPrinter.didLastStatementHaveBraces()) //add CR if explictly asked for or if there were no statement braces   
                                insertCR(false);
                        
                }
                W=(IToken)Match(input,WHILE,FOLLOW_WHILE_in_doWhileStatement10091); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {W_tree = (object)adaptor.Create(W);
                    adaptor.AddChild(root_0, W_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(W);{pushExpressionIndent();}insertWS(mPrinter.getSpacesBetweenControlKeywordsAndParens());
                }
                PushFollow(FOLLOW_parExpression_in_doWhileStatement10095);
                parExpression213 = parExpression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, parExpression213.Tree);
                PushFollow(FOLLOW_semic_in_doWhileStatement10097);
                semic214 = semic();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, semic214.Tree);
                // AS3_ex.g3:2666:133: (S= SEMI )?
                int alt104 = 2;
                int LA104_0 = input.LA(1);

                if ( (LA104_0 == SEMI) )
                {
                    int LA104_1 = input.LA(2);

                    if ( (synpred220_AS3_ex()) )
                    {
                        alt104 = 1;
                    }
                }
                switch (alt104) 
                {
                    case 1 :
                        // AS3_ex.g3:2666:134: S= SEMI
                        {
                            S=(IToken)Match(input,SEMI,FOLLOW_SEMI_in_doWhileStatement10102); if (state.failed) return retval;
                            if ( state.backtracking == 0 )
                            {S_tree = (object)adaptor.Create(S);
                                adaptor.AddChild(root_0, S_tree);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              emit(S);
                            }

                        }
                        break;

                }

                if ( state.backtracking == 0 ) 
                {
                  popIndent();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 83, doWhileStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "doWhileStatement"

    public class whileStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "whileStatement"
    // AS3_ex.g3:2673:1: whileStatement : W= WHILE parExpression statement ;
    public AS3_exParser.whileStatement_return whileStatement() // throws RecognitionException [1]
    {   
        AS3_exParser.whileStatement_return retval = new AS3_exParser.whileStatement_return();
        retval.Start = input.LT(1);
        int whileStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken W = null;
        AS3_exParser.parExpression_return parExpression215 = null;

        AS3_exParser.statement_return statement216 = null;


        object W_tree=null;


            int statementStartInOutput=(-1);
            int statementEndInOutput=(-1);
            int statementCount=0;
            IToken endToken=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 84) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2681:5: (W= WHILE parExpression statement )
            // AS3_ex.g3:2682:8: W= WHILE parExpression statement
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  mPrinter.markDeclEqualsContextChange();
                }
                W=(IToken)Match(input,WHILE,FOLLOW_WHILE_in_whileStatement10151); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {W_tree = (object)adaptor.Create(W);
                    adaptor.AddChild(root_0, W_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(W);statementStartInOutput=mPrinter.getCurrentOutputLength();insertWS(mPrinter.getSpacesBetweenControlKeywordsAndParens());
                }
                if ( state.backtracking == 0 ) 
                {
                  pushExpressionIndent();
                }
                PushFollow(FOLLOW_parExpression_in_whileStatement10156);
                parExpression215 = parExpression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, parExpression215.Tree);
                if ( state.backtracking == 0 ) 
                {
                  endToken=input.LT(-1);statementEndInOutput=mPrinter.getCurrentOutputLength();popIndent();
                }
                if ( state.backtracking == 0 ) 
                {
                  pushIndent(false);
                }
                if ( state.backtracking == 0 ) 
                {
                  mPrinter.addOpenBrace(input, ASPrettyPrinter.BraceAdd_Loop);
                         mPrinter.captureStatementStart(W, statementStartInOutput);
                         mPrinter.captureStatementEnd(endToken, statementEndInOutput);
                         statementCount=mStatementCount;
                        
                }
                PushFollow(FOLLOW_statement_in_whileStatement10176);
                statement216 = statement();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, statement216.Tree);
                if ( state.backtracking == 0 ) 
                {
                  mPrinter.addCloseBrace(input.LT(1), ASPrettyPrinter.BraceAdd_Loop, mStatementCount-statementCount);
                }
                if ( state.backtracking == 0 ) 
                {
                  popIndent();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 84, whileStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "whileStatement"

    public class ifStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "ifStatement"
    // AS3_ex.g3:2700:1: ifStatement : I= IF parExpression statement ( options {k=1; } : E= ELSE statement )? ;
    public AS3_exParser.ifStatement_return ifStatement() // throws RecognitionException [1]
    {   
        AS3_exParser.ifStatement_return retval = new AS3_exParser.ifStatement_return();
        retval.Start = input.LT(1);
        int ifStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken I = null;
        IToken E = null;
        AS3_exParser.parExpression_return parExpression217 = null;

        AS3_exParser.statement_return statement218 = null;

        AS3_exParser.statement_return statement219 = null;


        object I_tree=null;
        object E_tree=null;


           IToken tok=null;
           bool ifOnSameLine=false;
           bool wasBlock=false;
           bool needCloseBrace=false;
           int statementStartInOutput=(-1);
           int statementEndInOutput=(-1);
           int statementCount=0;
           IToken endToken=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 85) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2712:5: (I= IF parExpression statement ( options {k=1; } : E= ELSE statement )? )
            // AS3_ex.g3:2713:6: I= IF parExpression statement ( options {k=1; } : E= ELSE statement )?
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  mPrinter.markDeclEqualsContextChange();
                }
                if ( state.backtracking == 0 ) 
                {

                             tok=mPrinter.getLastToken(); 
                             //if the previous token was not an else, then insert a CR.  Also if it is an 'else' but the setting says to put the 'if' on a new line
                             if (!mPrinter.isKeepElseIfOnSameLine() || (tok==null) || tok.Text != "else")
                             {
                                    insertStatementCR();
                             }

                             if (tok!=null && tok.Text == "else")
                             {
                                    mPrinter.setElseIfState();
                             }
                          
                }
                I=(IToken)Match(input,IF,FOLLOW_IF_in_ifStatement10263); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {I_tree = (object)adaptor.Create(I);
                    adaptor.AddChild(root_0, I_tree);
                }
                if ( state.backtracking == 0 ) 
                {

                                emit(I);
                                statementStartInOutput=mPrinter.getCurrentOutputLength();
                                ifOnSameLine=mPrinter.getElseIfNeedToLoseIndent();
                                if (ifOnSameLine)
                                    popIndent();
                                insertWS(mPrinter.getSpacesBetweenControlKeywordsAndParens());
                           
                }
                if ( state.backtracking == 0 ) 
                {
                  pushExpressionIndent();
                }
                PushFollow(FOLLOW_parExpression_in_ifStatement10298);
                parExpression217 = parExpression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, parExpression217.Tree);
                if ( state.backtracking == 0 ) 
                {
                  endToken=input.LT(-1);statementEndInOutput=mPrinter.getCurrentOutputLength();
                }
                if ( state.backtracking == 0 ) 
                {
                  popIndent();
                }
                if ( state.backtracking == 0 ) 
                {
                  pushIndent(false);
                }
                if ( state.backtracking == 0 ) 
                {
                  addIfElseBlockTracker();setBlockFlag(false);clearBlockFlag();
                }
                if ( state.backtracking == 0 ) 
                {
                  mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_controlStatement_code);
                }
                if ( state.backtracking == 0 ) 
                {
                  mPrinter.addOpenBrace(input, ASPrettyPrinter.BraceAdd_Conditional);
                          mPrinter.captureStatementStart(I, statementStartInOutput);
                          mPrinter.captureStatementEnd(endToken, statementEndInOutput);
                          statementCount=mStatementCount;
                         
                }
                PushFollow(FOLLOW_statement_in_ifStatement10370);
                statement218 = statement();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, statement218.Tree);
                if ( state.backtracking == 0 ) 
                {
                  mPrinter.addCloseBrace(input.LT(1), ASPrettyPrinter.BraceAdd_Conditional, mStatementCount-statementCount);
                }
                if ( state.backtracking == 0 ) 
                {
                  popBlockStack();
                }
                if ( state.backtracking == 0 ) 
                {
                  wasBlock=isBlockFlag();popIfElseBlockTracker();
                }
                if ( state.backtracking == 0 ) 
                {
                  popIndent();
                }
                // AS3_ex.g3:2754:10: ( options {k=1; } : E= ELSE statement )?
                int alt105 = 2;
                int LA105_0 = input.LA(1);

                if ( (LA105_0 == ELSE) )
                {
                    int LA105_2 = input.LA(2);

                    if ( (synpred221_AS3_ex()) )
                    {
                        alt105 = 1;
                    }
                }
                switch (alt105) 
                {
                    case 1 :
                        // AS3_ex.g3:2754:26: E= ELSE statement
                        {
                            E=(IToken)Match(input,ELSE,FOLLOW_ELSE_in_ifStatement10447); if (state.failed) return retval;
                            if ( state.backtracking == 0 )
                            {E_tree = (object)adaptor.Create(E);
                                adaptor.AddChild(root_0, E_tree);
                            }
                            if ( state.backtracking == 0 ) 
                            {

                                          IToken tempTok=mPrinter.getLastToken();
                                          if (mPrinter.isCRBeforeElse() || !wasBlock)//tempTok==null || tempTok.Text != "}") 
                                              insertCR(false);
                                         
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              insertWS(1);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              emit(E);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              pushIndent(false);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_controlStatement_code);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              needCloseBrace=mPrinter.addOpenBraceForElse((CommonTokenStream)input);statementCount=mStatementCount;
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              mPrinter.inCondition();
                            }
                            PushFollow(FOLLOW_statement_in_ifStatement10535);
                            statement219 = statement();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, statement219.Tree);
                            if ( state.backtracking == 0 ) 
                            {
                              if (needCloseBrace)
                                            mPrinter.addCloseBrace(input.LT(1), ASPrettyPrinter.BraceAdd_Conditional, mStatementCount-statementCount);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              popBlockStack();
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              popIndent();
                            }

                        }
                        break;

                }

                if ( state.backtracking == 0 ) 
                {
                  if (ifOnSameLine)
                                pushIndent(false);
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 85, ifStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "ifStatement"

    public class emptyStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "emptyStatement"
    // AS3_ex.g3:2779:1: emptyStatement : S= SEMI ;
    public AS3_exParser.emptyStatement_return emptyStatement() // throws RecognitionException [1]
    {   
        AS3_exParser.emptyStatement_return retval = new AS3_exParser.emptyStatement_return();
        retval.Start = input.LT(1);
        int emptyStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken S = null;

        object S_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 86) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2780:5: (S= SEMI )
            // AS3_ex.g3:2780:11: S= SEMI
            {
                root_0 = (object)adaptor.GetNilNode();

                S=(IToken)Match(input,SEMI,FOLLOW_SEMI_in_emptyStatement10618); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {S_tree = (object)adaptor.Create(S);
                    adaptor.AddChild(root_0, S_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(S);
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 86, emptyStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "emptyStatement"

    public class variableStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "variableStatement"
    // AS3_ex.g3:2788:1: variableStatement : (I= IDENTIFIER )? V= VAR variableDeclaration (C= COMMA variableDeclaration )* semic ;
    public AS3_exParser.variableStatement_return variableStatement() // throws RecognitionException [1]
    {   
        AS3_exParser.variableStatement_return retval = new AS3_exParser.variableStatement_return();
        retval.Start = input.LT(1);
        int variableStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken I = null;
        IToken V = null;
        IToken C = null;
        AS3_exParser.variableDeclaration_return variableDeclaration220 = null;

        AS3_exParser.variableDeclaration_return variableDeclaration221 = null;

        AS3_exParser.semic_return semic222 = null;


        object I_tree=null;
        object V_tree=null;
        object C_tree=null;


            WrapOptions options=mPrinter.getExpressionWrapOptions();
            bool pushedFormat=false;
            bool pushedWrapInfo=false;
            bool pushedIndent=false;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 87) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2795:5: ( (I= IDENTIFIER )? V= VAR variableDeclaration (C= COMMA variableDeclaration )* semic )
            // AS3_ex.g3:2796:6: (I= IDENTIFIER )? V= VAR variableDeclaration (C= COMMA variableDeclaration )* semic
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  pushedFormat=pushFormatType(options, true);
                         pushedWrapInfo=pushWrapInfo(options, true);
                        
                }
                // AS3_ex.g3:2799:9: (I= IDENTIFIER )?
                int alt106 = 2;
                int LA106_0 = input.LA(1);

                if ( (LA106_0 == IDENTIFIER) )
                {
                    alt106 = 1;
                }
                switch (alt106) 
                {
                    case 1 :
                        // AS3_ex.g3:2799:10: I= IDENTIFIER
                        {
                            I=(IToken)Match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_variableStatement10665); if (state.failed) return retval;
                            if ( state.backtracking == 0 )
                            {I_tree = (object)adaptor.Create(I);
                                adaptor.AddChild(root_0, I_tree);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              emit(I);
                            }

                        }
                        break;

                }

                V=(IToken)Match(input,VAR,FOLLOW_VAR_in_variableStatement10673); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {V_tree = (object)adaptor.Create(V);
                    adaptor.AddChild(root_0, V_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(V);mInEqualAlignDecl=true;
                }
                PushFollow(FOLLOW_variableDeclaration_in_variableStatement10677);
                variableDeclaration220 = variableDeclaration();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, variableDeclaration220.Tree);
                if ( state.backtracking == 0 ) 
                {
                  mInEqualAlignDecl=false;
                }
                // AS3_ex.g3:2799:125: (C= COMMA variableDeclaration )*
                do 
                {
                    int alt107 = 2;
                    int LA107_0 = input.LA(1);

                    if ( (LA107_0 == COMMA) )
                    {
                        alt107 = 1;
                    }


                    switch (alt107) 
                    {
                        case 1 :
                            // AS3_ex.g3:2799:127: C= COMMA variableDeclaration
                            {
                                C=(IToken)Match(input,COMMA,FOLLOW_COMMA_in_variableStatement10685); if (state.failed) return retval;
                                if ( state.backtracking == 0 )
                                {C_tree = (object)adaptor.Create(C);
                                    adaptor.AddChild(root_0, C_tree);
                                }
                                if ( state.backtracking == 0 ) 
                                {
                                  pushedIndent=emitCommaWithSpacingAndCRs(options, C, pushedIndent, -1, ASPrettyPrinter.Break_SubType_Other);
                                }
                                PushFollow(FOLLOW_variableDeclaration_in_variableStatement10689);
                                variableDeclaration221 = variableDeclaration();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, variableDeclaration221.Tree);

                            }
                            break;

                        default:
                            goto loop107;
                    }
                } while (true);

                loop107:
                    ;   // Stops C# compiler whining that label 'loop107' has no statements

                PushFollow(FOLLOW_semic_in_variableStatement10694);
                semic222 = semic();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, semic222.Tree);
                if ( state.backtracking == 0 ) 
                {

                            if (pushedIndent)
                                popIndent();
                            if (pushedFormat)
                            {
                                mPrinter.popFormatMode();
                            }
                            if (pushedWrapInfo)
                                mPrinter.popWrapContext();
                        
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 87, variableStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "variableStatement"

    public class variableDeclarationList_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "variableDeclarationList"
    // AS3_ex.g3:2812:1: variableDeclarationList : variableDeclaration (C= COMMA variableDeclaration )* ;
    public AS3_exParser.variableDeclarationList_return variableDeclarationList() // throws RecognitionException [1]
    {   
        AS3_exParser.variableDeclarationList_return retval = new AS3_exParser.variableDeclarationList_return();
        retval.Start = input.LT(1);
        int variableDeclarationList_StartIndex = input.Index();
        object root_0 = null;

        IToken C = null;
        AS3_exParser.variableDeclaration_return variableDeclaration223 = null;

        AS3_exParser.variableDeclaration_return variableDeclaration224 = null;


        object C_tree=null;


            WrapOptions options=mPrinter.getExpressionWrapOptions();
            bool pushedFormat=false;
            bool pushedWrapInfo=false;
            bool pushedIndent=false;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 88) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2819:5: ( variableDeclaration (C= COMMA variableDeclaration )* )
            // AS3_ex.g3:2820:6: variableDeclaration (C= COMMA variableDeclaration )*
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  pushedFormat=pushFormatType(options, true);
                         pushedWrapInfo=pushWrapInfo(options, true);
                        
                }
                PushFollow(FOLLOW_variableDeclaration_in_variableDeclarationList10743);
                variableDeclaration223 = variableDeclaration();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, variableDeclaration223.Tree);
                // AS3_ex.g3:2823:30: (C= COMMA variableDeclaration )*
                do 
                {
                    int alt108 = 2;
                    int LA108_0 = input.LA(1);

                    if ( (LA108_0 == COMMA) )
                    {
                        alt108 = 1;
                    }


                    switch (alt108) 
                    {
                        case 1 :
                            // AS3_ex.g3:2823:33: C= COMMA variableDeclaration
                            {
                                C=(IToken)Match(input,COMMA,FOLLOW_COMMA_in_variableDeclarationList10750); if (state.failed) return retval;
                                if ( state.backtracking == 0 )
                                {C_tree = (object)adaptor.Create(C);
                                    adaptor.AddChild(root_0, C_tree);
                                }
                                if ( state.backtracking == 0 ) 
                                {
                                  pushedIndent=emitCommaWithSpacingAndCRs(options, C, pushedIndent, -1, ASPrettyPrinter.Break_SubType_Other);
                                }
                                PushFollow(FOLLOW_variableDeclaration_in_variableDeclarationList10754);
                                variableDeclaration224 = variableDeclaration();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, variableDeclaration224.Tree);

                            }
                            break;

                        default:
                            goto loop108;
                    }
                } while (true);

                loop108:
                    ;   // Stops C# compiler whining that label 'loop108' has no statements

                if ( state.backtracking == 0 ) 
                {

                            if (pushedIndent)
                                popIndent();
                            if (pushedFormat)
                            {
                                mPrinter.popFormatMode();
                            }
                            if (pushedWrapInfo)
                                mPrinter.popWrapContext();
                        
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 88, variableDeclarationList_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "variableDeclarationList"

    public class variableDeclarationNoInList_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "variableDeclarationNoInList"
    // AS3_ex.g3:2836:1: variableDeclarationNoInList : variableDeclarationNoIn (C= COMMA variableDeclarationNoIn )* ;
    public AS3_exParser.variableDeclarationNoInList_return variableDeclarationNoInList() // throws RecognitionException [1]
    {   
        AS3_exParser.variableDeclarationNoInList_return retval = new AS3_exParser.variableDeclarationNoInList_return();
        retval.Start = input.LT(1);
        int variableDeclarationNoInList_StartIndex = input.Index();
        object root_0 = null;

        IToken C = null;
        AS3_exParser.variableDeclarationNoIn_return variableDeclarationNoIn225 = null;

        AS3_exParser.variableDeclarationNoIn_return variableDeclarationNoIn226 = null;


        object C_tree=null;


            WrapOptions options=mPrinter.getExpressionWrapOptions();
            bool pushedFormat=false;
            bool pushedWrapInfo=false;
            bool pushedIndent=false;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 89) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2843:5: ( variableDeclarationNoIn (C= COMMA variableDeclarationNoIn )* )
            // AS3_ex.g3:2844:6: variableDeclarationNoIn (C= COMMA variableDeclarationNoIn )*
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  pushedFormat=pushFormatType(options, true);
                         pushedWrapInfo=pushWrapInfo(options, true);
                        
                }
                PushFollow(FOLLOW_variableDeclarationNoIn_in_variableDeclarationNoInList10803);
                variableDeclarationNoIn225 = variableDeclarationNoIn();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, variableDeclarationNoIn225.Tree);
                // AS3_ex.g3:2847:33: (C= COMMA variableDeclarationNoIn )*
                do 
                {
                    int alt109 = 2;
                    int LA109_0 = input.LA(1);

                    if ( (LA109_0 == COMMA) )
                    {
                        alt109 = 1;
                    }


                    switch (alt109) 
                    {
                        case 1 :
                            // AS3_ex.g3:2847:35: C= COMMA variableDeclarationNoIn
                            {
                                C=(IToken)Match(input,COMMA,FOLLOW_COMMA_in_variableDeclarationNoInList10809); if (state.failed) return retval;
                                if ( state.backtracking == 0 )
                                {C_tree = (object)adaptor.Create(C);
                                    adaptor.AddChild(root_0, C_tree);
                                }
                                if ( state.backtracking == 0 ) 
                                {
                                  pushedIndent=emitCommaWithSpacingAndCRs(options, C, pushedIndent, -1, ASPrettyPrinter.Break_SubType_Other);
                                }
                                PushFollow(FOLLOW_variableDeclarationNoIn_in_variableDeclarationNoInList10813);
                                variableDeclarationNoIn226 = variableDeclarationNoIn();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, variableDeclarationNoIn226.Tree);

                            }
                            break;

                        default:
                            goto loop109;
                    }
                } while (true);

                loop109:
                    ;   // Stops C# compiler whining that label 'loop109' has no statements

                if ( state.backtracking == 0 ) 
                {

                            if (pushedIndent)
                                popIndent();
                            if (pushedFormat)
                            {
                                mPrinter.popFormatMode();
                            }
                            if (pushedWrapInfo)
                                mPrinter.popWrapContext();
                        
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 89, variableDeclarationNoInList_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "variableDeclarationNoInList"

    public class variableDeclaration_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "variableDeclaration"
    // AS3_ex.g3:2860:1: variableDeclaration : variableIdentifierDecl (A= ASSIGN assignmentExpression )? ;
    public AS3_exParser.variableDeclaration_return variableDeclaration() // throws RecognitionException [1]
    {   
        AS3_exParser.variableDeclaration_return retval = new AS3_exParser.variableDeclaration_return();
        retval.Start = input.LT(1);
        int variableDeclaration_StartIndex = input.Index();
        object root_0 = null;

        IToken A = null;
        AS3_exParser.variableIdentifierDecl_return variableIdentifierDecl227 = null;

        AS3_exParser.assignmentExpression_return assignmentExpression228 = null;


        object A_tree=null;


            WrapOptions options=mPrinter.getExpressionWrapOptions();

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 90) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2864:5: ( variableIdentifierDecl (A= ASSIGN assignmentExpression )? )
            // AS3_ex.g3:2864:9: variableIdentifierDecl (A= ASSIGN assignmentExpression )?
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_variableIdentifierDecl_in_variableDeclaration10850);
                variableIdentifierDecl227 = variableIdentifierDecl();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, variableIdentifierDecl227.Tree);
                // AS3_ex.g3:2864:32: (A= ASSIGN assignmentExpression )?
                int alt110 = 2;
                int LA110_0 = input.LA(1);

                if ( (LA110_0 == ASSIGN) )
                {
                    alt110 = 1;
                }
                switch (alt110) 
                {
                    case 1 :
                        // AS3_ex.g3:2864:34: A= ASSIGN assignmentExpression
                        {
                            A=(IToken)Match(input,ASSIGN,FOLLOW_ASSIGN_in_variableDeclaration10856); if (state.failed) return retval;
                            if ( state.backtracking == 0 )
                            {A_tree = (object)adaptor.Create(A);
                                adaptor.AddChild(root_0, A_tree);
                            }
                            if ( state.backtracking == 0 ) 
                            {

                                        insertVariableDeclAssignmentWhitespace(A, true);
                                        {if (mInEqualAlignDecl) mPrinter.augmentDeclEqualPosition();}
                                        wrapEmit(A, mInFunctionParameterDecl ? ASPrettyPrinter.Break_Parameter_Assignment_code : ASPrettyPrinter.Break_Assignment_code);
                                        {if (mInEqualAlignDecl) mPrinter.captureDeclEqualPosition();}
                                        insertVariableDeclAssignmentWhitespace(A, false);
                                    
                            }
                            PushFollow(FOLLOW_assignmentExpression_in_variableDeclaration10872);
                            assignmentExpression228 = assignmentExpression();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, assignmentExpression228.Tree);
                            if ( state.backtracking == 0 ) 
                            {
                              popIndent();
                            }

                        }
                        break;

                }


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 90, variableDeclaration_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "variableDeclaration"

    public class variableDeclarationNoIn_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "variableDeclarationNoIn"
    // AS3_ex.g3:2875:1: variableDeclarationNoIn : variableIdentifierDecl (A= ASSIGN assignmentExpressionNoIn )? ;
    public AS3_exParser.variableDeclarationNoIn_return variableDeclarationNoIn() // throws RecognitionException [1]
    {   
        AS3_exParser.variableDeclarationNoIn_return retval = new AS3_exParser.variableDeclarationNoIn_return();
        retval.Start = input.LT(1);
        int variableDeclarationNoIn_StartIndex = input.Index();
        object root_0 = null;

        IToken A = null;
        AS3_exParser.variableIdentifierDecl_return variableIdentifierDecl229 = null;

        AS3_exParser.assignmentExpressionNoIn_return assignmentExpressionNoIn230 = null;


        object A_tree=null;


            WrapOptions options=mPrinter.getExpressionWrapOptions();

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 91) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2879:5: ( variableIdentifierDecl (A= ASSIGN assignmentExpressionNoIn )? )
            // AS3_ex.g3:2879:10: variableIdentifierDecl (A= ASSIGN assignmentExpressionNoIn )?
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_variableIdentifierDecl_in_variableDeclarationNoIn10901);
                variableIdentifierDecl229 = variableIdentifierDecl();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, variableIdentifierDecl229.Tree);
                // AS3_ex.g3:2879:33: (A= ASSIGN assignmentExpressionNoIn )?
                int alt111 = 2;
                int LA111_0 = input.LA(1);

                if ( (LA111_0 == ASSIGN) )
                {
                    alt111 = 1;
                }
                switch (alt111) 
                {
                    case 1 :
                        // AS3_ex.g3:2879:35: A= ASSIGN assignmentExpressionNoIn
                        {
                            A=(IToken)Match(input,ASSIGN,FOLLOW_ASSIGN_in_variableDeclarationNoIn10907); if (state.failed) return retval;
                            if ( state.backtracking == 0 )
                            {A_tree = (object)adaptor.Create(A);
                                adaptor.AddChild(root_0, A_tree);
                            }
                            if ( state.backtracking == 0 ) 
                            {

                                        insertVariableDeclAssignmentWhitespace(A, true);
                                        wrapEmit(A, ASPrettyPrinter.Break_Assignment_code);
                                        insertVariableDeclAssignmentWhitespace(A, false);
                                       
                            }
                            PushFollow(FOLLOW_assignmentExpressionNoIn_in_variableDeclarationNoIn10931);
                            assignmentExpressionNoIn230 = assignmentExpressionNoIn();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, assignmentExpressionNoIn230.Tree);
                            if ( state.backtracking == 0 ) 
                            {
                              popIndent();
                            }

                        }
                        break;

                }


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 91, variableDeclarationNoIn_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "variableDeclarationNoIn"

    public class variableIdentifierDecl_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "variableIdentifierDecl"
    // AS3_ex.g3:2888:1: variableIdentifierDecl : identifierLiteral (C= COLON type )? ;
    public AS3_exParser.variableIdentifierDecl_return variableIdentifierDecl() // throws RecognitionException [1]
    {   
        AS3_exParser.variableIdentifierDecl_return retval = new AS3_exParser.variableIdentifierDecl_return();
        retval.Start = input.LT(1);
        int variableIdentifierDecl_StartIndex = input.Index();
        object root_0 = null;

        IToken C = null;
        AS3_exParser.identifierLiteral_return identifierLiteral231 = null;

        AS3_exParser.type_return type232 = null;


        object C_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 92) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2889:2: ( identifierLiteral (C= COLON type )? )
            // AS3_ex.g3:2889:7: identifierLiteral (C= COLON type )?
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_identifierLiteral_in_variableIdentifierDecl10956);
                identifierLiteral231 = identifierLiteral();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, identifierLiteral231.Tree);
                // AS3_ex.g3:2889:25: (C= COLON type )?
                int alt112 = 2;
                int LA112_0 = input.LA(1);

                if ( (LA112_0 == COLON) )
                {
                    alt112 = 1;
                }
                switch (alt112) 
                {
                    case 1 :
                        // AS3_ex.g3:2889:27: C= COLON type
                        {
                            C=(IToken)Match(input,COLON,FOLLOW_COLON_in_variableIdentifierDecl10962); if (state.failed) return retval;
                            if ( state.backtracking == 0 )
                            {C_tree = (object)adaptor.Create(C);
                                adaptor.AddChild(root_0, C_tree);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              insertWS(mPrinter.getAdvancedSpacesBeforeColonsInDeclarations());emit(C);insertWS(mPrinter.getAdvancedSpacesAfterColonsInDeclarations());
                            }
                            PushFollow(FOLLOW_type_in_variableIdentifierDecl10966);
                            type232 = type();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, type232.Tree);

                        }
                        break;

                }


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 92, variableIdentifierDecl_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "variableIdentifierDecl"

    public class type_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "type"
    // AS3_ex.g3:2895:1: type : ( qualifiedName | S= STAR | V= VOID );
    public AS3_exParser.type_return type() // throws RecognitionException [1]
    {   
        AS3_exParser.type_return retval = new AS3_exParser.type_return();
        retval.Start = input.LT(1);
        int type_StartIndex = input.Index();
        object root_0 = null;

        IToken S = null;
        IToken V = null;
        AS3_exParser.qualifiedName_return qualifiedName233 = null;


        object S_tree=null;
        object V_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 93) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2895:5: ( qualifiedName | S= STAR | V= VOID )
            int alt113 = 3;
            switch ( input.LA(1) ) 
            {
            case DEFAULT:
            case INTERNAL:
            case NATIVE:
            case TO:
            case EACH:
            case GET:
            case SET:
            case NAMESPACE:
            case DYNAMIC:
            case FINAL:
            case OVERRIDE:
            case STATIC:
            case IDENTIFIER:
                {
                alt113 = 1;
                }
                break;
            case STAR:
                {
                alt113 = 2;
                }
                break;
            case VOID:
                {
                alt113 = 3;
                }
                break;
                default:
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    NoViableAltException nvae_d113s0 =
                        new NoViableAltException("", 113, 0, input);

                    throw nvae_d113s0;
            }

            switch (alt113) 
            {
                case 1 :
                    // AS3_ex.g3:2895:9: qualifiedName
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_qualifiedName_in_type10990);
                        qualifiedName233 = qualifiedName();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, qualifiedName233.Tree);

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:2895:25: S= STAR
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        S=(IToken)Match(input,STAR,FOLLOW_STAR_in_type10996); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {S_tree = (object)adaptor.Create(S);
                            adaptor.AddChild(root_0, S_tree);
                        }
                        if ( state.backtracking == 0 ) 
                        {
                          emit(S);
                        }

                    }
                    break;
                case 3 :
                    // AS3_ex.g3:2895:46: V= VOID
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        V=(IToken)Match(input,VOID,FOLLOW_VOID_in_type11004); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {V_tree = (object)adaptor.Create(V);
                            adaptor.AddChild(root_0, V_tree);
                        }
                        if ( state.backtracking == 0 ) 
                        {
                          emit(V);
                        }

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 93, type_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "type"

    public class typeList_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "typeList"
    // AS3_ex.g3:2897:1: typeList : type (C= COMMA type )* ;
    public AS3_exParser.typeList_return typeList() // throws RecognitionException [1]
    {   
        AS3_exParser.typeList_return retval = new AS3_exParser.typeList_return();
        retval.Start = input.LT(1);
        int typeList_StartIndex = input.Index();
        object root_0 = null;

        IToken C = null;
        AS3_exParser.type_return type234 = null;

        AS3_exParser.type_return type235 = null;


        object C_tree=null;


            WrapOptions options=mPrinter.getExpressionWrapOptions();
            bool pushedFormat=false;
            bool pushedWrapInfo=false;
            bool pushedIndent=false;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 94) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2904:5: ( type (C= COMMA type )* )
            // AS3_ex.g3:2905:6: type (C= COMMA type )*
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  pushedFormat=pushFormatType(options, true);
                         pushedWrapInfo=pushWrapInfo(options, true);
                        
                }
                PushFollow(FOLLOW_type_in_typeList11037);
                type234 = type();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, type234.Tree);
                // AS3_ex.g3:2908:13: (C= COMMA type )*
                do 
                {
                    int alt114 = 2;
                    int LA114_0 = input.LA(1);

                    if ( (LA114_0 == COMMA) )
                    {
                        alt114 = 1;
                    }


                    switch (alt114) 
                    {
                        case 1 :
                            // AS3_ex.g3:2908:14: C= COMMA type
                            {
                                C=(IToken)Match(input,COMMA,FOLLOW_COMMA_in_typeList11042); if (state.failed) return retval;
                                if ( state.backtracking == 0 )
                                {C_tree = (object)adaptor.Create(C);
                                    adaptor.AddChild(root_0, C_tree);
                                }
                                if ( state.backtracking == 0 ) 
                                {
                                  pushedIndent=emitCommaWithSpacingAndCRs(options, C, pushedIndent, -1, ASPrettyPrinter.Break_SubType_Other);
                                }
                                PushFollow(FOLLOW_type_in_typeList11046);
                                type235 = type();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, type235.Tree);

                            }
                            break;

                        default:
                            goto loop114;
                    }
                } while (true);

                loop114:
                    ;   // Stops C# compiler whining that label 'loop114' has no statements

                if ( state.backtracking == 0 ) 
                {

                            if (pushedIndent)
                                popIndent();
                            if (pushedFormat)
                            {
                                mPrinter.popFormatMode();
                            }
                            if (pushedWrapInfo)
                                mPrinter.popWrapContext();
                        
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 94, typeList_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "typeList"

    public class standardQualifiedName_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "standardQualifiedName"
    // AS3_ex.g3:2922:1: standardQualifiedName : typeSpecifier (D= DOT typeSpecifier )* ;
    public AS3_exParser.standardQualifiedName_return standardQualifiedName() // throws RecognitionException [1]
    {   
        AS3_exParser.standardQualifiedName_return retval = new AS3_exParser.standardQualifiedName_return();
        retval.Start = input.LT(1);
        int standardQualifiedName_StartIndex = input.Index();
        object root_0 = null;

        IToken D = null;
        AS3_exParser.typeSpecifier_return typeSpecifier236 = null;

        AS3_exParser.typeSpecifier_return typeSpecifier237 = null;


        object D_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 95) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2923:2: ( typeSpecifier (D= DOT typeSpecifier )* )
            // AS3_ex.g3:2924:2: typeSpecifier (D= DOT typeSpecifier )*
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_typeSpecifier_in_standardQualifiedName11077);
                typeSpecifier236 = typeSpecifier();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, typeSpecifier236.Tree);
                // AS3_ex.g3:2924:16: (D= DOT typeSpecifier )*
                do 
                {
                    int alt115 = 2;
                    int LA115_0 = input.LA(1);

                    if ( (LA115_0 == DOT) )
                    {
                        int LA115_1 = input.LA(2);

                        if ( (LA115_1 == DEFAULT || LA115_1 == INTERNAL || LA115_1 == NATIVE || LA115_1 == TO || (LA115_1 >= EACH && LA115_1 <= NAMESPACE) || (LA115_1 >= DYNAMIC && LA115_1 <= STATIC) || LA115_1 == IDENTIFIER) )
                        {
                            alt115 = 1;
                        }


                    }


                    switch (alt115) 
                    {
                        case 1 :
                            // AS3_ex.g3:2924:17: D= DOT typeSpecifier
                            {
                                D=(IToken)Match(input,DOT,FOLLOW_DOT_in_standardQualifiedName11082); if (state.failed) return retval;
                                if ( state.backtracking == 0 )
                                {D_tree = (object)adaptor.Create(D);
                                    adaptor.AddChild(root_0, D_tree);
                                }
                                if ( state.backtracking == 0 ) 
                                {
                                  wrapEmit(D, ASPrettyPrinter.Break_Other_Connectors_code);
                                }
                                PushFollow(FOLLOW_typeSpecifier_in_standardQualifiedName11086);
                                typeSpecifier237 = typeSpecifier();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, typeSpecifier237.Tree);
                                if ( state.backtracking == 0 ) 
                                {
                                  popIndent();
                                }

                            }
                            break;

                        default:
                            goto loop115;
                    }
                } while (true);

                loop115:
                    ;   // Stops C# compiler whining that label 'loop115' has no statements


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 95, standardQualifiedName_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "standardQualifiedName"

    public class qualifiedName_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "qualifiedName"
    // AS3_ex.g3:2928:1: qualifiedName : standardQualifiedName ( typePostfixSyntax )? ;
    public AS3_exParser.qualifiedName_return qualifiedName() // throws RecognitionException [1]
    {   
        AS3_exParser.qualifiedName_return retval = new AS3_exParser.qualifiedName_return();
        retval.Start = input.LT(1);
        int qualifiedName_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.standardQualifiedName_return standardQualifiedName238 = null;

        AS3_exParser.typePostfixSyntax_return typePostfixSyntax239 = null;



        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 96) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2929:5: ( standardQualifiedName ( typePostfixSyntax )? )
            // AS3_ex.g3:2930:6: standardQualifiedName ( typePostfixSyntax )?
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_standardQualifiedName_in_qualifiedName11115);
                standardQualifiedName238 = standardQualifiedName();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, standardQualifiedName238.Tree);
                // AS3_ex.g3:2930:28: ( typePostfixSyntax )?
                int alt116 = 2;
                int LA116_0 = input.LA(1);

                if ( (LA116_0 == DOT) )
                {
                    int LA116_1 = input.LA(2);

                    if ( (LA116_1 == LT) )
                    {
                        alt116 = 1;
                    }
                }
                switch (alt116) 
                {
                    case 1 :
                        // AS3_ex.g3:2930:29: typePostfixSyntax
                        {
                            PushFollow(FOLLOW_typePostfixSyntax_in_qualifiedName11118);
                            typePostfixSyntax239 = typePostfixSyntax();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, typePostfixSyntax239.Tree);

                        }
                        break;

                }


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 96, qualifiedName_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "qualifiedName"

    public class typePostfixSyntax_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "typePostfixSyntax"
    // AS3_ex.g3:2933:1: typePostfixSyntax : D= DOT L= LT ( standardQualifiedName | st= STAR ) ( typePostfixSyntax )? G= GT ;
    public AS3_exParser.typePostfixSyntax_return typePostfixSyntax() // throws RecognitionException [1]
    {   
        AS3_exParser.typePostfixSyntax_return retval = new AS3_exParser.typePostfixSyntax_return();
        retval.Start = input.LT(1);
        int typePostfixSyntax_StartIndex = input.Index();
        object root_0 = null;

        IToken D = null;
        IToken L = null;
        IToken st = null;
        IToken G = null;
        AS3_exParser.standardQualifiedName_return standardQualifiedName240 = null;

        AS3_exParser.typePostfixSyntax_return typePostfixSyntax241 = null;


        object D_tree=null;
        object L_tree=null;
        object st_tree=null;
        object G_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 97) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2933:18: (D= DOT L= LT ( standardQualifiedName | st= STAR ) ( typePostfixSyntax )? G= GT )
            // AS3_ex.g3:2934:2: D= DOT L= LT ( standardQualifiedName | st= STAR ) ( typePostfixSyntax )? G= GT
            {
                root_0 = (object)adaptor.GetNilNode();

                D=(IToken)Match(input,DOT,FOLLOW_DOT_in_typePostfixSyntax11140); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {D_tree = (object)adaptor.Create(D);
                    adaptor.AddChild(root_0, D_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(D);
                }
                L=(IToken)Match(input,LT,FOLLOW_LT_in_typePostfixSyntax11150); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {L_tree = (object)adaptor.Create(L);
                    adaptor.AddChild(root_0, L_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(L);
                }
                // AS3_ex.g3:2937:19: ( standardQualifiedName | st= STAR )
                int alt117 = 2;
                int LA117_0 = input.LA(1);

                if ( (LA117_0 == DEFAULT || LA117_0 == INTERNAL || LA117_0 == NATIVE || LA117_0 == TO || (LA117_0 >= EACH && LA117_0 <= NAMESPACE) || (LA117_0 >= DYNAMIC && LA117_0 <= STATIC) || LA117_0 == IDENTIFIER) )
                {
                    alt117 = 1;
                }
                else if ( (LA117_0 == STAR) )
                {
                    alt117 = 2;
                }
                else 
                {
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    NoViableAltException nvae_d117s0 =
                        new NoViableAltException("", 117, 0, input);

                    throw nvae_d117s0;
                }
                switch (alt117) 
                {
                    case 1 :
                        // AS3_ex.g3:2937:20: standardQualifiedName
                        {
                            PushFollow(FOLLOW_standardQualifiedName_in_typePostfixSyntax11155);
                            standardQualifiedName240 = standardQualifiedName();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, standardQualifiedName240.Tree);

                        }
                        break;
                    case 2 :
                        // AS3_ex.g3:2937:44: st= STAR
                        {
                            st=(IToken)Match(input,STAR,FOLLOW_STAR_in_typePostfixSyntax11161); if (state.failed) return retval;
                            if ( state.backtracking == 0 )
                            {st_tree = (object)adaptor.Create(st);
                                adaptor.AddChild(root_0, st_tree);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              emit(st);
                            }

                        }
                        break;

                }

                // AS3_ex.g3:2937:66: ( typePostfixSyntax )?
                int alt118 = 2;
                int LA118_0 = input.LA(1);

                if ( (LA118_0 == DOT) )
                {
                    alt118 = 1;
                }
                switch (alt118) 
                {
                    case 1 :
                        // AS3_ex.g3:2937:67: typePostfixSyntax
                        {
                            PushFollow(FOLLOW_typePostfixSyntax_in_typePostfixSyntax11167);
                            typePostfixSyntax241 = typePostfixSyntax();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, typePostfixSyntax241.Tree);

                        }
                        break;

                }

                G=(IToken)Match(input,GT,FOLLOW_GT_in_typePostfixSyntax11173); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {G_tree = (object)adaptor.Create(G);
                    adaptor.AddChild(root_0, G_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(G);
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 97, typePostfixSyntax_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "typePostfixSyntax"

    public class qualifiedIdentifier_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "qualifiedIdentifier"
    // AS3_ex.g3:2941:1: qualifiedIdentifier : I= IDENTIFIER ;
    public AS3_exParser.qualifiedIdentifier_return qualifiedIdentifier() // throws RecognitionException [1]
    {   
        AS3_exParser.qualifiedIdentifier_return retval = new AS3_exParser.qualifiedIdentifier_return();
        retval.Start = input.LT(1);
        int qualifiedIdentifier_StartIndex = input.Index();
        object root_0 = null;

        IToken I = null;

        object I_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 98) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2942:5: (I= IDENTIFIER )
            // AS3_ex.g3:2943:6: I= IDENTIFIER
            {
                root_0 = (object)adaptor.GetNilNode();

                I=(IToken)Match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_qualifiedIdentifier11206); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {I_tree = (object)adaptor.Create(I);
                    adaptor.AddChild(root_0, I_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(I);
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 98, qualifiedIdentifier_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "qualifiedIdentifier"

    public class parExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "parExpression"
    // AS3_ex.g3:2949:1: parExpression : L= LPAREN expression R= RPAREN ;
    public AS3_exParser.parExpression_return parExpression() // throws RecognitionException [1]
    {   
        AS3_exParser.parExpression_return retval = new AS3_exParser.parExpression_return();
        retval.Start = input.LT(1);
        int parExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        IToken R = null;
        AS3_exParser.expression_return expression242 = null;


        object L_tree=null;
        object R_tree=null;


            bool pushedWrap=false;
            WrapOptions options=mPrinter.getExpressionWrapOptions();

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 99) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2955:5: (L= LPAREN expression R= RPAREN )
            // AS3_ex.g3:2956:5: L= LPAREN expression R= RPAREN
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  pushedWrap=pushWrapInfo(options, true);
                }
                L=(IToken)Match(input,LPAREN,FOLLOW_LPAREN_in_parExpression11243); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {L_tree = (object)adaptor.Create(L);
                    adaptor.AddChild(root_0, L_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(L);insertWS(mPrinter.getAdvancedSpacesInsideParensInOtherPlaces());
                }
                if ( state.backtracking == 0 ) 
                {
                  pushExpressionIndent();
                }
                PushFollow(FOLLOW_expression_in_parExpression11250);
                expression242 = expression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, expression242.Tree);
                R=(IToken)Match(input,RPAREN,FOLLOW_RPAREN_in_parExpression11255); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {R_tree = (object)adaptor.Create(R);
                    adaptor.AddChild(root_0, R_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  insertWS(mPrinter.getAdvancedSpacesInsideParensInOtherPlaces());emit(R);
                }
                if ( state.backtracking == 0 ) 
                {
                  popIndent();
                }
                if ( state.backtracking == 0 ) 
                {
                  if (pushedWrap) mPrinter.popWrapContext();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 99, parExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "parExpression"

    public class expression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "expression"
    // AS3_ex.g3:2961:1: expression : assignmentExpression (C= COMMA assignmentExpression )* ;
    public AS3_exParser.expression_return expression() // throws RecognitionException [1]
    {   
        AS3_exParser.expression_return retval = new AS3_exParser.expression_return();
        retval.Start = input.LT(1);
        int expression_StartIndex = input.Index();
        object root_0 = null;

        IToken C = null;
        AS3_exParser.assignmentExpression_return assignmentExpression243 = null;

        AS3_exParser.assignmentExpression_return assignmentExpression244 = null;


        object C_tree=null;


            WrapOptions options=mPrinter.getExpressionWrapOptions();
            bool pushedFormat=false;
            bool pushedWrapInfo=false;
            bool pushedIndent=false;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 100) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2968:5: ( assignmentExpression (C= COMMA assignmentExpression )* )
            // AS3_ex.g3:2969:6: assignmentExpression (C= COMMA assignmentExpression )*
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  pushedFormat=pushFormatType(options, true);
                         pushedWrapInfo=pushWrapInfo(options, true);
                        
                }
                PushFollow(FOLLOW_assignmentExpression_in_expression11302);
                assignmentExpression243 = assignmentExpression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, assignmentExpression243.Tree);
                // AS3_ex.g3:2972:27: (C= COMMA assignmentExpression )*
                do 
                {
                    int alt119 = 2;
                    int LA119_0 = input.LA(1);

                    if ( (LA119_0 == COMMA) )
                    {
                        int LA119_2 = input.LA(2);

                        if ( (synpred236_AS3_ex()) )
                        {
                            alt119 = 1;
                        }


                    }


                    switch (alt119) 
                    {
                        case 1 :
                            // AS3_ex.g3:2972:30: C= COMMA assignmentExpression
                            {
                                C=(IToken)Match(input,COMMA,FOLLOW_COMMA_in_expression11309); if (state.failed) return retval;
                                if ( state.backtracking == 0 )
                                {C_tree = (object)adaptor.Create(C);
                                    adaptor.AddChild(root_0, C_tree);
                                }
                                if ( state.backtracking == 0 ) 
                                {
                                  pushedIndent=emitCommaWithSpacingAndCRs(options, C, pushedIndent, -1, ASPrettyPrinter.Break_SubType_Other);
                                }
                                PushFollow(FOLLOW_assignmentExpression_in_expression11314);
                                assignmentExpression244 = assignmentExpression();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, assignmentExpression244.Tree);

                            }
                            break;

                        default:
                            goto loop119;
                    }
                } while (true);

                loop119:
                    ;   // Stops C# compiler whining that label 'loop119' has no statements

                if ( state.backtracking == 0 ) 
                {

                            if (pushedIndent)
                                popIndent();
                            if (pushedFormat)
                            {
                                mPrinter.popFormatMode();
                            }
                            if (pushedWrapInfo)
                                mPrinter.popWrapContext();
                        
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 100, expression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "expression"

    public class expressionNoIn_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "expressionNoIn"
    // AS3_ex.g3:2985:1: expressionNoIn : assignmentExpressionNoIn (C= COMMA assignmentExpressionNoIn )* ;
    public AS3_exParser.expressionNoIn_return expressionNoIn() // throws RecognitionException [1]
    {   
        AS3_exParser.expressionNoIn_return retval = new AS3_exParser.expressionNoIn_return();
        retval.Start = input.LT(1);
        int expressionNoIn_StartIndex = input.Index();
        object root_0 = null;

        IToken C = null;
        AS3_exParser.assignmentExpressionNoIn_return assignmentExpressionNoIn245 = null;

        AS3_exParser.assignmentExpressionNoIn_return assignmentExpressionNoIn246 = null;


        object C_tree=null;


            WrapOptions options=mPrinter.getExpressionWrapOptions();
            bool pushedFormat=false;
            bool pushedWrapInfo=false;
            bool pushedIndent=false;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 101) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:2992:5: ( assignmentExpressionNoIn (C= COMMA assignmentExpressionNoIn )* )
            // AS3_ex.g3:2993:6: assignmentExpressionNoIn (C= COMMA assignmentExpressionNoIn )*
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  pushedFormat=pushFormatType(options, true);
                         pushedWrapInfo=pushWrapInfo(options, true);
                        
                }
                PushFollow(FOLLOW_assignmentExpressionNoIn_in_expressionNoIn11358);
                assignmentExpressionNoIn245 = assignmentExpressionNoIn();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, assignmentExpressionNoIn245.Tree);
                // AS3_ex.g3:2996:33: (C= COMMA assignmentExpressionNoIn )*
                do 
                {
                    int alt120 = 2;
                    int LA120_0 = input.LA(1);

                    if ( (LA120_0 == COMMA) )
                    {
                        alt120 = 1;
                    }


                    switch (alt120) 
                    {
                        case 1 :
                            // AS3_ex.g3:2996:36: C= COMMA assignmentExpressionNoIn
                            {
                                C=(IToken)Match(input,COMMA,FOLLOW_COMMA_in_expressionNoIn11365); if (state.failed) return retval;
                                if ( state.backtracking == 0 )
                                {C_tree = (object)adaptor.Create(C);
                                    adaptor.AddChild(root_0, C_tree);
                                }
                                if ( state.backtracking == 0 ) 
                                {
                                  pushedIndent=emitCommaWithSpacingAndCRs(options, C, pushedIndent, -1, ASPrettyPrinter.Break_SubType_Other);
                                }
                                PushFollow(FOLLOW_assignmentExpressionNoIn_in_expressionNoIn11370);
                                assignmentExpressionNoIn246 = assignmentExpressionNoIn();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, assignmentExpressionNoIn246.Tree);

                            }
                            break;

                        default:
                            goto loop120;
                    }
                } while (true);

                loop120:
                    ;   // Stops C# compiler whining that label 'loop120' has no statements

                if ( state.backtracking == 0 ) 
                {

                            if (pushedIndent)
                                popIndent();
                            if (pushedFormat)
                            {
                                mPrinter.popFormatMode();
                            }
                            if (pushedWrapInfo)
                                mPrinter.popWrapContext();
                        
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 101, expressionNoIn_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "expressionNoIn"

    public class assignmentExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "assignmentExpression"
    // AS3_ex.g3:3010:1: assignmentExpression : ( ( leftHandSideExpression assignmentOperator )=> leftHandSideExpression assignmentOperator assignmentExpression | conditionalExpression ) ;
    public AS3_exParser.assignmentExpression_return assignmentExpression() // throws RecognitionException [1]
    {   
        AS3_exParser.assignmentExpression_return retval = new AS3_exParser.assignmentExpression_return();
        retval.Start = input.LT(1);
        int assignmentExpression_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.leftHandSideExpression_return leftHandSideExpression247 = null;

        AS3_exParser.assignmentOperator_return assignmentOperator248 = null;

        AS3_exParser.assignmentExpression_return assignmentExpression249 = null;

        AS3_exParser.conditionalExpression_return conditionalExpression250 = null;




            WrapOptions options=mPrinter.getExpressionWrapOptions();
            bool pushedWrapInfo=false;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 102) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3015:5: ( ( ( leftHandSideExpression assignmentOperator )=> leftHandSideExpression assignmentOperator assignmentExpression | conditionalExpression ) )
            // AS3_ex.g3:3016:8: ( ( leftHandSideExpression assignmentOperator )=> leftHandSideExpression assignmentOperator assignmentExpression | conditionalExpression )
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  pushedWrapInfo=pushWrapInfo(options, true);
                }
                // AS3_ex.g3:3017:7: ( ( leftHandSideExpression assignmentOperator )=> leftHandSideExpression assignmentOperator assignmentExpression | conditionalExpression )
                int alt121 = 2;
                alt121 = dfa121.Predict(input);
                switch (alt121) 
                {
                    case 1 :
                        // AS3_ex.g3:3018:9: ( leftHandSideExpression assignmentOperator )=> leftHandSideExpression assignmentOperator assignmentExpression
                        {
                            PushFollow(FOLLOW_leftHandSideExpression_in_assignmentExpression11438);
                            leftHandSideExpression247 = leftHandSideExpression();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, leftHandSideExpression247.Tree);
                            PushFollow(FOLLOW_assignmentOperator_in_assignmentExpression11441);
                            assignmentOperator248 = assignmentOperator();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, assignmentOperator248.Tree);
                            PushFollow(FOLLOW_assignmentExpression_in_assignmentExpression11444);
                            assignmentExpression249 = assignmentExpression();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, assignmentExpression249.Tree);

                        }
                        break;
                    case 2 :
                        // AS3_ex.g3:3019:8: conditionalExpression
                        {
                            PushFollow(FOLLOW_conditionalExpression_in_assignmentExpression11453);
                            conditionalExpression250 = conditionalExpression();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, conditionalExpression250.Tree);

                        }
                        break;

                }

                if ( state.backtracking == 0 ) 
                {
                  if (pushedWrapInfo)
                            mPrinter.popWrapContext();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 102, assignmentExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "assignmentExpression"

    public class assignmentExpressionNoIn_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "assignmentExpressionNoIn"
    // AS3_ex.g3:3026:1: assignmentExpressionNoIn : ( ( leftHandSideExpression assignmentOperator )=> leftHandSideExpression assignmentOperator assignmentExpressionNoIn | conditionalExpressionNoIn ) ;
    public AS3_exParser.assignmentExpressionNoIn_return assignmentExpressionNoIn() // throws RecognitionException [1]
    {   
        AS3_exParser.assignmentExpressionNoIn_return retval = new AS3_exParser.assignmentExpressionNoIn_return();
        retval.Start = input.LT(1);
        int assignmentExpressionNoIn_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.leftHandSideExpression_return leftHandSideExpression251 = null;

        AS3_exParser.assignmentOperator_return assignmentOperator252 = null;

        AS3_exParser.assignmentExpressionNoIn_return assignmentExpressionNoIn253 = null;

        AS3_exParser.conditionalExpressionNoIn_return conditionalExpressionNoIn254 = null;




            WrapOptions options=mPrinter.getExpressionWrapOptions();
            bool pushedWrapInfo=false;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 103) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3031:5: ( ( ( leftHandSideExpression assignmentOperator )=> leftHandSideExpression assignmentOperator assignmentExpressionNoIn | conditionalExpressionNoIn ) )
            // AS3_ex.g3:3031:8: ( ( leftHandSideExpression assignmentOperator )=> leftHandSideExpression assignmentOperator assignmentExpressionNoIn | conditionalExpressionNoIn )
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  pushedWrapInfo=pushWrapInfo(options, true);
                }
                // AS3_ex.g3:3032:8: ( ( leftHandSideExpression assignmentOperator )=> leftHandSideExpression assignmentOperator assignmentExpressionNoIn | conditionalExpressionNoIn )
                int alt122 = 2;
                alt122 = dfa122.Predict(input);
                switch (alt122) 
                {
                    case 1 :
                        // AS3_ex.g3:3033:9: ( leftHandSideExpression assignmentOperator )=> leftHandSideExpression assignmentOperator assignmentExpressionNoIn
                        {
                            PushFollow(FOLLOW_leftHandSideExpression_in_assignmentExpressionNoIn11523);
                            leftHandSideExpression251 = leftHandSideExpression();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, leftHandSideExpression251.Tree);
                            PushFollow(FOLLOW_assignmentOperator_in_assignmentExpressionNoIn11526);
                            assignmentOperator252 = assignmentOperator();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, assignmentOperator252.Tree);
                            PushFollow(FOLLOW_assignmentExpressionNoIn_in_assignmentExpressionNoIn11529);
                            assignmentExpressionNoIn253 = assignmentExpressionNoIn();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, assignmentExpressionNoIn253.Tree);

                        }
                        break;
                    case 2 :
                        // AS3_ex.g3:3034:8: conditionalExpressionNoIn
                        {
                            PushFollow(FOLLOW_conditionalExpressionNoIn_in_assignmentExpressionNoIn11538);
                            conditionalExpressionNoIn254 = conditionalExpressionNoIn();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, conditionalExpressionNoIn254.Tree);

                        }
                        break;

                }

                if ( state.backtracking == 0 ) 
                {
                  if (pushedWrapInfo)
                            mPrinter.popWrapContext();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 103, assignmentExpressionNoIn_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "assignmentExpressionNoIn"

    public class assignmentOperator_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "assignmentOperator"
    // AS3_ex.g3:3040:1: assignmentOperator : op= assignmentOperator_int ;
    public AS3_exParser.assignmentOperator_return assignmentOperator() // throws RecognitionException [1]
    {   
        AS3_exParser.assignmentOperator_return retval = new AS3_exParser.assignmentOperator_return();
        retval.Start = input.LT(1);
        int assignmentOperator_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.assignmentOperator_int_return op = null;




            WrapOptions options=mPrinter.getExpressionWrapOptions();

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 104) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3044:2: (op= assignmentOperator_int )
            // AS3_ex.g3:3044:4: op= assignmentOperator_int
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_assignmentOperator_int_in_assignmentOperator11575);
                op = assignmentOperator_int();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, op.Tree);
                if ( state.backtracking == 0 ) 
                {
                  insertWS(mPrinter.getSpacesAroundAssignment());
                       emit((IToken)op.Start);
                       mPrinter.saveWrapChar((IToken)op.Start, ASPrettyPrinter.Break_Assignment_code, options.isBeforeAssignmentOperator(), false, -1, "");
                       insertWS(mPrinter.getSpacesAroundAssignment());
                      
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 104, assignmentOperator_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "assignmentOperator"

    public class assignmentOperator_int_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "assignmentOperator_int"
    // AS3_ex.g3:3052:1: assignmentOperator_int : ( ASSIGN | s= STAR a= ASSIGN | DIV_ASSIGN | MOD_ASSIGN | ADD_ASSIGN | SUB_ASSIGN | SHL_ASSIGN | ( ( '>' '>' '=' )=>t1= '>' t2= '>' t3= '=' {...}? -> SHR_ASSIGN ) | ( ( '>' '>' '>' '=' )=>t1= '>' t2= '>' t3= '>' t4= '=' {...}? -> SHU_ASSIGN ) | AND_ASSIGN | XOR_ASSIGN | OR_ASSIGN | LOR_ASSIGN | LAND_ASSIGN );
    public AS3_exParser.assignmentOperator_int_return assignmentOperator_int() // throws RecognitionException [1]
    {   
        AS3_exParser.assignmentOperator_int_return retval = new AS3_exParser.assignmentOperator_int_return();
        retval.Start = input.LT(1);
        int assignmentOperator_int_StartIndex = input.Index();
        object root_0 = null;

        IToken s = null;
        IToken a = null;
        IToken t1 = null;
        IToken t2 = null;
        IToken t3 = null;
        IToken t4 = null;
        IToken ASSIGN255 = null;
        IToken DIV_ASSIGN256 = null;
        IToken MOD_ASSIGN257 = null;
        IToken ADD_ASSIGN258 = null;
        IToken SUB_ASSIGN259 = null;
        IToken SHL_ASSIGN260 = null;
        IToken AND_ASSIGN261 = null;
        IToken XOR_ASSIGN262 = null;
        IToken OR_ASSIGN263 = null;
        IToken LOR_ASSIGN264 = null;
        IToken LAND_ASSIGN265 = null;

        object s_tree=null;
        object a_tree=null;
        object t1_tree=null;
        object t2_tree=null;
        object t3_tree=null;
        object t4_tree=null;
        object ASSIGN255_tree=null;
        object DIV_ASSIGN256_tree=null;
        object MOD_ASSIGN257_tree=null;
        object ADD_ASSIGN258_tree=null;
        object SUB_ASSIGN259_tree=null;
        object SHL_ASSIGN260_tree=null;
        object AND_ASSIGN261_tree=null;
        object XOR_ASSIGN262_tree=null;
        object OR_ASSIGN263_tree=null;
        object LOR_ASSIGN264_tree=null;
        object LAND_ASSIGN265_tree=null;
        RewriteRuleTokenStream stream_ASSIGN = new RewriteRuleTokenStream(adaptor,"token ASSIGN");
        RewriteRuleTokenStream stream_GT = new RewriteRuleTokenStream(adaptor,"token GT");

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 105) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3053:5: ( ASSIGN | s= STAR a= ASSIGN | DIV_ASSIGN | MOD_ASSIGN | ADD_ASSIGN | SUB_ASSIGN | SHL_ASSIGN | ( ( '>' '>' '=' )=>t1= '>' t2= '>' t3= '=' {...}? -> SHR_ASSIGN ) | ( ( '>' '>' '>' '=' )=>t1= '>' t2= '>' t3= '>' t4= '=' {...}? -> SHU_ASSIGN ) | AND_ASSIGN | XOR_ASSIGN | OR_ASSIGN | LOR_ASSIGN | LAND_ASSIGN )
            int alt123 = 14;
            alt123 = dfa123.Predict(input);
            switch (alt123) 
            {
                case 1 :
                    // AS3_ex.g3:3053:7: ASSIGN
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        ASSIGN255=(IToken)Match(input,ASSIGN,FOLLOW_ASSIGN_in_assignmentOperator_int11601); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {ASSIGN255_tree = (object)adaptor.Create(ASSIGN255);
                            adaptor.AddChild(root_0, ASSIGN255_tree);
                        }

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:3055:4: s= STAR a= ASSIGN
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        s=(IToken)Match(input,STAR,FOLLOW_STAR_in_assignmentOperator_int11610); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {s_tree = (object)adaptor.Create(s);
                            adaptor.AddChild(root_0, s_tree);
                        }
                        a=(IToken)Match(input,ASSIGN,FOLLOW_ASSIGN_in_assignmentOperator_int11614); if (state.failed) return retval;
                        if ( state.backtracking == 0 ) 
                        {
                          s.Text = "*=";
                        }

                    }
                    break;
                case 3 :
                    // AS3_ex.g3:3056:7: DIV_ASSIGN
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        DIV_ASSIGN256=(IToken)Match(input,DIV_ASSIGN,FOLLOW_DIV_ASSIGN_in_assignmentOperator_int11625); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {DIV_ASSIGN256_tree = (object)adaptor.Create(DIV_ASSIGN256);
                            adaptor.AddChild(root_0, DIV_ASSIGN256_tree);
                        }

                    }
                    break;
                case 4 :
                    // AS3_ex.g3:3057:7: MOD_ASSIGN
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        MOD_ASSIGN257=(IToken)Match(input,MOD_ASSIGN,FOLLOW_MOD_ASSIGN_in_assignmentOperator_int11634); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {MOD_ASSIGN257_tree = (object)adaptor.Create(MOD_ASSIGN257);
                            adaptor.AddChild(root_0, MOD_ASSIGN257_tree);
                        }

                    }
                    break;
                case 5 :
                    // AS3_ex.g3:3058:7: ADD_ASSIGN
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        ADD_ASSIGN258=(IToken)Match(input,ADD_ASSIGN,FOLLOW_ADD_ASSIGN_in_assignmentOperator_int11643); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {ADD_ASSIGN258_tree = (object)adaptor.Create(ADD_ASSIGN258);
                            adaptor.AddChild(root_0, ADD_ASSIGN258_tree);
                        }

                    }
                    break;
                case 6 :
                    // AS3_ex.g3:3059:7: SUB_ASSIGN
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        SUB_ASSIGN259=(IToken)Match(input,SUB_ASSIGN,FOLLOW_SUB_ASSIGN_in_assignmentOperator_int11652); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {SUB_ASSIGN259_tree = (object)adaptor.Create(SUB_ASSIGN259);
                            adaptor.AddChild(root_0, SUB_ASSIGN259_tree);
                        }

                    }
                    break;
                case 7 :
                    // AS3_ex.g3:3060:7: SHL_ASSIGN
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        SHL_ASSIGN260=(IToken)Match(input,SHL_ASSIGN,FOLLOW_SHL_ASSIGN_in_assignmentOperator_int11660); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {SHL_ASSIGN260_tree = (object)adaptor.Create(SHL_ASSIGN260);
                            adaptor.AddChild(root_0, SHL_ASSIGN260_tree);
                        }

                    }
                    break;
                case 8 :
                    // AS3_ex.g3:3069:9: ( ( '>' '>' '=' )=>t1= '>' t2= '>' t3= '=' {...}? -> SHR_ASSIGN )
                    {
                        // AS3_ex.g3:3069:9: ( ( '>' '>' '=' )=>t1= '>' t2= '>' t3= '=' {...}? -> SHR_ASSIGN )
                        // AS3_ex.g3:3069:10: ( '>' '>' '=' )=>t1= '>' t2= '>' t3= '=' {...}?
                        {
                            t1=(IToken)Match(input,GT,FOLLOW_GT_in_assignmentOperator_int11686); if (state.failed) return retval; 
                            if ( state.backtracking==0 ) stream_GT.Add(t1);

                            t2=(IToken)Match(input,GT,FOLLOW_GT_in_assignmentOperator_int11690); if (state.failed) return retval; 
                            if ( state.backtracking==0 ) stream_GT.Add(t2);

                            t3=(IToken)Match(input,ASSIGN,FOLLOW_ASSIGN_in_assignmentOperator_int11694); if (state.failed) return retval; 
                            if ( state.backtracking==0 ) stream_ASSIGN.Add(t3);

                            if ( !(( t1.Line == t2.Line && 
                                      t1.CharPositionInLine + 1 == t2.CharPositionInLine && 
                                      t2.Line == t3.Line && 
                                      t2.CharPositionInLine + 1 == t3.CharPositionInLine )) ) 
                            {
                                if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                                throw new FailedPredicateException(input, "assignmentOperator_int", " $t1.Line == $t2.Line && \n          $t1.CharPositionInLine + 1 == $t2.CharPositionInLine && \n          $t2.Line == $t3.Line && \n          $t2.CharPositionInLine + 1 == $t3.CharPositionInLine ");
                            }


                            // AST REWRITE
                            // elements:          
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if ( state.backtracking==0 ) {
                            retval.Tree = root_0;
                            RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));

                            root_0 = (object)adaptor.GetNilNode();
                            // 3074:7: -> SHR_ASSIGN
                            {
                                adaptor.AddChild(root_0, (object)adaptor.Create(SHR_ASSIGN, "SHR_ASSIGN"));

                            }

                            retval.Tree = root_0;retval.Tree = root_0;}
                        }

                        if ( state.backtracking == 0 ) 
                        {
                          t1.Text = ">>=";
                        }

                    }
                    break;
                case 9 :
                    // AS3_ex.g3:3076:7: ( ( '>' '>' '>' '=' )=>t1= '>' t2= '>' t3= '>' t4= '=' {...}? -> SHU_ASSIGN )
                    {
                        // AS3_ex.g3:3076:7: ( ( '>' '>' '>' '=' )=>t1= '>' t2= '>' t3= '>' t4= '=' {...}? -> SHU_ASSIGN )
                        // AS3_ex.g3:3076:8: ( '>' '>' '>' '=' )=>t1= '>' t2= '>' t3= '>' t4= '=' {...}?
                        {
                            t1=(IToken)Match(input,GT,FOLLOW_GT_in_assignmentOperator_int11740); if (state.failed) return retval; 
                            if ( state.backtracking==0 ) stream_GT.Add(t1);

                            t2=(IToken)Match(input,GT,FOLLOW_GT_in_assignmentOperator_int11744); if (state.failed) return retval; 
                            if ( state.backtracking==0 ) stream_GT.Add(t2);

                            t3=(IToken)Match(input,GT,FOLLOW_GT_in_assignmentOperator_int11748); if (state.failed) return retval; 
                            if ( state.backtracking==0 ) stream_GT.Add(t3);

                            t4=(IToken)Match(input,ASSIGN,FOLLOW_ASSIGN_in_assignmentOperator_int11752); if (state.failed) return retval; 
                            if ( state.backtracking==0 ) stream_ASSIGN.Add(t4);

                            if ( !(( t1.Line == t2.Line && 
                                      t1.CharPositionInLine + 1 == t2.CharPositionInLine &&
                                      t2.Line == t3.Line && 
                                      t2.CharPositionInLine + 1 == t3.CharPositionInLine &&
                                      t3.Line == t4.Line && 
                                      t3.CharPositionInLine + 1 == t4.CharPositionInLine )) ) 
                            {
                                if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                                throw new FailedPredicateException(input, "assignmentOperator_int", " $t1.Line == $t2.Line && \n          $t1.CharPositionInLine + 1 == $t2.CharPositionInLine &&\n          $t2.Line == $t3.Line && \n          $t2.CharPositionInLine + 1 == $t3.CharPositionInLine &&\n          $t3.Line == $t4.Line && \n          $t3.CharPositionInLine + 1 == $t4.CharPositionInLine ");
                            }


                            // AST REWRITE
                            // elements:          
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if ( state.backtracking==0 ) {
                            retval.Tree = root_0;
                            RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));

                            root_0 = (object)adaptor.GetNilNode();
                            // 3083:7: -> SHU_ASSIGN
                            {
                                adaptor.AddChild(root_0, (object)adaptor.Create(SHU_ASSIGN, "SHU_ASSIGN"));

                            }

                            retval.Tree = root_0;retval.Tree = root_0;}
                        }

                        if ( state.backtracking == 0 ) 
                        {
                          t1.Text = ">>>=";
                        }

                    }
                    break;
                case 10 :
                    // AS3_ex.g3:3084:7: AND_ASSIGN
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        AND_ASSIGN261=(IToken)Match(input,AND_ASSIGN,FOLLOW_AND_ASSIGN_in_assignmentOperator_int11783); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {AND_ASSIGN261_tree = (object)adaptor.Create(AND_ASSIGN261);
                            adaptor.AddChild(root_0, AND_ASSIGN261_tree);
                        }

                    }
                    break;
                case 11 :
                    // AS3_ex.g3:3085:7: XOR_ASSIGN
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        XOR_ASSIGN262=(IToken)Match(input,XOR_ASSIGN,FOLLOW_XOR_ASSIGN_in_assignmentOperator_int11792); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {XOR_ASSIGN262_tree = (object)adaptor.Create(XOR_ASSIGN262);
                            adaptor.AddChild(root_0, XOR_ASSIGN262_tree);
                        }

                    }
                    break;
                case 12 :
                    // AS3_ex.g3:3086:7: OR_ASSIGN
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        OR_ASSIGN263=(IToken)Match(input,OR_ASSIGN,FOLLOW_OR_ASSIGN_in_assignmentOperator_int11801); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {OR_ASSIGN263_tree = (object)adaptor.Create(OR_ASSIGN263);
                            adaptor.AddChild(root_0, OR_ASSIGN263_tree);
                        }

                    }
                    break;
                case 13 :
                    // AS3_ex.g3:3087:7: LOR_ASSIGN
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        LOR_ASSIGN264=(IToken)Match(input,LOR_ASSIGN,FOLLOW_LOR_ASSIGN_in_assignmentOperator_int11809); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {LOR_ASSIGN264_tree = (object)adaptor.Create(LOR_ASSIGN264);
                            adaptor.AddChild(root_0, LOR_ASSIGN264_tree);
                        }

                    }
                    break;
                case 14 :
                    // AS3_ex.g3:3088:7: LAND_ASSIGN
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        LAND_ASSIGN265=(IToken)Match(input,LAND_ASSIGN,FOLLOW_LAND_ASSIGN_in_assignmentOperator_int11817); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {LAND_ASSIGN265_tree = (object)adaptor.Create(LAND_ASSIGN265);
                            adaptor.AddChild(root_0, LAND_ASSIGN265_tree);
                        }

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 105, assignmentOperator_int_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "assignmentOperator_int"

    public class conditionalExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "conditionalExpression"
    // AS3_ex.g3:3092:1: conditionalExpression : logicalORExpression (Q= QUE assignmentExpression C= COLON assignmentExpression )? ;
    public AS3_exParser.conditionalExpression_return conditionalExpression() // throws RecognitionException [1]
    {   
        AS3_exParser.conditionalExpression_return retval = new AS3_exParser.conditionalExpression_return();
        retval.Start = input.LT(1);
        int conditionalExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken Q = null;
        IToken C = null;
        AS3_exParser.logicalORExpression_return logicalORExpression266 = null;

        AS3_exParser.assignmentExpression_return assignmentExpression267 = null;

        AS3_exParser.assignmentExpression_return assignmentExpression268 = null;


        object Q_tree=null;
        object C_tree=null;


            WrapOptions options=mPrinter.getExpressionWrapOptions();
            bool pushedWrapInfo=false;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 106) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3097:5: ( logicalORExpression (Q= QUE assignmentExpression C= COLON assignmentExpression )? )
            // AS3_ex.g3:3097:9: logicalORExpression (Q= QUE assignmentExpression C= COLON assignmentExpression )?
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  pushedWrapInfo=pushWrapInfo(options, true);
                }
                PushFollow(FOLLOW_logicalORExpression_in_conditionalExpression11852);
                logicalORExpression266 = logicalORExpression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, logicalORExpression266.Tree);
                // AS3_ex.g3:3098:29: (Q= QUE assignmentExpression C= COLON assignmentExpression )?
                int alt124 = 2;
                int LA124_0 = input.LA(1);

                if ( (LA124_0 == QUE) )
                {
                    int LA124_1 = input.LA(2);

                    if ( (synpred255_AS3_ex()) )
                    {
                        alt124 = 1;
                    }
                }
                switch (alt124) 
                {
                    case 1 :
                        // AS3_ex.g3:3098:31: Q= QUE assignmentExpression C= COLON assignmentExpression
                        {
                            Q=(IToken)Match(input,QUE,FOLLOW_QUE_in_conditionalExpression11858); if (state.failed) return retval;
                            if ( state.backtracking == 0 )
                            {Q_tree = (object)adaptor.Create(Q);
                                adaptor.AddChild(root_0, Q_tree);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              indentEmit(Q, ASPrettyPrinter.Break_Ternary_code);
                            }
                            PushFollow(FOLLOW_assignmentExpression_in_conditionalExpression11863);
                            assignmentExpression267 = assignmentExpression();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, assignmentExpression267.Tree);
                            if ( state.backtracking == 0 ) 
                            {
                              popIndent();
                            }
                            C=(IToken)Match(input,COLON,FOLLOW_COLON_in_conditionalExpression11870); if (state.failed) return retval;
                            if ( state.backtracking == 0 )
                            {C_tree = (object)adaptor.Create(C);
                                adaptor.AddChild(root_0, C_tree);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              indentEmit(C, ASPrettyPrinter.Break_Ternary_code);
                            }
                            PushFollow(FOLLOW_assignmentExpression_in_conditionalExpression11875);
                            assignmentExpression268 = assignmentExpression();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, assignmentExpression268.Tree);
                            if ( state.backtracking == 0 ) 
                            {
                              popIndent();
                            }

                        }
                        break;

                }

                if ( state.backtracking == 0 ) 
                {
                  if (pushedWrapInfo) mPrinter.popWrapContext();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 106, conditionalExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "conditionalExpression"

    public class conditionalExpressionNoIn_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "conditionalExpressionNoIn"
    // AS3_ex.g3:3102:1: conditionalExpressionNoIn : logicalORExpressionNoIn (Q= QUE assignmentExpression C= COLON assignmentExpression )? ;
    public AS3_exParser.conditionalExpressionNoIn_return conditionalExpressionNoIn() // throws RecognitionException [1]
    {   
        AS3_exParser.conditionalExpressionNoIn_return retval = new AS3_exParser.conditionalExpressionNoIn_return();
        retval.Start = input.LT(1);
        int conditionalExpressionNoIn_StartIndex = input.Index();
        object root_0 = null;

        IToken Q = null;
        IToken C = null;
        AS3_exParser.logicalORExpressionNoIn_return logicalORExpressionNoIn269 = null;

        AS3_exParser.assignmentExpression_return assignmentExpression270 = null;

        AS3_exParser.assignmentExpression_return assignmentExpression271 = null;


        object Q_tree=null;
        object C_tree=null;


            WrapOptions options=mPrinter.getExpressionWrapOptions();
            bool pushedWrapInfo=false;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 107) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3107:5: ( logicalORExpressionNoIn (Q= QUE assignmentExpression C= COLON assignmentExpression )? )
            // AS3_ex.g3:3107:9: logicalORExpressionNoIn (Q= QUE assignmentExpression C= COLON assignmentExpression )?
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  pushedWrapInfo=pushWrapInfo(options, true);
                }
                PushFollow(FOLLOW_logicalORExpressionNoIn_in_conditionalExpressionNoIn11927);
                logicalORExpressionNoIn269 = logicalORExpressionNoIn();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, logicalORExpressionNoIn269.Tree);
                // AS3_ex.g3:3108:33: (Q= QUE assignmentExpression C= COLON assignmentExpression )?
                int alt125 = 2;
                int LA125_0 = input.LA(1);

                if ( (LA125_0 == QUE) )
                {
                    alt125 = 1;
                }
                switch (alt125) 
                {
                    case 1 :
                        // AS3_ex.g3:3108:35: Q= QUE assignmentExpression C= COLON assignmentExpression
                        {
                            Q=(IToken)Match(input,QUE,FOLLOW_QUE_in_conditionalExpressionNoIn11933); if (state.failed) return retval;
                            if ( state.backtracking == 0 )
                            {Q_tree = (object)adaptor.Create(Q);
                                adaptor.AddChild(root_0, Q_tree);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              indentEmit(Q, ASPrettyPrinter.Break_Ternary_code);
                            }
                            PushFollow(FOLLOW_assignmentExpression_in_conditionalExpressionNoIn11937);
                            assignmentExpression270 = assignmentExpression();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, assignmentExpression270.Tree);
                            if ( state.backtracking == 0 ) 
                            {
                              popIndent();
                            }
                            C=(IToken)Match(input,COLON,FOLLOW_COLON_in_conditionalExpressionNoIn11944); if (state.failed) return retval;
                            if ( state.backtracking == 0 )
                            {C_tree = (object)adaptor.Create(C);
                                adaptor.AddChild(root_0, C_tree);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              indentEmit(C, ASPrettyPrinter.Break_Ternary_code);
                            }
                            PushFollow(FOLLOW_assignmentExpression_in_conditionalExpressionNoIn11949);
                            assignmentExpression271 = assignmentExpression();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, assignmentExpression271.Tree);
                            if ( state.backtracking == 0 ) 
                            {
                              popIndent();
                            }

                        }
                        break;

                }

                if ( state.backtracking == 0 ) 
                {
                  if (pushedWrapInfo) mPrinter.popWrapContext();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 107, conditionalExpressionNoIn_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "conditionalExpressionNoIn"

    public class logicalORExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "logicalORExpression"
    // AS3_ex.g3:3113:1: logicalORExpression : logicalANDExpression (L= LOR logicalANDExpression )* ;
    public AS3_exParser.logicalORExpression_return logicalORExpression() // throws RecognitionException [1]
    {   
        AS3_exParser.logicalORExpression_return retval = new AS3_exParser.logicalORExpression_return();
        retval.Start = input.LT(1);
        int logicalORExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        AS3_exParser.logicalANDExpression_return logicalANDExpression272 = null;

        AS3_exParser.logicalANDExpression_return logicalANDExpression273 = null;


        object L_tree=null;


            WrapOptions options=mPrinter.getExpressionWrapOptions();
            bool pushedWrapInfo=false;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 108) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3118:5: ( logicalANDExpression (L= LOR logicalANDExpression )* )
            // AS3_ex.g3:3118:9: logicalANDExpression (L= LOR logicalANDExpression )*
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  pushedWrapInfo=pushWrapInfo(options, true);
                }
                PushFollow(FOLLOW_logicalANDExpression_in_logicalORExpression12006);
                logicalANDExpression272 = logicalANDExpression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, logicalANDExpression272.Tree);
                // AS3_ex.g3:3119:30: (L= LOR logicalANDExpression )*
                do 
                {
                    int alt126 = 2;
                    int LA126_0 = input.LA(1);

                    if ( (LA126_0 == LOR) )
                    {
                        int LA126_2 = input.LA(2);

                        if ( (synpred257_AS3_ex()) )
                        {
                            alt126 = 1;
                        }


                    }


                    switch (alt126) 
                    {
                        case 1 :
                            // AS3_ex.g3:3119:32: L= LOR logicalANDExpression
                            {
                                L=(IToken)Match(input,LOR,FOLLOW_LOR_in_logicalORExpression12012); if (state.failed) return retval;
                                if ( state.backtracking == 0 )
                                {L_tree = (object)adaptor.Create(L);
                                    adaptor.AddChild(root_0, L_tree);
                                }
                                if ( state.backtracking == 0 ) 
                                {
                                  indentEmit(L, ASPrettyPrinter.Break_Logical_Ops_code);
                                }
                                PushFollow(FOLLOW_logicalANDExpression_in_logicalORExpression12016);
                                logicalANDExpression273 = logicalANDExpression();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, logicalANDExpression273.Tree);
                                if ( state.backtracking == 0 ) 
                                {
                                  popIndent();
                                }

                            }
                            break;

                        default:
                            goto loop126;
                    }
                } while (true);

                loop126:
                    ;   // Stops C# compiler whining that label 'loop126' has no statements

                if ( state.backtracking == 0 ) 
                {
                  if (pushedWrapInfo) mPrinter.popWrapContext();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 108, logicalORExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "logicalORExpression"

    public class logicalORExpressionNoIn_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "logicalORExpressionNoIn"
    // AS3_ex.g3:3123:1: logicalORExpressionNoIn : logicalANDExpressionNoIn (L= LOR logicalANDExpressionNoIn )* ;
    public AS3_exParser.logicalORExpressionNoIn_return logicalORExpressionNoIn() // throws RecognitionException [1]
    {   
        AS3_exParser.logicalORExpressionNoIn_return retval = new AS3_exParser.logicalORExpressionNoIn_return();
        retval.Start = input.LT(1);
        int logicalORExpressionNoIn_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        AS3_exParser.logicalANDExpressionNoIn_return logicalANDExpressionNoIn274 = null;

        AS3_exParser.logicalANDExpressionNoIn_return logicalANDExpressionNoIn275 = null;


        object L_tree=null;


            WrapOptions options=mPrinter.getExpressionWrapOptions();
            bool pushedWrapInfo=false;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 109) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3128:5: ( logicalANDExpressionNoIn (L= LOR logicalANDExpressionNoIn )* )
            // AS3_ex.g3:3128:9: logicalANDExpressionNoIn (L= LOR logicalANDExpressionNoIn )*
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  pushedWrapInfo=pushWrapInfo(options, true);
                }
                PushFollow(FOLLOW_logicalANDExpressionNoIn_in_logicalORExpressionNoIn12069);
                logicalANDExpressionNoIn274 = logicalANDExpressionNoIn();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, logicalANDExpressionNoIn274.Tree);
                // AS3_ex.g3:3129:34: (L= LOR logicalANDExpressionNoIn )*
                do 
                {
                    int alt127 = 2;
                    int LA127_0 = input.LA(1);

                    if ( (LA127_0 == LOR) )
                    {
                        alt127 = 1;
                    }


                    switch (alt127) 
                    {
                        case 1 :
                            // AS3_ex.g3:3129:36: L= LOR logicalANDExpressionNoIn
                            {
                                L=(IToken)Match(input,LOR,FOLLOW_LOR_in_logicalORExpressionNoIn12075); if (state.failed) return retval;
                                if ( state.backtracking == 0 )
                                {L_tree = (object)adaptor.Create(L);
                                    adaptor.AddChild(root_0, L_tree);
                                }
                                if ( state.backtracking == 0 ) 
                                {
                                  indentEmit(L, ASPrettyPrinter.Break_Logical_Ops_code);
                                }
                                PushFollow(FOLLOW_logicalANDExpressionNoIn_in_logicalORExpressionNoIn12079);
                                logicalANDExpressionNoIn275 = logicalANDExpressionNoIn();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, logicalANDExpressionNoIn275.Tree);
                                if ( state.backtracking == 0 ) 
                                {
                                  popIndent();
                                }

                            }
                            break;

                        default:
                            goto loop127;
                    }
                } while (true);

                loop127:
                    ;   // Stops C# compiler whining that label 'loop127' has no statements

                if ( state.backtracking == 0 ) 
                {
                  if (pushedWrapInfo) mPrinter.popWrapContext();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 109, logicalORExpressionNoIn_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "logicalORExpressionNoIn"

    public class logicalANDExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "logicalANDExpression"
    // AS3_ex.g3:3133:1: logicalANDExpression : bitwiseORExpression (L= LAND bitwiseORExpression )* ;
    public AS3_exParser.logicalANDExpression_return logicalANDExpression() // throws RecognitionException [1]
    {   
        AS3_exParser.logicalANDExpression_return retval = new AS3_exParser.logicalANDExpression_return();
        retval.Start = input.LT(1);
        int logicalANDExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        AS3_exParser.bitwiseORExpression_return bitwiseORExpression276 = null;

        AS3_exParser.bitwiseORExpression_return bitwiseORExpression277 = null;


        object L_tree=null;


            WrapOptions options=mPrinter.getExpressionWrapOptions();
            bool pushedWrapInfo=false;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 110) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3138:5: ( bitwiseORExpression (L= LAND bitwiseORExpression )* )
            // AS3_ex.g3:3138:9: bitwiseORExpression (L= LAND bitwiseORExpression )*
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  pushedWrapInfo=pushWrapInfo(options, true);
                }
                PushFollow(FOLLOW_bitwiseORExpression_in_logicalANDExpression12136);
                bitwiseORExpression276 = bitwiseORExpression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, bitwiseORExpression276.Tree);
                // AS3_ex.g3:3139:29: (L= LAND bitwiseORExpression )*
                do 
                {
                    int alt128 = 2;
                    int LA128_0 = input.LA(1);

                    if ( (LA128_0 == LAND) )
                    {
                        int LA128_2 = input.LA(2);

                        if ( (synpred259_AS3_ex()) )
                        {
                            alt128 = 1;
                        }


                    }


                    switch (alt128) 
                    {
                        case 1 :
                            // AS3_ex.g3:3139:31: L= LAND bitwiseORExpression
                            {
                                L=(IToken)Match(input,LAND,FOLLOW_LAND_in_logicalANDExpression12142); if (state.failed) return retval;
                                if ( state.backtracking == 0 )
                                {L_tree = (object)adaptor.Create(L);
                                    adaptor.AddChild(root_0, L_tree);
                                }
                                if ( state.backtracking == 0 ) 
                                {
                                  indentEmit(L, ASPrettyPrinter.Break_Logical_Ops_code);
                                }
                                PushFollow(FOLLOW_bitwiseORExpression_in_logicalANDExpression12146);
                                bitwiseORExpression277 = bitwiseORExpression();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, bitwiseORExpression277.Tree);
                                if ( state.backtracking == 0 ) 
                                {
                                  popIndent();
                                }

                            }
                            break;

                        default:
                            goto loop128;
                    }
                } while (true);

                loop128:
                    ;   // Stops C# compiler whining that label 'loop128' has no statements

                if ( state.backtracking == 0 ) 
                {
                  if (pushedWrapInfo) mPrinter.popWrapContext();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 110, logicalANDExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "logicalANDExpression"

    public class logicalANDExpressionNoIn_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "logicalANDExpressionNoIn"
    // AS3_ex.g3:3143:1: logicalANDExpressionNoIn : bitwiseORExpressionNoIn (L= LAND bitwiseORExpressionNoIn )* ;
    public AS3_exParser.logicalANDExpressionNoIn_return logicalANDExpressionNoIn() // throws RecognitionException [1]
    {   
        AS3_exParser.logicalANDExpressionNoIn_return retval = new AS3_exParser.logicalANDExpressionNoIn_return();
        retval.Start = input.LT(1);
        int logicalANDExpressionNoIn_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        AS3_exParser.bitwiseORExpressionNoIn_return bitwiseORExpressionNoIn278 = null;

        AS3_exParser.bitwiseORExpressionNoIn_return bitwiseORExpressionNoIn279 = null;


        object L_tree=null;


            WrapOptions options=mPrinter.getExpressionWrapOptions();
            bool pushedWrapInfo=false;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 111) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3148:5: ( bitwiseORExpressionNoIn (L= LAND bitwiseORExpressionNoIn )* )
            // AS3_ex.g3:3148:9: bitwiseORExpressionNoIn (L= LAND bitwiseORExpressionNoIn )*
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  pushedWrapInfo=pushWrapInfo(options, true);
                }
                PushFollow(FOLLOW_bitwiseORExpressionNoIn_in_logicalANDExpressionNoIn12198);
                bitwiseORExpressionNoIn278 = bitwiseORExpressionNoIn();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, bitwiseORExpressionNoIn278.Tree);
                // AS3_ex.g3:3149:33: (L= LAND bitwiseORExpressionNoIn )*
                do 
                {
                    int alt129 = 2;
                    int LA129_0 = input.LA(1);

                    if ( (LA129_0 == LAND) )
                    {
                        alt129 = 1;
                    }


                    switch (alt129) 
                    {
                        case 1 :
                            // AS3_ex.g3:3149:35: L= LAND bitwiseORExpressionNoIn
                            {
                                L=(IToken)Match(input,LAND,FOLLOW_LAND_in_logicalANDExpressionNoIn12204); if (state.failed) return retval;
                                if ( state.backtracking == 0 )
                                {L_tree = (object)adaptor.Create(L);
                                    adaptor.AddChild(root_0, L_tree);
                                }
                                if ( state.backtracking == 0 ) 
                                {
                                  indentEmit(L, ASPrettyPrinter.Break_Logical_Ops_code);
                                }
                                PushFollow(FOLLOW_bitwiseORExpressionNoIn_in_logicalANDExpressionNoIn12208);
                                bitwiseORExpressionNoIn279 = bitwiseORExpressionNoIn();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, bitwiseORExpressionNoIn279.Tree);
                                if ( state.backtracking == 0 ) 
                                {
                                  popIndent();
                                }

                            }
                            break;

                        default:
                            goto loop129;
                    }
                } while (true);

                loop129:
                    ;   // Stops C# compiler whining that label 'loop129' has no statements

                if ( state.backtracking == 0 ) 
                {
                  if (pushedWrapInfo) mPrinter.popWrapContext();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 111, logicalANDExpressionNoIn_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "logicalANDExpressionNoIn"

    public class bitwiseORExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "bitwiseORExpression"
    // AS3_ex.g3:3154:1: bitwiseORExpression : bitwiseXORExpression (O= OR bitwiseXORExpression )* ;
    public AS3_exParser.bitwiseORExpression_return bitwiseORExpression() // throws RecognitionException [1]
    {   
        AS3_exParser.bitwiseORExpression_return retval = new AS3_exParser.bitwiseORExpression_return();
        retval.Start = input.LT(1);
        int bitwiseORExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken O = null;
        AS3_exParser.bitwiseXORExpression_return bitwiseXORExpression280 = null;

        AS3_exParser.bitwiseXORExpression_return bitwiseXORExpression281 = null;


        object O_tree=null;


            WrapOptions options=mPrinter.getExpressionWrapOptions();
            bool pushedWrapInfo=false;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 112) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3159:5: ( bitwiseXORExpression (O= OR bitwiseXORExpression )* )
            // AS3_ex.g3:3159:9: bitwiseXORExpression (O= OR bitwiseXORExpression )*
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  pushedWrapInfo=pushWrapInfo(options, true);
                }
                PushFollow(FOLLOW_bitwiseXORExpression_in_bitwiseORExpression12265);
                bitwiseXORExpression280 = bitwiseXORExpression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, bitwiseXORExpression280.Tree);
                // AS3_ex.g3:3160:30: (O= OR bitwiseXORExpression )*
                do 
                {
                    int alt130 = 2;
                    int LA130_0 = input.LA(1);

                    if ( (LA130_0 == OR) )
                    {
                        int LA130_2 = input.LA(2);

                        if ( (synpred261_AS3_ex()) )
                        {
                            alt130 = 1;
                        }


                    }


                    switch (alt130) 
                    {
                        case 1 :
                            // AS3_ex.g3:3160:32: O= OR bitwiseXORExpression
                            {
                                O=(IToken)Match(input,OR,FOLLOW_OR_in_bitwiseORExpression12271); if (state.failed) return retval;
                                if ( state.backtracking == 0 )
                                {O_tree = (object)adaptor.Create(O);
                                    adaptor.AddChild(root_0, O_tree);
                                }
                                if ( state.backtracking == 0 ) 
                                {
                                  indentEmit(O, ASPrettyPrinter.Break_Arithmetic_Ops_code);
                                }
                                PushFollow(FOLLOW_bitwiseXORExpression_in_bitwiseORExpression12275);
                                bitwiseXORExpression281 = bitwiseXORExpression();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, bitwiseXORExpression281.Tree);
                                if ( state.backtracking == 0 ) 
                                {
                                  popIndent();
                                }

                            }
                            break;

                        default:
                            goto loop130;
                    }
                } while (true);

                loop130:
                    ;   // Stops C# compiler whining that label 'loop130' has no statements

                if ( state.backtracking == 0 ) 
                {
                  if (pushedWrapInfo) mPrinter.popWrapContext();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 112, bitwiseORExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "bitwiseORExpression"

    public class bitwiseORExpressionNoIn_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "bitwiseORExpressionNoIn"
    // AS3_ex.g3:3164:1: bitwiseORExpressionNoIn : bitwiseXORExpressionNoIn (O= OR bitwiseXORExpressionNoIn )* ;
    public AS3_exParser.bitwiseORExpressionNoIn_return bitwiseORExpressionNoIn() // throws RecognitionException [1]
    {   
        AS3_exParser.bitwiseORExpressionNoIn_return retval = new AS3_exParser.bitwiseORExpressionNoIn_return();
        retval.Start = input.LT(1);
        int bitwiseORExpressionNoIn_StartIndex = input.Index();
        object root_0 = null;

        IToken O = null;
        AS3_exParser.bitwiseXORExpressionNoIn_return bitwiseXORExpressionNoIn282 = null;

        AS3_exParser.bitwiseXORExpressionNoIn_return bitwiseXORExpressionNoIn283 = null;


        object O_tree=null;


            WrapOptions options=mPrinter.getExpressionWrapOptions();
            bool pushedWrapInfo=false;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 113) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3169:5: ( bitwiseXORExpressionNoIn (O= OR bitwiseXORExpressionNoIn )* )
            // AS3_ex.g3:3169:9: bitwiseXORExpressionNoIn (O= OR bitwiseXORExpressionNoIn )*
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  pushedWrapInfo=pushWrapInfo(options, true);
                }
                PushFollow(FOLLOW_bitwiseXORExpressionNoIn_in_bitwiseORExpressionNoIn12327);
                bitwiseXORExpressionNoIn282 = bitwiseXORExpressionNoIn();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, bitwiseXORExpressionNoIn282.Tree);
                // AS3_ex.g3:3170:34: (O= OR bitwiseXORExpressionNoIn )*
                do 
                {
                    int alt131 = 2;
                    int LA131_0 = input.LA(1);

                    if ( (LA131_0 == OR) )
                    {
                        alt131 = 1;
                    }


                    switch (alt131) 
                    {
                        case 1 :
                            // AS3_ex.g3:3170:36: O= OR bitwiseXORExpressionNoIn
                            {
                                O=(IToken)Match(input,OR,FOLLOW_OR_in_bitwiseORExpressionNoIn12333); if (state.failed) return retval;
                                if ( state.backtracking == 0 )
                                {O_tree = (object)adaptor.Create(O);
                                    adaptor.AddChild(root_0, O_tree);
                                }
                                if ( state.backtracking == 0 ) 
                                {
                                  indentEmit(O, ASPrettyPrinter.Break_Arithmetic_Ops_code);
                                }
                                PushFollow(FOLLOW_bitwiseXORExpressionNoIn_in_bitwiseORExpressionNoIn12337);
                                bitwiseXORExpressionNoIn283 = bitwiseXORExpressionNoIn();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, bitwiseXORExpressionNoIn283.Tree);
                                if ( state.backtracking == 0 ) 
                                {
                                  popIndent();
                                }

                            }
                            break;

                        default:
                            goto loop131;
                    }
                } while (true);

                loop131:
                    ;   // Stops C# compiler whining that label 'loop131' has no statements

                if ( state.backtracking == 0 ) 
                {
                  if (pushedWrapInfo) mPrinter.popWrapContext();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 113, bitwiseORExpressionNoIn_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "bitwiseORExpressionNoIn"

    public class bitwiseXORExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "bitwiseXORExpression"
    // AS3_ex.g3:3174:1: bitwiseXORExpression : bitwiseANDExpression (x= XOR bitwiseANDExpression )* ;
    public AS3_exParser.bitwiseXORExpression_return bitwiseXORExpression() // throws RecognitionException [1]
    {   
        AS3_exParser.bitwiseXORExpression_return retval = new AS3_exParser.bitwiseXORExpression_return();
        retval.Start = input.LT(1);
        int bitwiseXORExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken x = null;
        AS3_exParser.bitwiseANDExpression_return bitwiseANDExpression284 = null;

        AS3_exParser.bitwiseANDExpression_return bitwiseANDExpression285 = null;


        object x_tree=null;


            WrapOptions options=mPrinter.getExpressionWrapOptions();
            bool pushedWrapInfo=false;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 114) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3179:5: ( bitwiseANDExpression (x= XOR bitwiseANDExpression )* )
            // AS3_ex.g3:3179:9: bitwiseANDExpression (x= XOR bitwiseANDExpression )*
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  pushedWrapInfo=pushWrapInfo(options, true);
                }
                PushFollow(FOLLOW_bitwiseANDExpression_in_bitwiseXORExpression12393);
                bitwiseANDExpression284 = bitwiseANDExpression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, bitwiseANDExpression284.Tree);
                // AS3_ex.g3:3180:30: (x= XOR bitwiseANDExpression )*
                do 
                {
                    int alt132 = 2;
                    int LA132_0 = input.LA(1);

                    if ( (LA132_0 == XOR) )
                    {
                        int LA132_2 = input.LA(2);

                        if ( (synpred263_AS3_ex()) )
                        {
                            alt132 = 1;
                        }


                    }


                    switch (alt132) 
                    {
                        case 1 :
                            // AS3_ex.g3:3180:32: x= XOR bitwiseANDExpression
                            {
                                x=(IToken)Match(input,XOR,FOLLOW_XOR_in_bitwiseXORExpression12399); if (state.failed) return retval;
                                if ( state.backtracking == 0 )
                                {x_tree = (object)adaptor.Create(x);
                                    adaptor.AddChild(root_0, x_tree);
                                }
                                if ( state.backtracking == 0 ) 
                                {
                                  indentEmit(x, ASPrettyPrinter.Break_Arithmetic_Ops_code);
                                }
                                PushFollow(FOLLOW_bitwiseANDExpression_in_bitwiseXORExpression12403);
                                bitwiseANDExpression285 = bitwiseANDExpression();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, bitwiseANDExpression285.Tree);
                                if ( state.backtracking == 0 ) 
                                {
                                  popIndent();
                                }

                            }
                            break;

                        default:
                            goto loop132;
                    }
                } while (true);

                loop132:
                    ;   // Stops C# compiler whining that label 'loop132' has no statements

                if ( state.backtracking == 0 ) 
                {
                  if (pushedWrapInfo) mPrinter.popWrapContext();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 114, bitwiseXORExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "bitwiseXORExpression"

    public class bitwiseXORExpressionNoIn_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "bitwiseXORExpressionNoIn"
    // AS3_ex.g3:3184:1: bitwiseXORExpressionNoIn : bitwiseANDExpressionNoIn (x= XOR bitwiseANDExpressionNoIn )* ;
    public AS3_exParser.bitwiseXORExpressionNoIn_return bitwiseXORExpressionNoIn() // throws RecognitionException [1]
    {   
        AS3_exParser.bitwiseXORExpressionNoIn_return retval = new AS3_exParser.bitwiseXORExpressionNoIn_return();
        retval.Start = input.LT(1);
        int bitwiseXORExpressionNoIn_StartIndex = input.Index();
        object root_0 = null;

        IToken x = null;
        AS3_exParser.bitwiseANDExpressionNoIn_return bitwiseANDExpressionNoIn286 = null;

        AS3_exParser.bitwiseANDExpressionNoIn_return bitwiseANDExpressionNoIn287 = null;


        object x_tree=null;


            WrapOptions options=mPrinter.getExpressionWrapOptions();
            bool pushedWrapInfo=false;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 115) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3189:5: ( bitwiseANDExpressionNoIn (x= XOR bitwiseANDExpressionNoIn )* )
            // AS3_ex.g3:3189:9: bitwiseANDExpressionNoIn (x= XOR bitwiseANDExpressionNoIn )*
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  pushedWrapInfo=pushWrapInfo(options, true);
                }
                PushFollow(FOLLOW_bitwiseANDExpressionNoIn_in_bitwiseXORExpressionNoIn12455);
                bitwiseANDExpressionNoIn286 = bitwiseANDExpressionNoIn();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, bitwiseANDExpressionNoIn286.Tree);
                // AS3_ex.g3:3190:34: (x= XOR bitwiseANDExpressionNoIn )*
                do 
                {
                    int alt133 = 2;
                    int LA133_0 = input.LA(1);

                    if ( (LA133_0 == XOR) )
                    {
                        alt133 = 1;
                    }


                    switch (alt133) 
                    {
                        case 1 :
                            // AS3_ex.g3:3190:36: x= XOR bitwiseANDExpressionNoIn
                            {
                                x=(IToken)Match(input,XOR,FOLLOW_XOR_in_bitwiseXORExpressionNoIn12461); if (state.failed) return retval;
                                if ( state.backtracking == 0 )
                                {x_tree = (object)adaptor.Create(x);
                                    adaptor.AddChild(root_0, x_tree);
                                }
                                if ( state.backtracking == 0 ) 
                                {
                                  indentEmit(x, ASPrettyPrinter.Break_Arithmetic_Ops_code);
                                }
                                PushFollow(FOLLOW_bitwiseANDExpressionNoIn_in_bitwiseXORExpressionNoIn12465);
                                bitwiseANDExpressionNoIn287 = bitwiseANDExpressionNoIn();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, bitwiseANDExpressionNoIn287.Tree);
                                if ( state.backtracking == 0 ) 
                                {
                                  popIndent();
                                }

                            }
                            break;

                        default:
                            goto loop133;
                    }
                } while (true);

                loop133:
                    ;   // Stops C# compiler whining that label 'loop133' has no statements

                if ( state.backtracking == 0 ) 
                {
                  if (pushedWrapInfo) mPrinter.popWrapContext();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 115, bitwiseXORExpressionNoIn_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "bitwiseXORExpressionNoIn"

    public class bitwiseANDExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "bitwiseANDExpression"
    // AS3_ex.g3:3194:1: bitwiseANDExpression : equalityExpression (A= AND equalityExpression )* ;
    public AS3_exParser.bitwiseANDExpression_return bitwiseANDExpression() // throws RecognitionException [1]
    {   
        AS3_exParser.bitwiseANDExpression_return retval = new AS3_exParser.bitwiseANDExpression_return();
        retval.Start = input.LT(1);
        int bitwiseANDExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken A = null;
        AS3_exParser.equalityExpression_return equalityExpression288 = null;

        AS3_exParser.equalityExpression_return equalityExpression289 = null;


        object A_tree=null;


            WrapOptions options=mPrinter.getExpressionWrapOptions();
            bool pushedWrapInfo=false;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 116) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3199:5: ( equalityExpression (A= AND equalityExpression )* )
            // AS3_ex.g3:3199:9: equalityExpression (A= AND equalityExpression )*
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  pushedWrapInfo=pushWrapInfo(options, true);
                }
                PushFollow(FOLLOW_equalityExpression_in_bitwiseANDExpression12517);
                equalityExpression288 = equalityExpression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, equalityExpression288.Tree);
                // AS3_ex.g3:3200:28: (A= AND equalityExpression )*
                do 
                {
                    int alt134 = 2;
                    int LA134_0 = input.LA(1);

                    if ( (LA134_0 == AND) )
                    {
                        int LA134_2 = input.LA(2);

                        if ( (synpred265_AS3_ex()) )
                        {
                            alt134 = 1;
                        }


                    }


                    switch (alt134) 
                    {
                        case 1 :
                            // AS3_ex.g3:3200:30: A= AND equalityExpression
                            {
                                A=(IToken)Match(input,AND,FOLLOW_AND_in_bitwiseANDExpression12523); if (state.failed) return retval;
                                if ( state.backtracking == 0 )
                                {A_tree = (object)adaptor.Create(A);
                                    adaptor.AddChild(root_0, A_tree);
                                }
                                if ( state.backtracking == 0 ) 
                                {
                                  indentEmit(A, ASPrettyPrinter.Break_Arithmetic_Ops_code);
                                }
                                PushFollow(FOLLOW_equalityExpression_in_bitwiseANDExpression12527);
                                equalityExpression289 = equalityExpression();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, equalityExpression289.Tree);
                                if ( state.backtracking == 0 ) 
                                {
                                  popIndent();
                                }

                            }
                            break;

                        default:
                            goto loop134;
                    }
                } while (true);

                loop134:
                    ;   // Stops C# compiler whining that label 'loop134' has no statements

                if ( state.backtracking == 0 ) 
                {
                  if (pushedWrapInfo) mPrinter.popWrapContext();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 116, bitwiseANDExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "bitwiseANDExpression"

    public class bitwiseANDExpressionNoIn_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "bitwiseANDExpressionNoIn"
    // AS3_ex.g3:3204:1: bitwiseANDExpressionNoIn : equalityExpressionNoIn (A= AND equalityExpressionNoIn )* ;
    public AS3_exParser.bitwiseANDExpressionNoIn_return bitwiseANDExpressionNoIn() // throws RecognitionException [1]
    {   
        AS3_exParser.bitwiseANDExpressionNoIn_return retval = new AS3_exParser.bitwiseANDExpressionNoIn_return();
        retval.Start = input.LT(1);
        int bitwiseANDExpressionNoIn_StartIndex = input.Index();
        object root_0 = null;

        IToken A = null;
        AS3_exParser.equalityExpressionNoIn_return equalityExpressionNoIn290 = null;

        AS3_exParser.equalityExpressionNoIn_return equalityExpressionNoIn291 = null;


        object A_tree=null;


            WrapOptions options=mPrinter.getExpressionWrapOptions();
            bool pushedWrapInfo=false;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 117) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3209:5: ( equalityExpressionNoIn (A= AND equalityExpressionNoIn )* )
            // AS3_ex.g3:3209:9: equalityExpressionNoIn (A= AND equalityExpressionNoIn )*
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  pushedWrapInfo=pushWrapInfo(options, true);
                }
                PushFollow(FOLLOW_equalityExpressionNoIn_in_bitwiseANDExpressionNoIn12579);
                equalityExpressionNoIn290 = equalityExpressionNoIn();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, equalityExpressionNoIn290.Tree);
                // AS3_ex.g3:3210:32: (A= AND equalityExpressionNoIn )*
                do 
                {
                    int alt135 = 2;
                    int LA135_0 = input.LA(1);

                    if ( (LA135_0 == AND) )
                    {
                        alt135 = 1;
                    }


                    switch (alt135) 
                    {
                        case 1 :
                            // AS3_ex.g3:3210:34: A= AND equalityExpressionNoIn
                            {
                                A=(IToken)Match(input,AND,FOLLOW_AND_in_bitwiseANDExpressionNoIn12585); if (state.failed) return retval;
                                if ( state.backtracking == 0 )
                                {A_tree = (object)adaptor.Create(A);
                                    adaptor.AddChild(root_0, A_tree);
                                }
                                if ( state.backtracking == 0 ) 
                                {
                                  indentEmit(A, ASPrettyPrinter.Break_Arithmetic_Ops_code);
                                }
                                PushFollow(FOLLOW_equalityExpressionNoIn_in_bitwiseANDExpressionNoIn12589);
                                equalityExpressionNoIn291 = equalityExpressionNoIn();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, equalityExpressionNoIn291.Tree);
                                if ( state.backtracking == 0 ) 
                                {
                                  popIndent();
                                }

                            }
                            break;

                        default:
                            goto loop135;
                    }
                } while (true);

                loop135:
                    ;   // Stops C# compiler whining that label 'loop135' has no statements

                if ( state.backtracking == 0 ) 
                {
                  if (pushedWrapInfo) mPrinter.popWrapContext();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 117, bitwiseANDExpressionNoIn_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "bitwiseANDExpressionNoIn"

    public class equalityExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "equalityExpression"
    // AS3_ex.g3:3215:1: equalityExpression : relationalExpression (eq= ( EQ | NEQ | SAME | NSAME ) relationalExpression )* ;
    public AS3_exParser.equalityExpression_return equalityExpression() // throws RecognitionException [1]
    {   
        AS3_exParser.equalityExpression_return retval = new AS3_exParser.equalityExpression_return();
        retval.Start = input.LT(1);
        int equalityExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken eq = null;
        AS3_exParser.relationalExpression_return relationalExpression292 = null;

        AS3_exParser.relationalExpression_return relationalExpression293 = null;


        object eq_tree=null;


            WrapOptions options=mPrinter.getExpressionWrapOptions();
            bool pushedWrapInfo=false;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 118) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3220:5: ( relationalExpression (eq= ( EQ | NEQ | SAME | NSAME ) relationalExpression )* )
            // AS3_ex.g3:3220:9: relationalExpression (eq= ( EQ | NEQ | SAME | NSAME ) relationalExpression )*
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  pushedWrapInfo=pushWrapInfo(options, true);
                }
                PushFollow(FOLLOW_relationalExpression_in_equalityExpression12642);
                relationalExpression292 = relationalExpression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, relationalExpression292.Tree);
                // AS3_ex.g3:3221:30: (eq= ( EQ | NEQ | SAME | NSAME ) relationalExpression )*
                do 
                {
                    int alt136 = 2;
                    int LA136_0 = input.LA(1);

                    if ( ((LA136_0 >= EQ && LA136_0 <= NSAME)) )
                    {
                        int LA136_2 = input.LA(2);

                        if ( (synpred270_AS3_ex()) )
                        {
                            alt136 = 1;
                        }


                    }


                    switch (alt136) 
                    {
                        case 1 :
                            // AS3_ex.g3:3221:32: eq= ( EQ | NEQ | SAME | NSAME ) relationalExpression
                            {
                                eq = (IToken)input.LT(1);
                                if ( (input.LA(1) >= EQ && input.LA(1) <= NSAME) ) 
                                {
                                    input.Consume();
                                    if ( state.backtracking == 0 ) adaptor.AddChild(root_0, (object)adaptor.Create(eq));
                                    state.errorRecovery = false;state.failed = false;
                                }
                                else 
                                {
                                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                                    MismatchedSetException mse = new MismatchedSetException(null,input);
                                    throw mse;
                                }

                                if ( state.backtracking == 0 ) 
                                {
                                  indentEmit(eq, ASPrettyPrinter.Break_Arithmetic_Ops_code);
                                }
                                PushFollow(FOLLOW_relationalExpression_in_equalityExpression12660);
                                relationalExpression293 = relationalExpression();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, relationalExpression293.Tree);
                                if ( state.backtracking == 0 ) 
                                {
                                  popIndent();
                                }

                            }
                            break;

                        default:
                            goto loop136;
                    }
                } while (true);

                loop136:
                    ;   // Stops C# compiler whining that label 'loop136' has no statements

                if ( state.backtracking == 0 ) 
                {
                  if (pushedWrapInfo) mPrinter.popWrapContext();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 118, equalityExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "equalityExpression"

    public class equalityExpressionNoIn_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "equalityExpressionNoIn"
    // AS3_ex.g3:3225:1: equalityExpressionNoIn : relationalExpressionNoIn (eq= ( EQ | NEQ | SAME | NSAME ) relationalExpressionNoIn )* ;
    public AS3_exParser.equalityExpressionNoIn_return equalityExpressionNoIn() // throws RecognitionException [1]
    {   
        AS3_exParser.equalityExpressionNoIn_return retval = new AS3_exParser.equalityExpressionNoIn_return();
        retval.Start = input.LT(1);
        int equalityExpressionNoIn_StartIndex = input.Index();
        object root_0 = null;

        IToken eq = null;
        AS3_exParser.relationalExpressionNoIn_return relationalExpressionNoIn294 = null;

        AS3_exParser.relationalExpressionNoIn_return relationalExpressionNoIn295 = null;


        object eq_tree=null;


            WrapOptions options=mPrinter.getExpressionWrapOptions();
            bool pushedWrapInfo=false;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 119) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3230:5: ( relationalExpressionNoIn (eq= ( EQ | NEQ | SAME | NSAME ) relationalExpressionNoIn )* )
            // AS3_ex.g3:3230:9: relationalExpressionNoIn (eq= ( EQ | NEQ | SAME | NSAME ) relationalExpressionNoIn )*
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  pushedWrapInfo=pushWrapInfo(options, true);
                }
                PushFollow(FOLLOW_relationalExpressionNoIn_in_equalityExpressionNoIn12712);
                relationalExpressionNoIn294 = relationalExpressionNoIn();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, relationalExpressionNoIn294.Tree);
                // AS3_ex.g3:3231:34: (eq= ( EQ | NEQ | SAME | NSAME ) relationalExpressionNoIn )*
                do 
                {
                    int alt137 = 2;
                    int LA137_0 = input.LA(1);

                    if ( ((LA137_0 >= EQ && LA137_0 <= NSAME)) )
                    {
                        alt137 = 1;
                    }


                    switch (alt137) 
                    {
                        case 1 :
                            // AS3_ex.g3:3231:36: eq= ( EQ | NEQ | SAME | NSAME ) relationalExpressionNoIn
                            {
                                eq = (IToken)input.LT(1);
                                if ( (input.LA(1) >= EQ && input.LA(1) <= NSAME) ) 
                                {
                                    input.Consume();
                                    if ( state.backtracking == 0 ) adaptor.AddChild(root_0, (object)adaptor.Create(eq));
                                    state.errorRecovery = false;state.failed = false;
                                }
                                else 
                                {
                                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                                    MismatchedSetException mse = new MismatchedSetException(null,input);
                                    throw mse;
                                }

                                if ( state.backtracking == 0 ) 
                                {
                                  indentEmit(eq, ASPrettyPrinter.Break_Arithmetic_Ops_code);
                                }
                                PushFollow(FOLLOW_relationalExpressionNoIn_in_equalityExpressionNoIn12731);
                                relationalExpressionNoIn295 = relationalExpressionNoIn();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, relationalExpressionNoIn295.Tree);
                                if ( state.backtracking == 0 ) 
                                {
                                  popIndent();
                                }

                            }
                            break;

                        default:
                            goto loop137;
                    }
                } while (true);

                loop137:
                    ;   // Stops C# compiler whining that label 'loop137' has no statements

                if ( state.backtracking == 0 ) 
                {
                  if (pushedWrapInfo) mPrinter.popWrapContext();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 119, equalityExpressionNoIn_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "equalityExpressionNoIn"

    public class relationalExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "relationalExpression"
    // AS3_ex.g3:3236:1: relationalExpression : shiftExpression ( (g= GT (assign= ASSIGN )? | eq= ( IN | LT | LTE | INSTANCEOF | IS | AS ) ) shiftExpression )* ;
    public AS3_exParser.relationalExpression_return relationalExpression() // throws RecognitionException [1]
    {   
        AS3_exParser.relationalExpression_return retval = new AS3_exParser.relationalExpression_return();
        retval.Start = input.LT(1);
        int relationalExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken g = null;
        IToken assign = null;
        IToken eq = null;
        AS3_exParser.shiftExpression_return shiftExpression296 = null;

        AS3_exParser.shiftExpression_return shiftExpression297 = null;


        object g_tree=null;
        object assign_tree=null;
        object eq_tree=null;


            WrapOptions options=mPrinter.getExpressionWrapOptions();
            bool pushedWrapInfo=false;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 120) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3241:5: ( shiftExpression ( (g= GT (assign= ASSIGN )? | eq= ( IN | LT | LTE | INSTANCEOF | IS | AS ) ) shiftExpression )* )
            // AS3_ex.g3:3241:9: shiftExpression ( (g= GT (assign= ASSIGN )? | eq= ( IN | LT | LTE | INSTANCEOF | IS | AS ) ) shiftExpression )*
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  pushedWrapInfo=pushWrapInfo(options, true);
                }
                PushFollow(FOLLOW_shiftExpression_in_relationalExpression12784);
                shiftExpression296 = shiftExpression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, shiftExpression296.Tree);
                // AS3_ex.g3:3243:6: ( (g= GT (assign= ASSIGN )? | eq= ( IN | LT | LTE | INSTANCEOF | IS | AS ) ) shiftExpression )*
                do 
                {
                    int alt140 = 2;
                    switch ( input.LA(1) ) 
                    {
                    case LT:
                        {
                        int LA140_2 = input.LA(2);

                        if ( (synpred282_AS3_ex()) )
                        {
                            alt140 = 1;
                        }


                        }
                        break;
                    case IN:
                        {
                        int LA140_3 = input.LA(2);

                        if ( (synpred282_AS3_ex()) )
                        {
                            alt140 = 1;
                        }


                        }
                        break;
                    case AS:
                    case INSTANCEOF:
                    case IS:
                        {
                        int LA140_4 = input.LA(2);

                        if ( (synpred282_AS3_ex()) )
                        {
                            alt140 = 1;
                        }


                        }
                        break;
                    case GT:
                        {
                        int LA140_5 = input.LA(2);

                        if ( (synpred282_AS3_ex()) )
                        {
                            alt140 = 1;
                        }


                        }
                        break;
                    case LTE:
                        {
                        int LA140_6 = input.LA(2);

                        if ( (synpred282_AS3_ex()) )
                        {
                            alt140 = 1;
                        }


                        }
                        break;

                    }

                    switch (alt140) 
                    {
                        case 1 :
                            // AS3_ex.g3:3244:7: (g= GT (assign= ASSIGN )? | eq= ( IN | LT | LTE | INSTANCEOF | IS | AS ) ) shiftExpression
                            {
                                // AS3_ex.g3:3244:7: (g= GT (assign= ASSIGN )? | eq= ( IN | LT | LTE | INSTANCEOF | IS | AS ) )
                                int alt139 = 2;
                                int LA139_0 = input.LA(1);

                                if ( (LA139_0 == GT) )
                                {
                                    alt139 = 1;
                                }
                                else if ( (LA139_0 == AS || (LA139_0 >= IN && LA139_0 <= INSTANCEOF) || LA139_0 == IS || LA139_0 == LT || LA139_0 == LTE) )
                                {
                                    alt139 = 2;
                                }
                                else 
                                {
                                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                                    NoViableAltException nvae_d139s0 =
                                        new NoViableAltException("", 139, 0, input);

                                    throw nvae_d139s0;
                                }
                                switch (alt139) 
                                {
                                    case 1 :
                                        // AS3_ex.g3:3244:9: g= GT (assign= ASSIGN )?
                                        {
                                            g=(IToken)Match(input,GT,FOLLOW_GT_in_relationalExpression12804); if (state.failed) return retval;
                                            if ( state.backtracking == 0 )
                                            {g_tree = (object)adaptor.Create(g);
                                                adaptor.AddChild(root_0, g_tree);
                                            }
                                            // AS3_ex.g3:3244:14: (assign= ASSIGN )?
                                            int alt138 = 2;
                                            int LA138_0 = input.LA(1);

                                            if ( (LA138_0 == ASSIGN) )
                                            {
                                                alt138 = 1;
                                            }
                                            switch (alt138) 
                                            {
                                                case 1 :
                                                    // AS3_ex.g3:3244:15: assign= ASSIGN
                                                    {
                                                        assign=(IToken)Match(input,ASSIGN,FOLLOW_ASSIGN_in_relationalExpression12809); if (state.failed) return retval;
                                                        if ( state.backtracking == 0 )
                                                        {assign_tree = (object)adaptor.Create(assign);
                                                            adaptor.AddChild(root_0, assign_tree);
                                                        }

                                                    }
                                                    break;

                                            }

                                            if ( state.backtracking == 0 ) 
                                            {
                                              if (assign!=null)
                                                             {
                                                                g.Text = ">=";
                                                                g.Type = GTE;
                                                             }
                                                             indentEmit(g, ASPrettyPrinter.Break_Arithmetic_Ops_code);
                                                            
                                            }

                                        }
                                        break;
                                    case 2 :
                                        // AS3_ex.g3:3252:14: eq= ( IN | LT | LTE | INSTANCEOF | IS | AS )
                                        {
                                            eq = (IToken)input.LT(1);
                                            if ( input.LA(1) == AS || (input.LA(1) >= IN && input.LA(1) <= INSTANCEOF) || input.LA(1) == IS || input.LA(1) == LT || input.LA(1) == LTE ) 
                                            {
                                                input.Consume();
                                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, (object)adaptor.Create(eq));
                                                state.errorRecovery = false;state.failed = false;
                                            }
                                            else 
                                            {
                                                if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                                                MismatchedSetException mse = new MismatchedSetException(null,input);
                                                throw mse;
                                            }

                                            if ( state.backtracking == 0 ) 
                                            {
                                              indentEmit(eq, ASPrettyPrinter.Break_Arithmetic_Ops_code);
                                            }

                                        }
                                        break;

                                }

                                PushFollow(FOLLOW_shiftExpression_in_relationalExpression12880);
                                shiftExpression297 = shiftExpression();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, shiftExpression297.Tree);
                                if ( state.backtracking == 0 ) 
                                {
                                  popIndent();
                                }

                            }
                            break;

                        default:
                            goto loop140;
                    }
                } while (true);

                loop140:
                    ;   // Stops C# compiler whining that label 'loop140' has no statements

                if ( state.backtracking == 0 ) 
                {
                  if (pushedWrapInfo) mPrinter.popWrapContext();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 120, relationalExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "relationalExpression"

    public class relationalExpressionNoIn_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "relationalExpressionNoIn"
    // AS3_ex.g3:3259:1: relationalExpressionNoIn : shiftExpression ( (g= GT (assign= ASSIGN )? | eq= ( LT | LTE | INSTANCEOF | IS | AS ) ) shiftExpression )* ;
    public AS3_exParser.relationalExpressionNoIn_return relationalExpressionNoIn() // throws RecognitionException [1]
    {   
        AS3_exParser.relationalExpressionNoIn_return retval = new AS3_exParser.relationalExpressionNoIn_return();
        retval.Start = input.LT(1);
        int relationalExpressionNoIn_StartIndex = input.Index();
        object root_0 = null;

        IToken g = null;
        IToken assign = null;
        IToken eq = null;
        AS3_exParser.shiftExpression_return shiftExpression298 = null;

        AS3_exParser.shiftExpression_return shiftExpression299 = null;


        object g_tree=null;
        object assign_tree=null;
        object eq_tree=null;


            WrapOptions options=mPrinter.getExpressionWrapOptions();
            bool pushedWrapInfo=false;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 121) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3264:5: ( shiftExpression ( (g= GT (assign= ASSIGN )? | eq= ( LT | LTE | INSTANCEOF | IS | AS ) ) shiftExpression )* )
            // AS3_ex.g3:3264:9: shiftExpression ( (g= GT (assign= ASSIGN )? | eq= ( LT | LTE | INSTANCEOF | IS | AS ) ) shiftExpression )*
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  pushedWrapInfo=pushWrapInfo(options, true);
                }
                PushFollow(FOLLOW_shiftExpression_in_relationalExpressionNoIn12941);
                shiftExpression298 = shiftExpression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, shiftExpression298.Tree);
                // AS3_ex.g3:3266:6: ( (g= GT (assign= ASSIGN )? | eq= ( LT | LTE | INSTANCEOF | IS | AS ) ) shiftExpression )*
                do 
                {
                    int alt143 = 2;
                    int LA143_0 = input.LA(1);

                    if ( (LA143_0 == AS || LA143_0 == INSTANCEOF || LA143_0 == IS || (LA143_0 >= LT && LA143_0 <= LTE)) )
                    {
                        alt143 = 1;
                    }


                    switch (alt143) 
                    {
                        case 1 :
                            // AS3_ex.g3:3267:7: (g= GT (assign= ASSIGN )? | eq= ( LT | LTE | INSTANCEOF | IS | AS ) ) shiftExpression
                            {
                                // AS3_ex.g3:3267:7: (g= GT (assign= ASSIGN )? | eq= ( LT | LTE | INSTANCEOF | IS | AS ) )
                                int alt142 = 2;
                                int LA142_0 = input.LA(1);

                                if ( (LA142_0 == GT) )
                                {
                                    alt142 = 1;
                                }
                                else if ( (LA142_0 == AS || LA142_0 == INSTANCEOF || LA142_0 == IS || LA142_0 == LT || LA142_0 == LTE) )
                                {
                                    alt142 = 2;
                                }
                                else 
                                {
                                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                                    NoViableAltException nvae_d142s0 =
                                        new NoViableAltException("", 142, 0, input);

                                    throw nvae_d142s0;
                                }
                                switch (alt142) 
                                {
                                    case 1 :
                                        // AS3_ex.g3:3267:9: g= GT (assign= ASSIGN )?
                                        {
                                            g=(IToken)Match(input,GT,FOLLOW_GT_in_relationalExpressionNoIn12961); if (state.failed) return retval;
                                            if ( state.backtracking == 0 )
                                            {g_tree = (object)adaptor.Create(g);
                                                adaptor.AddChild(root_0, g_tree);
                                            }
                                            // AS3_ex.g3:3267:14: (assign= ASSIGN )?
                                            int alt141 = 2;
                                            int LA141_0 = input.LA(1);

                                            if ( (LA141_0 == ASSIGN) )
                                            {
                                                alt141 = 1;
                                            }
                                            switch (alt141) 
                                            {
                                                case 1 :
                                                    // AS3_ex.g3:3267:15: assign= ASSIGN
                                                    {
                                                        assign=(IToken)Match(input,ASSIGN,FOLLOW_ASSIGN_in_relationalExpressionNoIn12966); if (state.failed) return retval;
                                                        if ( state.backtracking == 0 )
                                                        {assign_tree = (object)adaptor.Create(assign);
                                                            adaptor.AddChild(root_0, assign_tree);
                                                        }

                                                    }
                                                    break;

                                            }

                                            if ( state.backtracking == 0 ) 
                                            {
                                              if (assign!=null)
                                                             {
                                                                g.Text = ">=";
                                                                g.Type = GTE;
                                                             }
                                                             indentEmit(g, ASPrettyPrinter.Break_Arithmetic_Ops_code);
                                                            
                                            }

                                        }
                                        break;
                                    case 2 :
                                        // AS3_ex.g3:3275:14: eq= ( LT | LTE | INSTANCEOF | IS | AS )
                                        {
                                            eq = (IToken)input.LT(1);
                                            if ( input.LA(1) == AS || input.LA(1) == INSTANCEOF || input.LA(1) == IS || input.LA(1) == LT || input.LA(1) == LTE ) 
                                            {
                                                input.Consume();
                                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, (object)adaptor.Create(eq));
                                                state.errorRecovery = false;state.failed = false;
                                            }
                                            else 
                                            {
                                                if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                                                MismatchedSetException mse = new MismatchedSetException(null,input);
                                                throw mse;
                                            }

                                            if ( state.backtracking == 0 ) 
                                            {
                                              indentEmit(eq, ASPrettyPrinter.Break_Arithmetic_Ops_code);
                                            }

                                        }
                                        break;

                                }

                                PushFollow(FOLLOW_shiftExpression_in_relationalExpressionNoIn13035);
                                shiftExpression299 = shiftExpression();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, shiftExpression299.Tree);
                                if ( state.backtracking == 0 ) 
                                {
                                  popIndent();
                                }

                            }
                            break;

                        default:
                            goto loop143;
                    }
                } while (true);

                loop143:
                    ;   // Stops C# compiler whining that label 'loop143' has no statements

                if ( state.backtracking == 0 ) 
                {
                  if (pushedWrapInfo) mPrinter.popWrapContext();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 121, relationalExpressionNoIn_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "relationalExpressionNoIn"

    public class shiftExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "shiftExpression"
    // AS3_ex.g3:3283:1: shiftExpression : additiveExpression ( (t1= SHL | ( ( '>' '>' )=>t1= '>' t2= '>' {...}? -> SHR ) | ( ( '>' '>' '>' )=>t1= '>' t2= '>' t3= '>' {...}? -> SHU ) ) additiveExpression )* ;
    public AS3_exParser.shiftExpression_return shiftExpression() // throws RecognitionException [1]
    {   
        AS3_exParser.shiftExpression_return retval = new AS3_exParser.shiftExpression_return();
        retval.Start = input.LT(1);
        int shiftExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken t1 = null;
        IToken t2 = null;
        IToken t3 = null;
        AS3_exParser.additiveExpression_return additiveExpression300 = null;

        AS3_exParser.additiveExpression_return additiveExpression301 = null;


        object t1_tree=null;
        object t2_tree=null;
        object t3_tree=null;
        RewriteRuleTokenStream stream_SHL = new RewriteRuleTokenStream(adaptor,"token SHL");
        RewriteRuleTokenStream stream_GT = new RewriteRuleTokenStream(adaptor,"token GT");
        RewriteRuleSubtreeStream stream_additiveExpression = new RewriteRuleSubtreeStream(adaptor,"rule additiveExpression");

            WrapOptions options=mPrinter.getExpressionWrapOptions();
            bool pushedWrapInfo=false;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 122) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3288:5: ( additiveExpression ( (t1= SHL | ( ( '>' '>' )=>t1= '>' t2= '>' {...}? -> SHR ) | ( ( '>' '>' '>' )=>t1= '>' t2= '>' t3= '>' {...}? -> SHU ) ) additiveExpression )* )
            // AS3_ex.g3:3288:9: additiveExpression ( (t1= SHL | ( ( '>' '>' )=>t1= '>' t2= '>' {...}? -> SHR ) | ( ( '>' '>' '>' )=>t1= '>' t2= '>' t3= '>' {...}? -> SHU ) ) additiveExpression )*
            {
                if ( state.backtracking == 0 ) 
                {
                  pushedWrapInfo=pushWrapInfo(options, true);
                }
                PushFollow(FOLLOW_additiveExpression_in_shiftExpression13093);
                additiveExpression300 = additiveExpression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking==0 ) stream_additiveExpression.Add(additiveExpression300.Tree);
                // AS3_ex.g3:3289:28: ( (t1= SHL | ( ( '>' '>' )=>t1= '>' t2= '>' {...}? -> SHR ) | ( ( '>' '>' '>' )=>t1= '>' t2= '>' t3= '>' {...}? -> SHU ) ) additiveExpression )*
                do 
                {
                    int alt145 = 2;
                    int LA145_0 = input.LA(1);

                    if ( (LA145_0 == GT) )
                    {
                        int LA145_1 = input.LA(2);

                        if ( (synpred294_AS3_ex()) )
                        {
                            alt145 = 1;
                        }


                    }
                    else if ( (LA145_0 == SHL) )
                    {
                        int LA145_3 = input.LA(2);

                        if ( (synpred294_AS3_ex()) )
                        {
                            alt145 = 1;
                        }


                    }


                    switch (alt145) 
                    {
                        case 1 :
                            // AS3_ex.g3:3290:7: (t1= SHL | ( ( '>' '>' )=>t1= '>' t2= '>' {...}? -> SHR ) | ( ( '>' '>' '>' )=>t1= '>' t2= '>' t3= '>' {...}? -> SHU ) ) additiveExpression
                            {
                                // AS3_ex.g3:3290:7: (t1= SHL | ( ( '>' '>' )=>t1= '>' t2= '>' {...}? -> SHR ) | ( ( '>' '>' '>' )=>t1= '>' t2= '>' t3= '>' {...}? -> SHU ) )
                                int alt144 = 3;
                                int LA144_0 = input.LA(1);

                                if ( (LA144_0 == SHL) )
                                {
                                    alt144 = 1;
                                }
                                else if ( (LA144_0 == GT) )
                                {
                                    int LA144_2 = input.LA(2);

                                    if ( (LA144_2 == GT) )
                                    {
                                        int LA144_3 = input.LA(3);

                                        if ( (LA144_3 == GT) && (synpred293_AS3_ex()) )
                                        {
                                            alt144 = 3;
                                        }
                                        else if ( ((LA144_3 >= AS && LA144_3 <= STATIC) || LA144_3 == LCURLY || LA144_3 == LPAREN || LA144_3 == LBRACK || LA144_3 == LT || (LA144_3 >= PLUS && LA144_3 <= STAR) || (LA144_3 >= INC && LA144_3 <= DEC) || (LA144_3 >= NOT && LA144_3 <= INV) || (LA144_3 >= XML_AT && LA144_3 <= XML_LS_STD) || (LA144_3 >= SINGLE_QUOTE_LITERAL && LA144_3 <= DOUBLE_QUOTE_LITERAL) || LA144_3 == REGULAR_EXPR_LITERAL || LA144_3 == HEX_NUMBER_LITERAL || LA144_3 == DEC_NUMBER_LITERAL || LA144_3 == IDENTIFIER || (LA144_3 >= XML_COMMENT && LA144_3 <= XML_PI)) )
                                        {
                                            alt144 = 2;
                                        }
                                        else 
                                        {
                                            if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                                            NoViableAltException nvae_d144s3 =
                                                new NoViableAltException("", 144, 3, input);

                                            throw nvae_d144s3;
                                        }
                                    }
                                    else 
                                    {
                                        if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                                        NoViableAltException nvae_d144s2 =
                                            new NoViableAltException("", 144, 2, input);

                                        throw nvae_d144s2;
                                    }
                                }
                                else 
                                {
                                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                                    NoViableAltException nvae_d144s0 =
                                        new NoViableAltException("", 144, 0, input);

                                    throw nvae_d144s0;
                                }
                                switch (alt144) 
                                {
                                    case 1 :
                                        // AS3_ex.g3:3291:8: t1= SHL
                                        {
                                            t1=(IToken)Match(input,SHL,FOLLOW_SHL_in_shiftExpression13115); if (state.failed) return retval; 
                                            if ( state.backtracking==0 ) stream_SHL.Add(t1);


                                        }
                                        break;
                                    case 2 :
                                        // AS3_ex.g3:3296:11: ( ( '>' '>' )=>t1= '>' t2= '>' {...}? -> SHR )
                                        {
                                            // AS3_ex.g3:3296:11: ( ( '>' '>' )=>t1= '>' t2= '>' {...}? -> SHR )
                                            // AS3_ex.g3:3296:12: ( '>' '>' )=>t1= '>' t2= '>' {...}?
                                            {
                                                t1=(IToken)Match(input,GT,FOLLOW_GT_in_shiftExpression13146); if (state.failed) return retval; 
                                                if ( state.backtracking==0 ) stream_GT.Add(t1);

                                                t2=(IToken)Match(input,GT,FOLLOW_GT_in_shiftExpression13150); if (state.failed) return retval; 
                                                if ( state.backtracking==0 ) stream_GT.Add(t2);

                                                if ( !(( t1.Line == t2.Line && 
                                                                    t1.CharPositionInLine + 1 == t2.CharPositionInLine )) ) 
                                                {
                                                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                                                    throw new FailedPredicateException(input, "shiftExpression", " $t1.Line == $t2.Line && \n          \t\t\t$t1.CharPositionInLine + 1 == $t2.CharPositionInLine ");
                                                }


                                                // AST REWRITE
                                                // elements:          
                                                // token labels:      
                                                // rule labels:       retval
                                                // token list labels: 
                                                // rule list labels:  
                                                if ( state.backtracking==0 ) {
                                                retval.Tree = root_0;
                                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));

                                                root_0 = (object)adaptor.GetNilNode();
                                                // 3299:10: -> SHR
                                                {
                                                    adaptor.AddChild(root_0, (object)adaptor.Create(SHR, "SHR"));

                                                }

                                                retval.Tree = root_0;retval.Tree = root_0;}
                                            }

                                            if ( state.backtracking == 0 ) 
                                            {
                                              t1.Text = ">>";
                                            }

                                        }
                                        break;
                                    case 3 :
                                        // AS3_ex.g3:3300:10: ( ( '>' '>' '>' )=>t1= '>' t2= '>' t3= '>' {...}? -> SHU )
                                        {
                                            // AS3_ex.g3:3300:10: ( ( '>' '>' '>' )=>t1= '>' t2= '>' t3= '>' {...}? -> SHU )
                                            // AS3_ex.g3:3300:11: ( '>' '>' '>' )=>t1= '>' t2= '>' t3= '>' {...}?
                                            {
                                                t1=(IToken)Match(input,GT,FOLLOW_GT_in_shiftExpression13201); if (state.failed) return retval; 
                                                if ( state.backtracking==0 ) stream_GT.Add(t1);

                                                t2=(IToken)Match(input,GT,FOLLOW_GT_in_shiftExpression13205); if (state.failed) return retval; 
                                                if ( state.backtracking==0 ) stream_GT.Add(t2);

                                                t3=(IToken)Match(input,GT,FOLLOW_GT_in_shiftExpression13209); if (state.failed) return retval; 
                                                if ( state.backtracking==0 ) stream_GT.Add(t3);

                                                if ( !(( t1.Line == t2.Line && 
                                                                    t1.CharPositionInLine + 1 == t2.CharPositionInLine &&
                                                                    t2.Line == t3.Line && 
                                                                    t2.CharPositionInLine + 1 == t3.CharPositionInLine )) ) 
                                                {
                                                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                                                    throw new FailedPredicateException(input, "shiftExpression", " $t1.Line == $t2.Line && \n          \t\t\t$t1.CharPositionInLine + 1 == $t2.CharPositionInLine &&\n          \t\t\t$t2.Line == $t3.Line && \n          \t\t\t$t2.CharPositionInLine + 1 == $t3.CharPositionInLine ");
                                                }


                                                // AST REWRITE
                                                // elements:          
                                                // token labels:      
                                                // rule labels:       retval
                                                // token list labels: 
                                                // rule list labels:  
                                                if ( state.backtracking==0 ) {
                                                retval.Tree = root_0;
                                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));

                                                root_0 = (object)adaptor.GetNilNode();
                                                // 3305:10: -> SHU
                                                {
                                                    adaptor.AddChild(root_0, (object)adaptor.Create(SHU, "SHU"));

                                                }

                                                retval.Tree = root_0;retval.Tree = root_0;}
                                            }

                                            if ( state.backtracking == 0 ) 
                                            {
                                              t1.Text = ">>>";
                                            }

                                        }
                                        break;

                                }

                                if ( state.backtracking == 0 ) 
                                {
                                  indentEmit(t1, ASPrettyPrinter.Break_Arithmetic_Ops_code);
                                }
                                PushFollow(FOLLOW_additiveExpression_in_shiftExpression13256);
                                additiveExpression301 = additiveExpression();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking==0 ) stream_additiveExpression.Add(additiveExpression301.Tree);
                                if ( state.backtracking == 0 ) 
                                {
                                  popIndent();
                                }

                            }
                            break;

                        default:
                            goto loop145;
                    }
                } while (true);

                loop145:
                    ;   // Stops C# compiler whining that label 'loop145' has no statements

                if ( state.backtracking == 0 ) 
                {
                  if (pushedWrapInfo) mPrinter.popWrapContext();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 122, shiftExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "shiftExpression"

    public class additiveExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "additiveExpression"
    // AS3_ex.g3:3313:1: additiveExpression : multiplicativeExpression (op= ( PLUS | SUB ) multiplicativeExpression )* ;
    public AS3_exParser.additiveExpression_return additiveExpression() // throws RecognitionException [1]
    {   
        AS3_exParser.additiveExpression_return retval = new AS3_exParser.additiveExpression_return();
        retval.Start = input.LT(1);
        int additiveExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken op = null;
        AS3_exParser.multiplicativeExpression_return multiplicativeExpression302 = null;

        AS3_exParser.multiplicativeExpression_return multiplicativeExpression303 = null;


        object op_tree=null;


            WrapOptions options=mPrinter.getExpressionWrapOptions();
            bool pushedWrapInfo=false;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 123) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3318:5: ( multiplicativeExpression (op= ( PLUS | SUB ) multiplicativeExpression )* )
            // AS3_ex.g3:3318:9: multiplicativeExpression (op= ( PLUS | SUB ) multiplicativeExpression )*
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  pushedWrapInfo=pushWrapInfo(options, true);
                }
                PushFollow(FOLLOW_multiplicativeExpression_in_additiveExpression13308);
                multiplicativeExpression302 = multiplicativeExpression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, multiplicativeExpression302.Tree);
                // AS3_ex.g3:3319:34: (op= ( PLUS | SUB ) multiplicativeExpression )*
                do 
                {
                    int alt146 = 2;
                    int LA146_0 = input.LA(1);

                    if ( ((LA146_0 >= PLUS && LA146_0 <= SUB)) )
                    {
                        int LA146_2 = input.LA(2);

                        if ( (synpred296_AS3_ex()) )
                        {
                            alt146 = 1;
                        }


                    }


                    switch (alt146) 
                    {
                        case 1 :
                            // AS3_ex.g3:3319:36: op= ( PLUS | SUB ) multiplicativeExpression
                            {
                                op = (IToken)input.LT(1);
                                if ( (input.LA(1) >= PLUS && input.LA(1) <= SUB) ) 
                                {
                                    input.Consume();
                                    if ( state.backtracking == 0 ) adaptor.AddChild(root_0, (object)adaptor.Create(op));
                                    state.errorRecovery = false;state.failed = false;
                                }
                                else 
                                {
                                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                                    MismatchedSetException mse = new MismatchedSetException(null,input);
                                    throw mse;
                                }

                                if ( state.backtracking == 0 ) 
                                {
                                  indentEmit(op, ASPrettyPrinter.Break_Arithmetic_Ops_code);
                                }
                                PushFollow(FOLLOW_multiplicativeExpression_in_additiveExpression13322);
                                multiplicativeExpression303 = multiplicativeExpression();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, multiplicativeExpression303.Tree);
                                if ( state.backtracking == 0 ) 
                                {
                                  popIndent();
                                }

                            }
                            break;

                        default:
                            goto loop146;
                    }
                } while (true);

                loop146:
                    ;   // Stops C# compiler whining that label 'loop146' has no statements

                if ( state.backtracking == 0 ) 
                {
                  if (pushedWrapInfo) mPrinter.popWrapContext();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 123, additiveExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "additiveExpression"

    public class multiplicativeExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "multiplicativeExpression"
    // AS3_ex.g3:3324:1: multiplicativeExpression : unaryExpression (op= ( STAR | DIV | MOD ) unaryExpression )* ;
    public AS3_exParser.multiplicativeExpression_return multiplicativeExpression() // throws RecognitionException [1]
    {   
        AS3_exParser.multiplicativeExpression_return retval = new AS3_exParser.multiplicativeExpression_return();
        retval.Start = input.LT(1);
        int multiplicativeExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken op = null;
        AS3_exParser.unaryExpression_return unaryExpression304 = null;

        AS3_exParser.unaryExpression_return unaryExpression305 = null;


        object op_tree=null;


            WrapOptions options=mPrinter.getExpressionWrapOptions();
            bool pushedWrapInfo=false;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 124) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3329:5: ( unaryExpression (op= ( STAR | DIV | MOD ) unaryExpression )* )
            // AS3_ex.g3:3329:9: unaryExpression (op= ( STAR | DIV | MOD ) unaryExpression )*
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  pushedWrapInfo=pushWrapInfo(options, true);
                }
                PushFollow(FOLLOW_unaryExpression_in_multiplicativeExpression13371);
                unaryExpression304 = unaryExpression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, unaryExpression304.Tree);
                // AS3_ex.g3:3330:25: (op= ( STAR | DIV | MOD ) unaryExpression )*
                do 
                {
                    int alt147 = 2;
                    int LA147_0 = input.LA(1);

                    if ( (LA147_0 == STAR) )
                    {
                        int LA147_2 = input.LA(2);

                        if ( (synpred299_AS3_ex()) )
                        {
                            alt147 = 1;
                        }


                    }
                    else if ( ((LA147_0 >= DIV && LA147_0 <= MOD)) )
                    {
                        int LA147_3 = input.LA(2);

                        if ( (synpred299_AS3_ex()) )
                        {
                            alt147 = 1;
                        }


                    }


                    switch (alt147) 
                    {
                        case 1 :
                            // AS3_ex.g3:3330:27: op= ( STAR | DIV | MOD ) unaryExpression
                            {
                                op = (IToken)input.LT(1);
                                if ( (input.LA(1) >= STAR && input.LA(1) <= MOD) ) 
                                {
                                    input.Consume();
                                    if ( state.backtracking == 0 ) adaptor.AddChild(root_0, (object)adaptor.Create(op));
                                    state.errorRecovery = false;state.failed = false;
                                }
                                else 
                                {
                                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                                    MismatchedSetException mse = new MismatchedSetException(null,input);
                                    throw mse;
                                }

                                if ( state.backtracking == 0 ) 
                                {
                                  indentEmit(op, ASPrettyPrinter.Break_Arithmetic_Ops_code);
                                }
                                PushFollow(FOLLOW_unaryExpression_in_multiplicativeExpression13386);
                                unaryExpression305 = unaryExpression();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, unaryExpression305.Tree);
                                if ( state.backtracking == 0 ) 
                                {
                                  popIndent();
                                }

                            }
                            break;

                        default:
                            goto loop147;
                    }
                } while (true);

                loop147:
                    ;   // Stops C# compiler whining that label 'loop147' has no statements

                if ( state.backtracking == 0 ) 
                {
                  if (pushedWrapInfo) mPrinter.popWrapContext();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 124, multiplicativeExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "multiplicativeExpression"

    public class unaryExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "unaryExpression"
    // AS3_ex.g3:3335:1: unaryExpression : ( postfixExpression | op= ( NOT | INV ) unaryExpression | unaryOp postfixExpression );
    public AS3_exParser.unaryExpression_return unaryExpression() // throws RecognitionException [1]
    {   
        AS3_exParser.unaryExpression_return retval = new AS3_exParser.unaryExpression_return();
        retval.Start = input.LT(1);
        int unaryExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken op = null;
        AS3_exParser.postfixExpression_return postfixExpression306 = null;

        AS3_exParser.unaryExpression_return unaryExpression307 = null;

        AS3_exParser.unaryOp_return unaryOp308 = null;

        AS3_exParser.postfixExpression_return postfixExpression309 = null;


        object op_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 125) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3336:5: ( postfixExpression | op= ( NOT | INV ) unaryExpression | unaryOp postfixExpression )
            int alt148 = 3;
            alt148 = dfa148.Predict(input);
            switch (alt148) 
            {
                case 1 :
                    // AS3_ex.g3:3336:9: postfixExpression
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_postfixExpression_in_unaryExpression13421);
                        postfixExpression306 = postfixExpression();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, postfixExpression306.Tree);

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:3337:8: op= ( NOT | INV ) unaryExpression
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        op = (IToken)input.LT(1);
                        if ( (input.LA(1) >= NOT && input.LA(1) <= INV) ) 
                        {
                            input.Consume();
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, (object)adaptor.Create(op));
                            state.errorRecovery = false;state.failed = false;
                        }
                        else 
                        {
                            if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                            MismatchedSetException mse = new MismatchedSetException(null,input);
                            throw mse;
                        }

                        if ( state.backtracking == 0 ) 
                        {
                          emit(op);
                        }
                        PushFollow(FOLLOW_unaryExpression_in_unaryExpression13442);
                        unaryExpression307 = unaryExpression();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, unaryExpression307.Tree);

                    }
                    break;
                case 3 :
                    // AS3_ex.g3:3338:9: unaryOp postfixExpression
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_unaryOp_in_unaryExpression13452);
                        unaryOp308 = unaryOp();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, unaryOp308.Tree);
                        PushFollow(FOLLOW_postfixExpression_in_unaryExpression13454);
                        postfixExpression309 = postfixExpression();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, postfixExpression309.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 125, unaryExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "unaryExpression"

    public class unaryOp_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "unaryOp"
    // AS3_ex.g3:3343:1: unaryOp : op= ( DELETE | VOID | TYPEOF | INC | DEC | PLUS | SUB | INV | NOT ) ;
    public AS3_exParser.unaryOp_return unaryOp() // throws RecognitionException [1]
    {   
        AS3_exParser.unaryOp_return retval = new AS3_exParser.unaryOp_return();
        retval.Start = input.LT(1);
        int unaryOp_StartIndex = input.Index();
        object root_0 = null;

        IToken op = null;

        object op_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 126) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3344:5: (op= ( DELETE | VOID | TYPEOF | INC | DEC | PLUS | SUB | INV | NOT ) )
            // AS3_ex.g3:3344:9: op= ( DELETE | VOID | TYPEOF | INC | DEC | PLUS | SUB | INV | NOT )
            {
                root_0 = (object)adaptor.GetNilNode();

                op = (IToken)input.LT(1);
                if ( input.LA(1) == DELETE || input.LA(1) == TYPEOF || input.LA(1) == VOID || (input.LA(1) >= PLUS && input.LA(1) <= SUB) || (input.LA(1) >= INC && input.LA(1) <= DEC) || (input.LA(1) >= NOT && input.LA(1) <= INV) ) 
                {
                    input.Consume();
                    if ( state.backtracking == 0 ) adaptor.AddChild(root_0, (object)adaptor.Create(op));
                    state.errorRecovery = false;state.failed = false;
                }
                else 
                {
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    MismatchedSetException mse = new MismatchedSetException(null,input);
                    throw mse;
                }

                if ( state.backtracking == 0 ) 
                {
                  emit(op);
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 126, unaryOp_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "unaryOp"

    public class postfixExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "postfixExpression"
    // AS3_ex.g3:3349:1: postfixExpression : leftHandSideExpression ( postfixOp )? ;
    public AS3_exParser.postfixExpression_return postfixExpression() // throws RecognitionException [1]
    {   
        AS3_exParser.postfixExpression_return retval = new AS3_exParser.postfixExpression_return();
        retval.Start = input.LT(1);
        int postfixExpression_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.leftHandSideExpression_return leftHandSideExpression310 = null;

        AS3_exParser.postfixOp_return postfixOp311 = null;



        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 127) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3350:5: ( leftHandSideExpression ( postfixOp )? )
            // AS3_ex.g3:3350:9: leftHandSideExpression ( postfixOp )?
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_leftHandSideExpression_in_postfixExpression13542);
                leftHandSideExpression310 = leftHandSideExpression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, leftHandSideExpression310.Tree);
                // AS3_ex.g3:3350:32: ( postfixOp )?
                int alt149 = 2;
                int LA149_0 = input.LA(1);

                if ( ((LA149_0 >= INC && LA149_0 <= DEC)) )
                {
                    int LA149_1 = input.LA(2);

                    if ( (synpred311_AS3_ex()) )
                    {
                        alt149 = 1;
                    }
                }
                switch (alt149) 
                {
                    case 1 :
                        // AS3_ex.g3:0:0: postfixOp
                        {
                            PushFollow(FOLLOW_postfixOp_in_postfixExpression13544);
                            postfixOp311 = postfixOp();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, postfixOp311.Tree);

                        }
                        break;

                }


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 127, postfixExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "postfixExpression"

    public class postfixOp_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "postfixOp"
    // AS3_ex.g3:3353:1: postfixOp : op= ( INC | DEC ) ;
    public AS3_exParser.postfixOp_return postfixOp() // throws RecognitionException [1]
    {   
        AS3_exParser.postfixOp_return retval = new AS3_exParser.postfixOp_return();
        retval.Start = input.LT(1);
        int postfixOp_StartIndex = input.Index();
        object root_0 = null;

        IToken op = null;

        object op_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 128) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3354:5: (op= ( INC | DEC ) )
            // AS3_ex.g3:3354:9: op= ( INC | DEC )
            {
                root_0 = (object)adaptor.GetNilNode();

                op = (IToken)input.LT(1);
                if ( (input.LA(1) >= INC && input.LA(1) <= DEC) ) 
                {
                    input.Consume();
                    if ( state.backtracking == 0 ) adaptor.AddChild(root_0, (object)adaptor.Create(op));
                    state.errorRecovery = false;state.failed = false;
                }
                else 
                {
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    MismatchedSetException mse = new MismatchedSetException(null,input);
                    throw mse;
                }

                if ( state.backtracking == 0 ) 
                {
                  emit(op);
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 128, postfixOp_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "postfixOp"

    public class memberExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "memberExpression"
    // AS3_ex.g3:3358:1: memberExpression : ( primaryExpression | functionExpression | newExpression );
    public AS3_exParser.memberExpression_return memberExpression() // throws RecognitionException [1]
    {   
        AS3_exParser.memberExpression_return retval = new AS3_exParser.memberExpression_return();
        retval.Start = input.LT(1);
        int memberExpression_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.primaryExpression_return primaryExpression312 = null;

        AS3_exParser.functionExpression_return functionExpression313 = null;

        AS3_exParser.newExpression_return newExpression314 = null;



        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 129) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3359:2: ( primaryExpression | functionExpression | newExpression )
            int alt150 = 3;
            switch ( input.LA(1) ) 
            {
            case AS:
            case BREAK:
            case CASE:
            case CATCH:
            case CLASS:
            case CONST:
            case CONTINUE:
            case DEFAULT:
            case DELETE:
            case DO:
            case ELSE:
            case EXTENDS:
            case FALSE:
            case FINALLY:
            case FOR:
            case IF:
            case IMPLEMENTS:
            case IMPORT:
            case IN:
            case INSTANCEOF:
            case INTERFACE:
            case INTERNAL:
            case IS:
            case NATIVE:
            case NULL:
            case PACKAGE:
            case PRIVATE:
            case PROTECTED:
            case PUBLIC:
            case RETURN:
            case SUPER:
            case SWITCH:
            case THIS:
            case THROW:
            case TO:
            case TRUE:
            case TRY:
            case TYPEOF:
            case USE:
            case VAR:
            case VOID:
            case WHILE:
            case WITH:
            case EACH:
            case GET:
            case SET:
            case NAMESPACE:
            case INCLUDE:
            case DYNAMIC:
            case FINAL:
            case OVERRIDE:
            case STATIC:
            case LCURLY:
            case LPAREN:
            case LBRACK:
            case LT:
            case STAR:
            case XML_AT:
            case XML_LS_STD:
            case SINGLE_QUOTE_LITERAL:
            case DOUBLE_QUOTE_LITERAL:
            case REGULAR_EXPR_LITERAL:
            case HEX_NUMBER_LITERAL:
            case DEC_NUMBER_LITERAL:
            case IDENTIFIER:
            case XML_COMMENT:
            case XML_CDATA:
            case XML_PI:
                {
                alt150 = 1;
                }
                break;
            case FUNCTION:
                {
                int LA150_2 = input.LA(2);

                if ( (LA150_2 == LPAREN || LA150_2 == IDENTIFIER) )
                {
                    alt150 = 2;
                }
                else if ( (LA150_2 == DOT || LA150_2 == SUB || LA150_2 == COLON || LA150_2 == XML_NS_OP) )
                {
                    alt150 = 1;
                }
                else 
                {
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    NoViableAltException nvae_d150s2 =
                        new NoViableAltException("", 150, 2, input);

                    throw nvae_d150s2;
                }
                }
                break;
            case NEW:
                {
                int LA150_3 = input.LA(2);

                if ( (LA150_3 == DOT || LA150_3 == SUB || LA150_3 == COLON || LA150_3 == XML_NS_OP) )
                {
                    alt150 = 1;
                }
                else if ( ((LA150_3 >= AS && LA150_3 <= STATIC) || LA150_3 == LCURLY || LA150_3 == LPAREN || LA150_3 == LBRACK || LA150_3 == LT || LA150_3 == STAR || (LA150_3 >= XML_AT && LA150_3 <= XML_LS_STD) || (LA150_3 >= SINGLE_QUOTE_LITERAL && LA150_3 <= DOUBLE_QUOTE_LITERAL) || LA150_3 == REGULAR_EXPR_LITERAL || LA150_3 == HEX_NUMBER_LITERAL || LA150_3 == DEC_NUMBER_LITERAL || LA150_3 == IDENTIFIER || (LA150_3 >= XML_COMMENT && LA150_3 <= XML_PI)) )
                {
                    alt150 = 3;
                }
                else 
                {
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    NoViableAltException nvae_d150s3 =
                        new NoViableAltException("", 150, 3, input);

                    throw nvae_d150s3;
                }
                }
                break;
                default:
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    NoViableAltException nvae_d150s0 =
                        new NoViableAltException("", 150, 0, input);

                    throw nvae_d150s0;
            }

            switch (alt150) 
            {
                case 1 :
                    // AS3_ex.g3:3359:4: primaryExpression
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_primaryExpression_in_memberExpression13592);
                        primaryExpression312 = primaryExpression();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, primaryExpression312.Tree);

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:3360:4: functionExpression
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_functionExpression_in_memberExpression13597);
                        functionExpression313 = functionExpression();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, functionExpression313.Tree);

                    }
                    break;
                case 3 :
                    // AS3_ex.g3:3361:4: newExpression
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_newExpression_in_memberExpression13602);
                        newExpression314 = newExpression();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, newExpression314.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 129, memberExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "memberExpression"

    public class newExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "newExpression"
    // AS3_ex.g3:3364:1: newExpression : N= NEW primaryExpression ;
    public AS3_exParser.newExpression_return newExpression() // throws RecognitionException [1]
    {   
        AS3_exParser.newExpression_return retval = new AS3_exParser.newExpression_return();
        retval.Start = input.LT(1);
        int newExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken N = null;
        AS3_exParser.primaryExpression_return primaryExpression315 = null;


        object N_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 130) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3365:2: (N= NEW primaryExpression )
            // AS3_ex.g3:3365:4: N= NEW primaryExpression
            {
                root_0 = (object)adaptor.GetNilNode();

                N=(IToken)Match(input,NEW,FOLLOW_NEW_in_newExpression13615); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {N_tree = (object)adaptor.Create(N);
                    adaptor.AddChild(root_0, N_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(N);insertWS(1);
                }
                PushFollow(FOLLOW_primaryExpression_in_newExpression13620);
                primaryExpression315 = primaryExpression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, primaryExpression315.Tree);

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 130, newExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "newExpression"

    public class leftHandSideExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "leftHandSideExpression"
    // AS3_ex.g3:3369:1: leftHandSideExpression : memberExpression ( arguments | L= LBRACK expression R= RBRACK | E= XML_ELLIPSIS eitherIdentifier | D= DOT ( eitherIdentifier | parExpression ) | typePostfixSyntax | op= XML_NS_OP expression )* ;
    public AS3_exParser.leftHandSideExpression_return leftHandSideExpression() // throws RecognitionException [1]
    {   
        AS3_exParser.leftHandSideExpression_return retval = new AS3_exParser.leftHandSideExpression_return();
        retval.Start = input.LT(1);
        int leftHandSideExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        IToken R = null;
        IToken E = null;
        IToken D = null;
        IToken op = null;
        AS3_exParser.memberExpression_return memberExpression316 = null;

        AS3_exParser.arguments_return arguments317 = null;

        AS3_exParser.expression_return expression318 = null;

        AS3_exParser.eitherIdentifier_return eitherIdentifier319 = null;

        AS3_exParser.eitherIdentifier_return eitherIdentifier320 = null;

        AS3_exParser.parExpression_return parExpression321 = null;

        AS3_exParser.typePostfixSyntax_return typePostfixSyntax322 = null;

        AS3_exParser.expression_return expression323 = null;


        object L_tree=null;
        object R_tree=null;
        object E_tree=null;
        object D_tree=null;
        object op_tree=null;


            WrapOptions options=mPrinter.getExpressionWrapOptions();
            bool pushedWrapInfo=false;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 131) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3374:5: ( memberExpression ( arguments | L= LBRACK expression R= RBRACK | E= XML_ELLIPSIS eitherIdentifier | D= DOT ( eitherIdentifier | parExpression ) | typePostfixSyntax | op= XML_NS_OP expression )* )
            // AS3_ex.g3:3374:7: memberExpression ( arguments | L= LBRACK expression R= RBRACK | E= XML_ELLIPSIS eitherIdentifier | D= DOT ( eitherIdentifier | parExpression ) | typePostfixSyntax | op= XML_NS_OP expression )*
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  pushedWrapInfo=pushWrapInfo(options, true);
                }
                PushFollow(FOLLOW_memberExpression_in_leftHandSideExpression13646);
                memberExpression316 = memberExpression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, memberExpression316.Tree);
                // AS3_ex.g3:3376:5: ( arguments | L= LBRACK expression R= RBRACK | E= XML_ELLIPSIS eitherIdentifier | D= DOT ( eitherIdentifier | parExpression ) | typePostfixSyntax | op= XML_NS_OP expression )*
                do 
                {
                    int alt152 = 7;
                    alt152 = dfa152.Predict(input);
                    switch (alt152) 
                    {
                        case 1 :
                            // AS3_ex.g3:3377:7: arguments
                            {
                                PushFollow(FOLLOW_arguments_in_leftHandSideExpression13661);
                                arguments317 = arguments();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, arguments317.Tree);

                            }
                            break;
                        case 2 :
                            // AS3_ex.g3:3378:9: L= LBRACK expression R= RBRACK
                            {
                                L=(IToken)Match(input,LBRACK,FOLLOW_LBRACK_in_leftHandSideExpression13673); if (state.failed) return retval;
                                if ( state.backtracking == 0 )
                                {L_tree = (object)adaptor.Create(L);
                                    adaptor.AddChild(root_0, L_tree);
                                }
                                if ( state.backtracking == 0 ) 
                                {
                                  emit(L);insertWS(mPrinter.getAdvancedSpacesInsideArrayReferenceBrackets());
                                }
                                PushFollow(FOLLOW_expression_in_leftHandSideExpression13677);
                                expression318 = expression();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, expression318.Tree);
                                R=(IToken)Match(input,RBRACK,FOLLOW_RBRACK_in_leftHandSideExpression13681); if (state.failed) return retval;
                                if ( state.backtracking == 0 )
                                {R_tree = (object)adaptor.Create(R);
                                    adaptor.AddChild(root_0, R_tree);
                                }
                                if ( state.backtracking == 0 ) 
                                {
                                  insertWS(mPrinter.getAdvancedSpacesInsideArrayReferenceBrackets());emit(R);
                                }

                            }
                            break;
                        case 3 :
                            // AS3_ex.g3:3381:9: E= XML_ELLIPSIS eitherIdentifier
                            {
                                E=(IToken)Match(input,XML_ELLIPSIS,FOLLOW_XML_ELLIPSIS_in_leftHandSideExpression13697); if (state.failed) return retval;
                                if ( state.backtracking == 0 )
                                {E_tree = (object)adaptor.Create(E);
                                    adaptor.AddChild(root_0, E_tree);
                                }
                                if ( state.backtracking == 0 ) 
                                {
                                  wrapEmit(E, ASPrettyPrinter.Break_Other_Connectors_code);
                                }
                                PushFollow(FOLLOW_eitherIdentifier_in_leftHandSideExpression13700);
                                eitherIdentifier319 = eitherIdentifier();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, eitherIdentifier319.Tree);
                                if ( state.backtracking == 0 ) 
                                {
                                  popIndent();
                                }

                            }
                            break;
                        case 4 :
                            // AS3_ex.g3:3382:9: D= DOT ( eitherIdentifier | parExpression )
                            {
                                D=(IToken)Match(input,DOT,FOLLOW_DOT_in_leftHandSideExpression13714); if (state.failed) return retval;
                                if ( state.backtracking == 0 )
                                {D_tree = (object)adaptor.Create(D);
                                    adaptor.AddChild(root_0, D_tree);
                                }
                                // AS3_ex.g3:3382:15: ( eitherIdentifier | parExpression )
                                int alt151 = 2;
                                int LA151_0 = input.LA(1);

                                if ( ((LA151_0 >= AS && LA151_0 <= STATIC) || LA151_0 == STAR || LA151_0 == XML_AT || LA151_0 == IDENTIFIER) )
                                {
                                    alt151 = 1;
                                }
                                else if ( (LA151_0 == LPAREN) )
                                {
                                    alt151 = 2;
                                }
                                else 
                                {
                                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                                    NoViableAltException nvae_d151s0 =
                                        new NoViableAltException("", 151, 0, input);

                                    throw nvae_d151s0;
                                }
                                switch (alt151) 
                                {
                                    case 1 :
                                        // AS3_ex.g3:3382:16: eitherIdentifier
                                        {
                                            if ( state.backtracking == 0 ) 
                                            {
                                              wrapEmit(D, ASPrettyPrinter.Break_Function_Calls_code);
                                            }
                                            PushFollow(FOLLOW_eitherIdentifier_in_leftHandSideExpression13719);
                                            eitherIdentifier320 = eitherIdentifier();
                                            state.followingStackPointer--;
                                            if (state.failed) return retval;
                                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, eitherIdentifier320.Tree);

                                        }
                                        break;
                                    case 2 :
                                        // AS3_ex.g3:3382:94: parExpression
                                        {
                                            if ( state.backtracking == 0 ) 
                                            {
                                              wrapEmit(D, ASPrettyPrinter.Break_Other_Connectors_code);
                                            }
                                            PushFollow(FOLLOW_parExpression_in_leftHandSideExpression13725);
                                            parExpression321 = parExpression();
                                            state.followingStackPointer--;
                                            if (state.failed) return retval;
                                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, parExpression321.Tree);

                                        }
                                        break;

                                }

                                if ( state.backtracking == 0 ) 
                                {
                                  popIndent();
                                }

                            }
                            break;
                        case 5 :
                            // AS3_ex.g3:3383:9: typePostfixSyntax
                            {
                                PushFollow(FOLLOW_typePostfixSyntax_in_leftHandSideExpression13738);
                                typePostfixSyntax322 = typePostfixSyntax();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, typePostfixSyntax322.Tree);

                            }
                            break;
                        case 6 :
                            // AS3_ex.g3:3384:9: op= XML_NS_OP expression
                            {
                                op=(IToken)Match(input,XML_NS_OP,FOLLOW_XML_NS_OP_in_leftHandSideExpression13750); if (state.failed) return retval;
                                if ( state.backtracking == 0 )
                                {op_tree = (object)adaptor.Create(op);
                                    adaptor.AddChild(root_0, op_tree);
                                }
                                if ( state.backtracking == 0 ) 
                                {
                                  wrapEmit(op, ASPrettyPrinter.Break_Other_Connectors_code);
                                }
                                PushFollow(FOLLOW_expression_in_leftHandSideExpression13754);
                                expression323 = expression();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, expression323.Tree);
                                if ( state.backtracking == 0 ) 
                                {
                                  popIndent();
                                }

                            }
                            break;

                        default:
                            goto loop152;
                    }
                } while (true);

                loop152:
                    ;   // Stops C# compiler whining that label 'loop152' has no statements

                if ( state.backtracking == 0 ) 
                {
                  if (pushedWrapInfo) mPrinter.popWrapContext();
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 131, leftHandSideExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "leftHandSideExpression"

    public class eitherIdentifier_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "eitherIdentifier"
    // AS3_ex.g3:3389:1: eitherIdentifier : (I= IDENTIFIER | xmlPropertyIdentifier | allKeywords );
    public AS3_exParser.eitherIdentifier_return eitherIdentifier() // throws RecognitionException [1]
    {   
        AS3_exParser.eitherIdentifier_return retval = new AS3_exParser.eitherIdentifier_return();
        retval.Start = input.LT(1);
        int eitherIdentifier_StartIndex = input.Index();
        object root_0 = null;

        IToken I = null;
        AS3_exParser.xmlPropertyIdentifier_return xmlPropertyIdentifier324 = null;

        AS3_exParser.allKeywords_return allKeywords325 = null;


        object I_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 132) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3390:2: (I= IDENTIFIER | xmlPropertyIdentifier | allKeywords )
            int alt153 = 3;
            switch ( input.LA(1) ) 
            {
            case IDENTIFIER:
                {
                int LA153_1 = input.LA(2);

                if ( (synpred322_AS3_ex()) )
                {
                    alt153 = 1;
                }
                else if ( (synpred323_AS3_ex()) )
                {
                    alt153 = 2;
                }
                else 
                {
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    NoViableAltException nvae_d153s1 =
                        new NoViableAltException("", 153, 1, input);

                    throw nvae_d153s1;
                }
                }
                break;
            case STAR:
            case XML_AT:
                {
                alt153 = 2;
                }
                break;
            case AS:
            case BREAK:
            case CASE:
            case CATCH:
            case CLASS:
            case CONST:
            case CONTINUE:
            case DEFAULT:
            case DELETE:
            case DO:
            case ELSE:
            case EXTENDS:
            case FALSE:
            case FINALLY:
            case FOR:
            case FUNCTION:
            case IF:
            case IMPLEMENTS:
            case IMPORT:
            case IN:
            case INSTANCEOF:
            case INTERFACE:
            case INTERNAL:
            case IS:
            case NEW:
            case NULL:
            case PACKAGE:
            case PRIVATE:
            case PROTECTED:
            case PUBLIC:
            case RETURN:
            case SUPER:
            case SWITCH:
            case THIS:
            case THROW:
            case TRUE:
            case TRY:
            case TYPEOF:
            case USE:
            case VAR:
            case VOID:
            case WHILE:
            case WITH:
            case INCLUDE:
                {
                int LA153_3 = input.LA(2);

                if ( (synpred323_AS3_ex()) )
                {
                    alt153 = 2;
                }
                else if ( (true) )
                {
                    alt153 = 3;
                }
                else 
                {
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    NoViableAltException nvae_d153s3 =
                        new NoViableAltException("", 153, 3, input);

                    throw nvae_d153s3;
                }
                }
                break;
            case NATIVE:
            case TO:
            case EACH:
            case GET:
            case SET:
            case NAMESPACE:
            case DYNAMIC:
            case FINAL:
            case OVERRIDE:
            case STATIC:
                {
                int LA153_4 = input.LA(2);

                if ( (synpred323_AS3_ex()) )
                {
                    alt153 = 2;
                }
                else if ( (true) )
                {
                    alt153 = 3;
                }
                else 
                {
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    NoViableAltException nvae_d153s4 =
                        new NoViableAltException("", 153, 4, input);

                    throw nvae_d153s4;
                }
                }
                break;
                default:
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    NoViableAltException nvae_d153s0 =
                        new NoViableAltException("", 153, 0, input);

                    throw nvae_d153s0;
            }

            switch (alt153) 
            {
                case 1 :
                    // AS3_ex.g3:3390:4: I= IDENTIFIER
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        I=(IToken)Match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_eitherIdentifier13791); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {I_tree = (object)adaptor.Create(I);
                            adaptor.AddChild(root_0, I_tree);
                        }
                        if ( state.backtracking == 0 ) 
                        {
                          emit(I);
                        }

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:3391:5: xmlPropertyIdentifier
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_xmlPropertyIdentifier_in_eitherIdentifier13801);
                        xmlPropertyIdentifier324 = xmlPropertyIdentifier();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlPropertyIdentifier324.Tree);

                    }
                    break;
                case 3 :
                    // AS3_ex.g3:3392:5: allKeywords
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_allKeywords_in_eitherIdentifier13807);
                        allKeywords325 = allKeywords();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, allKeywords325.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 132, eitherIdentifier_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "eitherIdentifier"

    public class typeSpecifier_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "typeSpecifier"
    // AS3_ex.g3:3395:1: typeSpecifier : (I= IDENTIFIER | notQuiteReservedWord | I= INTERNAL | D= DEFAULT );
    public AS3_exParser.typeSpecifier_return typeSpecifier() // throws RecognitionException [1]
    {   
        AS3_exParser.typeSpecifier_return retval = new AS3_exParser.typeSpecifier_return();
        retval.Start = input.LT(1);
        int typeSpecifier_StartIndex = input.Index();
        object root_0 = null;

        IToken I = null;
        IToken D = null;
        AS3_exParser.notQuiteReservedWord_return notQuiteReservedWord326 = null;


        object I_tree=null;
        object D_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 133) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3395:14: (I= IDENTIFIER | notQuiteReservedWord | I= INTERNAL | D= DEFAULT )
            int alt154 = 4;
            switch ( input.LA(1) ) 
            {
            case IDENTIFIER:
                {
                alt154 = 1;
                }
                break;
            case NATIVE:
            case TO:
            case EACH:
            case GET:
            case SET:
            case NAMESPACE:
            case DYNAMIC:
            case FINAL:
            case OVERRIDE:
            case STATIC:
                {
                alt154 = 2;
                }
                break;
            case INTERNAL:
                {
                alt154 = 3;
                }
                break;
            case DEFAULT:
                {
                alt154 = 4;
                }
                break;
                default:
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    NoViableAltException nvae_d154s0 =
                        new NoViableAltException("", 154, 0, input);

                    throw nvae_d154s0;
            }

            switch (alt154) 
            {
                case 1 :
                    // AS3_ex.g3:3396:2: I= IDENTIFIER
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        I=(IToken)Match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_typeSpecifier13820); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {I_tree = (object)adaptor.Create(I);
                            adaptor.AddChild(root_0, I_tree);
                        }
                        if ( state.backtracking == 0 ) 
                        {
                          emit(I);
                        }

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:3396:29: notQuiteReservedWord
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_notQuiteReservedWord_in_typeSpecifier13826);
                        notQuiteReservedWord326 = notQuiteReservedWord();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, notQuiteReservedWord326.Tree);

                    }
                    break;
                case 3 :
                    // AS3_ex.g3:3396:52: I= INTERNAL
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        I=(IToken)Match(input,INTERNAL,FOLLOW_INTERNAL_in_typeSpecifier13832); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {I_tree = (object)adaptor.Create(I);
                            adaptor.AddChild(root_0, I_tree);
                        }
                        if ( state.backtracking == 0 ) 
                        {
                          emit(I);
                        }

                    }
                    break;
                case 4 :
                    // AS3_ex.g3:3396:77: D= DEFAULT
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        D=(IToken)Match(input,DEFAULT,FOLLOW_DEFAULT_in_typeSpecifier13840); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {D_tree = (object)adaptor.Create(D);
                            adaptor.AddChild(root_0, D_tree);
                        }
                        if ( state.backtracking == 0 ) 
                        {
                          emit(D);
                        }

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 133, typeSpecifier_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "typeSpecifier"

    public class notQuiteReservedWord_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "notQuiteReservedWord"
    // AS3_ex.g3:3399:1: notQuiteReservedWord : word= ( TO | NATIVE | EACH | GET | SET | NAMESPACE | DYNAMIC | FINAL | OVERRIDE | STATIC ) ;
    public AS3_exParser.notQuiteReservedWord_return notQuiteReservedWord() // throws RecognitionException [1]
    {   
        AS3_exParser.notQuiteReservedWord_return retval = new AS3_exParser.notQuiteReservedWord_return();
        retval.Start = input.LT(1);
        int notQuiteReservedWord_StartIndex = input.Index();
        object root_0 = null;

        IToken word = null;

        object word_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 134) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3400:2: (word= ( TO | NATIVE | EACH | GET | SET | NAMESPACE | DYNAMIC | FINAL | OVERRIDE | STATIC ) )
            // AS3_ex.g3:3401:2: word= ( TO | NATIVE | EACH | GET | SET | NAMESPACE | DYNAMIC | FINAL | OVERRIDE | STATIC )
            {
                root_0 = (object)adaptor.GetNilNode();

                word = (IToken)input.LT(1);
                if ( input.LA(1) == NATIVE || input.LA(1) == TO || (input.LA(1) >= EACH && input.LA(1) <= NAMESPACE) || (input.LA(1) >= DYNAMIC && input.LA(1) <= STATIC) ) 
                {
                    input.Consume();
                    if ( state.backtracking == 0 ) adaptor.AddChild(root_0, (object)adaptor.Create(word));
                    state.errorRecovery = false;state.failed = false;
                }
                else 
                {
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    MismatchedSetException mse = new MismatchedSetException(null,input);
                    throw mse;
                }

                if ( state.backtracking == 0 ) 
                {
                  emit(word);
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 134, notQuiteReservedWord_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "notQuiteReservedWord"

    public class allKeywords_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "allKeywords"
    // AS3_ex.g3:3404:1: allKeywords : ( reservedWord | notQuiteReservedWord ) ;
    public AS3_exParser.allKeywords_return allKeywords() // throws RecognitionException [1]
    {   
        AS3_exParser.allKeywords_return retval = new AS3_exParser.allKeywords_return();
        retval.Start = input.LT(1);
        int allKeywords_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.reservedWord_return reservedWord327 = null;

        AS3_exParser.notQuiteReservedWord_return notQuiteReservedWord328 = null;



        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 135) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3405:2: ( ( reservedWord | notQuiteReservedWord ) )
            // AS3_ex.g3:3405:4: ( reservedWord | notQuiteReservedWord )
            {
                root_0 = (object)adaptor.GetNilNode();

                // AS3_ex.g3:3405:4: ( reservedWord | notQuiteReservedWord )
                int alt155 = 2;
                int LA155_0 = input.LA(1);

                if ( ((LA155_0 >= AS && LA155_0 <= IS) || (LA155_0 >= NEW && LA155_0 <= THROW) || (LA155_0 >= TRUE && LA155_0 <= WITH) || LA155_0 == INCLUDE) )
                {
                    alt155 = 1;
                }
                else if ( (LA155_0 == NATIVE || LA155_0 == TO || (LA155_0 >= EACH && LA155_0 <= NAMESPACE) || (LA155_0 >= DYNAMIC && LA155_0 <= STATIC)) )
                {
                    alt155 = 2;
                }
                else 
                {
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    NoViableAltException nvae_d155s0 =
                        new NoViableAltException("", 155, 0, input);

                    throw nvae_d155s0;
                }
                switch (alt155) 
                {
                    case 1 :
                        // AS3_ex.g3:3405:5: reservedWord
                        {
                            PushFollow(FOLLOW_reservedWord_in_allKeywords13911);
                            reservedWord327 = reservedWord();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, reservedWord327.Tree);

                        }
                        break;
                    case 2 :
                        // AS3_ex.g3:3405:20: notQuiteReservedWord
                        {
                            PushFollow(FOLLOW_notQuiteReservedWord_in_allKeywords13915);
                            notQuiteReservedWord328 = notQuiteReservedWord();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, notQuiteReservedWord328.Tree);

                        }
                        break;

                }


            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 135, allKeywords_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "allKeywords"

    public class reservedWord_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "reservedWord"
    // AS3_ex.g3:3407:1: reservedWord : word= ( AS | BREAK | CASE | CATCH | CLASS | CONST | CONTINUE | DEFAULT | DELETE | DO | ELSE | EXTENDS | FALSE | FINALLY | FOR | FUNCTION | IF | IMPLEMENTS | IMPORT | IN | INSTANCEOF | INTERFACE | INTERNAL | IS | NEW | NULL | PACKAGE | PRIVATE | PROTECTED | PUBLIC | RETURN | SUPER | SWITCH | THIS | THROW | TRUE | TRY | TYPEOF | USE | VAR | VOID | WHILE | WITH | INCLUDE ) ;
    public AS3_exParser.reservedWord_return reservedWord() // throws RecognitionException [1]
    {   
        AS3_exParser.reservedWord_return retval = new AS3_exParser.reservedWord_return();
        retval.Start = input.LT(1);
        int reservedWord_StartIndex = input.Index();
        object root_0 = null;

        IToken word = null;

        object word_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 136) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3408:2: (word= ( AS | BREAK | CASE | CATCH | CLASS | CONST | CONTINUE | DEFAULT | DELETE | DO | ELSE | EXTENDS | FALSE | FINALLY | FOR | FUNCTION | IF | IMPLEMENTS | IMPORT | IN | INSTANCEOF | INTERFACE | INTERNAL | IS | NEW | NULL | PACKAGE | PRIVATE | PROTECTED | PUBLIC | RETURN | SUPER | SWITCH | THIS | THROW | TRUE | TRY | TYPEOF | USE | VAR | VOID | WHILE | WITH | INCLUDE ) )
            // AS3_ex.g3:3409:5: word= ( AS | BREAK | CASE | CATCH | CLASS | CONST | CONTINUE | DEFAULT | DELETE | DO | ELSE | EXTENDS | FALSE | FINALLY | FOR | FUNCTION | IF | IMPLEMENTS | IMPORT | IN | INSTANCEOF | INTERFACE | INTERNAL | IS | NEW | NULL | PACKAGE | PRIVATE | PROTECTED | PUBLIC | RETURN | SUPER | SWITCH | THIS | THROW | TRUE | TRY | TYPEOF | USE | VAR | VOID | WHILE | WITH | INCLUDE )
            {
                root_0 = (object)adaptor.GetNilNode();

                word = (IToken)input.LT(1);
                if ( (input.LA(1) >= AS && input.LA(1) <= IS) || (input.LA(1) >= NEW && input.LA(1) <= THROW) || (input.LA(1) >= TRUE && input.LA(1) <= WITH) || input.LA(1) == INCLUDE ) 
                {
                    input.Consume();
                    if ( state.backtracking == 0 ) adaptor.AddChild(root_0, (object)adaptor.Create(word));
                    state.errorRecovery = false;state.failed = false;
                }
                else 
                {
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    MismatchedSetException mse = new MismatchedSetException(null,input);
                    throw mse;
                }

                if ( state.backtracking == 0 ) 
                {
                  emit(word);
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 136, reservedWord_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "reservedWord"

    public class arguments_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "arguments"
    // AS3_ex.g3:3466:1: arguments : L= LPAREN ( assignmentExpression (C= COMMA assignmentExpression )* )? R= RPAREN ;
    public AS3_exParser.arguments_return arguments() // throws RecognitionException [1]
    {   
        AS3_exParser.arguments_return retval = new AS3_exParser.arguments_return();
        retval.Start = input.LT(1);
        int arguments_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        IToken C = null;
        IToken R = null;
        AS3_exParser.assignmentExpression_return assignmentExpression329 = null;

        AS3_exParser.assignmentExpression_return assignmentExpression330 = null;


        object L_tree=null;
        object C_tree=null;
        object R_tree=null;


            WrapOptions options=mPrinter.getMethodCallWrapOptions();
            bool pushedFormat=false;
            bool pushedIndent=false;
            bool pushedWrapInfo=false;
            int firstArgPos=0;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 137) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3475:2: (L= LPAREN ( assignmentExpression (C= COMMA assignmentExpression )* )? R= RPAREN )
            // AS3_ex.g3:3476:4: L= LPAREN ( assignmentExpression (C= COMMA assignmentExpression )* )? R= RPAREN
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  pushedFormat=pushFormatType(options, true);
                       pushedWrapInfo=pushWrapInfo(options, true);
                      
                }
                L=(IToken)Match(input,LPAREN,FOLLOW_LPAREN_in_arguments14494); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {L_tree = (object)adaptor.Create(L);
                    adaptor.AddChild(root_0, L_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  {insertWS(mPrinter.getSpacesBeforeArguments());} emit(L);insertWS(mPrinter.getAdvancedSpacesInsideParensInArgumentLists());
                }
                // AS3_ex.g3:3480:4: ( assignmentExpression (C= COMMA assignmentExpression )* )?
                int alt157 = 2;
                int LA157_0 = input.LA(1);

                if ( ((LA157_0 >= AS && LA157_0 <= STATIC) || LA157_0 == LCURLY || LA157_0 == LPAREN || LA157_0 == LBRACK || LA157_0 == LT || (LA157_0 >= PLUS && LA157_0 <= STAR) || (LA157_0 >= INC && LA157_0 <= DEC) || (LA157_0 >= NOT && LA157_0 <= INV) || (LA157_0 >= XML_AT && LA157_0 <= XML_LS_STD) || (LA157_0 >= SINGLE_QUOTE_LITERAL && LA157_0 <= DOUBLE_QUOTE_LITERAL) || LA157_0 == REGULAR_EXPR_LITERAL || LA157_0 == HEX_NUMBER_LITERAL || LA157_0 == DEC_NUMBER_LITERAL || LA157_0 == IDENTIFIER || (LA157_0 >= XML_COMMENT && LA157_0 <= XML_PI)) )
                {
                    alt157 = 1;
                }
                switch (alt157) 
                {
                    case 1 :
                        // AS3_ex.g3:3480:6: assignmentExpression (C= COMMA assignmentExpression )*
                        {
                            if ( state.backtracking == 0 ) 
                            {
                              pushedIndent=pushLazyParmIndent(pushedIndent, options.getIndentStyle());
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              mPrinter.captureNextTextPosition();
                            }
                            PushFollow(FOLLOW_assignmentExpression_in_arguments14507);
                            assignmentExpression329 = assignmentExpression();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, assignmentExpression329.Tree);
                            if ( state.backtracking == 0 ) 
                            {
                              firstArgPos=mPrinter.getLastCapturePosition();
                            }
                            // AS3_ex.g3:3481:10: (C= COMMA assignmentExpression )*
                            do 
                            {
                                int alt156 = 2;
                                int LA156_0 = input.LA(1);

                                if ( (LA156_0 == COMMA) )
                                {
                                    alt156 = 1;
                                }


                                switch (alt156) 
                                {
                                    case 1 :
                                        // AS3_ex.g3:3482:11: C= COMMA assignmentExpression
                                        {
                                            C=(IToken)Match(input,COMMA,FOLLOW_COMMA_in_arguments14537); if (state.failed) return retval;
                                            if ( state.backtracking == 0 )
                                            {C_tree = (object)adaptor.Create(C);
                                                adaptor.AddChild(root_0, C_tree);
                                            }
                                            if ( state.backtracking == 0 ) 
                                            {
                                              pushedIndent=emitCommaWithSpacingAndCRs(options, C, pushedIndent, firstArgPos, ASPrettyPrinter.Break_SubType_Arguments);
                                            }
                                            PushFollow(FOLLOW_assignmentExpression_in_arguments14562);
                                            assignmentExpression330 = assignmentExpression();
                                            state.followingStackPointer--;
                                            if (state.failed) return retval;
                                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, assignmentExpression330.Tree);

                                        }
                                        break;

                                    default:
                                        goto loop156;
                                }
                            } while (true);

                            loop156:
                                ;   // Stops C# compiler whining that label 'loop156' has no statements


                        }
                        break;

                }

                R=(IToken)Match(input,RPAREN,FOLLOW_RPAREN_in_arguments14588); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {R_tree = (object)adaptor.Create(R);
                    adaptor.AddChild(root_0, R_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  insertWS(mPrinter.getAdvancedSpacesInsideParensInArgumentLists());emit(R);
                }
                if ( state.backtracking == 0 ) 
                {

                          if (pushedIndent)
                                popIndent();
                            if (pushedFormat)
                            {
                                mPrinter.popFormatMode();
                            }
                            if (pushedWrapInfo)
                                mPrinter.popWrapContext();
                        
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 137, arguments_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "arguments"

    public class suffix_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "suffix"
    // AS3_ex.g3:3501:1: suffix : ( indexSuffix | propertyReferenceSuffix );
    public AS3_exParser.suffix_return suffix() // throws RecognitionException [1]
    {   
        AS3_exParser.suffix_return retval = new AS3_exParser.suffix_return();
        retval.Start = input.LT(1);
        int suffix_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.indexSuffix_return indexSuffix331 = null;

        AS3_exParser.propertyReferenceSuffix_return propertyReferenceSuffix332 = null;



        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 138) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3502:5: ( indexSuffix | propertyReferenceSuffix )
            int alt158 = 2;
            int LA158_0 = input.LA(1);

            if ( (LA158_0 == LBRACK) )
            {
                alt158 = 1;
            }
            else if ( (LA158_0 == DOT) )
            {
                alt158 = 2;
            }
            else 
            {
                if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                NoViableAltException nvae_d158s0 =
                    new NoViableAltException("", 158, 0, input);

                throw nvae_d158s0;
            }
            switch (alt158) 
            {
                case 1 :
                    // AS3_ex.g3:3502:10: indexSuffix
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_indexSuffix_in_suffix14618);
                        indexSuffix331 = indexSuffix();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, indexSuffix331.Tree);

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:3502:24: propertyReferenceSuffix
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_propertyReferenceSuffix_in_suffix14622);
                        propertyReferenceSuffix332 = propertyReferenceSuffix();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, propertyReferenceSuffix332.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 138, suffix_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "suffix"

    public class indexSuffix_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "indexSuffix"
    // AS3_ex.g3:3505:1: indexSuffix : L= LBRACK expression R= RBRACK ;
    public AS3_exParser.indexSuffix_return indexSuffix() // throws RecognitionException [1]
    {   
        AS3_exParser.indexSuffix_return retval = new AS3_exParser.indexSuffix_return();
        retval.Start = input.LT(1);
        int indexSuffix_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        IToken R = null;
        AS3_exParser.expression_return expression333 = null;


        object L_tree=null;
        object R_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 139) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3506:5: (L= LBRACK expression R= RBRACK )
            // AS3_ex.g3:3506:10: L= LBRACK expression R= RBRACK
            {
                root_0 = (object)adaptor.GetNilNode();

                L=(IToken)Match(input,LBRACK,FOLLOW_LBRACK_in_indexSuffix14663); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {L_tree = (object)adaptor.Create(L);
                    adaptor.AddChild(root_0, L_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(L);insertWS(mPrinter.getAdvancedSpacesInsideArrayReferenceBrackets());
                }
                PushFollow(FOLLOW_expression_in_indexSuffix14668);
                expression333 = expression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, expression333.Tree);
                R=(IToken)Match(input,RBRACK,FOLLOW_RBRACK_in_indexSuffix14673); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {R_tree = (object)adaptor.Create(R);
                    adaptor.AddChild(root_0, R_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  insertWS(mPrinter.getAdvancedSpacesInsideArrayReferenceBrackets());emit(R);
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 139, indexSuffix_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "indexSuffix"

    public class propertyReferenceSuffix_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "propertyReferenceSuffix"
    // AS3_ex.g3:3509:1: propertyReferenceSuffix : (D= DOT I= IDENTIFIER | D= DOT xmlPropertyIdentifier | D= DOT );
    public AS3_exParser.propertyReferenceSuffix_return propertyReferenceSuffix() // throws RecognitionException [1]
    {   
        AS3_exParser.propertyReferenceSuffix_return retval = new AS3_exParser.propertyReferenceSuffix_return();
        retval.Start = input.LT(1);
        int propertyReferenceSuffix_StartIndex = input.Index();
        object root_0 = null;

        IToken D = null;
        IToken I = null;
        AS3_exParser.xmlPropertyIdentifier_return xmlPropertyIdentifier334 = null;


        object D_tree=null;
        object I_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 140) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3510:5: (D= DOT I= IDENTIFIER | D= DOT xmlPropertyIdentifier | D= DOT )
            int alt159 = 3;
            int LA159_0 = input.LA(1);

            if ( (LA159_0 == DOT) )
            {
                switch ( input.LA(2) ) 
                {
                case EOF:
                    {
                    alt159 = 3;
                    }
                    break;
                case AS:
                case BREAK:
                case CASE:
                case CATCH:
                case CLASS:
                case CONST:
                case CONTINUE:
                case DEFAULT:
                case DELETE:
                case DO:
                case ELSE:
                case EXTENDS:
                case FALSE:
                case FINALLY:
                case FOR:
                case FUNCTION:
                case IF:
                case IMPLEMENTS:
                case IMPORT:
                case IN:
                case INSTANCEOF:
                case INTERFACE:
                case INTERNAL:
                case IS:
                case NATIVE:
                case NEW:
                case NULL:
                case PACKAGE:
                case PRIVATE:
                case PROTECTED:
                case PUBLIC:
                case RETURN:
                case SUPER:
                case SWITCH:
                case THIS:
                case THROW:
                case TO:
                case TRUE:
                case TRY:
                case TYPEOF:
                case USE:
                case VAR:
                case VOID:
                case WHILE:
                case WITH:
                case EACH:
                case GET:
                case SET:
                case NAMESPACE:
                case INCLUDE:
                case DYNAMIC:
                case FINAL:
                case OVERRIDE:
                case STATIC:
                case STAR:
                case XML_AT:
                    {
                    alt159 = 2;
                    }
                    break;
                case IDENTIFIER:
                    {
                    int LA159_4 = input.LA(3);

                    if ( (LA159_4 == EOF) )
                    {
                        alt159 = 1;
                    }
                    else if ( (LA159_4 == DOT || LA159_4 == SUB || LA159_4 == COLON || LA159_4 == XML_NS_OP) )
                    {
                        alt159 = 2;
                    }
                    else 
                    {
                        if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                        NoViableAltException nvae_d159s4 =
                            new NoViableAltException("", 159, 4, input);

                        throw nvae_d159s4;
                    }
                    }
                    break;
                    default:
                        if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                        NoViableAltException nvae_d159s1 =
                            new NoViableAltException("", 159, 1, input);

                        throw nvae_d159s1;
                }

            }
            else 
            {
                if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                NoViableAltException nvae_d159s0 =
                    new NoViableAltException("", 159, 0, input);

                throw nvae_d159s0;
            }
            switch (alt159) 
            {
                case 1 :
                    // AS3_ex.g3:3510:10: D= DOT I= IDENTIFIER
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        D=(IToken)Match(input,DOT,FOLLOW_DOT_in_propertyReferenceSuffix14701); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {D_tree = (object)adaptor.Create(D);
                            adaptor.AddChild(root_0, D_tree);
                        }
                        if ( state.backtracking == 0 ) 
                        {
                          wrapEmit(D, ASPrettyPrinter.Break_Other_Connectors_code);
                        }
                        I=(IToken)Match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_propertyReferenceSuffix14708); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {I_tree = (object)adaptor.Create(I);
                            adaptor.AddChild(root_0, I_tree);
                        }
                        if ( state.backtracking == 0 ) 
                        {
                          emit(I);
                        }
                        if ( state.backtracking == 0 ) 
                        {
                          popIndent();
                        }

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:3511:10: D= DOT xmlPropertyIdentifier
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        D=(IToken)Match(input,DOT,FOLLOW_DOT_in_propertyReferenceSuffix14725); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {D_tree = (object)adaptor.Create(D);
                            adaptor.AddChild(root_0, D_tree);
                        }
                        if ( state.backtracking == 0 ) 
                        {
                          wrapEmit(D, ASPrettyPrinter.Break_Other_Connectors_code);
                        }
                        PushFollow(FOLLOW_xmlPropertyIdentifier_in_propertyReferenceSuffix14730);
                        xmlPropertyIdentifier334 = xmlPropertyIdentifier();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlPropertyIdentifier334.Tree);
                        if ( state.backtracking == 0 ) 
                        {
                          popIndent();
                        }

                    }
                    break;
                case 3 :
                    // AS3_ex.g3:3512:10: D= DOT
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        D=(IToken)Match(input,DOT,FOLLOW_DOT_in_propertyReferenceSuffix14745); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {D_tree = (object)adaptor.Create(D);
                            adaptor.AddChild(root_0, D_tree);
                        }
                        if ( state.backtracking == 0 ) 
                        {
                          wrapEmit(D, ASPrettyPrinter.Break_Other_Connectors_code);
                        }
                        if ( state.backtracking == 0 ) 
                        {
                          popIndent();
                        }

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 140, propertyReferenceSuffix_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "propertyReferenceSuffix"

    public class primaryExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "primaryExpression"
    // AS3_ex.g3:3516:1: primaryExpression : primaryExpressionHelper ;
    public AS3_exParser.primaryExpression_return primaryExpression() // throws RecognitionException [1]
    {   
        AS3_exParser.primaryExpression_return retval = new AS3_exParser.primaryExpression_return();
        retval.Start = input.LT(1);
        int primaryExpression_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.primaryExpressionHelper_return primaryExpressionHelper335 = null;



        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 141) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3517:5: ( primaryExpressionHelper )
            // AS3_ex.g3:3517:10: primaryExpressionHelper
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_primaryExpressionHelper_in_primaryExpression14775);
                primaryExpressionHelper335 = primaryExpressionHelper();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, primaryExpressionHelper335.Tree);

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 141, primaryExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "primaryExpression"

    public class primaryExpressionHelper_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "primaryExpressionHelper"
    // AS3_ex.g3:3521:1: primaryExpressionHelper : (T= THIS | S= SUPER | literal | arrayLiteral | objectLiteral | ( identifierLiteral x= XML_NS_OP )? identifierLiteral | xmlPrimaryExpression | parExpression | l= LT type g= GT ( arrayLiteral )? );
    public AS3_exParser.primaryExpressionHelper_return primaryExpressionHelper() // throws RecognitionException [1]
    {   
        AS3_exParser.primaryExpressionHelper_return retval = new AS3_exParser.primaryExpressionHelper_return();
        retval.Start = input.LT(1);
        int primaryExpressionHelper_StartIndex = input.Index();
        object root_0 = null;

        IToken T = null;
        IToken S = null;
        IToken x = null;
        IToken l = null;
        IToken g = null;
        AS3_exParser.literal_return literal336 = null;

        AS3_exParser.arrayLiteral_return arrayLiteral337 = null;

        AS3_exParser.objectLiteral_return objectLiteral338 = null;

        AS3_exParser.identifierLiteral_return identifierLiteral339 = null;

        AS3_exParser.identifierLiteral_return identifierLiteral340 = null;

        AS3_exParser.xmlPrimaryExpression_return xmlPrimaryExpression341 = null;

        AS3_exParser.parExpression_return parExpression342 = null;

        AS3_exParser.type_return type343 = null;

        AS3_exParser.arrayLiteral_return arrayLiteral344 = null;


        object T_tree=null;
        object S_tree=null;
        object x_tree=null;
        object l_tree=null;
        object g_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 142) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3522:5: (T= THIS | S= SUPER | literal | arrayLiteral | objectLiteral | ( identifierLiteral x= XML_NS_OP )? identifierLiteral | xmlPrimaryExpression | parExpression | l= LT type g= GT ( arrayLiteral )? )
            int alt162 = 9;
            alt162 = dfa162.Predict(input);
            switch (alt162) 
            {
                case 1 :
                    // AS3_ex.g3:3522:9: T= THIS
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        T=(IToken)Match(input,THIS,FOLLOW_THIS_in_primaryExpressionHelper14802); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {T_tree = (object)adaptor.Create(T);
                            adaptor.AddChild(root_0, T_tree);
                        }
                        if ( state.backtracking == 0 ) 
                        {
                          emit(T);
                        }

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:3523:9: S= SUPER
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        S=(IToken)Match(input,SUPER,FOLLOW_SUPER_in_primaryExpressionHelper14816); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {S_tree = (object)adaptor.Create(S);
                            adaptor.AddChild(root_0, S_tree);
                        }
                        if ( state.backtracking == 0 ) 
                        {
                          emit(S);
                        }

                    }
                    break;
                case 3 :
                    // AS3_ex.g3:3524:9: literal
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_literal_in_primaryExpressionHelper14828);
                        literal336 = literal();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, literal336.Tree);

                    }
                    break;
                case 4 :
                    // AS3_ex.g3:3525:9: arrayLiteral
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_arrayLiteral_in_primaryExpressionHelper14840);
                        arrayLiteral337 = arrayLiteral();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, arrayLiteral337.Tree);

                    }
                    break;
                case 5 :
                    // AS3_ex.g3:3526:9: objectLiteral
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_objectLiteral_in_primaryExpressionHelper14851);
                        objectLiteral338 = objectLiteral();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, objectLiteral338.Tree);

                    }
                    break;
                case 6 :
                    // AS3_ex.g3:3527:9: ( identifierLiteral x= XML_NS_OP )? identifierLiteral
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        // AS3_ex.g3:3527:9: ( identifierLiteral x= XML_NS_OP )?
                        int alt160 = 2;
                        int LA160_0 = input.LA(1);

                        if ( (LA160_0 == IDENTIFIER) )
                        {
                            int LA160_1 = input.LA(2);

                            if ( (LA160_1 == XML_NS_OP) )
                            {
                                int LA160_3 = input.LA(3);

                                if ( (synpred390_AS3_ex()) )
                                {
                                    alt160 = 1;
                                }
                            }
                        }
                        else if ( (LA160_0 == NATIVE || LA160_0 == TO || (LA160_0 >= EACH && LA160_0 <= NAMESPACE) || (LA160_0 >= DYNAMIC && LA160_0 <= STATIC)) )
                        {
                            int LA160_2 = input.LA(2);

                            if ( (LA160_2 == XML_NS_OP) )
                            {
                                int LA160_3 = input.LA(3);

                                if ( (synpred390_AS3_ex()) )
                                {
                                    alt160 = 1;
                                }
                            }
                        }
                        switch (alt160) 
                        {
                            case 1 :
                                // AS3_ex.g3:3527:10: identifierLiteral x= XML_NS_OP
                                {
                                    PushFollow(FOLLOW_identifierLiteral_in_primaryExpressionHelper14864);
                                    identifierLiteral339 = identifierLiteral();
                                    state.followingStackPointer--;
                                    if (state.failed) return retval;
                                    if ( state.backtracking == 0 ) adaptor.AddChild(root_0, identifierLiteral339.Tree);
                                    x=(IToken)Match(input,XML_NS_OP,FOLLOW_XML_NS_OP_in_primaryExpressionHelper14868); if (state.failed) return retval;
                                    if ( state.backtracking == 0 )
                                    {x_tree = (object)adaptor.Create(x);
                                        adaptor.AddChild(root_0, x_tree);
                                    }
                                    if ( state.backtracking == 0 ) 
                                    {
                                      emit(x);
                                    }

                                }
                                break;

                        }

                        PushFollow(FOLLOW_identifierLiteral_in_primaryExpressionHelper14874);
                        identifierLiteral340 = identifierLiteral();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, identifierLiteral340.Tree);

                    }
                    break;
                case 7 :
                    // AS3_ex.g3:3528:9: xmlPrimaryExpression
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_xmlPrimaryExpression_in_primaryExpressionHelper14885);
                        xmlPrimaryExpression341 = xmlPrimaryExpression();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, xmlPrimaryExpression341.Tree);

                    }
                    break;
                case 8 :
                    // AS3_ex.g3:3529:9: parExpression
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_parExpression_in_primaryExpressionHelper14895);
                        parExpression342 = parExpression();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, parExpression342.Tree);

                    }
                    break;
                case 9 :
                    // AS3_ex.g3:3530:9: l= LT type g= GT ( arrayLiteral )?
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        l=(IToken)Match(input,LT,FOLLOW_LT_in_primaryExpressionHelper14908); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {l_tree = (object)adaptor.Create(l);
                            adaptor.AddChild(root_0, l_tree);
                        }
                        if ( state.backtracking == 0 ) 
                        {
                          emit(l);
                        }
                        PushFollow(FOLLOW_type_in_primaryExpressionHelper14912);
                        type343 = type();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, type343.Tree);
                        g=(IToken)Match(input,GT,FOLLOW_GT_in_primaryExpressionHelper14916); if (state.failed) return retval;
                        if ( state.backtracking == 0 )
                        {g_tree = (object)adaptor.Create(g);
                            adaptor.AddChild(root_0, g_tree);
                        }
                        if ( state.backtracking == 0 ) 
                        {
                          emit(g);
                        }
                        // AS3_ex.g3:3530:48: ( arrayLiteral )?
                        int alt161 = 2;
                        alt161 = dfa161.Predict(input);
                        switch (alt161) 
                        {
                            case 1 :
                                // AS3_ex.g3:3530:49: arrayLiteral
                                {
                                    PushFollow(FOLLOW_arrayLiteral_in_primaryExpressionHelper14921);
                                    arrayLiteral344 = arrayLiteral();
                                    state.followingStackPointer--;
                                    if (state.failed) return retval;
                                    if ( state.backtracking == 0 ) adaptor.AddChild(root_0, arrayLiteral344.Tree);

                                }
                                break;

                        }


                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 142, primaryExpressionHelper_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "primaryExpressionHelper"

    public class objectLiteral_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "objectLiteral"
    // AS3_ex.g3:3534:1: objectLiteral : L= LCURLY ( propertyNameAndValueList )? R= RCURLY ;
    public AS3_exParser.objectLiteral_return objectLiteral() // throws RecognitionException [1]
    {   
        AS3_exParser.objectLiteral_return retval = new AS3_exParser.objectLiteral_return();
        retval.Start = input.LT(1);
        int objectLiteral_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        IToken R = null;
        AS3_exParser.propertyNameAndValueList_return propertyNameAndValueList345 = null;


        object L_tree=null;
        object R_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 143) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3535:5: (L= LCURLY ( propertyNameAndValueList )? R= RCURLY )
            // AS3_ex.g3:3535:9: L= LCURLY ( propertyNameAndValueList )? R= RCURLY
            {
                root_0 = (object)adaptor.GetNilNode();

                L=(IToken)Match(input,LCURLY,FOLLOW_LCURLY_in_objectLiteral14946); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {L_tree = (object)adaptor.Create(L);
                    adaptor.AddChild(root_0, L_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(L);insertWS(mPrinter.getAdvancedSpacesInsideObjectBraces());
                      pushIndent(true);
                      
                }
                // AS3_ex.g3:3537:7: ( propertyNameAndValueList )?
                int alt163 = 2;
                int LA163_0 = input.LA(1);

                if ( (LA163_0 == NATIVE || LA163_0 == TO || (LA163_0 >= EACH && LA163_0 <= NAMESPACE) || (LA163_0 >= DYNAMIC && LA163_0 <= STATIC) || (LA163_0 >= SINGLE_QUOTE_LITERAL && LA163_0 <= DOUBLE_QUOTE_LITERAL) || LA163_0 == HEX_NUMBER_LITERAL || LA163_0 == DEC_NUMBER_LITERAL || LA163_0 == IDENTIFIER) )
                {
                    alt163 = 1;
                }
                switch (alt163) 
                {
                    case 1 :
                        // AS3_ex.g3:0:0: propertyNameAndValueList
                        {
                            PushFollow(FOLLOW_propertyNameAndValueList_in_objectLiteral14950);
                            propertyNameAndValueList345 = propertyNameAndValueList();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, propertyNameAndValueList345.Tree);

                        }
                        break;

                }

                R=(IToken)Match(input,RCURLY,FOLLOW_RCURLY_in_objectLiteral14955); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {R_tree = (object)adaptor.Create(R);
                    adaptor.AddChild(root_0, R_tree);
                }
                if ( state.backtracking == 0 ) 
                {

                      popIndent();
                      insertWS(mPrinter.getAdvancedSpacesInsideObjectBraces());emit(R);
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 143, objectLiteral_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "objectLiteral"

    public class propertyNameAndValueList_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "propertyNameAndValueList"
    // AS3_ex.g3:3542:1: propertyNameAndValueList : propertyNameAndValue (C= COMMA propertyNameAndValue )* ;
    public AS3_exParser.propertyNameAndValueList_return propertyNameAndValueList() // throws RecognitionException [1]
    {   
        AS3_exParser.propertyNameAndValueList_return retval = new AS3_exParser.propertyNameAndValueList_return();
        retval.Start = input.LT(1);
        int propertyNameAndValueList_StartIndex = input.Index();
        object root_0 = null;

        IToken C = null;
        AS3_exParser.propertyNameAndValue_return propertyNameAndValue346 = null;

        AS3_exParser.propertyNameAndValue_return propertyNameAndValue347 = null;


        object C_tree=null;


            WrapOptions options=mPrinter.getArrayInitWrapOptions();
            bool pushedFormat=false;
            bool pushedIndent=true; //so that we won't push another indent
            bool pushedWrapInfo=false;
            int firstItem=(-1);

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 144) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3551:5: ( propertyNameAndValue (C= COMMA propertyNameAndValue )* )
            // AS3_ex.g3:3552:4: propertyNameAndValue (C= COMMA propertyNameAndValue )*
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  pushedFormat=pushFormatType(options, true);
                       pushedWrapInfo=pushWrapInfo(options, true);
                      
                }
                if ( state.backtracking == 0 ) 
                {
                  mPrinter.captureNextTextPosition();
                }
                PushFollow(FOLLOW_propertyNameAndValue_in_propertyNameAndValueList14998);
                propertyNameAndValue346 = propertyNameAndValue();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, propertyNameAndValue346.Tree);
                if ( state.backtracking == 0 ) 
                {
                  firstItem=mPrinter.getLastCapturePosition();
                }
                // AS3_ex.g3:3558:10: (C= COMMA propertyNameAndValue )*
                do 
                {
                    int alt164 = 2;
                    int LA164_0 = input.LA(1);

                    if ( (LA164_0 == COMMA) )
                    {
                        alt164 = 1;
                    }


                    switch (alt164) 
                    {
                        case 1 :
                            // AS3_ex.g3:3558:11: C= COMMA propertyNameAndValue
                            {
                                C=(IToken)Match(input,COMMA,FOLLOW_COMMA_in_propertyNameAndValueList15022); if (state.failed) return retval;
                                if ( state.backtracking == 0 )
                                {C_tree = (object)adaptor.Create(C);
                                    adaptor.AddChild(root_0, C_tree);
                                }
                                if ( state.backtracking == 0 ) 
                                {
                                  pushedIndent=emitCommaWithSpacingAndCRs(options, C, pushedIndent, firstItem, ASPrettyPrinter.Break_SubType_Object);
                                }
                                PushFollow(FOLLOW_propertyNameAndValue_in_propertyNameAndValueList15026);
                                propertyNameAndValue347 = propertyNameAndValue();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, propertyNameAndValue347.Tree);

                            }
                            break;

                        default:
                            goto loop164;
                    }
                } while (true);

                loop164:
                    ;   // Stops C# compiler whining that label 'loop164' has no statements

                if ( state.backtracking == 0 ) 
                {

                  //        if (pushedIndent)
                  //            popIndent();
                            if (pushedFormat)
                            {
                                mPrinter.popFormatMode();
                            }
                            if (pushedWrapInfo)
                                mPrinter.popWrapContext();
                        
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 144, propertyNameAndValueList_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "propertyNameAndValueList"

    public class propertyNameAndValue_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "propertyNameAndValue"
    // AS3_ex.g3:3571:1: propertyNameAndValue : propertyName C= COLON assignmentExpression ;
    public AS3_exParser.propertyNameAndValue_return propertyNameAndValue() // throws RecognitionException [1]
    {   
        AS3_exParser.propertyNameAndValue_return retval = new AS3_exParser.propertyNameAndValue_return();
        retval.Start = input.LT(1);
        int propertyNameAndValue_StartIndex = input.Index();
        object root_0 = null;

        IToken C = null;
        AS3_exParser.propertyName_return propertyName348 = null;

        AS3_exParser.assignmentExpression_return assignmentExpression349 = null;


        object C_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 145) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3572:5: ( propertyName C= COLON assignmentExpression )
            // AS3_ex.g3:3572:9: propertyName C= COLON assignmentExpression
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_propertyName_in_propertyNameAndValue15056);
                propertyName348 = propertyName();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, propertyName348.Tree);
                C=(IToken)Match(input,COLON,FOLLOW_COLON_in_propertyNameAndValue15060); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {C_tree = (object)adaptor.Create(C);
                    adaptor.AddChild(root_0, C_tree);
                }
                if ( state.backtracking == 0 ) 
                {

                            emit(C);
                            insertWS(mPrinter.getSpacesAfterLabel());
                            
                }
                PushFollow(FOLLOW_assignmentExpression_in_propertyNameAndValue15078);
                assignmentExpression349 = assignmentExpression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, assignmentExpression349.Tree);

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 145, propertyNameAndValue_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "propertyNameAndValue"

    public class propertyName_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "propertyName"
    // AS3_ex.g3:3580:1: propertyName : ( identifierLiteral | stringLiteral | numericLiteral );
    public AS3_exParser.propertyName_return propertyName() // throws RecognitionException [1]
    {   
        AS3_exParser.propertyName_return retval = new AS3_exParser.propertyName_return();
        retval.Start = input.LT(1);
        int propertyName_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.identifierLiteral_return identifierLiteral350 = null;

        AS3_exParser.stringLiteral_return stringLiteral351 = null;

        AS3_exParser.numericLiteral_return numericLiteral352 = null;



        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 146) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3581:5: ( identifierLiteral | stringLiteral | numericLiteral )
            int alt165 = 3;
            switch ( input.LA(1) ) 
            {
            case NATIVE:
            case TO:
            case EACH:
            case GET:
            case SET:
            case NAMESPACE:
            case DYNAMIC:
            case FINAL:
            case OVERRIDE:
            case STATIC:
            case IDENTIFIER:
                {
                alt165 = 1;
                }
                break;
            case SINGLE_QUOTE_LITERAL:
            case DOUBLE_QUOTE_LITERAL:
                {
                alt165 = 2;
                }
                break;
            case HEX_NUMBER_LITERAL:
            case DEC_NUMBER_LITERAL:
                {
                alt165 = 3;
                }
                break;
                default:
                    if ( state.backtracking > 0 ) {state.failed = true; return retval;}
                    NoViableAltException nvae_d165s0 =
                        new NoViableAltException("", 165, 0, input);

                    throw nvae_d165s0;
            }

            switch (alt165) 
            {
                case 1 :
                    // AS3_ex.g3:3581:9: identifierLiteral
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_identifierLiteral_in_propertyName15097);
                        identifierLiteral350 = identifierLiteral();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, identifierLiteral350.Tree);

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:3582:9: stringLiteral
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_stringLiteral_in_propertyName15108);
                        stringLiteral351 = stringLiteral();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, stringLiteral351.Tree);

                    }
                    break;
                case 3 :
                    // AS3_ex.g3:3583:9: numericLiteral
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_numericLiteral_in_propertyName15119);
                        numericLiteral352 = numericLiteral();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if ( state.backtracking == 0 ) adaptor.AddChild(root_0, numericLiteral352.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 146, propertyName_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "propertyName"

    public class arrayLiteral_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "arrayLiteral"
    // AS3_ex.g3:3587:1: arrayLiteral : L= LBRACK ( elementList )? R= RBRACK ;
    public AS3_exParser.arrayLiteral_return arrayLiteral() // throws RecognitionException [1]
    {   
        AS3_exParser.arrayLiteral_return retval = new AS3_exParser.arrayLiteral_return();
        retval.Start = input.LT(1);
        int arrayLiteral_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        IToken R = null;
        AS3_exParser.elementList_return elementList353 = null;


        object L_tree=null;
        object R_tree=null;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 147) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3588:5: (L= LBRACK ( elementList )? R= RBRACK )
            // AS3_ex.g3:3588:9: L= LBRACK ( elementList )? R= RBRACK
            {
                root_0 = (object)adaptor.GetNilNode();

                L=(IToken)Match(input,LBRACK,FOLLOW_LBRACK_in_arrayLiteral15142); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {L_tree = (object)adaptor.Create(L);
                    adaptor.AddChild(root_0, L_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  emit(L);insertWS(mPrinter.getAdvancedSpacesInsideArrayDeclBrackets());
                }
                // AS3_ex.g3:3588:92: ( elementList )?
                int alt166 = 2;
                int LA166_0 = input.LA(1);

                if ( ((LA166_0 >= AS && LA166_0 <= STATIC) || LA166_0 == LCURLY || LA166_0 == LPAREN || LA166_0 == LBRACK || LA166_0 == LT || (LA166_0 >= PLUS && LA166_0 <= STAR) || (LA166_0 >= INC && LA166_0 <= DEC) || (LA166_0 >= NOT && LA166_0 <= INV) || (LA166_0 >= XML_AT && LA166_0 <= XML_LS_STD) || (LA166_0 >= SINGLE_QUOTE_LITERAL && LA166_0 <= DOUBLE_QUOTE_LITERAL) || LA166_0 == REGULAR_EXPR_LITERAL || LA166_0 == HEX_NUMBER_LITERAL || LA166_0 == DEC_NUMBER_LITERAL || LA166_0 == IDENTIFIER || (LA166_0 >= XML_COMMENT && LA166_0 <= XML_PI)) )
                {
                    alt166 = 1;
                }
                switch (alt166) 
                {
                    case 1 :
                        // AS3_ex.g3:0:0: elementList
                        {
                            PushFollow(FOLLOW_elementList_in_arrayLiteral15146);
                            elementList353 = elementList();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if ( state.backtracking == 0 ) adaptor.AddChild(root_0, elementList353.Tree);

                        }
                        break;

                }

                R=(IToken)Match(input,RBRACK,FOLLOW_RBRACK_in_arrayLiteral15151); if (state.failed) return retval;
                if ( state.backtracking == 0 )
                {R_tree = (object)adaptor.Create(R);
                    adaptor.AddChild(root_0, R_tree);
                }
                if ( state.backtracking == 0 ) 
                {
                  insertWS(mPrinter.getAdvancedSpacesInsideArrayDeclBrackets());emit(R);
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 147, arrayLiteral_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "arrayLiteral"

    public class elementList_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object) value; }
        }
    };

    // $ANTLR start "elementList"
    // AS3_ex.g3:3591:1: elementList : assignmentExpression (C= COMMA assignmentExpression )* (C= COMMA )? ;
    public AS3_exParser.elementList_return elementList() // throws RecognitionException [1]
    {   
        AS3_exParser.elementList_return retval = new AS3_exParser.elementList_return();
        retval.Start = input.LT(1);
        int elementList_StartIndex = input.Index();
        object root_0 = null;

        IToken C = null;
        AS3_exParser.assignmentExpression_return assignmentExpression354 = null;

        AS3_exParser.assignmentExpression_return assignmentExpression355 = null;


        object C_tree=null;


            WrapOptions options=mPrinter.getArrayInitWrapOptions();
            bool pushedFormat=false;
            bool pushedIndent=false;
            bool pushedWrapInfo=false;
            int firstItemPos=0;

        try 
        {
            if ( (state.backtracking > 0) && AlreadyParsedRule(input, 148) ) 
            {
                return retval; 
            }
            // AS3_ex.g3:3600:5: ( assignmentExpression (C= COMMA assignmentExpression )* (C= COMMA )? )
            // AS3_ex.g3:3601:6: assignmentExpression (C= COMMA assignmentExpression )* (C= COMMA )?
            {
                root_0 = (object)adaptor.GetNilNode();

                if ( state.backtracking == 0 ) 
                {
                  pushedFormat=pushFormatType(options, true);
                }
                if ( state.backtracking == 0 ) 
                {

                         pushedIndent=pushLazyParmIndent(pushedIndent, options.getIndentStyle());
                         pushedWrapInfo=pushWrapInfo(options, true);
                }
                if ( state.backtracking == 0 ) 
                {
                  mPrinter.captureNextTextPosition();
                }
                PushFollow(FOLLOW_assignmentExpression_in_elementList15199);
                assignmentExpression354 = assignmentExpression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, assignmentExpression354.Tree);
                if ( state.backtracking == 0 ) 
                {
                  firstItemPos=mPrinter.getLastCapturePosition();
                }
                // AS3_ex.g3:3606:6: (C= COMMA assignmentExpression )*
                do 
                {
                    int alt167 = 2;
                    int LA167_0 = input.LA(1);

                    if ( (LA167_0 == COMMA) )
                    {
                        int LA167_1 = input.LA(2);

                        if ( ((LA167_1 >= AS && LA167_1 <= STATIC) || LA167_1 == LCURLY || LA167_1 == LPAREN || LA167_1 == LBRACK || LA167_1 == LT || (LA167_1 >= PLUS && LA167_1 <= STAR) || (LA167_1 >= INC && LA167_1 <= DEC) || (LA167_1 >= NOT && LA167_1 <= INV) || (LA167_1 >= XML_AT && LA167_1 <= XML_LS_STD) || (LA167_1 >= SINGLE_QUOTE_LITERAL && LA167_1 <= DOUBLE_QUOTE_LITERAL) || LA167_1 == REGULAR_EXPR_LITERAL || LA167_1 == HEX_NUMBER_LITERAL || LA167_1 == DEC_NUMBER_LITERAL || LA167_1 == IDENTIFIER || (LA167_1 >= XML_COMMENT && LA167_1 <= XML_PI)) )
                        {
                            alt167 = 1;
                        }


                    }


                    switch (alt167) 
                    {
                        case 1 :
                            // AS3_ex.g3:3607:7: C= COMMA assignmentExpression
                            {
                                C=(IToken)Match(input,COMMA,FOLLOW_COMMA_in_elementList15219); if (state.failed) return retval;
                                if ( state.backtracking == 0 )
                                {C_tree = (object)adaptor.Create(C);
                                    adaptor.AddChild(root_0, C_tree);
                                }
                                if ( state.backtracking == 0 ) 
                                {
                                  pushedIndent=emitCommaWithSpacingAndCRs(options, C, pushedIndent, firstItemPos, ASPrettyPrinter.Break_SubType_Array);
                                }
                                PushFollow(FOLLOW_assignmentExpression_in_elementList15236);
                                assignmentExpression355 = assignmentExpression();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if ( state.backtracking == 0 ) adaptor.AddChild(root_0, assignmentExpression355.Tree);

                            }
                            break;

                        default:
                            goto loop167;
                    }
                } while (true);

                loop167:
                    ;   // Stops C# compiler whining that label 'loop167' has no statements

                // AS3_ex.g3:3610:9: (C= COMMA )?
                int alt168 = 2;
                int LA168_0 = input.LA(1);

                if ( (LA168_0 == COMMA) )
                {
                    alt168 = 1;
                }
                switch (alt168) 
                {
                    case 1 :
                        // AS3_ex.g3:3610:10: C= COMMA
                        {
                            C=(IToken)Match(input,COMMA,FOLLOW_COMMA_in_elementList15249); if (state.failed) return retval;
                            if ( state.backtracking == 0 )
                            {C_tree = (object)adaptor.Create(C);
                                adaptor.AddChild(root_0, C_tree);
                            }
                            if ( state.backtracking == 0 ) 
                            {
                              emit(C);
                            }

                        }
                        break;

                }

                if ( state.backtracking == 0 ) 
                {

                            if (pushedIndent)
                                popIndent();
                            if (pushedFormat)
                            {
                                mPrinter.popFormatMode();
                            }
                            if (pushedWrapInfo)
                                mPrinter.popWrapContext();
                        
                }

            }

            retval.Stop = input.LT(-1);

            if ( state.backtracking==0 )
            {   retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);}
        }
        catch (RecognitionException re) 
        {
            ReportError(re);
            Recover(input,re);
        // Conversion of the second argument necessary, but harmless
        retval.Tree = (object)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);

        }
        finally 
        {
            if ( state.backtracking > 0 ) 
            {
                Memoize(input, 148, elementList_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end "elementList"

    // $ANTLR start "synpred9_AS3_ex"
    public void synpred9_AS3_ex_fragment() {
        IToken s = null;
        IToken d = null;
        IToken c = null;
        IToken I2 = null;

        // AS3_ex.g3:1548:82: ({...}? => (s= SUB | d= DOT | c= COLON ) {...}? => (I2= IDENTIFIER | allKeywords ) )
        // AS3_ex.g3:1548:82: {...}? => (s= SUB | d= DOT | c= COLON ) {...}? => (I2= IDENTIFIER | allKeywords )
        {
            if ( !((!promoteWhitespace())) ) 
            {
                if ( state.backtracking > 0 ) {state.failed = true; return ;}
                throw new FailedPredicateException(input, "synpred9_AS3_ex", "!promoteWhitespace()");
            }
            // AS3_ex.g3:1548:108: (s= SUB | d= DOT | c= COLON )
            int alt169 = 3;
            switch ( input.LA(1) ) 
            {
            case SUB:
                {
                alt169 = 1;
                }
                break;
            case DOT:
                {
                alt169 = 2;
                }
                break;
            case COLON:
                {
                alt169 = 3;
                }
                break;
                default:
                    if ( state.backtracking > 0 ) {state.failed = true; return ;}
                    NoViableAltException nvae_d169s0 =
                        new NoViableAltException("", 169, 0, input);

                    throw nvae_d169s0;
            }

            switch (alt169) 
            {
                case 1 :
                    // AS3_ex.g3:1548:109: s= SUB
                    {
                        s=(IToken)Match(input,SUB,FOLLOW_SUB_in_synpred9_AS3_ex3849); if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:1548:129: d= DOT
                    {
                        d=(IToken)Match(input,DOT,FOLLOW_DOT_in_synpred9_AS3_ex3857); if (state.failed) return ;

                    }
                    break;
                case 3 :
                    // AS3_ex.g3:1548:149: c= COLON
                    {
                        c=(IToken)Match(input,COLON,FOLLOW_COLON_in_synpred9_AS3_ex3865); if (state.failed) return ;

                    }
                    break;

            }

            if ( !((!promoteWhitespace())) ) 
            {
                if ( state.backtracking > 0 ) {state.failed = true; return ;}
                throw new FailedPredicateException(input, "synpred9_AS3_ex", "!promoteWhitespace()");
            }
            // AS3_ex.g3:1548:196: (I2= IDENTIFIER | allKeywords )
            int alt170 = 2;
            int LA170_0 = input.LA(1);

            if ( (LA170_0 == IDENTIFIER) )
            {
                alt170 = 1;
            }
            else if ( ((LA170_0 >= AS && LA170_0 <= STATIC)) )
            {
                alt170 = 2;
            }
            else 
            {
                if ( state.backtracking > 0 ) {state.failed = true; return ;}
                NoViableAltException nvae_d170s0 =
                    new NoViableAltException("", 170, 0, input);

                throw nvae_d170s0;
            }
            switch (alt170) 
            {
                case 1 :
                    // AS3_ex.g3:1548:197: I2= IDENTIFIER
                    {
                        I2=(IToken)Match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_synpred9_AS3_ex3876); if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:1548:226: allKeywords
                    {
                        PushFollow(FOLLOW_allKeywords_in_synpred9_AS3_ex3882);
                        allKeywords();
                        state.followingStackPointer--;
                        if (state.failed) return ;

                    }
                    break;

            }


        }
    }
    // $ANTLR end "synpred9_AS3_ex"

    // $ANTLR start "synpred68_AS3_ex"
    public void synpred68_AS3_ex_fragment() {
        // AS3_ex.g3:1637:6: ( xmlTextElement )
        // AS3_ex.g3:1637:6: xmlTextElement
        {
            PushFollow(FOLLOW_xmlTextElement_in_synpred68_AS3_ex4909);
            xmlTextElement();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred68_AS3_ex"

    // $ANTLR start "synpred72_AS3_ex"
    public void synpred72_AS3_ex_fragment() {
        // AS3_ex.g3:1659:11: ( xmlQualifiedIdentifier )
        // AS3_ex.g3:1659:11: xmlQualifiedIdentifier
        {
            PushFollow(FOLLOW_xmlQualifiedIdentifier_in_synpred72_AS3_ex5058);
            xmlQualifiedIdentifier();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred72_AS3_ex"

    // $ANTLR start "synpred73_AS3_ex"
    public void synpred73_AS3_ex_fragment() {
        // AS3_ex.g3:1666:12: ( xmlQualifiedIdentifier )
        // AS3_ex.g3:1666:12: xmlQualifiedIdentifier
        {
            PushFollow(FOLLOW_xmlQualifiedIdentifier_in_synpred73_AS3_ex5163);
            xmlQualifiedIdentifier();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred73_AS3_ex"

    // $ANTLR start "synpred74_AS3_ex"
    public void synpred74_AS3_ex_fragment() {
        // AS3_ex.g3:1667:14: ( xmlPropertySelector )
        // AS3_ex.g3:1667:14: xmlPropertySelector
        {
            PushFollow(FOLLOW_xmlPropertySelector_in_synpred74_AS3_ex5178);
            xmlPropertySelector();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred74_AS3_ex"

    // $ANTLR start "synpred96_AS3_ex"
    public void synpred96_AS3_ex_fragment() {
        IToken l = null;
        IToken r = null;

        // AS3_ex.g3:1849:4: ( conditionalCompilerOption l= LCURLY mxmlEmbedded r= RCURLY )
        // AS3_ex.g3:1849:4: conditionalCompilerOption l= LCURLY mxmlEmbedded r= RCURLY
        {
            if ( state.backtracking == 0 ) 
            {
              insertCR(false);
            }
            PushFollow(FOLLOW_conditionalCompilerOption_in_synpred96_AS3_ex6082);
            conditionalCompilerOption();
            state.followingStackPointer--;
            if (state.failed) return ;
            l=(IToken)Match(input,LCURLY,FOLLOW_LCURLY_in_synpred96_AS3_ex6090); if (state.failed) return ;
            PushFollow(FOLLOW_mxmlEmbedded_in_synpred96_AS3_ex6100);
            mxmlEmbedded();
            state.followingStackPointer--;
            if (state.failed) return ;
            r=(IToken)Match(input,RCURLY,FOLLOW_RCURLY_in_synpred96_AS3_ex6109); if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred96_AS3_ex"

    // $ANTLR start "synpred97_AS3_ex"
    public void synpred97_AS3_ex_fragment() {
        // AS3_ex.g3:1859:9: ( propertyDeclaration )
        // AS3_ex.g3:1859:9: propertyDeclaration
        {
            PushFollow(FOLLOW_propertyDeclaration_in_synpred97_AS3_ex6122);
            propertyDeclaration();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred97_AS3_ex"

    // $ANTLR start "synpred98_AS3_ex"
    public void synpred98_AS3_ex_fragment() {
        // AS3_ex.g3:1859:31: ( functionDeclaration )
        // AS3_ex.g3:1859:31: functionDeclaration
        {
            PushFollow(FOLLOW_functionDeclaration_in_synpred98_AS3_ex6126);
            functionDeclaration();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred98_AS3_ex"

    // $ANTLR start "synpred99_AS3_ex"
    public void synpred99_AS3_ex_fragment() {
        // AS3_ex.g3:1859:53: ( statement )
        // AS3_ex.g3:1859:53: statement
        {
            PushFollow(FOLLOW_statement_in_synpred99_AS3_ex6130);
            statement();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred99_AS3_ex"

    // $ANTLR start "synpred100_AS3_ex"
    public void synpred100_AS3_ex_fragment() {
        // AS3_ex.g3:1859:65: ( directive )
        // AS3_ex.g3:1859:65: directive
        {
            PushFollow(FOLLOW_directive_in_synpred100_AS3_ex6134);
            directive();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred100_AS3_ex"

    // $ANTLR start "synpred101_AS3_ex"
    public void synpred101_AS3_ex_fragment() {
        // AS3_ex.g3:1859:77: ( interfaceFunctionDeclaration )
        // AS3_ex.g3:1859:77: interfaceFunctionDeclaration
        {
            PushFollow(FOLLOW_interfaceFunctionDeclaration_in_synpred101_AS3_ex6138);
            interfaceFunctionDeclaration();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred101_AS3_ex"

    // $ANTLR start "synpred104_AS3_ex"
    public void synpred104_AS3_ex_fragment() {
        IToken l = null;
        IToken r = null;

        // AS3_ex.g3:1866:6: ( conditionalCompilerOption l= LCURLY ( packageElement )* r= RCURLY )
        // AS3_ex.g3:1866:6: conditionalCompilerOption l= LCURLY ( packageElement )* r= RCURLY
        {
            if ( state.backtracking == 0 ) 
            {
              insertCR(false);
            }
            PushFollow(FOLLOW_conditionalCompilerOption_in_synpred104_AS3_ex6181);
            conditionalCompilerOption();
            state.followingStackPointer--;
            if (state.failed) return ;
            l=(IToken)Match(input,LCURLY,FOLLOW_LCURLY_in_synpred104_AS3_ex6189); if (state.failed) return ;
            // AS3_ex.g3:1875:4: ( packageElement )*
            do 
            {
                int alt173 = 2;
                int LA173_0 = input.LA(1);

                if ( ((LA173_0 >= AS && LA173_0 <= LCURLY) || LA173_0 == LPAREN || LA173_0 == LBRACK || LA173_0 == LT || (LA173_0 >= PLUS && LA173_0 <= STAR) || (LA173_0 >= INC && LA173_0 <= DEC) || (LA173_0 >= NOT && LA173_0 <= INV) || (LA173_0 >= XML_AT && LA173_0 <= XML_LS_STD) || (LA173_0 >= SINGLE_QUOTE_LITERAL && LA173_0 <= DOUBLE_QUOTE_LITERAL) || LA173_0 == REGULAR_EXPR_LITERAL || LA173_0 == HEX_NUMBER_LITERAL || LA173_0 == DEC_NUMBER_LITERAL || LA173_0 == IDENTIFIER || (LA173_0 >= XML_COMMENT && LA173_0 <= XML_PI)) )
                {
                    alt173 = 1;
                }


                switch (alt173) 
                {
                    case 1 :
                        // AS3_ex.g3:0:0: packageElement
                        {
                            PushFollow(FOLLOW_packageElement_in_synpred104_AS3_ex6199);
                            packageElement();
                            state.followingStackPointer--;
                            if (state.failed) return ;

                        }
                        break;

                    default:
                        goto loop173;
                }
            } while (true);

            loop173:
                ;   // Stops C# compiler whining that label 'loop173' has no statements

            r=(IToken)Match(input,RCURLY,FOLLOW_RCURLY_in_synpred104_AS3_ex6214); if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred104_AS3_ex"

    // $ANTLR start "synpred105_AS3_ex"
    public void synpred105_AS3_ex_fragment() {
        // AS3_ex.g3:1878:8: ( classOrInterfaceDecl )
        // AS3_ex.g3:1878:8: classOrInterfaceDecl
        {
            PushFollow(FOLLOW_classOrInterfaceDecl_in_synpred105_AS3_ex6229);
            classOrInterfaceDecl();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred105_AS3_ex"

    // $ANTLR start "synpred106_AS3_ex"
    public void synpred106_AS3_ex_fragment() {
        // AS3_ex.g3:1878:31: ( propertyDeclaration )
        // AS3_ex.g3:1878:31: propertyDeclaration
        {
            PushFollow(FOLLOW_propertyDeclaration_in_synpred106_AS3_ex6233);
            propertyDeclaration();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred106_AS3_ex"

    // $ANTLR start "synpred107_AS3_ex"
    public void synpred107_AS3_ex_fragment() {
        // AS3_ex.g3:1878:53: ( functionDeclaration )
        // AS3_ex.g3:1878:53: functionDeclaration
        {
            PushFollow(FOLLOW_functionDeclaration_in_synpred107_AS3_ex6237);
            functionDeclaration();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred107_AS3_ex"

    // $ANTLR start "synpred108_AS3_ex"
    public void synpred108_AS3_ex_fragment() {
        // AS3_ex.g3:1878:75: ( interfaceFunctionDeclaration )
        // AS3_ex.g3:1878:75: interfaceFunctionDeclaration
        {
            PushFollow(FOLLOW_interfaceFunctionDeclaration_in_synpred108_AS3_ex6241);
            interfaceFunctionDeclaration();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred108_AS3_ex"

    // $ANTLR start "synpred109_AS3_ex"
    public void synpred109_AS3_ex_fragment() {
        // AS3_ex.g3:1878:106: ( statement )
        // AS3_ex.g3:1878:106: statement
        {
            PushFollow(FOLLOW_statement_in_synpred109_AS3_ex6245);
            statement();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred109_AS3_ex"

    // $ANTLR start "synpred123_AS3_ex"
    public void synpred123_AS3_ex_fragment() {
        IToken s = null;

        // AS3_ex.g3:1962:26: (s= SEMI )
        // AS3_ex.g3:1962:26: s= SEMI
        {
            s=(IToken)Match(input,SEMI,FOLLOW_SEMI_in_synpred123_AS3_ex6636); if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred123_AS3_ex"

    // $ANTLR start "synpred124_AS3_ex"
    public void synpred124_AS3_ex_fragment() {
        IToken E = null;

        // AS3_ex.g3:1993:6: ( eitherIdentifier E= ASSIGN )
        // AS3_ex.g3:1993:6: eitherIdentifier E= ASSIGN
        {
            PushFollow(FOLLOW_eitherIdentifier_in_synpred124_AS3_ex6700);
            eitherIdentifier();
            state.followingStackPointer--;
            if (state.failed) return ;
            E=(IToken)Match(input,ASSIGN,FOLLOW_ASSIGN_in_synpred124_AS3_ex6704); if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred124_AS3_ex"

    // $ANTLR start "synpred135_AS3_ex"
    public void synpred135_AS3_ex_fragment() {
        // AS3_ex.g3:2076:7: ( conditionalCompilerOption LCURLY )
        // AS3_ex.g3:2076:8: conditionalCompilerOption LCURLY
        {
            PushFollow(FOLLOW_conditionalCompilerOption_in_synpred135_AS3_ex7092);
            conditionalCompilerOption();
            state.followingStackPointer--;
            if (state.failed) return ;
            Match(input,LCURLY,FOLLOW_LCURLY_in_synpred135_AS3_ex7094); if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred135_AS3_ex"

    // $ANTLR start "synpred137_AS3_ex"
    public void synpred137_AS3_ex_fragment() {
        // AS3_ex.g3:2090:7: ( propertyDeclaration )
        // AS3_ex.g3:2090:7: propertyDeclaration
        {
            PushFollow(FOLLOW_propertyDeclaration_in_synpred137_AS3_ex7159);
            propertyDeclaration();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred137_AS3_ex"

    // $ANTLR start "synpred138_AS3_ex"
    public void synpred138_AS3_ex_fragment() {
        // AS3_ex.g3:2090:29: ( functionDeclaration )
        // AS3_ex.g3:2090:29: functionDeclaration
        {
            PushFollow(FOLLOW_functionDeclaration_in_synpred138_AS3_ex7163);
            functionDeclaration();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred138_AS3_ex"

    // $ANTLR start "synpred139_AS3_ex"
    public void synpred139_AS3_ex_fragment() {
        // AS3_ex.g3:2090:51: ( statement )
        // AS3_ex.g3:2090:51: statement
        {
            PushFollow(FOLLOW_statement_in_synpred139_AS3_ex7167);
            statement();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred139_AS3_ex"

    // $ANTLR start "synpred140_AS3_ex"
    public void synpred140_AS3_ex_fragment() {
        // AS3_ex.g3:2094:7: ( conditionalCompilerOption LCURLY )
        // AS3_ex.g3:2094:8: conditionalCompilerOption LCURLY
        {
            PushFollow(FOLLOW_conditionalCompilerOption_in_synpred140_AS3_ex7186);
            conditionalCompilerOption();
            state.followingStackPointer--;
            if (state.failed) return ;
            Match(input,LCURLY,FOLLOW_LCURLY_in_synpred140_AS3_ex7188); if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred140_AS3_ex"

    // $ANTLR start "synpred142_AS3_ex"
    public void synpred142_AS3_ex_fragment() {
        // AS3_ex.g3:2108:7: ( propertyDeclaration )
        // AS3_ex.g3:2108:7: propertyDeclaration
        {
            PushFollow(FOLLOW_propertyDeclaration_in_synpred142_AS3_ex7254);
            propertyDeclaration();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred142_AS3_ex"

    // $ANTLR start "synpred143_AS3_ex"
    public void synpred143_AS3_ex_fragment() {
        // AS3_ex.g3:2108:29: ( interfaceFunctionDeclaration )
        // AS3_ex.g3:2108:29: interfaceFunctionDeclaration
        {
            PushFollow(FOLLOW_interfaceFunctionDeclaration_in_synpred143_AS3_ex7258);
            interfaceFunctionDeclaration();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred143_AS3_ex"

    // $ANTLR start "synpred144_AS3_ex"
    public void synpred144_AS3_ex_fragment() {
        // AS3_ex.g3:2108:60: ( statement )
        // AS3_ex.g3:2108:60: statement
        {
            PushFollow(FOLLOW_statement_in_synpred144_AS3_ex7262);
            statement();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred144_AS3_ex"

    // $ANTLR start "synpred152_AS3_ex"
    public void synpred152_AS3_ex_fragment() {
        // AS3_ex.g3:2135:203: ( memberModifiers )
        // AS3_ex.g3:2135:203: memberModifiers
        {
            PushFollow(FOLLOW_memberModifiers_in_synpred152_AS3_ex7413);
            memberModifiers();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred152_AS3_ex"

    // $ANTLR start "synpred167_AS3_ex"
    public void synpred167_AS3_ex_fragment() {
        // AS3_ex.g3:2226:9: ( statement )
        // AS3_ex.g3:2226:9: statement
        {
            PushFollow(FOLLOW_statement_in_synpred167_AS3_ex7936);
            statement();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred167_AS3_ex"

    // $ANTLR start "synpred169_AS3_ex"
    public void synpred169_AS3_ex_fragment() {
        // AS3_ex.g3:2241:9: ( memberModifier )
        // AS3_ex.g3:2241:9: memberModifier
        {
            PushFollow(FOLLOW_memberModifier_in_synpred169_AS3_ex8001);
            memberModifier();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred169_AS3_ex"

    // $ANTLR start "synpred179_AS3_ex"
    public void synpred179_AS3_ex_fragment() {
        // AS3_ex.g3:2273:7: ( blockStatement )
        // AS3_ex.g3:2273:7: blockStatement
        {
            if ( state.backtracking == 0 ) 
            {
              mPrinter.inOther();
            }
            PushFollow(FOLLOW_blockStatement_in_synpred179_AS3_ex8177);
            blockStatement();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred179_AS3_ex"

    // $ANTLR start "synpred180_AS3_ex"
    public void synpred180_AS3_ex_fragment() {
        // AS3_ex.g3:2274:9: ( directive )
        // AS3_ex.g3:2274:9: directive
        {
            if ( state.backtracking == 0 ) 
            {
              insertStatementCR();
            }
            PushFollow(FOLLOW_directive_in_synpred180_AS3_ex8188);
            directive();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred180_AS3_ex"

    // $ANTLR start "synpred181_AS3_ex"
    public void synpred181_AS3_ex_fragment() {
        // AS3_ex.g3:2275:9: ( namespaceDirective )
        // AS3_ex.g3:2275:9: namespaceDirective
        {
            if ( state.backtracking == 0 ) 
            {
              insertStatementCR();
            }
            PushFollow(FOLLOW_namespaceDirective_in_synpred181_AS3_ex8199);
            namespaceDirective();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred181_AS3_ex"

    // $ANTLR start "synpred182_AS3_ex"
    public void synpred182_AS3_ex_fragment() {
        // AS3_ex.g3:2276:9: ( constantVarStatement )
        // AS3_ex.g3:2276:9: constantVarStatement
        {
            if ( state.backtracking == 0 ) 
            {
              insertStatementCR();
            }
            PushFollow(FOLLOW_constantVarStatement_in_synpred182_AS3_ex8212);
            constantVarStatement();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred182_AS3_ex"

    // $ANTLR start "synpred183_AS3_ex"
    public void synpred183_AS3_ex_fragment() {
        // AS3_ex.g3:2277:9: ( tryStatement )
        // AS3_ex.g3:2277:9: tryStatement
        {
            if ( state.backtracking == 0 ) 
            {
              markBlockFlag();insertLines(mPrinter.getBlankLinesBeforeControlStatement());
            }
            PushFollow(FOLLOW_tryStatement_in_synpred183_AS3_ex8225);
            tryStatement();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred183_AS3_ex"

    // $ANTLR start "synpred184_AS3_ex"
    public void synpred184_AS3_ex_fragment() {
        // AS3_ex.g3:2278:9: ( switchStatement )
        // AS3_ex.g3:2278:9: switchStatement
        {
            if ( state.backtracking == 0 ) 
            {
              markBlockFlag();
            }
            PushFollow(FOLLOW_switchStatement_in_synpred184_AS3_ex8237);
            switchStatement();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred184_AS3_ex"

    // $ANTLR start "synpred185_AS3_ex"
    public void synpred185_AS3_ex_fragment() {
        // AS3_ex.g3:2279:9: ( withStatement )
        // AS3_ex.g3:2279:9: withStatement
        {
            if ( state.backtracking == 0 ) 
            {
              markBlockFlag();insertLines(mPrinter.getBlankLinesBeforeControlStatement());
            }
            PushFollow(FOLLOW_withStatement_in_synpred185_AS3_ex8251);
            withStatement();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred185_AS3_ex"

    // $ANTLR start "synpred186_AS3_ex"
    public void synpred186_AS3_ex_fragment() {
        // AS3_ex.g3:2280:9: ( returnStatement )
        // AS3_ex.g3:2280:9: returnStatement
        {
            if ( state.backtracking == 0 ) 
            {
              pushLazyIndent();
            }
            PushFollow(FOLLOW_returnStatement_in_synpred186_AS3_ex8265);
            returnStatement();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred186_AS3_ex"

    // $ANTLR start "synpred187_AS3_ex"
    public void synpred187_AS3_ex_fragment() {
        // AS3_ex.g3:2281:9: ( breakStatement )
        // AS3_ex.g3:2281:9: breakStatement
        {
            if ( state.backtracking == 0 ) 
            {
              pushLazyIndent();
            }
            PushFollow(FOLLOW_breakStatement_in_synpred187_AS3_ex8279);
            breakStatement();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred187_AS3_ex"

    // $ANTLR start "synpred188_AS3_ex"
    public void synpred188_AS3_ex_fragment() {
        // AS3_ex.g3:2282:9: ( continueStatement )
        // AS3_ex.g3:2282:9: continueStatement
        {
            if ( state.backtracking == 0 ) 
            {
              pushLazyIndent();
            }
            PushFollow(FOLLOW_continueStatement_in_synpred188_AS3_ex8293);
            continueStatement();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred188_AS3_ex"

    // $ANTLR start "synpred189_AS3_ex"
    public void synpred189_AS3_ex_fragment() {
        // AS3_ex.g3:2283:9: ( forStatement )
        // AS3_ex.g3:2283:9: forStatement
        {
            if ( state.backtracking == 0 ) 
            {
              mPrinter.inLoop();
            }
            PushFollow(FOLLOW_forStatement_in_synpred189_AS3_ex8310);
            forStatement();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred189_AS3_ex"

    // $ANTLR start "synpred190_AS3_ex"
    public void synpred190_AS3_ex_fragment() {
        // AS3_ex.g3:2284:9: ( forInStatement )
        // AS3_ex.g3:2284:9: forInStatement
        {
            if ( state.backtracking == 0 ) 
            {
              mPrinter.inLoop();
            }
            PushFollow(FOLLOW_forInStatement_in_synpred190_AS3_ex8327);
            forInStatement();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred190_AS3_ex"

    // $ANTLR start "synpred191_AS3_ex"
    public void synpred191_AS3_ex_fragment() {
        // AS3_ex.g3:2285:9: ( forEachInStatement )
        // AS3_ex.g3:2285:9: forEachInStatement
        {
            if ( state.backtracking == 0 ) 
            {
              mPrinter.inLoop();
            }
            PushFollow(FOLLOW_forEachInStatement_in_synpred191_AS3_ex8344);
            forEachInStatement();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred191_AS3_ex"

    // $ANTLR start "synpred192_AS3_ex"
    public void synpred192_AS3_ex_fragment() {
        // AS3_ex.g3:2286:9: ( doWhileStatement )
        // AS3_ex.g3:2286:9: doWhileStatement
        {
            if ( state.backtracking == 0 ) 
            {
              mPrinter.inLoop();
            }
            PushFollow(FOLLOW_doWhileStatement_in_synpred192_AS3_ex8361);
            doWhileStatement();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred192_AS3_ex"

    // $ANTLR start "synpred193_AS3_ex"
    public void synpred193_AS3_ex_fragment() {
        // AS3_ex.g3:2287:9: ( whileStatement )
        // AS3_ex.g3:2287:9: whileStatement
        {
            if ( state.backtracking == 0 ) 
            {
              mPrinter.inLoop();
            }
            PushFollow(FOLLOW_whileStatement_in_synpred193_AS3_ex8378);
            whileStatement();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred193_AS3_ex"

    // $ANTLR start "synpred194_AS3_ex"
    public void synpred194_AS3_ex_fragment() {
        // AS3_ex.g3:2288:9: ( ifStatement )
        // AS3_ex.g3:2288:9: ifStatement
        {
            if ( state.backtracking == 0 ) 
            {
              mPrinter.inCondition();
            }
            PushFollow(FOLLOW_ifStatement_in_synpred194_AS3_ex8393);
            ifStatement();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred194_AS3_ex"

    // $ANTLR start "synpred195_AS3_ex"
    public void synpred195_AS3_ex_fragment() {
        // AS3_ex.g3:2289:9: ( variableStatement )
        // AS3_ex.g3:2289:9: variableStatement
        {
            if ( state.backtracking == 0 ) 
            {
              insertStatementCR();
            }
            PushFollow(FOLLOW_variableStatement_in_synpred195_AS3_ex8407);
            variableStatement();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred195_AS3_ex"

    // $ANTLR start "synpred196_AS3_ex"
    public void synpred196_AS3_ex_fragment() {
        // AS3_ex.g3:2290:9: ( throwStatement )
        // AS3_ex.g3:2290:9: throwStatement
        {
            if ( state.backtracking == 0 ) 
            {
              pushLazyIndent();
            }
            PushFollow(FOLLOW_throwStatement_in_synpred196_AS3_ex8422);
            throwStatement();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred196_AS3_ex"

    // $ANTLR start "synpred197_AS3_ex"
    public void synpred197_AS3_ex_fragment() {
        // AS3_ex.g3:2291:9: ( labelledStatement )
        // AS3_ex.g3:2291:9: labelledStatement
        {
            if ( state.backtracking == 0 ) 
            {
              insertLines(mPrinter.getBlankLinesBeforeControlStatement());
            }
            PushFollow(FOLLOW_labelledStatement_in_synpred197_AS3_ex8438);
            labelledStatement();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred197_AS3_ex"

    // $ANTLR start "synpred198_AS3_ex"
    public void synpred198_AS3_ex_fragment() {
        // AS3_ex.g3:2292:9: ( expression semic )
        // AS3_ex.g3:2292:9: expression semic
        {
            if ( state.backtracking == 0 ) 
            {
              pushLazyIndent();
            }
            PushFollow(FOLLOW_expression_in_synpred198_AS3_ex8470);
            expression();
            state.followingStackPointer--;
            if (state.failed) return ;
            PushFollow(FOLLOW_semic_in_synpred198_AS3_ex8472);
            semic();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred198_AS3_ex"

    // $ANTLR start "synpred201_AS3_ex"
    public void synpred201_AS3_ex_fragment() {
        IToken S = null;

        // AS3_ex.g3:2344:51: (S= SEMI )
        // AS3_ex.g3:2344:51: S= SEMI
        {
            S=(IToken)Match(input,SEMI,FOLLOW_SEMI_in_synpred201_AS3_ex8651); if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred201_AS3_ex"

    // $ANTLR start "synpred205_AS3_ex"
    public void synpred205_AS3_ex_fragment() {
        // AS3_ex.g3:2396:11: ( ( catchClause )+ finallyClause )
        // AS3_ex.g3:2396:11: ( catchClause )+ finallyClause
        {
            // AS3_ex.g3:2396:11: ( catchClause )+
            int cnt181 = 0;
            do 
            {
                int alt181 = 2;
                int LA181_0 = input.LA(1);

                if ( (LA181_0 == CATCH) )
                {
                    alt181 = 1;
                }


                switch (alt181) 
                {
                    case 1 :
                        // AS3_ex.g3:0:0: catchClause
                        {
                            PushFollow(FOLLOW_catchClause_in_synpred205_AS3_ex8853);
                            catchClause();
                            state.followingStackPointer--;
                            if (state.failed) return ;

                        }
                        break;

                    default:
                        if ( cnt181 >= 1 ) goto loop181;
                        if ( state.backtracking > 0 ) {state.failed = true; return ;}
                            EarlyExitException eee =
                                new EarlyExitException(181, input);
                            throw eee;
                }
                cnt181++;
            } while (true);

            loop181:
                ;   // Stops C# compiler whinging that label 'loop181' has no statements

            PushFollow(FOLLOW_finallyClause_in_synpred205_AS3_ex8856);
            finallyClause();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred205_AS3_ex"

    // $ANTLR start "synpred207_AS3_ex"
    public void synpred207_AS3_ex_fragment() {
        // AS3_ex.g3:2397:11: ( ( catchClause )+ )
        // AS3_ex.g3:2397:11: ( catchClause )+
        {
            // AS3_ex.g3:2397:11: ( catchClause )+
            int cnt182 = 0;
            do 
            {
                int alt182 = 2;
                int LA182_0 = input.LA(1);

                if ( (LA182_0 == CATCH) )
                {
                    alt182 = 1;
                }


                switch (alt182) 
                {
                    case 1 :
                        // AS3_ex.g3:0:0: catchClause
                        {
                            PushFollow(FOLLOW_catchClause_in_synpred207_AS3_ex8868);
                            catchClause();
                            state.followingStackPointer--;
                            if (state.failed) return ;

                        }
                        break;

                    default:
                        if ( cnt182 >= 1 ) goto loop182;
                        if ( state.backtracking > 0 ) {state.failed = true; return ;}
                            EarlyExitException eee =
                                new EarlyExitException(182, input);
                            throw eee;
                }
                cnt182++;
            } while (true);

            loop182:
                ;   // Stops C# compiler whinging that label 'loop182' has no statements


        }
    }
    // $ANTLR end "synpred207_AS3_ex"

    // $ANTLR start "synpred209_AS3_ex"
    public void synpred209_AS3_ex_fragment() {
        // AS3_ex.g3:2465:6: ( statement )
        // AS3_ex.g3:2465:6: statement
        {
            PushFollow(FOLLOW_statement_in_synpred209_AS3_ex9179);
            statement();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred209_AS3_ex"

    // $ANTLR start "synpred220_AS3_ex"
    public void synpred220_AS3_ex_fragment() {
        IToken S = null;

        // AS3_ex.g3:2666:134: (S= SEMI )
        // AS3_ex.g3:2666:134: S= SEMI
        {
            S=(IToken)Match(input,SEMI,FOLLOW_SEMI_in_synpred220_AS3_ex10102); if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred220_AS3_ex"

    // $ANTLR start "synpred221_AS3_ex"
    public void synpred221_AS3_ex_fragment() {
        IToken E = null;

        // AS3_ex.g3:2754:26: (E= ELSE statement )
        // AS3_ex.g3:2754:26: E= ELSE statement
        {
            E=(IToken)Match(input,ELSE,FOLLOW_ELSE_in_synpred221_AS3_ex10447); if (state.failed) return ;
            PushFollow(FOLLOW_statement_in_synpred221_AS3_ex10535);
            statement();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred221_AS3_ex"

    // $ANTLR start "synpred236_AS3_ex"
    public void synpred236_AS3_ex_fragment() {
        IToken C = null;

        // AS3_ex.g3:2972:30: (C= COMMA assignmentExpression )
        // AS3_ex.g3:2972:30: C= COMMA assignmentExpression
        {
            C=(IToken)Match(input,COMMA,FOLLOW_COMMA_in_synpred236_AS3_ex11309); if (state.failed) return ;
            PushFollow(FOLLOW_assignmentExpression_in_synpred236_AS3_ex11314);
            assignmentExpression();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred236_AS3_ex"

    // $ANTLR start "synpred238_AS3_ex"
    public void synpred238_AS3_ex_fragment() {
        // AS3_ex.g3:3018:9: ( leftHandSideExpression assignmentOperator )
        // AS3_ex.g3:3018:10: leftHandSideExpression assignmentOperator
        {
            PushFollow(FOLLOW_leftHandSideExpression_in_synpred238_AS3_ex11431);
            leftHandSideExpression();
            state.followingStackPointer--;
            if (state.failed) return ;
            PushFollow(FOLLOW_assignmentOperator_in_synpred238_AS3_ex11434);
            assignmentOperator();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred238_AS3_ex"

    // $ANTLR start "synpred239_AS3_ex"
    public void synpred239_AS3_ex_fragment() {
        // AS3_ex.g3:3033:9: ( leftHandSideExpression assignmentOperator )
        // AS3_ex.g3:3033:10: leftHandSideExpression assignmentOperator
        {
            PushFollow(FOLLOW_leftHandSideExpression_in_synpred239_AS3_ex11515);
            leftHandSideExpression();
            state.followingStackPointer--;
            if (state.failed) return ;
            PushFollow(FOLLOW_assignmentOperator_in_synpred239_AS3_ex11518);
            assignmentOperator();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred239_AS3_ex"

    // $ANTLR start "synpred255_AS3_ex"
    public void synpred255_AS3_ex_fragment() {
        IToken Q = null;
        IToken C = null;

        // AS3_ex.g3:3098:31: (Q= QUE assignmentExpression C= COLON assignmentExpression )
        // AS3_ex.g3:3098:31: Q= QUE assignmentExpression C= COLON assignmentExpression
        {
            Q=(IToken)Match(input,QUE,FOLLOW_QUE_in_synpred255_AS3_ex11858); if (state.failed) return ;
            PushFollow(FOLLOW_assignmentExpression_in_synpred255_AS3_ex11863);
            assignmentExpression();
            state.followingStackPointer--;
            if (state.failed) return ;
            C=(IToken)Match(input,COLON,FOLLOW_COLON_in_synpred255_AS3_ex11870); if (state.failed) return ;
            PushFollow(FOLLOW_assignmentExpression_in_synpred255_AS3_ex11875);
            assignmentExpression();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred255_AS3_ex"

    // $ANTLR start "synpred257_AS3_ex"
    public void synpred257_AS3_ex_fragment() {
        IToken L = null;

        // AS3_ex.g3:3119:32: (L= LOR logicalANDExpression )
        // AS3_ex.g3:3119:32: L= LOR logicalANDExpression
        {
            L=(IToken)Match(input,LOR,FOLLOW_LOR_in_synpred257_AS3_ex12012); if (state.failed) return ;
            PushFollow(FOLLOW_logicalANDExpression_in_synpred257_AS3_ex12016);
            logicalANDExpression();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred257_AS3_ex"

    // $ANTLR start "synpred259_AS3_ex"
    public void synpred259_AS3_ex_fragment() {
        IToken L = null;

        // AS3_ex.g3:3139:31: (L= LAND bitwiseORExpression )
        // AS3_ex.g3:3139:31: L= LAND bitwiseORExpression
        {
            L=(IToken)Match(input,LAND,FOLLOW_LAND_in_synpred259_AS3_ex12142); if (state.failed) return ;
            PushFollow(FOLLOW_bitwiseORExpression_in_synpred259_AS3_ex12146);
            bitwiseORExpression();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred259_AS3_ex"

    // $ANTLR start "synpred261_AS3_ex"
    public void synpred261_AS3_ex_fragment() {
        IToken O = null;

        // AS3_ex.g3:3160:32: (O= OR bitwiseXORExpression )
        // AS3_ex.g3:3160:32: O= OR bitwiseXORExpression
        {
            O=(IToken)Match(input,OR,FOLLOW_OR_in_synpred261_AS3_ex12271); if (state.failed) return ;
            PushFollow(FOLLOW_bitwiseXORExpression_in_synpred261_AS3_ex12275);
            bitwiseXORExpression();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred261_AS3_ex"

    // $ANTLR start "synpred263_AS3_ex"
    public void synpred263_AS3_ex_fragment() {
        IToken x = null;

        // AS3_ex.g3:3180:32: (x= XOR bitwiseANDExpression )
        // AS3_ex.g3:3180:32: x= XOR bitwiseANDExpression
        {
            x=(IToken)Match(input,XOR,FOLLOW_XOR_in_synpred263_AS3_ex12399); if (state.failed) return ;
            PushFollow(FOLLOW_bitwiseANDExpression_in_synpred263_AS3_ex12403);
            bitwiseANDExpression();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred263_AS3_ex"

    // $ANTLR start "synpred265_AS3_ex"
    public void synpred265_AS3_ex_fragment() {
        IToken A = null;

        // AS3_ex.g3:3200:30: (A= AND equalityExpression )
        // AS3_ex.g3:3200:30: A= AND equalityExpression
        {
            A=(IToken)Match(input,AND,FOLLOW_AND_in_synpred265_AS3_ex12523); if (state.failed) return ;
            PushFollow(FOLLOW_equalityExpression_in_synpred265_AS3_ex12527);
            equalityExpression();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred265_AS3_ex"

    // $ANTLR start "synpred270_AS3_ex"
    public void synpred270_AS3_ex_fragment() {
        IToken eq = null;

        // AS3_ex.g3:3221:32: (eq= ( EQ | NEQ | SAME | NSAME ) relationalExpression )
        // AS3_ex.g3:3221:32: eq= ( EQ | NEQ | SAME | NSAME ) relationalExpression
        {
            eq = (IToken)input.LT(1);
            if ( (input.LA(1) >= EQ && input.LA(1) <= NSAME) ) 
            {
                input.Consume();
                state.errorRecovery = false;state.failed = false;
            }
            else 
            {
                if ( state.backtracking > 0 ) {state.failed = true; return ;}
                MismatchedSetException mse = new MismatchedSetException(null,input);
                throw mse;
            }

            PushFollow(FOLLOW_relationalExpression_in_synpred270_AS3_ex12660);
            relationalExpression();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred270_AS3_ex"

    // $ANTLR start "synpred282_AS3_ex"
    public void synpred282_AS3_ex_fragment() {
        IToken g = null;
        IToken assign = null;
        IToken eq = null;

        // AS3_ex.g3:3244:7: ( (g= GT (assign= ASSIGN )? | eq= ( IN | LT | LTE | INSTANCEOF | IS | AS ) ) shiftExpression )
        // AS3_ex.g3:3244:7: (g= GT (assign= ASSIGN )? | eq= ( IN | LT | LTE | INSTANCEOF | IS | AS ) ) shiftExpression
        {
            // AS3_ex.g3:3244:7: (g= GT (assign= ASSIGN )? | eq= ( IN | LT | LTE | INSTANCEOF | IS | AS ) )
            int alt185 = 2;
            int LA185_0 = input.LA(1);

            if ( (LA185_0 == GT) )
            {
                alt185 = 1;
            }
            else if ( (LA185_0 == AS || (LA185_0 >= IN && LA185_0 <= INSTANCEOF) || LA185_0 == IS || LA185_0 == LT || LA185_0 == LTE) )
            {
                alt185 = 2;
            }
            else 
            {
                if ( state.backtracking > 0 ) {state.failed = true; return ;}
                NoViableAltException nvae_d185s0 =
                    new NoViableAltException("", 185, 0, input);

                throw nvae_d185s0;
            }
            switch (alt185) 
            {
                case 1 :
                    // AS3_ex.g3:3244:9: g= GT (assign= ASSIGN )?
                    {
                        g=(IToken)Match(input,GT,FOLLOW_GT_in_synpred282_AS3_ex12804); if (state.failed) return ;
                        // AS3_ex.g3:3244:14: (assign= ASSIGN )?
                        int alt184 = 2;
                        int LA184_0 = input.LA(1);

                        if ( (LA184_0 == ASSIGN) )
                        {
                            alt184 = 1;
                        }
                        switch (alt184) 
                        {
                            case 1 :
                                // AS3_ex.g3:3244:15: assign= ASSIGN
                                {
                                    assign=(IToken)Match(input,ASSIGN,FOLLOW_ASSIGN_in_synpred282_AS3_ex12809); if (state.failed) return ;

                                }
                                break;

                        }


                    }
                    break;
                case 2 :
                    // AS3_ex.g3:3252:14: eq= ( IN | LT | LTE | INSTANCEOF | IS | AS )
                    {
                        eq = (IToken)input.LT(1);
                        if ( input.LA(1) == AS || (input.LA(1) >= IN && input.LA(1) <= INSTANCEOF) || input.LA(1) == IS || input.LA(1) == LT || input.LA(1) == LTE ) 
                        {
                            input.Consume();
                            state.errorRecovery = false;state.failed = false;
                        }
                        else 
                        {
                            if ( state.backtracking > 0 ) {state.failed = true; return ;}
                            MismatchedSetException mse = new MismatchedSetException(null,input);
                            throw mse;
                        }


                    }
                    break;

            }

            PushFollow(FOLLOW_shiftExpression_in_synpred282_AS3_ex12880);
            shiftExpression();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred282_AS3_ex"

    // $ANTLR start "synpred293_AS3_ex"
    public void synpred293_AS3_ex_fragment() {
        // AS3_ex.g3:3300:11: ( '>' '>' '>' )
        // AS3_ex.g3:3300:12: '>' '>' '>'
        {
            Match(input,GT,FOLLOW_GT_in_synpred293_AS3_ex13191); if (state.failed) return ;
            Match(input,GT,FOLLOW_GT_in_synpred293_AS3_ex13193); if (state.failed) return ;
            Match(input,GT,FOLLOW_GT_in_synpred293_AS3_ex13195); if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred293_AS3_ex"

    // $ANTLR start "synpred294_AS3_ex"
    public void synpred294_AS3_ex_fragment() {
        IToken t1 = null;
        IToken t2 = null;
        IToken t3 = null;

        // AS3_ex.g3:3290:7: ( (t1= SHL | ( ( '>' '>' )=>t1= '>' t2= '>' {...}?) | ( ( '>' '>' '>' )=>t1= '>' t2= '>' t3= '>' {...}?) ) additiveExpression )
        // AS3_ex.g3:3290:7: (t1= SHL | ( ( '>' '>' )=>t1= '>' t2= '>' {...}?) | ( ( '>' '>' '>' )=>t1= '>' t2= '>' t3= '>' {...}?) ) additiveExpression
        {
            // AS3_ex.g3:3290:7: (t1= SHL | ( ( '>' '>' )=>t1= '>' t2= '>' {...}?) | ( ( '>' '>' '>' )=>t1= '>' t2= '>' t3= '>' {...}?) )
            int alt189 = 3;
            int LA189_0 = input.LA(1);

            if ( (LA189_0 == SHL) )
            {
                alt189 = 1;
            }
            else if ( (LA189_0 == GT) )
            {
                int LA189_2 = input.LA(2);

                if ( (LA189_2 == GT) )
                {
                    int LA189_3 = input.LA(3);

                    if ( (LA189_3 == GT) && (synpred293_AS3_ex()) )
                    {
                        alt189 = 3;
                    }
                    else if ( ((LA189_3 >= AS && LA189_3 <= STATIC) || LA189_3 == LCURLY || LA189_3 == LPAREN || LA189_3 == LBRACK || LA189_3 == LT || (LA189_3 >= PLUS && LA189_3 <= STAR) || (LA189_3 >= INC && LA189_3 <= DEC) || (LA189_3 >= NOT && LA189_3 <= INV) || (LA189_3 >= XML_AT && LA189_3 <= XML_LS_STD) || (LA189_3 >= SINGLE_QUOTE_LITERAL && LA189_3 <= DOUBLE_QUOTE_LITERAL) || LA189_3 == REGULAR_EXPR_LITERAL || LA189_3 == HEX_NUMBER_LITERAL || LA189_3 == DEC_NUMBER_LITERAL || LA189_3 == IDENTIFIER || (LA189_3 >= XML_COMMENT && LA189_3 <= XML_PI)) )
                    {
                        alt189 = 2;
                    }
                    else 
                    {
                        if ( state.backtracking > 0 ) {state.failed = true; return ;}
                        NoViableAltException nvae_d189s3 =
                            new NoViableAltException("", 189, 3, input);

                        throw nvae_d189s3;
                    }
                }
                else 
                {
                    if ( state.backtracking > 0 ) {state.failed = true; return ;}
                    NoViableAltException nvae_d189s2 =
                        new NoViableAltException("", 189, 2, input);

                    throw nvae_d189s2;
                }
            }
            else 
            {
                if ( state.backtracking > 0 ) {state.failed = true; return ;}
                NoViableAltException nvae_d189s0 =
                    new NoViableAltException("", 189, 0, input);

                throw nvae_d189s0;
            }
            switch (alt189) 
            {
                case 1 :
                    // AS3_ex.g3:3291:8: t1= SHL
                    {
                        t1=(IToken)Match(input,SHL,FOLLOW_SHL_in_synpred294_AS3_ex13115); if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:3296:11: ( ( '>' '>' )=>t1= '>' t2= '>' {...}?)
                    {
                        // AS3_ex.g3:3296:11: ( ( '>' '>' )=>t1= '>' t2= '>' {...}?)
                        // AS3_ex.g3:3296:12: ( '>' '>' )=>t1= '>' t2= '>' {...}?
                        {
                            t1=(IToken)Match(input,GT,FOLLOW_GT_in_synpred294_AS3_ex13146); if (state.failed) return ;
                            t2=(IToken)Match(input,GT,FOLLOW_GT_in_synpred294_AS3_ex13150); if (state.failed) return ;
                            if ( !(( t1.Line == t2.Line && 
                                                t1.CharPositionInLine + 1 == t2.CharPositionInLine )) ) 
                            {
                                if ( state.backtracking > 0 ) {state.failed = true; return ;}
                                throw new FailedPredicateException(input, "synpred294_AS3_ex", " $t1.Line == $t2.Line && \n          \t\t\t$t1.CharPositionInLine + 1 == $t2.CharPositionInLine ");
                            }

                        }


                    }
                    break;
                case 3 :
                    // AS3_ex.g3:3300:10: ( ( '>' '>' '>' )=>t1= '>' t2= '>' t3= '>' {...}?)
                    {
                        // AS3_ex.g3:3300:10: ( ( '>' '>' '>' )=>t1= '>' t2= '>' t3= '>' {...}?)
                        // AS3_ex.g3:3300:11: ( '>' '>' '>' )=>t1= '>' t2= '>' t3= '>' {...}?
                        {
                            t1=(IToken)Match(input,GT,FOLLOW_GT_in_synpred294_AS3_ex13201); if (state.failed) return ;
                            t2=(IToken)Match(input,GT,FOLLOW_GT_in_synpred294_AS3_ex13205); if (state.failed) return ;
                            t3=(IToken)Match(input,GT,FOLLOW_GT_in_synpred294_AS3_ex13209); if (state.failed) return ;
                            if ( !(( t1.Line == t2.Line && 
                                                t1.CharPositionInLine + 1 == t2.CharPositionInLine &&
                                                t2.Line == t3.Line && 
                                                t2.CharPositionInLine + 1 == t3.CharPositionInLine )) ) 
                            {
                                if ( state.backtracking > 0 ) {state.failed = true; return ;}
                                throw new FailedPredicateException(input, "synpred294_AS3_ex", " $t1.Line == $t2.Line && \n          \t\t\t$t1.CharPositionInLine + 1 == $t2.CharPositionInLine &&\n          \t\t\t$t2.Line == $t3.Line && \n          \t\t\t$t2.CharPositionInLine + 1 == $t3.CharPositionInLine ");
                            }

                        }


                    }
                    break;

            }

            PushFollow(FOLLOW_additiveExpression_in_synpred294_AS3_ex13256);
            additiveExpression();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred294_AS3_ex"

    // $ANTLR start "synpred296_AS3_ex"
    public void synpred296_AS3_ex_fragment() {
        IToken op = null;

        // AS3_ex.g3:3319:36: (op= ( PLUS | SUB ) multiplicativeExpression )
        // AS3_ex.g3:3319:36: op= ( PLUS | SUB ) multiplicativeExpression
        {
            op = (IToken)input.LT(1);
            if ( (input.LA(1) >= PLUS && input.LA(1) <= SUB) ) 
            {
                input.Consume();
                state.errorRecovery = false;state.failed = false;
            }
            else 
            {
                if ( state.backtracking > 0 ) {state.failed = true; return ;}
                MismatchedSetException mse = new MismatchedSetException(null,input);
                throw mse;
            }

            PushFollow(FOLLOW_multiplicativeExpression_in_synpred296_AS3_ex13322);
            multiplicativeExpression();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred296_AS3_ex"

    // $ANTLR start "synpred299_AS3_ex"
    public void synpred299_AS3_ex_fragment() {
        IToken op = null;

        // AS3_ex.g3:3330:27: (op= ( STAR | DIV | MOD ) unaryExpression )
        // AS3_ex.g3:3330:27: op= ( STAR | DIV | MOD ) unaryExpression
        {
            op = (IToken)input.LT(1);
            if ( (input.LA(1) >= STAR && input.LA(1) <= MOD) ) 
            {
                input.Consume();
                state.errorRecovery = false;state.failed = false;
            }
            else 
            {
                if ( state.backtracking > 0 ) {state.failed = true; return ;}
                MismatchedSetException mse = new MismatchedSetException(null,input);
                throw mse;
            }

            PushFollow(FOLLOW_unaryExpression_in_synpred299_AS3_ex13386);
            unaryExpression();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred299_AS3_ex"

    // $ANTLR start "synpred300_AS3_ex"
    public void synpred300_AS3_ex_fragment() {
        // AS3_ex.g3:3336:9: ( postfixExpression )
        // AS3_ex.g3:3336:9: postfixExpression
        {
            PushFollow(FOLLOW_postfixExpression_in_synpred300_AS3_ex13421);
            postfixExpression();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred300_AS3_ex"

    // $ANTLR start "synpred302_AS3_ex"
    public void synpred302_AS3_ex_fragment() {
        IToken op = null;

        // AS3_ex.g3:3337:8: (op= ( NOT | INV ) unaryExpression )
        // AS3_ex.g3:3337:8: op= ( NOT | INV ) unaryExpression
        {
            op = (IToken)input.LT(1);
            if ( (input.LA(1) >= NOT && input.LA(1) <= INV) ) 
            {
                input.Consume();
                state.errorRecovery = false;state.failed = false;
            }
            else 
            {
                if ( state.backtracking > 0 ) {state.failed = true; return ;}
                MismatchedSetException mse = new MismatchedSetException(null,input);
                throw mse;
            }

            PushFollow(FOLLOW_unaryExpression_in_synpred302_AS3_ex13442);
            unaryExpression();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred302_AS3_ex"

    // $ANTLR start "synpred311_AS3_ex"
    public void synpred311_AS3_ex_fragment() {
        // AS3_ex.g3:3350:32: ( postfixOp )
        // AS3_ex.g3:3350:32: postfixOp
        {
            PushFollow(FOLLOW_postfixOp_in_synpred311_AS3_ex13544);
            postfixOp();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred311_AS3_ex"

    // $ANTLR start "synpred315_AS3_ex"
    public void synpred315_AS3_ex_fragment() {
        // AS3_ex.g3:3377:7: ( arguments )
        // AS3_ex.g3:3377:7: arguments
        {
            PushFollow(FOLLOW_arguments_in_synpred315_AS3_ex13661);
            arguments();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred315_AS3_ex"

    // $ANTLR start "synpred316_AS3_ex"
    public void synpred316_AS3_ex_fragment() {
        IToken L = null;
        IToken R = null;

        // AS3_ex.g3:3378:9: (L= LBRACK expression R= RBRACK )
        // AS3_ex.g3:3378:9: L= LBRACK expression R= RBRACK
        {
            L=(IToken)Match(input,LBRACK,FOLLOW_LBRACK_in_synpred316_AS3_ex13673); if (state.failed) return ;
            PushFollow(FOLLOW_expression_in_synpred316_AS3_ex13677);
            expression();
            state.followingStackPointer--;
            if (state.failed) return ;
            R=(IToken)Match(input,RBRACK,FOLLOW_RBRACK_in_synpred316_AS3_ex13681); if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred316_AS3_ex"

    // $ANTLR start "synpred317_AS3_ex"
    public void synpred317_AS3_ex_fragment() {
        IToken E = null;

        // AS3_ex.g3:3381:9: (E= XML_ELLIPSIS eitherIdentifier )
        // AS3_ex.g3:3381:9: E= XML_ELLIPSIS eitherIdentifier
        {
            E=(IToken)Match(input,XML_ELLIPSIS,FOLLOW_XML_ELLIPSIS_in_synpred317_AS3_ex13697); if (state.failed) return ;
            PushFollow(FOLLOW_eitherIdentifier_in_synpred317_AS3_ex13700);
            eitherIdentifier();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred317_AS3_ex"

    // $ANTLR start "synpred319_AS3_ex"
    public void synpred319_AS3_ex_fragment() {
        IToken D = null;

        // AS3_ex.g3:3382:9: (D= DOT ( eitherIdentifier | parExpression ) )
        // AS3_ex.g3:3382:9: D= DOT ( eitherIdentifier | parExpression )
        {
            D=(IToken)Match(input,DOT,FOLLOW_DOT_in_synpred319_AS3_ex13714); if (state.failed) return ;
            // AS3_ex.g3:3382:15: ( eitherIdentifier | parExpression )
            int alt190 = 2;
            int LA190_0 = input.LA(1);

            if ( ((LA190_0 >= AS && LA190_0 <= STATIC) || LA190_0 == STAR || LA190_0 == XML_AT || LA190_0 == IDENTIFIER) )
            {
                alt190 = 1;
            }
            else if ( (LA190_0 == LPAREN) )
            {
                alt190 = 2;
            }
            else 
            {
                if ( state.backtracking > 0 ) {state.failed = true; return ;}
                NoViableAltException nvae_d190s0 =
                    new NoViableAltException("", 190, 0, input);

                throw nvae_d190s0;
            }
            switch (alt190) 
            {
                case 1 :
                    // AS3_ex.g3:3382:16: eitherIdentifier
                    {
                        PushFollow(FOLLOW_eitherIdentifier_in_synpred319_AS3_ex13719);
                        eitherIdentifier();
                        state.followingStackPointer--;
                        if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // AS3_ex.g3:3382:94: parExpression
                    {
                        if ( state.backtracking == 0 ) 
                        {
                          wrapEmit(D, ASPrettyPrinter.Break_Other_Connectors_code);
                        }
                        PushFollow(FOLLOW_parExpression_in_synpred319_AS3_ex13725);
                        parExpression();
                        state.followingStackPointer--;
                        if (state.failed) return ;

                    }
                    break;

            }


        }
    }
    // $ANTLR end "synpred319_AS3_ex"

    // $ANTLR start "synpred320_AS3_ex"
    public void synpred320_AS3_ex_fragment() {
        // AS3_ex.g3:3383:9: ( typePostfixSyntax )
        // AS3_ex.g3:3383:9: typePostfixSyntax
        {
            PushFollow(FOLLOW_typePostfixSyntax_in_synpred320_AS3_ex13738);
            typePostfixSyntax();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred320_AS3_ex"

    // $ANTLR start "synpred321_AS3_ex"
    public void synpred321_AS3_ex_fragment() {
        IToken op = null;

        // AS3_ex.g3:3384:9: (op= XML_NS_OP expression )
        // AS3_ex.g3:3384:9: op= XML_NS_OP expression
        {
            op=(IToken)Match(input,XML_NS_OP,FOLLOW_XML_NS_OP_in_synpred321_AS3_ex13750); if (state.failed) return ;
            PushFollow(FOLLOW_expression_in_synpred321_AS3_ex13754);
            expression();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred321_AS3_ex"

    // $ANTLR start "synpred322_AS3_ex"
    public void synpred322_AS3_ex_fragment() {
        IToken I = null;

        // AS3_ex.g3:3390:4: (I= IDENTIFIER )
        // AS3_ex.g3:3390:4: I= IDENTIFIER
        {
            I=(IToken)Match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_synpred322_AS3_ex13791); if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred322_AS3_ex"

    // $ANTLR start "synpred323_AS3_ex"
    public void synpred323_AS3_ex_fragment() {
        // AS3_ex.g3:3391:5: ( xmlPropertyIdentifier )
        // AS3_ex.g3:3391:5: xmlPropertyIdentifier
        {
            PushFollow(FOLLOW_xmlPropertyIdentifier_in_synpred323_AS3_ex13801);
            xmlPropertyIdentifier();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred323_AS3_ex"

    // $ANTLR start "synpred385_AS3_ex"
    public void synpred385_AS3_ex_fragment() {
        IToken T = null;

        // AS3_ex.g3:3522:9: (T= THIS )
        // AS3_ex.g3:3522:9: T= THIS
        {
            T=(IToken)Match(input,THIS,FOLLOW_THIS_in_synpred385_AS3_ex14802); if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred385_AS3_ex"

    // $ANTLR start "synpred386_AS3_ex"
    public void synpred386_AS3_ex_fragment() {
        IToken S = null;

        // AS3_ex.g3:3523:9: (S= SUPER )
        // AS3_ex.g3:3523:9: S= SUPER
        {
            S=(IToken)Match(input,SUPER,FOLLOW_SUPER_in_synpred386_AS3_ex14816); if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred386_AS3_ex"

    // $ANTLR start "synpred387_AS3_ex"
    public void synpred387_AS3_ex_fragment() {
        // AS3_ex.g3:3524:9: ( literal )
        // AS3_ex.g3:3524:9: literal
        {
            PushFollow(FOLLOW_literal_in_synpred387_AS3_ex14828);
            literal();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred387_AS3_ex"

    // $ANTLR start "synpred390_AS3_ex"
    public void synpred390_AS3_ex_fragment() {
        IToken x = null;

        // AS3_ex.g3:3527:10: ( identifierLiteral x= XML_NS_OP )
        // AS3_ex.g3:3527:10: identifierLiteral x= XML_NS_OP
        {
            PushFollow(FOLLOW_identifierLiteral_in_synpred390_AS3_ex14864);
            identifierLiteral();
            state.followingStackPointer--;
            if (state.failed) return ;
            x=(IToken)Match(input,XML_NS_OP,FOLLOW_XML_NS_OP_in_synpred390_AS3_ex14868); if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred390_AS3_ex"

    // $ANTLR start "synpred391_AS3_ex"
    public void synpred391_AS3_ex_fragment() {
        IToken x = null;

        // AS3_ex.g3:3527:9: ( ( identifierLiteral x= XML_NS_OP )? identifierLiteral )
        // AS3_ex.g3:3527:9: ( identifierLiteral x= XML_NS_OP )? identifierLiteral
        {
            // AS3_ex.g3:3527:9: ( identifierLiteral x= XML_NS_OP )?
            int alt192 = 2;
            int LA192_0 = input.LA(1);

            if ( (LA192_0 == IDENTIFIER) )
            {
                int LA192_1 = input.LA(2);

                if ( (LA192_1 == XML_NS_OP) )
                {
                    alt192 = 1;
                }
            }
            else if ( (LA192_0 == NATIVE || LA192_0 == TO || (LA192_0 >= EACH && LA192_0 <= NAMESPACE) || (LA192_0 >= DYNAMIC && LA192_0 <= STATIC)) )
            {
                int LA192_2 = input.LA(2);

                if ( (LA192_2 == XML_NS_OP) )
                {
                    alt192 = 1;
                }
            }
            switch (alt192) 
            {
                case 1 :
                    // AS3_ex.g3:3527:10: identifierLiteral x= XML_NS_OP
                    {
                        PushFollow(FOLLOW_identifierLiteral_in_synpred391_AS3_ex14864);
                        identifierLiteral();
                        state.followingStackPointer--;
                        if (state.failed) return ;
                        x=(IToken)Match(input,XML_NS_OP,FOLLOW_XML_NS_OP_in_synpred391_AS3_ex14868); if (state.failed) return ;

                    }
                    break;

            }

            PushFollow(FOLLOW_identifierLiteral_in_synpred391_AS3_ex14874);
            identifierLiteral();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred391_AS3_ex"

    // $ANTLR start "synpred392_AS3_ex"
    public void synpred392_AS3_ex_fragment() {
        // AS3_ex.g3:3528:9: ( xmlPrimaryExpression )
        // AS3_ex.g3:3528:9: xmlPrimaryExpression
        {
            PushFollow(FOLLOW_xmlPrimaryExpression_in_synpred392_AS3_ex14885);
            xmlPrimaryExpression();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred392_AS3_ex"

    // $ANTLR start "synpred394_AS3_ex"
    public void synpred394_AS3_ex_fragment() {
        // AS3_ex.g3:3530:49: ( arrayLiteral )
        // AS3_ex.g3:3530:49: arrayLiteral
        {
            PushFollow(FOLLOW_arrayLiteral_in_synpred394_AS3_ex14921);
            arrayLiteral();
            state.followingStackPointer--;
            if (state.failed) return ;

        }
    }
    // $ANTLR end "synpred394_AS3_ex"

    // Delegated rules

    public bool synpred220_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred220_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred221_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred221_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred189_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred189_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred319_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred319_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred201_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred201_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred205_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred205_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred207_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred207_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred186_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred186_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred187_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred187_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred188_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred188_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred263_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred263_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred261_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred261_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred72_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred72_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred391_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred391_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred73_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred73_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred74_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred74_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred394_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred394_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred109_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred109_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred390_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred390_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred392_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred392_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred142_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred142_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred124_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred124_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred259_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred259_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred144_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred144_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred140_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred140_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred293_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred293_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred137_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred137_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred282_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred282_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred96_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred96_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred180_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred180_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred139_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred139_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred98_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred98_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred135_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred135_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred191_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred191_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred323_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred323_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred182_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred182_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred184_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred184_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred209_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred209_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred321_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred321_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred299_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred299_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred316_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred316_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred9_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred9_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred179_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred179_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred195_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred195_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred197_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred197_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred198_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred198_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred194_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred194_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred196_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred196_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred192_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred192_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred193_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred193_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred101_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred101_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred236_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred236_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred270_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred270_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred387_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred387_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred238_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred238_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred239_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred239_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred255_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred255_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred257_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred257_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred385_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred385_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred386_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred386_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred68_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred68_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred100_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred100_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred106_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred106_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred104_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred104_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred105_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred105_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred107_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred107_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred108_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred108_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred294_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred294_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred99_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred99_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred143_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred143_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred152_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred152_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred296_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred296_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred123_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred123_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred265_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred265_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred311_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred311_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred97_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred97_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred138_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred138_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred190_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred190_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred302_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred302_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred300_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred300_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred183_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred183_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred315_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred315_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred322_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred322_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred181_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred181_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred185_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred185_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred317_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred317_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred320_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred320_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred167_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred167_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred169_AS3_ex() 
    {
        state.backtracking++;
        int start = input.Mark();
        try 
        {
            synpred169_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re) 
        {
            Console.Error.WriteLine("impossible: "+re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }


    protected DFA8 dfa8;
    protected DFA34 dfa34;
    protected DFA37 dfa37;
    protected DFA49 dfa49;
    protected DFA59 dfa59;
    protected DFA61 dfa61;
    protected DFA80 dfa80;
    protected DFA83 dfa83;
    protected DFA93 dfa93;
    protected DFA121 dfa121;
    protected DFA122 dfa122;
    protected DFA123 dfa123;
    protected DFA148 dfa148;
    protected DFA152 dfa152;
    protected DFA162 dfa162;
    protected DFA161 dfa161;
    private void InitializeCyclicDFAs()
    {
        this.dfa8 = new DFA8(this);
        this.dfa34 = new DFA34(this);
        this.dfa37 = new DFA37(this);
        this.dfa49 = new DFA49(this);
        this.dfa59 = new DFA59(this);
        this.dfa61 = new DFA61(this);
        this.dfa80 = new DFA80(this);
        this.dfa83 = new DFA83(this);
        this.dfa93 = new DFA93(this);
        this.dfa121 = new DFA121(this);
        this.dfa122 = new DFA122(this);
        this.dfa123 = new DFA123(this);
        this.dfa148 = new DFA148(this);
        this.dfa152 = new DFA152(this);
        this.dfa162 = new DFA162(this);
        this.dfa161 = new DFA161(this);
        this.dfa8.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA8_SpecialStateTransition);
        this.dfa34.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA34_SpecialStateTransition);
        this.dfa37.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA37_SpecialStateTransition);
        this.dfa49.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA49_SpecialStateTransition);
        this.dfa59.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA59_SpecialStateTransition);
        this.dfa61.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA61_SpecialStateTransition);
        this.dfa80.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA80_SpecialStateTransition);
        this.dfa83.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA83_SpecialStateTransition);
        this.dfa93.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA93_SpecialStateTransition);
        this.dfa121.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA121_SpecialStateTransition);
        this.dfa122.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA122_SpecialStateTransition);

        this.dfa148.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA148_SpecialStateTransition);
        this.dfa152.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA152_SpecialStateTransition);
        this.dfa162.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA162_SpecialStateTransition);
        this.dfa161.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA161_SpecialStateTransition);
    }

    const string DFA8_eotS =
        "\x32\uffff";
    const string DFA8_eofS =
        "\x01\x01\x03\uffff\x01\x01\x2d\uffff";
    const string DFA8_minS =
        "\x01\x04\x01\uffff\x03\x04\x2c\x00\x01\uffff";
    const string DFA8_maxS =
        "\x01\u0092\x01\uffff\x01\u008e\x02\u0092\x2c\x00\x01\uffff";
    const string DFA8_acceptS =
        "\x01\uffff\x01\x02\x2f\uffff\x01\x01";
    const string DFA8_specialS =
        "\x05\uffff\x01\x1f\x01\x26\x01\x00\x01\x2a\x01\x1b\x01\x12\x01"+
        "\x13\x01\x1d\x01\x0d\x01\x09\x01\x2b\x01\x0a\x01\x21\x01\x19\x01"+
        "\x1a\x01\x07\x01\x01\x01\x0e\x01\x08\x01\x04\x01\x22\x01\x16\x01"+
        "\x05\x01\x20\x01\x0c\x01\x14\x01\x0b\x01\x06\x01\x17\x01\x29\x01"+
        "\x03\x01\x15\x01\x1e\x01\x10\x01\x28\x01\x02\x01\x1c\x01\x0f\x01"+
        "\x24\x01\x25\x01\x23\x01\x11\x01\x27\x01\x18\x01\uffff}>";
    static readonly string[] DFA8_transitionS = {
            "\x3d\x01\x01\x02\x04\x01\x01\uffff\x05\x01\x01\x03\x06\x01"+
            "\x02\uffff\x08\x01\x01\x04\x06\x01\x02\uffff\x05\x01\x01\uffff"+
            "\x02\x01\x01\uffff\x03\x01\x0e\uffff\x02\x01\x02\uffff\x01\x01"+
            "\x04\uffff\x01\x01\x02\uffff\x01\x01\x01\uffff\x01\x01\x01\uffff"+
            "\x03\x01",
            "",
            "\x18\x06\x01\x07\x0b\x06\x01\x07\x08\x06\x04\x07\x01\x06\x04"+
            "\x07\x03\uffff\x01\x01\x05\uffff\x01\x01\x09\uffff\x01\x01\x22"+
            "\uffff\x01\x01\x1d\uffff\x01\x05",
            "\x08\x12\x01\x11\x03\x12\x01\x0c\x02\x12\x01\x0f\x08\x12\x01"+
            "\x0e\x01\x10\x01\x0a\x05\x12\x01\x09\x01\x12\x01\x08\x01\x12"+
            "\x01\x0e\x01\x0b\x01\x12\x01\x11\x02\x12\x01\x11\x02\x12\x04"+
            "\x0e\x01\x12\x04\x0e\x01\uffff\x01\x01\x01\uffff\x01\x01\x01"+
            "\uffff\x01\x01\x03\uffff\x01\x01\x07\uffff\x03\x01\x02\uffff"+
            "\x02\x01\x06\uffff\x02\x01\x16\uffff\x02\x01\x0e\uffff\x02\x01"+
            "\x02\uffff\x01\x01\x04\uffff\x01\x01\x02\uffff\x01\x01\x01\uffff"+
            "\x01\x0d\x01\uffff\x03\x01",
            "\x01\x30\x01\x1f\x01\x2f\x02\x30\x01\x1a\x01\x20\x01\x18\x01"+
            "\x2e\x01\x22\x02\x30\x01\x2b\x01\x30\x01\x21\x01\x2c\x01\x24"+
            "\x01\x30\x01\x17\x05\x30\x01\x19\x01\x2d\x01\x29\x04\x30\x01"+
            "\x1e\x01\x28\x01\x1c\x01\x27\x01\x26\x01\x19\x01\x2a\x01\x1b"+
            "\x01\x2e\x01\x16\x01\x25\x01\x2e\x01\x23\x01\x1d\x03\x19\x01"+
            "\x14\x01\x15\x04\x19\x04\x01\x01\uffff\x01\x01\x03\uffff\x01"+
            "\x01\x07\uffff\x03\x01\x02\uffff\x02\x01\x06\uffff\x02\x01\x16"+
            "\uffff\x02\x01\x0e\uffff\x02\x01\x02\uffff\x01\x01\x04\uffff"+
            "\x01\x01\x02\uffff\x01\x01\x01\uffff\x01\x13\x01\uffff\x03\x01",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            ""
    };

    static readonly short[] DFA8_eot = DFA.UnpackEncodedString(DFA8_eotS);
    static readonly short[] DFA8_eof = DFA.UnpackEncodedString(DFA8_eofS);
    static readonly char[] DFA8_min = DFA.UnpackEncodedStringToUnsignedChars(DFA8_minS);
    static readonly char[] DFA8_max = DFA.UnpackEncodedStringToUnsignedChars(DFA8_maxS);
    static readonly short[] DFA8_accept = DFA.UnpackEncodedString(DFA8_acceptS);
    static readonly short[] DFA8_special = DFA.UnpackEncodedString(DFA8_specialS);
    static readonly short[][] DFA8_transition = DFA.UnpackEncodedStringArray(DFA8_transitionS);

    protected class DFA8 : DFA
    {
        public DFA8(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 8;
            this.eot = DFA8_eot;
            this.eof = DFA8_eof;
            this.min = DFA8_min;
            this.max = DFA8_max;
            this.accept = DFA8_accept;
            this.special = DFA8_special;
            this.transition = DFA8_transition;

        }

        override public string Description
        {
            get { return "()* loopback of 1548:80: ({...}? => (s= SUB | d= DOT | c= COLON ) {...}? => (I2= IDENTIFIER | allKeywords ) )*"; }
        }

    }


    protected internal int DFA8_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
            ITokenStream input = (ITokenStream)_input;
        int _s = s;
        switch ( s )
        {
                case 0 : 
                    int LA8_7 = input.LA(1);

                     
                    int index8_7 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( ((synpred9_AS3_ex() && (!promoteWhitespace()))) ) { s = 49; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index8_7);
                    if ( s >= 0 ) return s;
                    break;
                case 1 : 
                    int LA8_21 = input.LA(1);

                     
                    int index8_21 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( ((synpred9_AS3_ex() && (!promoteWhitespace()))) ) { s = 49; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index8_21);
                    if ( s >= 0 ) return s;
                    break;
                case 2 : 
                    int LA8_40 = input.LA(1);

                     
                    int index8_40 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( ((synpred9_AS3_ex() && (!promoteWhitespace()))) ) { s = 49; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index8_40);
                    if ( s >= 0 ) return s;
                    break;
                case 3 : 
                    int LA8_35 = input.LA(1);

                     
                    int index8_35 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( ((synpred9_AS3_ex() && (!promoteWhitespace()))) ) { s = 49; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index8_35);
                    if ( s >= 0 ) return s;
                    break;
                case 4 : 
                    int LA8_24 = input.LA(1);

                     
                    int index8_24 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( ((synpred9_AS3_ex() && (!promoteWhitespace()))) ) { s = 49; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index8_24);
                    if ( s >= 0 ) return s;
                    break;
                case 5 : 
                    int LA8_27 = input.LA(1);

                     
                    int index8_27 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( ((synpred9_AS3_ex() && (!promoteWhitespace()))) ) { s = 49; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index8_27);
                    if ( s >= 0 ) return s;
                    break;
                case 6 : 
                    int LA8_32 = input.LA(1);

                     
                    int index8_32 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( ((synpred9_AS3_ex() && (!promoteWhitespace()))) ) { s = 49; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index8_32);
                    if ( s >= 0 ) return s;
                    break;
                case 7 : 
                    int LA8_20 = input.LA(1);

                     
                    int index8_20 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( ((synpred9_AS3_ex() && (!promoteWhitespace()))) ) { s = 49; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index8_20);
                    if ( s >= 0 ) return s;
                    break;
                case 8 : 
                    int LA8_23 = input.LA(1);

                     
                    int index8_23 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( ((synpred9_AS3_ex() && (!promoteWhitespace()))) ) { s = 49; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index8_23);
                    if ( s >= 0 ) return s;
                    break;
                case 9 : 
                    int LA8_14 = input.LA(1);

                     
                    int index8_14 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( ((synpred9_AS3_ex() && (!promoteWhitespace()))) ) { s = 49; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index8_14);
                    if ( s >= 0 ) return s;
                    break;
                case 10 : 
                    int LA8_16 = input.LA(1);

                     
                    int index8_16 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( ((synpred9_AS3_ex() && (!promoteWhitespace()))) ) { s = 49; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index8_16);
                    if ( s >= 0 ) return s;
                    break;
                case 11 : 
                    int LA8_31 = input.LA(1);

                     
                    int index8_31 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( ((synpred9_AS3_ex() && (!promoteWhitespace()))) ) { s = 49; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index8_31);
                    if ( s >= 0 ) return s;
                    break;
                case 12 : 
                    int LA8_29 = input.LA(1);

                     
                    int index8_29 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( ((synpred9_AS3_ex() && (!promoteWhitespace()))) ) { s = 49; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index8_29);
                    if ( s >= 0 ) return s;
                    break;
                case 13 : 
                    int LA8_13 = input.LA(1);

                     
                    int index8_13 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( ((synpred9_AS3_ex() && (!promoteWhitespace()))) ) { s = 49; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index8_13);
                    if ( s >= 0 ) return s;
                    break;
                case 14 : 
                    int LA8_22 = input.LA(1);

                     
                    int index8_22 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( ((synpred9_AS3_ex() && (!promoteWhitespace()))) ) { s = 49; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index8_22);
                    if ( s >= 0 ) return s;
                    break;
                case 15 : 
                    int LA8_42 = input.LA(1);

                     
                    int index8_42 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( ((synpred9_AS3_ex() && (!promoteWhitespace()))) ) { s = 49; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index8_42);
                    if ( s >= 0 ) return s;
                    break;
                case 16 : 
                    int LA8_38 = input.LA(1);

                     
                    int index8_38 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( ((synpred9_AS3_ex() && (!promoteWhitespace()))) ) { s = 49; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index8_38);
                    if ( s >= 0 ) return s;
                    break;
                case 17 : 
                    int LA8_46 = input.LA(1);

                     
                    int index8_46 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( ((synpred9_AS3_ex() && (!promoteWhitespace()))) ) { s = 49; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index8_46);
                    if ( s >= 0 ) return s;
                    break;
                case 18 : 
                    int LA8_10 = input.LA(1);

                     
                    int index8_10 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( ((synpred9_AS3_ex() && (!promoteWhitespace()))) ) { s = 49; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index8_10);
                    if ( s >= 0 ) return s;
                    break;
                case 19 : 
                    int LA8_11 = input.LA(1);

                     
                    int index8_11 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( ((synpred9_AS3_ex() && (!promoteWhitespace()))) ) { s = 49; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index8_11);
                    if ( s >= 0 ) return s;
                    break;
                case 20 : 
                    int LA8_30 = input.LA(1);

                     
                    int index8_30 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( ((synpred9_AS3_ex() && (!promoteWhitespace()))) ) { s = 49; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index8_30);
                    if ( s >= 0 ) return s;
                    break;
                case 21 : 
                    int LA8_36 = input.LA(1);

                     
                    int index8_36 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( ((synpred9_AS3_ex() && (!promoteWhitespace()))) ) { s = 49; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index8_36);
                    if ( s >= 0 ) return s;
                    break;
                case 22 : 
                    int LA8_26 = input.LA(1);

                     
                    int index8_26 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( ((synpred9_AS3_ex() && (!promoteWhitespace()))) ) { s = 49; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index8_26);
                    if ( s >= 0 ) return s;
                    break;
                case 23 : 
                    int LA8_33 = input.LA(1);

                     
                    int index8_33 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( ((synpred9_AS3_ex() && (!promoteWhitespace()))) ) { s = 49; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index8_33);
                    if ( s >= 0 ) return s;
                    break;
                case 24 : 
                    int LA8_48 = input.LA(1);

                     
                    int index8_48 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( ((synpred9_AS3_ex() && (!promoteWhitespace()))) ) { s = 49; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index8_48);
                    if ( s >= 0 ) return s;
                    break;
                case 25 : 
                    int LA8_18 = input.LA(1);

                     
                    int index8_18 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( ((synpred9_AS3_ex() && (!promoteWhitespace()))) ) { s = 49; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index8_18);
                    if ( s >= 0 ) return s;
                    break;
                case 26 : 
                    int LA8_19 = input.LA(1);

                     
                    int index8_19 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( ((synpred9_AS3_ex() && (!promoteWhitespace()))) ) { s = 49; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index8_19);
                    if ( s >= 0 ) return s;
                    break;
                case 27 : 
                    int LA8_9 = input.LA(1);

                     
                    int index8_9 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( ((synpred9_AS3_ex() && (!promoteWhitespace()))) ) { s = 49; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index8_9);
                    if ( s >= 0 ) return s;
                    break;
                case 28 : 
                    int LA8_41 = input.LA(1);

                     
                    int index8_41 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( ((synpred9_AS3_ex() && (!promoteWhitespace()))) ) { s = 49; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index8_41);
                    if ( s >= 0 ) return s;
                    break;
                case 29 : 
                    int LA8_12 = input.LA(1);

                     
                    int index8_12 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( ((synpred9_AS3_ex() && (!promoteWhitespace()))) ) { s = 49; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index8_12);
                    if ( s >= 0 ) return s;
                    break;
                case 30 : 
                    int LA8_37 = input.LA(1);

                     
                    int index8_37 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( ((synpred9_AS3_ex() && (!promoteWhitespace()))) ) { s = 49; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index8_37);
                    if ( s >= 0 ) return s;
                    break;
                case 31 : 
                    int LA8_5 = input.LA(1);

                     
                    int index8_5 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( ((synpred9_AS3_ex() && (!promoteWhitespace()))) ) { s = 49; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index8_5);
                    if ( s >= 0 ) return s;
                    break;
                case 32 : 
                    int LA8_28 = input.LA(1);

                     
                    int index8_28 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( ((synpred9_AS3_ex() && (!promoteWhitespace()))) ) { s = 49; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index8_28);
                    if ( s >= 0 ) return s;
                    break;
                case 33 : 
                    int LA8_17 = input.LA(1);

                     
                    int index8_17 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( ((synpred9_AS3_ex() && (!promoteWhitespace()))) ) { s = 49; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index8_17);
                    if ( s >= 0 ) return s;
                    break;
                case 34 : 
                    int LA8_25 = input.LA(1);

                     
                    int index8_25 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( ((synpred9_AS3_ex() && (!promoteWhitespace()))) ) { s = 49; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index8_25);
                    if ( s >= 0 ) return s;
                    break;
                case 35 : 
                    int LA8_45 = input.LA(1);

                     
                    int index8_45 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( ((synpred9_AS3_ex() && (!promoteWhitespace()))) ) { s = 49; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index8_45);
                    if ( s >= 0 ) return s;
                    break;
                case 36 : 
                    int LA8_43 = input.LA(1);

                     
                    int index8_43 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( ((synpred9_AS3_ex() && (!promoteWhitespace()))) ) { s = 49; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index8_43);
                    if ( s >= 0 ) return s;
                    break;
                case 37 : 
                    int LA8_44 = input.LA(1);

                     
                    int index8_44 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( ((synpred9_AS3_ex() && (!promoteWhitespace()))) ) { s = 49; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index8_44);
                    if ( s >= 0 ) return s;
                    break;
                case 38 : 
                    int LA8_6 = input.LA(1);

                     
                    int index8_6 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( ((synpred9_AS3_ex() && (!promoteWhitespace()))) ) { s = 49; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index8_6);
                    if ( s >= 0 ) return s;
                    break;
                case 39 : 
                    int LA8_47 = input.LA(1);

                     
                    int index8_47 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( ((synpred9_AS3_ex() && (!promoteWhitespace()))) ) { s = 49; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index8_47);
                    if ( s >= 0 ) return s;
                    break;
                case 40 : 
                    int LA8_39 = input.LA(1);

                     
                    int index8_39 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( ((synpred9_AS3_ex() && (!promoteWhitespace()))) ) { s = 49; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index8_39);
                    if ( s >= 0 ) return s;
                    break;
                case 41 : 
                    int LA8_34 = input.LA(1);

                     
                    int index8_34 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( ((synpred9_AS3_ex() && (!promoteWhitespace()))) ) { s = 49; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index8_34);
                    if ( s >= 0 ) return s;
                    break;
                case 42 : 
                    int LA8_8 = input.LA(1);

                     
                    int index8_8 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( ((synpred9_AS3_ex() && (!promoteWhitespace()))) ) { s = 49; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index8_8);
                    if ( s >= 0 ) return s;
                    break;
                case 43 : 
                    int LA8_15 = input.LA(1);

                     
                    int index8_15 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( ((synpred9_AS3_ex() && (!promoteWhitespace()))) ) { s = 49; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index8_15);
                    if ( s >= 0 ) return s;
                    break;
        }
        if (state.backtracking > 0) {state.failed = true; return -1;}
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 8, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA34_eotS =
        "\x39\uffff";
    const string DFA34_eofS =
        "\x01\x01\x38\uffff";
    const string DFA34_minS =
        "\x01\x04\x02\uffff\x08\x00\x01\uffff\x05\x00\x28\uffff";
    const string DFA34_maxS =
        "\x01\u0092\x02\uffff\x08\x00\x01\uffff\x05\x00\x28\uffff";
    const string DFA34_acceptS =
        "\x01\uffff\x01\x07\x09\uffff\x01\x04\x28\uffff\x01\x01\x01\x02"+
        "\x01\x03\x01\x06\x01\x05";
    const string DFA34_specialS =
        "\x03\uffff\x01\x00\x01\x01\x01\x02\x01\x03\x01\x04\x01\x05\x01"+
        "\x06\x01\x07\x01\uffff\x01\x08\x01\x09\x01\x0a\x01\x0b\x01\x0c\x28"+
        "\uffff}>";
    static readonly string[] DFA34_transitionS = {
            "\x05\x0b\x01\x08\x01\x0b\x01\x10\x07\x0b\x01\x0a\x02\x0b\x01"+
            "\x0f\x03\x0b\x01\x06\x01\x0b\x01\x04\x03\x0b\x03\x06\x05\x0b"+
            "\x01\x09\x03\x0b\x01\x0e\x01\x07\x03\x0b\x03\x09\x01\x05\x01"+
            "\x0d\x04\x04\x02\x0b\x01\x01\x01\x0b\x01\uffff\x01\x0c\x03\uffff"+
            "\x01\x0b\x07\uffff\x03\x0b\x02\uffff\x02\x0b\x06\uffff\x02\x0b"+
            "\x16\uffff\x02\x0b\x0e\uffff\x02\x0b\x02\uffff\x01\x0b\x04\uffff"+
            "\x01\x0b\x02\uffff\x01\x0b\x01\uffff\x01\x03\x01\uffff\x03\x0b",
            "",
            "",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
    };

    static readonly short[] DFA34_eot = DFA.UnpackEncodedString(DFA34_eotS);
    static readonly short[] DFA34_eof = DFA.UnpackEncodedString(DFA34_eofS);
    static readonly char[] DFA34_min = DFA.UnpackEncodedStringToUnsignedChars(DFA34_minS);
    static readonly char[] DFA34_max = DFA.UnpackEncodedStringToUnsignedChars(DFA34_maxS);
    static readonly short[] DFA34_accept = DFA.UnpackEncodedString(DFA34_acceptS);
    static readonly short[] DFA34_special = DFA.UnpackEncodedString(DFA34_specialS);
    static readonly short[][] DFA34_transition = DFA.UnpackEncodedStringArray(DFA34_transitionS);

    protected class DFA34 : DFA
    {
        public DFA34(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 34;
            this.eot = DFA34_eot;
            this.eof = DFA34_eof;
            this.min = DFA34_min;
            this.max = DFA34_max;
            this.accept = DFA34_accept;
            this.special = DFA34_special;
            this.transition = DFA34_transition;

        }

        override public string Description
        {
            get { return "()* loopback of 1849:3: ( conditionalCompilerOption l= LCURLY mxmlEmbedded r= RCURLY | propertyDeclaration | functionDeclaration | statement | directive | interfaceFunctionDeclaration )*"; }
        }

    }


    protected internal int DFA34_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
            ITokenStream input = (ITokenStream)_input;
        int _s = s;
        switch ( s )
        {
                case 0 : 
                    int LA34_3 = input.LA(1);

                     
                    int index34_3 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred96_AS3_ex()) ) { s = 52; }

                    else if ( (synpred97_AS3_ex()) ) { s = 53; }

                    else if ( (synpred98_AS3_ex()) ) { s = 54; }

                    else if ( (synpred99_AS3_ex()) ) { s = 11; }

                    else if ( (synpred101_AS3_ex()) ) { s = 55; }

                     
                    input.Seek(index34_3);
                    if ( s >= 0 ) return s;
                    break;
                case 1 : 
                    int LA34_4 = input.LA(1);

                     
                    int index34_4 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred96_AS3_ex()) ) { s = 52; }

                    else if ( (synpred97_AS3_ex()) ) { s = 53; }

                    else if ( (synpred98_AS3_ex()) ) { s = 54; }

                    else if ( (synpred99_AS3_ex()) ) { s = 11; }

                    else if ( (synpred101_AS3_ex()) ) { s = 55; }

                     
                    input.Seek(index34_4);
                    if ( s >= 0 ) return s;
                    break;
                case 2 : 
                    int LA34_5 = input.LA(1);

                     
                    int index34_5 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred96_AS3_ex()) ) { s = 52; }

                    else if ( (synpred97_AS3_ex()) ) { s = 53; }

                    else if ( (synpred98_AS3_ex()) ) { s = 54; }

                    else if ( (synpred99_AS3_ex()) ) { s = 11; }

                    else if ( (synpred101_AS3_ex()) ) { s = 55; }

                     
                    input.Seek(index34_5);
                    if ( s >= 0 ) return s;
                    break;
                case 3 : 
                    int LA34_6 = input.LA(1);

                     
                    int index34_6 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred97_AS3_ex()) ) { s = 53; }

                    else if ( (synpred98_AS3_ex()) ) { s = 54; }

                    else if ( (synpred99_AS3_ex()) ) { s = 11; }

                    else if ( (synpred101_AS3_ex()) ) { s = 55; }

                     
                    input.Seek(index34_6);
                    if ( s >= 0 ) return s;
                    break;
                case 4 : 
                    int LA34_7 = input.LA(1);

                     
                    int index34_7 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred97_AS3_ex()) ) { s = 53; }

                    else if ( (synpred99_AS3_ex()) ) { s = 11; }

                     
                    input.Seek(index34_7);
                    if ( s >= 0 ) return s;
                    break;
                case 5 : 
                    int LA34_8 = input.LA(1);

                     
                    int index34_8 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred97_AS3_ex()) ) { s = 53; }

                    else if ( (synpred99_AS3_ex()) ) { s = 11; }

                     
                    input.Seek(index34_8);
                    if ( s >= 0 ) return s;
                    break;
                case 6 : 
                    int LA34_9 = input.LA(1);

                     
                    int index34_9 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred96_AS3_ex()) ) { s = 52; }

                    else if ( (synpred97_AS3_ex()) ) { s = 53; }

                    else if ( (synpred98_AS3_ex()) ) { s = 54; }

                    else if ( (synpred99_AS3_ex()) ) { s = 11; }

                    else if ( (synpred101_AS3_ex()) ) { s = 55; }

                     
                    input.Seek(index34_9);
                    if ( s >= 0 ) return s;
                    break;
                case 7 : 
                    int LA34_10 = input.LA(1);

                     
                    int index34_10 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred98_AS3_ex()) ) { s = 54; }

                    else if ( (synpred99_AS3_ex()) ) { s = 11; }

                    else if ( (synpred101_AS3_ex()) ) { s = 55; }

                     
                    input.Seek(index34_10);
                    if ( s >= 0 ) return s;
                    break;
                case 8 : 
                    int LA34_12 = input.LA(1);

                     
                    int index34_12 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred99_AS3_ex()) ) { s = 11; }

                    else if ( (synpred100_AS3_ex()) ) { s = 56; }

                     
                    input.Seek(index34_12);
                    if ( s >= 0 ) return s;
                    break;
                case 9 : 
                    int LA34_13 = input.LA(1);

                     
                    int index34_13 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred99_AS3_ex()) ) { s = 11; }

                    else if ( (synpred100_AS3_ex()) ) { s = 56; }

                     
                    input.Seek(index34_13);
                    if ( s >= 0 ) return s;
                    break;
                case 10 : 
                    int LA34_14 = input.LA(1);

                     
                    int index34_14 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred99_AS3_ex()) ) { s = 11; }

                    else if ( (synpred100_AS3_ex()) ) { s = 56; }

                     
                    input.Seek(index34_14);
                    if ( s >= 0 ) return s;
                    break;
                case 11 : 
                    int LA34_15 = input.LA(1);

                     
                    int index34_15 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred99_AS3_ex()) ) { s = 11; }

                    else if ( (synpred100_AS3_ex()) ) { s = 56; }

                     
                    input.Seek(index34_15);
                    if ( s >= 0 ) return s;
                    break;
                case 12 : 
                    int LA34_16 = input.LA(1);

                     
                    int index34_16 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred99_AS3_ex()) ) { s = 11; }

                    else if ( (synpred100_AS3_ex()) ) { s = 56; }

                     
                    input.Seek(index34_16);
                    if ( s >= 0 ) return s;
                    break;
        }
        if (state.backtracking > 0) {state.failed = true; return -1;}
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 34, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA37_eotS =
        "\x3a\uffff";
    const string DFA37_eofS =
        "\x3a\uffff";
    const string DFA37_minS =
        "\x01\x04\x0a\x00\x01\uffff\x05\x00\x29\uffff";
    const string DFA37_maxS =
        "\x01\u0092\x0a\x00\x01\uffff\x05\x00\x29\uffff";
    const string DFA37_acceptS =
        "\x0b\uffff\x01\x06\x28\uffff\x01\x01\x01\x02\x01\x03\x01\x04\x01"+
        "\x05\x01\x07";
    const string DFA37_specialS =
        "\x01\uffff\x01\x00\x01\x01\x01\x02\x01\x03\x01\x04\x01\x05\x01"+
        "\x06\x01\x07\x01\x08\x01\x09\x01\uffff\x01\x0a\x01\x0b\x01\x0c\x01"+
        "\x0d\x01\x0e\x29\uffff}>";
    static readonly string[] DFA37_transitionS = {
            "\x04\x0b\x01\x06\x01\x08\x01\x0b\x01\x10\x07\x0b\x01\x0a\x02"+
            "\x0b\x01\x0f\x02\x0b\x01\x05\x01\x04\x01\x0b\x01\x02\x03\x0b"+
            "\x03\x04\x05\x0b\x01\x09\x03\x0b\x01\x0e\x01\x07\x03\x0b\x03"+
            "\x09\x01\x03\x01\x0d\x04\x02\x02\x0b\x01\uffff\x01\x0b\x01\uffff"+
            "\x01\x0c\x03\uffff\x01\x0b\x07\uffff\x03\x0b\x02\uffff\x02\x0b"+
            "\x06\uffff\x02\x0b\x16\uffff\x02\x0b\x0e\uffff\x02\x0b\x02\uffff"+
            "\x01\x0b\x04\uffff\x01\x0b\x02\uffff\x01\x0b\x01\uffff\x01\x01"+
            "\x01\uffff\x03\x0b",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
    };

    static readonly short[] DFA37_eot = DFA.UnpackEncodedString(DFA37_eotS);
    static readonly short[] DFA37_eof = DFA.UnpackEncodedString(DFA37_eofS);
    static readonly char[] DFA37_min = DFA.UnpackEncodedStringToUnsignedChars(DFA37_minS);
    static readonly char[] DFA37_max = DFA.UnpackEncodedStringToUnsignedChars(DFA37_maxS);
    static readonly short[] DFA37_accept = DFA.UnpackEncodedString(DFA37_acceptS);
    static readonly short[] DFA37_special = DFA.UnpackEncodedString(DFA37_specialS);
    static readonly short[][] DFA37_transition = DFA.UnpackEncodedStringArray(DFA37_transitionS);

    protected class DFA37 : DFA
    {
        public DFA37(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 37;
            this.eot = DFA37_eot;
            this.eof = DFA37_eof;
            this.min = DFA37_min;
            this.max = DFA37_max;
            this.accept = DFA37_accept;
            this.special = DFA37_special;
            this.transition = DFA37_transition;

        }

        override public string Description
        {
            get { return "1864:1: packageElement : ( conditionalCompilerOption l= LCURLY ( packageElement )* r= RCURLY | classOrInterfaceDecl | propertyDeclaration | functionDeclaration | interfaceFunctionDeclaration | statement | directive );"; }
        }

    }


    protected internal int DFA37_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
            ITokenStream input = (ITokenStream)_input;
        int _s = s;
        switch ( s )
        {
                case 0 : 
                    int LA37_1 = input.LA(1);

                     
                    int index37_1 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred104_AS3_ex()) ) { s = 52; }

                    else if ( (synpred105_AS3_ex()) ) { s = 53; }

                    else if ( (synpred106_AS3_ex()) ) { s = 54; }

                    else if ( (synpred107_AS3_ex()) ) { s = 55; }

                    else if ( (synpred108_AS3_ex()) ) { s = 56; }

                    else if ( (synpred109_AS3_ex()) ) { s = 11; }

                     
                    input.Seek(index37_1);
                    if ( s >= 0 ) return s;
                    break;
                case 1 : 
                    int LA37_2 = input.LA(1);

                     
                    int index37_2 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred104_AS3_ex()) ) { s = 52; }

                    else if ( (synpred105_AS3_ex()) ) { s = 53; }

                    else if ( (synpred106_AS3_ex()) ) { s = 54; }

                    else if ( (synpred107_AS3_ex()) ) { s = 55; }

                    else if ( (synpred108_AS3_ex()) ) { s = 56; }

                    else if ( (synpred109_AS3_ex()) ) { s = 11; }

                     
                    input.Seek(index37_2);
                    if ( s >= 0 ) return s;
                    break;
                case 2 : 
                    int LA37_3 = input.LA(1);

                     
                    int index37_3 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred104_AS3_ex()) ) { s = 52; }

                    else if ( (synpred105_AS3_ex()) ) { s = 53; }

                    else if ( (synpred106_AS3_ex()) ) { s = 54; }

                    else if ( (synpred107_AS3_ex()) ) { s = 55; }

                    else if ( (synpred108_AS3_ex()) ) { s = 56; }

                    else if ( (synpred109_AS3_ex()) ) { s = 11; }

                     
                    input.Seek(index37_3);
                    if ( s >= 0 ) return s;
                    break;
                case 3 : 
                    int LA37_4 = input.LA(1);

                     
                    int index37_4 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred105_AS3_ex()) ) { s = 53; }

                    else if ( (synpred106_AS3_ex()) ) { s = 54; }

                    else if ( (synpred107_AS3_ex()) ) { s = 55; }

                    else if ( (synpred108_AS3_ex()) ) { s = 56; }

                    else if ( (synpred109_AS3_ex()) ) { s = 11; }

                     
                    input.Seek(index37_4);
                    if ( s >= 0 ) return s;
                    break;
                case 4 : 
                    int LA37_5 = input.LA(1);

                     
                    int index37_5 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred105_AS3_ex()) ) { s = 53; }

                    else if ( (synpred109_AS3_ex()) ) { s = 11; }

                     
                    input.Seek(index37_5);
                    if ( s >= 0 ) return s;
                    break;
                case 5 : 
                    int LA37_6 = input.LA(1);

                     
                    int index37_6 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred105_AS3_ex()) ) { s = 53; }

                    else if ( (synpred109_AS3_ex()) ) { s = 11; }

                     
                    input.Seek(index37_6);
                    if ( s >= 0 ) return s;
                    break;
                case 6 : 
                    int LA37_7 = input.LA(1);

                     
                    int index37_7 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred106_AS3_ex()) ) { s = 54; }

                    else if ( (synpred109_AS3_ex()) ) { s = 11; }

                     
                    input.Seek(index37_7);
                    if ( s >= 0 ) return s;
                    break;
                case 7 : 
                    int LA37_8 = input.LA(1);

                     
                    int index37_8 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred106_AS3_ex()) ) { s = 54; }

                    else if ( (synpred109_AS3_ex()) ) { s = 11; }

                     
                    input.Seek(index37_8);
                    if ( s >= 0 ) return s;
                    break;
                case 8 : 
                    int LA37_9 = input.LA(1);

                     
                    int index37_9 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred104_AS3_ex()) ) { s = 52; }

                    else if ( (synpred105_AS3_ex()) ) { s = 53; }

                    else if ( (synpred106_AS3_ex()) ) { s = 54; }

                    else if ( (synpred107_AS3_ex()) ) { s = 55; }

                    else if ( (synpred108_AS3_ex()) ) { s = 56; }

                    else if ( (synpred109_AS3_ex()) ) { s = 11; }

                     
                    input.Seek(index37_9);
                    if ( s >= 0 ) return s;
                    break;
                case 9 : 
                    int LA37_10 = input.LA(1);

                     
                    int index37_10 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred107_AS3_ex()) ) { s = 55; }

                    else if ( (synpred108_AS3_ex()) ) { s = 56; }

                    else if ( (synpred109_AS3_ex()) ) { s = 11; }

                     
                    input.Seek(index37_10);
                    if ( s >= 0 ) return s;
                    break;
                case 10 : 
                    int LA37_12 = input.LA(1);

                     
                    int index37_12 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred109_AS3_ex()) ) { s = 11; }

                    else if ( (true) ) { s = 57; }

                     
                    input.Seek(index37_12);
                    if ( s >= 0 ) return s;
                    break;
                case 11 : 
                    int LA37_13 = input.LA(1);

                     
                    int index37_13 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred109_AS3_ex()) ) { s = 11; }

                    else if ( (true) ) { s = 57; }

                     
                    input.Seek(index37_13);
                    if ( s >= 0 ) return s;
                    break;
                case 12 : 
                    int LA37_14 = input.LA(1);

                     
                    int index37_14 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred109_AS3_ex()) ) { s = 11; }

                    else if ( (true) ) { s = 57; }

                     
                    input.Seek(index37_14);
                    if ( s >= 0 ) return s;
                    break;
                case 13 : 
                    int LA37_15 = input.LA(1);

                     
                    int index37_15 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred109_AS3_ex()) ) { s = 11; }

                    else if ( (true) ) { s = 57; }

                     
                    input.Seek(index37_15);
                    if ( s >= 0 ) return s;
                    break;
                case 14 : 
                    int LA37_16 = input.LA(1);

                     
                    int index37_16 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred109_AS3_ex()) ) { s = 11; }

                    else if ( (true) ) { s = 57; }

                     
                    input.Seek(index37_16);
                    if ( s >= 0 ) return s;
                    break;
        }
        if (state.backtracking > 0) {state.failed = true; return -1;}
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 37, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA49_eotS =
        "\x0d\uffff";
    const string DFA49_eofS =
        "\x0d\uffff";
    const string DFA49_minS =
        "\x01\x04\x05\x00\x07\uffff";
    const string DFA49_maxS =
        "\x01\u008e\x05\x00\x07\uffff";
    const string DFA49_acceptS =
        "\x06\uffff\x01\x02\x05\uffff\x01\x01";
    const string DFA49_specialS =
        "\x01\uffff\x01\x00\x01\x01\x01\x02\x01\x03\x01\x04\x07\uffff}>";
    static readonly string[] DFA49_transitionS = {
            "\x18\x03\x01\x04\x0b\x03\x01\x04\x08\x03\x04\x04\x01\x03\x04"+
            "\x04\x11\uffff\x02\x06\x01\x05\x22\uffff\x01\x02\x0f\uffff\x02"+
            "\x06\x07\uffff\x01\x06\x02\uffff\x01\x06\x01\uffff\x01\x01",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
    };

    static readonly short[] DFA49_eot = DFA.UnpackEncodedString(DFA49_eotS);
    static readonly short[] DFA49_eof = DFA.UnpackEncodedString(DFA49_eofS);
    static readonly char[] DFA49_min = DFA.UnpackEncodedStringToUnsignedChars(DFA49_minS);
    static readonly char[] DFA49_max = DFA.UnpackEncodedStringToUnsignedChars(DFA49_maxS);
    static readonly short[] DFA49_accept = DFA.UnpackEncodedString(DFA49_acceptS);
    static readonly short[] DFA49_special = DFA.UnpackEncodedString(DFA49_specialS);
    static readonly short[][] DFA49_transition = DFA.UnpackEncodedStringArray(DFA49_transitionS);

    protected class DFA49 : DFA
    {
        public DFA49(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 49;
            this.eot = DFA49_eot;
            this.eof = DFA49_eof;
            this.min = DFA49_min;
            this.max = DFA49_max;
            this.accept = DFA49_accept;
            this.special = DFA49_special;
            this.transition = DFA49_transition;

        }

        override public string Description
        {
            get { return "1993:5: ( eitherIdentifier E= ASSIGN )?"; }
        }

    }


    protected internal int DFA49_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
            ITokenStream input = (ITokenStream)_input;
        int _s = s;
        switch ( s )
        {
                case 0 : 
                    int LA49_1 = input.LA(1);

                     
                    int index49_1 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred124_AS3_ex()) ) { s = 12; }

                    else if ( (true) ) { s = 6; }

                     
                    input.Seek(index49_1);
                    if ( s >= 0 ) return s;
                    break;
                case 1 : 
                    int LA49_2 = input.LA(1);

                     
                    int index49_2 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred124_AS3_ex()) ) { s = 12; }

                    else if ( (true) ) { s = 6; }

                     
                    input.Seek(index49_2);
                    if ( s >= 0 ) return s;
                    break;
                case 2 : 
                    int LA49_3 = input.LA(1);

                     
                    int index49_3 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred124_AS3_ex()) ) { s = 12; }

                    else if ( (true) ) { s = 6; }

                     
                    input.Seek(index49_3);
                    if ( s >= 0 ) return s;
                    break;
                case 3 : 
                    int LA49_4 = input.LA(1);

                     
                    int index49_4 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred124_AS3_ex()) ) { s = 12; }

                    else if ( (true) ) { s = 6; }

                     
                    input.Seek(index49_4);
                    if ( s >= 0 ) return s;
                    break;
                case 4 : 
                    int LA49_5 = input.LA(1);

                     
                    int index49_5 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred124_AS3_ex()) ) { s = 12; }

                    else if ( (true) ) { s = 6; }

                     
                    input.Seek(index49_5);
                    if ( s >= 0 ) return s;
                    break;
        }
        if (state.backtracking > 0) {state.failed = true; return -1;}
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 49, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA59_eotS =
        "\x36\uffff";
    const string DFA59_eofS =
        "\x36\uffff";
    const string DFA59_minS =
        "\x01\x04\x08\x00\x01\uffff\x05\x00\x27\uffff";
    const string DFA59_maxS =
        "\x01\u0092\x08\x00\x01\uffff\x05\x00\x27\uffff";
    const string DFA59_acceptS =
        "\x09\uffff\x01\x04\x28\uffff\x01\x01\x01\x02\x01\x03\x01\x05";
    const string DFA59_specialS =
        "\x01\uffff\x01\x00\x01\x01\x01\x02\x01\x03\x01\x04\x01\x05\x01"+
        "\x06\x01\x07\x01\uffff\x01\x08\x01\x09\x01\x0a\x01\x0b\x01\x0c\x27"+
        "\uffff}>";
    static readonly string[] DFA59_transitionS = {
            "\x05\x09\x01\x06\x01\x09\x01\x0e\x07\x09\x01\x08\x02\x09\x01"+
            "\x0d\x03\x09\x01\x04\x01\x09\x01\x02\x03\x09\x03\x04\x05\x09"+
            "\x01\x07\x03\x09\x01\x0c\x01\x05\x03\x09\x03\x07\x01\x03\x01"+
            "\x0b\x04\x02\x02\x09\x01\uffff\x01\x09\x01\uffff\x01\x0a\x03"+
            "\uffff\x01\x09\x07\uffff\x03\x09\x02\uffff\x02\x09\x06\uffff"+
            "\x02\x09\x16\uffff\x02\x09\x0e\uffff\x02\x09\x02\uffff\x01\x09"+
            "\x04\uffff\x01\x09\x02\uffff\x01\x09\x01\uffff\x01\x01\x01\uffff"+
            "\x03\x09",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
    };

    static readonly short[] DFA59_eot = DFA.UnpackEncodedString(DFA59_eotS);
    static readonly short[] DFA59_eof = DFA.UnpackEncodedString(DFA59_eofS);
    static readonly char[] DFA59_min = DFA.UnpackEncodedStringToUnsignedChars(DFA59_minS);
    static readonly char[] DFA59_max = DFA.UnpackEncodedStringToUnsignedChars(DFA59_maxS);
    static readonly short[] DFA59_accept = DFA.UnpackEncodedString(DFA59_acceptS);
    static readonly short[] DFA59_special = DFA.UnpackEncodedString(DFA59_specialS);
    static readonly short[][] DFA59_transition = DFA.UnpackEncodedStringArray(DFA59_transitionS);

    protected class DFA59 : DFA
    {
        public DFA59(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 59;
            this.eot = DFA59_eot;
            this.eof = DFA59_eof;
            this.min = DFA59_min;
            this.max = DFA59_max;
            this.accept = DFA59_accept;
            this.special = DFA59_special;
            this.transition = DFA59_transition;

        }

        override public string Description
        {
            get { return "2075:1: classBodyElement : ( ( conditionalCompilerOption LCURLY )=> conditionalCompilerOption l= LCURLY ( classBodyElement )* r= RCURLY | propertyDeclaration | functionDeclaration | statement | directive );"; }
        }

    }


    protected internal int DFA59_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
            ITokenStream input = (ITokenStream)_input;
        int _s = s;
        switch ( s )
        {
                case 0 : 
                    int LA59_1 = input.LA(1);

                     
                    int index59_1 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred135_AS3_ex()) ) { s = 50; }

                    else if ( (synpred137_AS3_ex()) ) { s = 51; }

                    else if ( (synpred138_AS3_ex()) ) { s = 52; }

                    else if ( (synpred139_AS3_ex()) ) { s = 9; }

                     
                    input.Seek(index59_1);
                    if ( s >= 0 ) return s;
                    break;
                case 1 : 
                    int LA59_2 = input.LA(1);

                     
                    int index59_2 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred135_AS3_ex()) ) { s = 50; }

                    else if ( (synpred137_AS3_ex()) ) { s = 51; }

                    else if ( (synpred138_AS3_ex()) ) { s = 52; }

                    else if ( (synpred139_AS3_ex()) ) { s = 9; }

                     
                    input.Seek(index59_2);
                    if ( s >= 0 ) return s;
                    break;
                case 2 : 
                    int LA59_3 = input.LA(1);

                     
                    int index59_3 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred135_AS3_ex()) ) { s = 50; }

                    else if ( (synpred137_AS3_ex()) ) { s = 51; }

                    else if ( (synpred138_AS3_ex()) ) { s = 52; }

                    else if ( (synpred139_AS3_ex()) ) { s = 9; }

                     
                    input.Seek(index59_3);
                    if ( s >= 0 ) return s;
                    break;
                case 3 : 
                    int LA59_4 = input.LA(1);

                     
                    int index59_4 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred137_AS3_ex()) ) { s = 51; }

                    else if ( (synpred138_AS3_ex()) ) { s = 52; }

                    else if ( (synpred139_AS3_ex()) ) { s = 9; }

                     
                    input.Seek(index59_4);
                    if ( s >= 0 ) return s;
                    break;
                case 4 : 
                    int LA59_5 = input.LA(1);

                     
                    int index59_5 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred137_AS3_ex()) ) { s = 51; }

                    else if ( (synpred139_AS3_ex()) ) { s = 9; }

                     
                    input.Seek(index59_5);
                    if ( s >= 0 ) return s;
                    break;
                case 5 : 
                    int LA59_6 = input.LA(1);

                     
                    int index59_6 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred137_AS3_ex()) ) { s = 51; }

                    else if ( (synpred139_AS3_ex()) ) { s = 9; }

                     
                    input.Seek(index59_6);
                    if ( s >= 0 ) return s;
                    break;
                case 6 : 
                    int LA59_7 = input.LA(1);

                     
                    int index59_7 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred135_AS3_ex()) ) { s = 50; }

                    else if ( (synpred137_AS3_ex()) ) { s = 51; }

                    else if ( (synpred138_AS3_ex()) ) { s = 52; }

                    else if ( (synpred139_AS3_ex()) ) { s = 9; }

                     
                    input.Seek(index59_7);
                    if ( s >= 0 ) return s;
                    break;
                case 7 : 
                    int LA59_8 = input.LA(1);

                     
                    int index59_8 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred138_AS3_ex()) ) { s = 52; }

                    else if ( (synpred139_AS3_ex()) ) { s = 9; }

                     
                    input.Seek(index59_8);
                    if ( s >= 0 ) return s;
                    break;
                case 8 : 
                    int LA59_10 = input.LA(1);

                     
                    int index59_10 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred139_AS3_ex()) ) { s = 9; }

                    else if ( (true) ) { s = 53; }

                     
                    input.Seek(index59_10);
                    if ( s >= 0 ) return s;
                    break;
                case 9 : 
                    int LA59_11 = input.LA(1);

                     
                    int index59_11 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred139_AS3_ex()) ) { s = 9; }

                    else if ( (true) ) { s = 53; }

                     
                    input.Seek(index59_11);
                    if ( s >= 0 ) return s;
                    break;
                case 10 : 
                    int LA59_12 = input.LA(1);

                     
                    int index59_12 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred139_AS3_ex()) ) { s = 9; }

                    else if ( (true) ) { s = 53; }

                     
                    input.Seek(index59_12);
                    if ( s >= 0 ) return s;
                    break;
                case 11 : 
                    int LA59_13 = input.LA(1);

                     
                    int index59_13 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred139_AS3_ex()) ) { s = 9; }

                    else if ( (true) ) { s = 53; }

                     
                    input.Seek(index59_13);
                    if ( s >= 0 ) return s;
                    break;
                case 12 : 
                    int LA59_14 = input.LA(1);

                     
                    int index59_14 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred139_AS3_ex()) ) { s = 9; }

                    else if ( (true) ) { s = 53; }

                     
                    input.Seek(index59_14);
                    if ( s >= 0 ) return s;
                    break;
        }
        if (state.backtracking > 0) {state.failed = true; return -1;}
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 59, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA61_eotS =
        "\x36\uffff";
    const string DFA61_eofS =
        "\x36\uffff";
    const string DFA61_minS =
        "\x01\x04\x08\x00\x01\uffff\x05\x00\x27\uffff";
    const string DFA61_maxS =
        "\x01\u0092\x08\x00\x01\uffff\x05\x00\x27\uffff";
    const string DFA61_acceptS =
        "\x09\uffff\x01\x04\x28\uffff\x01\x01\x01\x02\x01\x03\x01\x05";
    const string DFA61_specialS =
        "\x01\uffff\x01\x00\x01\x01\x01\x02\x01\x03\x01\x04\x01\x05\x01"+
        "\x06\x01\x07\x01\uffff\x01\x08\x01\x09\x01\x0a\x01\x0b\x01\x0c\x27"+
        "\uffff}>";
    static readonly string[] DFA61_transitionS = {
            "\x05\x09\x01\x06\x01\x09\x01\x0e\x07\x09\x01\x08\x02\x09\x01"+
            "\x0d\x03\x09\x01\x04\x01\x09\x01\x02\x03\x09\x03\x04\x05\x09"+
            "\x01\x07\x03\x09\x01\x0c\x01\x05\x03\x09\x03\x07\x01\x03\x01"+
            "\x0b\x04\x02\x02\x09\x01\uffff\x01\x09\x01\uffff\x01\x0a\x03"+
            "\uffff\x01\x09\x07\uffff\x03\x09\x02\uffff\x02\x09\x06\uffff"+
            "\x02\x09\x16\uffff\x02\x09\x0e\uffff\x02\x09\x02\uffff\x01\x09"+
            "\x04\uffff\x01\x09\x02\uffff\x01\x09\x01\uffff\x01\x01\x01\uffff"+
            "\x03\x09",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
    };

    static readonly short[] DFA61_eot = DFA.UnpackEncodedString(DFA61_eotS);
    static readonly short[] DFA61_eof = DFA.UnpackEncodedString(DFA61_eofS);
    static readonly char[] DFA61_min = DFA.UnpackEncodedStringToUnsignedChars(DFA61_minS);
    static readonly char[] DFA61_max = DFA.UnpackEncodedStringToUnsignedChars(DFA61_maxS);
    static readonly short[] DFA61_accept = DFA.UnpackEncodedString(DFA61_acceptS);
    static readonly short[] DFA61_special = DFA.UnpackEncodedString(DFA61_specialS);
    static readonly short[][] DFA61_transition = DFA.UnpackEncodedStringArray(DFA61_transitionS);

    protected class DFA61 : DFA
    {
        public DFA61(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 61;
            this.eot = DFA61_eot;
            this.eof = DFA61_eof;
            this.min = DFA61_min;
            this.max = DFA61_max;
            this.accept = DFA61_accept;
            this.special = DFA61_special;
            this.transition = DFA61_transition;

        }

        override public string Description
        {
            get { return "2093:1: interfaceElement : ( ( conditionalCompilerOption LCURLY )=> conditionalCompilerOption l= LCURLY ( interfaceElement )* r= RCURLY | propertyDeclaration | interfaceFunctionDeclaration | statement | directive );"; }
        }

    }


    protected internal int DFA61_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
            ITokenStream input = (ITokenStream)_input;
        int _s = s;
        switch ( s )
        {
                case 0 : 
                    int LA61_1 = input.LA(1);

                     
                    int index61_1 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred140_AS3_ex()) ) { s = 50; }

                    else if ( (synpred142_AS3_ex()) ) { s = 51; }

                    else if ( (synpred143_AS3_ex()) ) { s = 52; }

                    else if ( (synpred144_AS3_ex()) ) { s = 9; }

                     
                    input.Seek(index61_1);
                    if ( s >= 0 ) return s;
                    break;
                case 1 : 
                    int LA61_2 = input.LA(1);

                     
                    int index61_2 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred140_AS3_ex()) ) { s = 50; }

                    else if ( (synpred142_AS3_ex()) ) { s = 51; }

                    else if ( (synpred143_AS3_ex()) ) { s = 52; }

                    else if ( (synpred144_AS3_ex()) ) { s = 9; }

                     
                    input.Seek(index61_2);
                    if ( s >= 0 ) return s;
                    break;
                case 2 : 
                    int LA61_3 = input.LA(1);

                     
                    int index61_3 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred140_AS3_ex()) ) { s = 50; }

                    else if ( (synpred142_AS3_ex()) ) { s = 51; }

                    else if ( (synpred143_AS3_ex()) ) { s = 52; }

                    else if ( (synpred144_AS3_ex()) ) { s = 9; }

                     
                    input.Seek(index61_3);
                    if ( s >= 0 ) return s;
                    break;
                case 3 : 
                    int LA61_4 = input.LA(1);

                     
                    int index61_4 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred142_AS3_ex()) ) { s = 51; }

                    else if ( (synpred143_AS3_ex()) ) { s = 52; }

                    else if ( (synpred144_AS3_ex()) ) { s = 9; }

                     
                    input.Seek(index61_4);
                    if ( s >= 0 ) return s;
                    break;
                case 4 : 
                    int LA61_5 = input.LA(1);

                     
                    int index61_5 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred142_AS3_ex()) ) { s = 51; }

                    else if ( (synpred144_AS3_ex()) ) { s = 9; }

                     
                    input.Seek(index61_5);
                    if ( s >= 0 ) return s;
                    break;
                case 5 : 
                    int LA61_6 = input.LA(1);

                     
                    int index61_6 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred142_AS3_ex()) ) { s = 51; }

                    else if ( (synpred144_AS3_ex()) ) { s = 9; }

                     
                    input.Seek(index61_6);
                    if ( s >= 0 ) return s;
                    break;
                case 6 : 
                    int LA61_7 = input.LA(1);

                     
                    int index61_7 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred140_AS3_ex()) ) { s = 50; }

                    else if ( (synpred142_AS3_ex()) ) { s = 51; }

                    else if ( (synpred143_AS3_ex()) ) { s = 52; }

                    else if ( (synpred144_AS3_ex()) ) { s = 9; }

                     
                    input.Seek(index61_7);
                    if ( s >= 0 ) return s;
                    break;
                case 7 : 
                    int LA61_8 = input.LA(1);

                     
                    int index61_8 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred143_AS3_ex()) ) { s = 52; }

                    else if ( (synpred144_AS3_ex()) ) { s = 9; }

                     
                    input.Seek(index61_8);
                    if ( s >= 0 ) return s;
                    break;
                case 8 : 
                    int LA61_10 = input.LA(1);

                     
                    int index61_10 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred144_AS3_ex()) ) { s = 9; }

                    else if ( (true) ) { s = 53; }

                     
                    input.Seek(index61_10);
                    if ( s >= 0 ) return s;
                    break;
                case 9 : 
                    int LA61_11 = input.LA(1);

                     
                    int index61_11 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred144_AS3_ex()) ) { s = 9; }

                    else if ( (true) ) { s = 53; }

                     
                    input.Seek(index61_11);
                    if ( s >= 0 ) return s;
                    break;
                case 10 : 
                    int LA61_12 = input.LA(1);

                     
                    int index61_12 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred144_AS3_ex()) ) { s = 9; }

                    else if ( (true) ) { s = 53; }

                     
                    input.Seek(index61_12);
                    if ( s >= 0 ) return s;
                    break;
                case 11 : 
                    int LA61_13 = input.LA(1);

                     
                    int index61_13 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred144_AS3_ex()) ) { s = 9; }

                    else if ( (true) ) { s = 53; }

                     
                    input.Seek(index61_13);
                    if ( s >= 0 ) return s;
                    break;
                case 12 : 
                    int LA61_14 = input.LA(1);

                     
                    int index61_14 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred144_AS3_ex()) ) { s = 9; }

                    else if ( (true) ) { s = 53; }

                     
                    input.Seek(index61_14);
                    if ( s >= 0 ) return s;
                    break;
        }
        if (state.backtracking > 0) {state.failed = true; return -1;}
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 61, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA80_eotS =
        "\x33\uffff";
    const string DFA80_eofS =
        "\x33\uffff";
    const string DFA80_minS =
        "\x01\x04\x02\x00\x06\uffff\x01\x00\x18\uffff\x01\x00\x0a\uffff"+
        "\x01\x00\x02\uffff\x01\x00\x02\uffff";
    const string DFA80_maxS =
        "\x01\u0092\x02\x00\x06\uffff\x01\x00\x18\uffff\x01\x00\x0a\uffff"+
        "\x01\x00\x02\uffff\x01\x00\x02\uffff";
    const string DFA80_acceptS =
        "\x03\uffff\x01\x01\x2e\uffff\x01\x02";
    const string DFA80_specialS =
        "\x01\uffff\x01\x00\x01\x01\x06\uffff\x01\x02\x18\uffff\x01\x03"+
        "\x0a\uffff\x01\x04\x02\uffff\x01\x05\x02\uffff}>";
    static readonly string[] DFA80_transitionS = {
            "\x0f\x03\x01\x22\x06\x03\x01\x2d\x01\x03\x01\x09\x03\x03\x03"+
            "\x2d\x05\x03\x01\x30\x08\x03\x03\x30\x01\x02\x01\x03\x04\x09"+
            "\x02\x03\x01\uffff\x01\x03\x01\uffff\x01\x03\x03\uffff\x01\x03"+
            "\x07\uffff\x03\x03\x02\uffff\x02\x03\x06\uffff\x02\x03\x16\uffff"+
            "\x02\x03\x0e\uffff\x02\x03\x02\uffff\x01\x03\x04\uffff\x01\x03"+
            "\x02\uffff\x01\x03\x01\uffff\x01\x01\x01\uffff\x03\x03",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "\x01\uffff",
            "",
            "",
            "\x01\uffff",
            "",
            ""
    };

    static readonly short[] DFA80_eot = DFA.UnpackEncodedString(DFA80_eotS);
    static readonly short[] DFA80_eof = DFA.UnpackEncodedString(DFA80_eofS);
    static readonly char[] DFA80_min = DFA.UnpackEncodedStringToUnsignedChars(DFA80_minS);
    static readonly char[] DFA80_max = DFA.UnpackEncodedStringToUnsignedChars(DFA80_maxS);
    static readonly short[] DFA80_accept = DFA.UnpackEncodedString(DFA80_acceptS);
    static readonly short[] DFA80_special = DFA.UnpackEncodedString(DFA80_specialS);
    static readonly short[][] DFA80_transition = DFA.UnpackEncodedStringArray(DFA80_transitionS);

    protected class DFA80 : DFA
    {
        public DFA80(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 80;
            this.eot = DFA80_eot;
            this.eof = DFA80_eof;
            this.min = DFA80_min;
            this.max = DFA80_max;
            this.accept = DFA80_accept;
            this.special = DFA80_special;
            this.transition = DFA80_transition;

        }

        override public string Description
        {
            get { return "2226:8: ( statement | functionDeclaration )"; }
        }

    }


    protected internal int DFA80_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
            ITokenStream input = (ITokenStream)_input;
        int _s = s;
        switch ( s )
        {
                case 0 : 
                    int LA80_1 = input.LA(1);

                     
                    int index80_1 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred167_AS3_ex()) ) { s = 3; }

                    else if ( (true) ) { s = 50; }

                     
                    input.Seek(index80_1);
                    if ( s >= 0 ) return s;
                    break;
                case 1 : 
                    int LA80_2 = input.LA(1);

                     
                    int index80_2 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred167_AS3_ex()) ) { s = 3; }

                    else if ( (true) ) { s = 50; }

                     
                    input.Seek(index80_2);
                    if ( s >= 0 ) return s;
                    break;
                case 2 : 
                    int LA80_9 = input.LA(1);

                     
                    int index80_9 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred167_AS3_ex()) ) { s = 3; }

                    else if ( (true) ) { s = 50; }

                     
                    input.Seek(index80_9);
                    if ( s >= 0 ) return s;
                    break;
                case 3 : 
                    int LA80_34 = input.LA(1);

                     
                    int index80_34 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred167_AS3_ex()) ) { s = 3; }

                    else if ( (true) ) { s = 50; }

                     
                    input.Seek(index80_34);
                    if ( s >= 0 ) return s;
                    break;
                case 4 : 
                    int LA80_45 = input.LA(1);

                     
                    int index80_45 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred167_AS3_ex()) ) { s = 3; }

                    else if ( (true) ) { s = 50; }

                     
                    input.Seek(index80_45);
                    if ( s >= 0 ) return s;
                    break;
                case 5 : 
                    int LA80_48 = input.LA(1);

                     
                    int index80_48 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred167_AS3_ex()) ) { s = 3; }

                    else if ( (true) ) { s = 50; }

                     
                    input.Seek(index80_48);
                    if ( s >= 0 ) return s;
                    break;
        }
        if (state.backtracking > 0) {state.failed = true; return -1;}
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 80, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA83_eotS =
        "\x43\uffff";
    const string DFA83_eofS =
        "\x43\uffff";
    const string DFA83_minS =
        "\x01\x04\x16\x00\x2c\uffff";
    const string DFA83_maxS =
        "\x01\u0092\x16\x00\x2c\uffff";
    const string DFA83_acceptS =
        "\x17\uffff\x01\x14\x17\uffff\x01\x15\x01\x01\x01\x11\x01\x13\x01"+
        "\x03\x01\x02\x01\x04\x01\x05\x01\x06\x01\x07\x01\x08\x01\x09\x01"+
        "\x0a\x01\x0b\x01\x0c\x01\x0d\x01\x0e\x01\x0f\x01\x10\x01\x12";
    const string DFA83_specialS =
        "\x01\uffff\x01\x00\x01\x01\x01\x02\x01\x03\x01\x04\x01\x05\x01"+
        "\x06\x01\x07\x01\x08\x01\x09\x01\x0a\x01\x0b\x01\x0c\x01\x0d\x01"+
        "\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x2c"+
        "\uffff}>";
    static readonly string[] DFA83_transitionS = {
            "\x01\x17\x01\x0f\x03\x17\x01\x0a\x01\x10\x01\x08\x01\x17\x01"+
            "\x12\x04\x17\x01\x11\x01\x17\x01\x14\x01\x17\x01\x07\x05\x17"+
            "\x01\x09\x06\x17\x01\x0e\x01\x17\x01\x0c\x01\x17\x01\x16\x01"+
            "\x09\x01\x17\x01\x0b\x01\x17\x01\x06\x01\x15\x01\x17\x01\x13"+
            "\x01\x0d\x03\x09\x01\x02\x01\x05\x04\x09\x01\x2f\x01\x03\x01"+
            "\uffff\x01\x17\x01\uffff\x01\x04\x03\uffff\x01\x17\x07\uffff"+
            "\x03\x17\x02\uffff\x02\x17\x06\uffff\x02\x17\x16\uffff\x02\x17"+
            "\x0e\uffff\x02\x17\x02\uffff\x01\x17\x04\uffff\x01\x17\x02\uffff"+
            "\x01\x17\x01\uffff\x01\x01\x01\uffff\x03\x17",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
    };

    static readonly short[] DFA83_eot = DFA.UnpackEncodedString(DFA83_eotS);
    static readonly short[] DFA83_eof = DFA.UnpackEncodedString(DFA83_eofS);
    static readonly char[] DFA83_min = DFA.UnpackEncodedStringToUnsignedChars(DFA83_minS);
    static readonly char[] DFA83_max = DFA.UnpackEncodedStringToUnsignedChars(DFA83_maxS);
    static readonly short[] DFA83_accept = DFA.UnpackEncodedString(DFA83_acceptS);
    static readonly short[] DFA83_special = DFA.UnpackEncodedString(DFA83_specialS);
    static readonly short[][] DFA83_transition = DFA.UnpackEncodedStringArray(DFA83_transitionS);

    protected class DFA83 : DFA
    {
        public DFA83(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 83;
            this.eot = DFA83_eot;
            this.eof = DFA83_eof;
            this.min = DFA83_min;
            this.max = DFA83_max;
            this.accept = DFA83_accept;
            this.special = DFA83_special;
            this.transition = DFA83_transition;

        }

        override public string Description
        {
            get { return "2273:5: ( blockStatement | directive | namespaceDirective | constantVarStatement | tryStatement | switchStatement | withStatement | returnStatement | breakStatement | continueStatement | forStatement | forInStatement | forEachInStatement | doWhileStatement | whileStatement | ifStatement | variableStatement | throwStatement | labelledStatement | expression semic | emptyStatement )"; }
        }

    }


    protected internal int DFA83_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
            ITokenStream input = (ITokenStream)_input;
        int _s = s;
        switch ( s )
        {
                case 0 : 
                    int LA83_1 = input.LA(1);

                     
                    int index83_1 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred179_AS3_ex()) ) { s = 48; }

                    else if ( (synpred195_AS3_ex()) ) { s = 49; }

                    else if ( (synpred197_AS3_ex()) ) { s = 50; }

                    else if ( (synpred198_AS3_ex()) ) { s = 23; }

                     
                    input.Seek(index83_1);
                    if ( s >= 0 ) return s;
                    break;
                case 1 : 
                    int LA83_2 = input.LA(1);

                     
                    int index83_2 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred179_AS3_ex()) ) { s = 48; }

                    else if ( (synpred181_AS3_ex()) ) { s = 51; }

                    else if ( (synpred198_AS3_ex()) ) { s = 23; }

                     
                    input.Seek(index83_2);
                    if ( s >= 0 ) return s;
                    break;
                case 2 : 
                    int LA83_3 = input.LA(1);

                     
                    int index83_3 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred179_AS3_ex()) ) { s = 48; }

                    else if ( (synpred198_AS3_ex()) ) { s = 23; }

                     
                    input.Seek(index83_3);
                    if ( s >= 0 ) return s;
                    break;
                case 3 : 
                    int LA83_4 = input.LA(1);

                     
                    int index83_4 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred180_AS3_ex()) ) { s = 52; }

                    else if ( (synpred198_AS3_ex()) ) { s = 23; }

                     
                    input.Seek(index83_4);
                    if ( s >= 0 ) return s;
                    break;
                case 4 : 
                    int LA83_5 = input.LA(1);

                     
                    int index83_5 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred180_AS3_ex()) ) { s = 52; }

                    else if ( (synpred198_AS3_ex()) ) { s = 23; }

                     
                    input.Seek(index83_5);
                    if ( s >= 0 ) return s;
                    break;
                case 5 : 
                    int LA83_6 = input.LA(1);

                     
                    int index83_6 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred180_AS3_ex()) ) { s = 52; }

                    else if ( (synpred198_AS3_ex()) ) { s = 23; }

                     
                    input.Seek(index83_6);
                    if ( s >= 0 ) return s;
                    break;
                case 6 : 
                    int LA83_7 = input.LA(1);

                     
                    int index83_7 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred180_AS3_ex()) ) { s = 52; }

                    else if ( (synpred198_AS3_ex()) ) { s = 23; }

                     
                    input.Seek(index83_7);
                    if ( s >= 0 ) return s;
                    break;
                case 7 : 
                    int LA83_8 = input.LA(1);

                     
                    int index83_8 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred180_AS3_ex()) ) { s = 52; }

                    else if ( (synpred198_AS3_ex()) ) { s = 23; }

                     
                    input.Seek(index83_8);
                    if ( s >= 0 ) return s;
                    break;
                case 8 : 
                    int LA83_9 = input.LA(1);

                     
                    int index83_9 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred179_AS3_ex()) ) { s = 48; }

                    else if ( (synpred198_AS3_ex()) ) { s = 23; }

                     
                    input.Seek(index83_9);
                    if ( s >= 0 ) return s;
                    break;
                case 9 : 
                    int LA83_10 = input.LA(1);

                     
                    int index83_10 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred182_AS3_ex()) ) { s = 53; }

                    else if ( (synpred198_AS3_ex()) ) { s = 23; }

                     
                    input.Seek(index83_10);
                    if ( s >= 0 ) return s;
                    break;
                case 10 : 
                    int LA83_11 = input.LA(1);

                     
                    int index83_11 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred183_AS3_ex()) ) { s = 54; }

                    else if ( (synpred198_AS3_ex()) ) { s = 23; }

                     
                    input.Seek(index83_11);
                    if ( s >= 0 ) return s;
                    break;
                case 11 : 
                    int LA83_12 = input.LA(1);

                     
                    int index83_12 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred184_AS3_ex()) ) { s = 55; }

                    else if ( (synpred198_AS3_ex()) ) { s = 23; }

                     
                    input.Seek(index83_12);
                    if ( s >= 0 ) return s;
                    break;
                case 12 : 
                    int LA83_13 = input.LA(1);

                     
                    int index83_13 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred185_AS3_ex()) ) { s = 56; }

                    else if ( (synpred198_AS3_ex()) ) { s = 23; }

                     
                    input.Seek(index83_13);
                    if ( s >= 0 ) return s;
                    break;
                case 13 : 
                    int LA83_14 = input.LA(1);

                     
                    int index83_14 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred186_AS3_ex()) ) { s = 57; }

                    else if ( (synpred198_AS3_ex()) ) { s = 23; }

                     
                    input.Seek(index83_14);
                    if ( s >= 0 ) return s;
                    break;
                case 14 : 
                    int LA83_15 = input.LA(1);

                     
                    int index83_15 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred187_AS3_ex()) ) { s = 58; }

                    else if ( (synpred198_AS3_ex()) ) { s = 23; }

                     
                    input.Seek(index83_15);
                    if ( s >= 0 ) return s;
                    break;
                case 15 : 
                    int LA83_16 = input.LA(1);

                     
                    int index83_16 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred188_AS3_ex()) ) { s = 59; }

                    else if ( (synpred198_AS3_ex()) ) { s = 23; }

                     
                    input.Seek(index83_16);
                    if ( s >= 0 ) return s;
                    break;
                case 16 : 
                    int LA83_17 = input.LA(1);

                     
                    int index83_17 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred189_AS3_ex()) ) { s = 60; }

                    else if ( (synpred190_AS3_ex()) ) { s = 61; }

                    else if ( (synpred191_AS3_ex()) ) { s = 62; }

                    else if ( (synpred198_AS3_ex()) ) { s = 23; }

                     
                    input.Seek(index83_17);
                    if ( s >= 0 ) return s;
                    break;
                case 17 : 
                    int LA83_18 = input.LA(1);

                     
                    int index83_18 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred192_AS3_ex()) ) { s = 63; }

                    else if ( (synpred198_AS3_ex()) ) { s = 23; }

                     
                    input.Seek(index83_18);
                    if ( s >= 0 ) return s;
                    break;
                case 18 : 
                    int LA83_19 = input.LA(1);

                     
                    int index83_19 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred193_AS3_ex()) ) { s = 64; }

                    else if ( (synpred198_AS3_ex()) ) { s = 23; }

                     
                    input.Seek(index83_19);
                    if ( s >= 0 ) return s;
                    break;
                case 19 : 
                    int LA83_20 = input.LA(1);

                     
                    int index83_20 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred194_AS3_ex()) ) { s = 65; }

                    else if ( (synpred198_AS3_ex()) ) { s = 23; }

                     
                    input.Seek(index83_20);
                    if ( s >= 0 ) return s;
                    break;
                case 20 : 
                    int LA83_21 = input.LA(1);

                     
                    int index83_21 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred195_AS3_ex()) ) { s = 49; }

                    else if ( (synpred198_AS3_ex()) ) { s = 23; }

                     
                    input.Seek(index83_21);
                    if ( s >= 0 ) return s;
                    break;
                case 21 : 
                    int LA83_22 = input.LA(1);

                     
                    int index83_22 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred196_AS3_ex()) ) { s = 66; }

                    else if ( (synpred198_AS3_ex()) ) { s = 23; }

                     
                    input.Seek(index83_22);
                    if ( s >= 0 ) return s;
                    break;
        }
        if (state.backtracking > 0) {state.failed = true; return -1;}
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 83, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA93_eotS =
        "\x33\uffff";
    const string DFA93_eofS =
        "\x01\x02\x32\uffff";
    const string DFA93_minS =
        "\x01\x04\x01\x00\x01\uffff\x02\x00\x2e\uffff";
    const string DFA93_maxS =
        "\x01\u0092\x01\x00\x01\uffff\x02\x00\x2e\uffff";
    const string DFA93_acceptS =
        "\x02\uffff\x01\x02\x03\uffff\x01\x01\x2c\uffff";
    const string DFA93_specialS =
        "\x01\uffff\x01\x00\x01\uffff\x01\x01\x01\x02\x2e\uffff}>";
    static readonly string[] DFA93_transitionS = {
            "\x01\x06\x01\x01\x01\x03\x04\x06\x01\x04\x30\x06\x01\x02\x01"+
            "\x06\x01\uffff\x01\x06\x03\uffff\x01\x06\x07\uffff\x03\x06\x02"+
            "\uffff\x02\x06\x06\uffff\x02\x06\x16\uffff\x02\x06\x0e\uffff"+
            "\x02\x06\x02\uffff\x01\x06\x04\uffff\x01\x06\x02\uffff\x01\x06"+
            "\x01\uffff\x01\x06\x01\uffff\x03\x06",
            "\x01\uffff",
            "",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
    };

    static readonly short[] DFA93_eot = DFA.UnpackEncodedString(DFA93_eotS);
    static readonly short[] DFA93_eof = DFA.UnpackEncodedString(DFA93_eofS);
    static readonly char[] DFA93_min = DFA.UnpackEncodedStringToUnsignedChars(DFA93_minS);
    static readonly char[] DFA93_max = DFA.UnpackEncodedStringToUnsignedChars(DFA93_maxS);
    static readonly short[] DFA93_accept = DFA.UnpackEncodedString(DFA93_acceptS);
    static readonly short[] DFA93_special = DFA.UnpackEncodedString(DFA93_specialS);
    static readonly short[][] DFA93_transition = DFA.UnpackEncodedStringArray(DFA93_transitionS);

    protected class DFA93 : DFA
    {
        public DFA93(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 93;
            this.eot = DFA93_eot;
            this.eof = DFA93_eof;
            this.min = DFA93_min;
            this.max = DFA93_max;
            this.accept = DFA93_accept;
            this.special = DFA93_special;
            this.transition = DFA93_transition;

        }

        override public string Description
        {
            get { return "()* loopback of 2465:6: ( statement )*"; }
        }

    }


    protected internal int DFA93_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
            ITokenStream input = (ITokenStream)_input;
        int _s = s;
        switch ( s )
        {
                case 0 : 
                    int LA93_1 = input.LA(1);

                     
                    int index93_1 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred209_AS3_ex()) ) { s = 6; }

                    else if ( (true) ) { s = 2; }

                     
                    input.Seek(index93_1);
                    if ( s >= 0 ) return s;
                    break;
                case 1 : 
                    int LA93_3 = input.LA(1);

                     
                    int index93_3 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred209_AS3_ex()) ) { s = 6; }

                    else if ( (true) ) { s = 2; }

                     
                    input.Seek(index93_3);
                    if ( s >= 0 ) return s;
                    break;
                case 2 : 
                    int LA93_4 = input.LA(1);

                     
                    int index93_4 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred209_AS3_ex()) ) { s = 6; }

                    else if ( (true) ) { s = 2; }

                     
                    input.Seek(index93_4);
                    if ( s >= 0 ) return s;
                    break;
        }
        if (state.backtracking > 0) {state.failed = true; return -1;}
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 93, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA121_eotS =
        "\x1e\uffff";
    const string DFA121_eofS =
        "\x1e\uffff";
    const string DFA121_minS =
        "\x01\x04\x19\x00\x01\uffff\x01\x00\x02\uffff";
    const string DFA121_maxS =
        "\x01\u0092\x19\x00\x01\uffff\x01\x00\x02\uffff";
    const string DFA121_acceptS =
        "\x1a\uffff\x01\x02\x02\uffff\x01\x01";
    const string DFA121_specialS =
        "\x01\uffff\x01\x00\x01\x01\x01\x02\x01\x03\x01\x04\x01\x05\x01"+
        "\x06\x01\x07\x01\x08\x01\x09\x01\x0a\x01\x0b\x01\x0c\x01\x0d\x01"+
        "\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01"+
        "\x16\x01\x17\x01\x18\x01\uffff\x01\x19\x02\uffff}>";
    static readonly string[] DFA121_transitionS = {
            "\x08\x1b\x01\x19\x03\x1b\x01\x05\x02\x1b\x01\x10\x08\x1b\x01"+
            "\x0e\x01\x18\x01\x03\x05\x1b\x01\x02\x01\x1b\x01\x01\x01\x1b"+
            "\x01\x0e\x01\x04\x01\x1b\x01\x19\x02\x1b\x01\x19\x02\x1b\x04"+
            "\x0e\x01\x1b\x04\x0e\x01\uffff\x01\x0c\x01\uffff\x01\x17\x01"+
            "\uffff\x01\x0b\x03\uffff\x01\x15\x07\uffff\x02\x1a\x01\x11\x02"+
            "\uffff\x02\x1a\x06\uffff\x02\x1a\x16\uffff\x01\x0f\x01\x16\x0e"+
            "\uffff\x01\x08\x01\x09\x02\uffff\x01\x0a\x04\uffff\x01\x07\x02"+
            "\uffff\x01\x06\x01\uffff\x01\x0d\x01\uffff\x01\x12\x01\x13\x01"+
            "\x14",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "\x01\uffff",
            "",
            ""
    };

    static readonly short[] DFA121_eot = DFA.UnpackEncodedString(DFA121_eotS);
    static readonly short[] DFA121_eof = DFA.UnpackEncodedString(DFA121_eofS);
    static readonly char[] DFA121_min = DFA.UnpackEncodedStringToUnsignedChars(DFA121_minS);
    static readonly char[] DFA121_max = DFA.UnpackEncodedStringToUnsignedChars(DFA121_maxS);
    static readonly short[] DFA121_accept = DFA.UnpackEncodedString(DFA121_acceptS);
    static readonly short[] DFA121_special = DFA.UnpackEncodedString(DFA121_specialS);
    static readonly short[][] DFA121_transition = DFA.UnpackEncodedStringArray(DFA121_transitionS);

    protected class DFA121 : DFA
    {
        public DFA121(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 121;
            this.eot = DFA121_eot;
            this.eof = DFA121_eof;
            this.min = DFA121_min;
            this.max = DFA121_max;
            this.accept = DFA121_accept;
            this.special = DFA121_special;
            this.transition = DFA121_transition;

        }

        override public string Description
        {
            get { return "3017:7: ( ( leftHandSideExpression assignmentOperator )=> leftHandSideExpression assignmentOperator assignmentExpression | conditionalExpression )"; }
        }

    }


    protected internal int DFA121_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
            ITokenStream input = (ITokenStream)_input;
        int _s = s;
        switch ( s )
        {
                case 0 : 
                    int LA121_1 = input.LA(1);

                     
                    int index121_1 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred238_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index121_1);
                    if ( s >= 0 ) return s;
                    break;
                case 1 : 
                    int LA121_2 = input.LA(1);

                     
                    int index121_2 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred238_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index121_2);
                    if ( s >= 0 ) return s;
                    break;
                case 2 : 
                    int LA121_3 = input.LA(1);

                     
                    int index121_3 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred238_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index121_3);
                    if ( s >= 0 ) return s;
                    break;
                case 3 : 
                    int LA121_4 = input.LA(1);

                     
                    int index121_4 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred238_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index121_4);
                    if ( s >= 0 ) return s;
                    break;
                case 4 : 
                    int LA121_5 = input.LA(1);

                     
                    int index121_5 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred238_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index121_5);
                    if ( s >= 0 ) return s;
                    break;
                case 5 : 
                    int LA121_6 = input.LA(1);

                     
                    int index121_6 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred238_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index121_6);
                    if ( s >= 0 ) return s;
                    break;
                case 6 : 
                    int LA121_7 = input.LA(1);

                     
                    int index121_7 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred238_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index121_7);
                    if ( s >= 0 ) return s;
                    break;
                case 7 : 
                    int LA121_8 = input.LA(1);

                     
                    int index121_8 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred238_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index121_8);
                    if ( s >= 0 ) return s;
                    break;
                case 8 : 
                    int LA121_9 = input.LA(1);

                     
                    int index121_9 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred238_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index121_9);
                    if ( s >= 0 ) return s;
                    break;
                case 9 : 
                    int LA121_10 = input.LA(1);

                     
                    int index121_10 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred238_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index121_10);
                    if ( s >= 0 ) return s;
                    break;
                case 10 : 
                    int LA121_11 = input.LA(1);

                     
                    int index121_11 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred238_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index121_11);
                    if ( s >= 0 ) return s;
                    break;
                case 11 : 
                    int LA121_12 = input.LA(1);

                     
                    int index121_12 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred238_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index121_12);
                    if ( s >= 0 ) return s;
                    break;
                case 12 : 
                    int LA121_13 = input.LA(1);

                     
                    int index121_13 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred238_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index121_13);
                    if ( s >= 0 ) return s;
                    break;
                case 13 : 
                    int LA121_14 = input.LA(1);

                     
                    int index121_14 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred238_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index121_14);
                    if ( s >= 0 ) return s;
                    break;
                case 14 : 
                    int LA121_15 = input.LA(1);

                     
                    int index121_15 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred238_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index121_15);
                    if ( s >= 0 ) return s;
                    break;
                case 15 : 
                    int LA121_16 = input.LA(1);

                     
                    int index121_16 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred238_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index121_16);
                    if ( s >= 0 ) return s;
                    break;
                case 16 : 
                    int LA121_17 = input.LA(1);

                     
                    int index121_17 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred238_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index121_17);
                    if ( s >= 0 ) return s;
                    break;
                case 17 : 
                    int LA121_18 = input.LA(1);

                     
                    int index121_18 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred238_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index121_18);
                    if ( s >= 0 ) return s;
                    break;
                case 18 : 
                    int LA121_19 = input.LA(1);

                     
                    int index121_19 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred238_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index121_19);
                    if ( s >= 0 ) return s;
                    break;
                case 19 : 
                    int LA121_20 = input.LA(1);

                     
                    int index121_20 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred238_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index121_20);
                    if ( s >= 0 ) return s;
                    break;
                case 20 : 
                    int LA121_21 = input.LA(1);

                     
                    int index121_21 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred238_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index121_21);
                    if ( s >= 0 ) return s;
                    break;
                case 21 : 
                    int LA121_22 = input.LA(1);

                     
                    int index121_22 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred238_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index121_22);
                    if ( s >= 0 ) return s;
                    break;
                case 22 : 
                    int LA121_23 = input.LA(1);

                     
                    int index121_23 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred238_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index121_23);
                    if ( s >= 0 ) return s;
                    break;
                case 23 : 
                    int LA121_24 = input.LA(1);

                     
                    int index121_24 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred238_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index121_24);
                    if ( s >= 0 ) return s;
                    break;
                case 24 : 
                    int LA121_25 = input.LA(1);

                     
                    int index121_25 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred238_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index121_25);
                    if ( s >= 0 ) return s;
                    break;
                case 25 : 
                    int LA121_27 = input.LA(1);

                     
                    int index121_27 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred238_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index121_27);
                    if ( s >= 0 ) return s;
                    break;
        }
        if (state.backtracking > 0) {state.failed = true; return -1;}
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 121, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA122_eotS =
        "\x1e\uffff";
    const string DFA122_eofS =
        "\x1e\uffff";
    const string DFA122_minS =
        "\x01\x04\x19\x00\x01\uffff\x01\x00\x02\uffff";
    const string DFA122_maxS =
        "\x01\u0092\x19\x00\x01\uffff\x01\x00\x02\uffff";
    const string DFA122_acceptS =
        "\x1a\uffff\x01\x02\x02\uffff\x01\x01";
    const string DFA122_specialS =
        "\x01\uffff\x01\x00\x01\x01\x01\x02\x01\x03\x01\x04\x01\x05\x01"+
        "\x06\x01\x07\x01\x08\x01\x09\x01\x0a\x01\x0b\x01\x0c\x01\x0d\x01"+
        "\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01"+
        "\x16\x01\x17\x01\x18\x01\uffff\x01\x19\x02\uffff}>";
    static readonly string[] DFA122_transitionS = {
            "\x08\x1b\x01\x19\x03\x1b\x01\x05\x02\x1b\x01\x10\x08\x1b\x01"+
            "\x0e\x01\x18\x01\x03\x05\x1b\x01\x02\x01\x1b\x01\x01\x01\x1b"+
            "\x01\x0e\x01\x04\x01\x1b\x01\x19\x02\x1b\x01\x19\x02\x1b\x04"+
            "\x0e\x01\x1b\x04\x0e\x01\uffff\x01\x0c\x01\uffff\x01\x17\x01"+
            "\uffff\x01\x0b\x03\uffff\x01\x15\x07\uffff\x02\x1a\x01\x11\x02"+
            "\uffff\x02\x1a\x06\uffff\x02\x1a\x16\uffff\x01\x0f\x01\x16\x0e"+
            "\uffff\x01\x08\x01\x09\x02\uffff\x01\x0a\x04\uffff\x01\x07\x02"+
            "\uffff\x01\x06\x01\uffff\x01\x0d\x01\uffff\x01\x12\x01\x13\x01"+
            "\x14",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "\x01\uffff",
            "",
            ""
    };

    static readonly short[] DFA122_eot = DFA.UnpackEncodedString(DFA122_eotS);
    static readonly short[] DFA122_eof = DFA.UnpackEncodedString(DFA122_eofS);
    static readonly char[] DFA122_min = DFA.UnpackEncodedStringToUnsignedChars(DFA122_minS);
    static readonly char[] DFA122_max = DFA.UnpackEncodedStringToUnsignedChars(DFA122_maxS);
    static readonly short[] DFA122_accept = DFA.UnpackEncodedString(DFA122_acceptS);
    static readonly short[] DFA122_special = DFA.UnpackEncodedString(DFA122_specialS);
    static readonly short[][] DFA122_transition = DFA.UnpackEncodedStringArray(DFA122_transitionS);

    protected class DFA122 : DFA
    {
        public DFA122(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 122;
            this.eot = DFA122_eot;
            this.eof = DFA122_eof;
            this.min = DFA122_min;
            this.max = DFA122_max;
            this.accept = DFA122_accept;
            this.special = DFA122_special;
            this.transition = DFA122_transition;

        }

        override public string Description
        {
            get { return "3032:8: ( ( leftHandSideExpression assignmentOperator )=> leftHandSideExpression assignmentOperator assignmentExpressionNoIn | conditionalExpressionNoIn )"; }
        }

    }


    protected internal int DFA122_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
            ITokenStream input = (ITokenStream)_input;
        int _s = s;
        switch ( s )
        {
                case 0 : 
                    int LA122_1 = input.LA(1);

                     
                    int index122_1 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred239_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index122_1);
                    if ( s >= 0 ) return s;
                    break;
                case 1 : 
                    int LA122_2 = input.LA(1);

                     
                    int index122_2 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred239_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index122_2);
                    if ( s >= 0 ) return s;
                    break;
                case 2 : 
                    int LA122_3 = input.LA(1);

                     
                    int index122_3 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred239_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index122_3);
                    if ( s >= 0 ) return s;
                    break;
                case 3 : 
                    int LA122_4 = input.LA(1);

                     
                    int index122_4 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred239_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index122_4);
                    if ( s >= 0 ) return s;
                    break;
                case 4 : 
                    int LA122_5 = input.LA(1);

                     
                    int index122_5 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred239_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index122_5);
                    if ( s >= 0 ) return s;
                    break;
                case 5 : 
                    int LA122_6 = input.LA(1);

                     
                    int index122_6 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred239_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index122_6);
                    if ( s >= 0 ) return s;
                    break;
                case 6 : 
                    int LA122_7 = input.LA(1);

                     
                    int index122_7 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred239_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index122_7);
                    if ( s >= 0 ) return s;
                    break;
                case 7 : 
                    int LA122_8 = input.LA(1);

                     
                    int index122_8 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred239_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index122_8);
                    if ( s >= 0 ) return s;
                    break;
                case 8 : 
                    int LA122_9 = input.LA(1);

                     
                    int index122_9 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred239_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index122_9);
                    if ( s >= 0 ) return s;
                    break;
                case 9 : 
                    int LA122_10 = input.LA(1);

                     
                    int index122_10 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred239_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index122_10);
                    if ( s >= 0 ) return s;
                    break;
                case 10 : 
                    int LA122_11 = input.LA(1);

                     
                    int index122_11 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred239_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index122_11);
                    if ( s >= 0 ) return s;
                    break;
                case 11 : 
                    int LA122_12 = input.LA(1);

                     
                    int index122_12 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred239_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index122_12);
                    if ( s >= 0 ) return s;
                    break;
                case 12 : 
                    int LA122_13 = input.LA(1);

                     
                    int index122_13 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred239_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index122_13);
                    if ( s >= 0 ) return s;
                    break;
                case 13 : 
                    int LA122_14 = input.LA(1);

                     
                    int index122_14 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred239_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index122_14);
                    if ( s >= 0 ) return s;
                    break;
                case 14 : 
                    int LA122_15 = input.LA(1);

                     
                    int index122_15 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred239_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index122_15);
                    if ( s >= 0 ) return s;
                    break;
                case 15 : 
                    int LA122_16 = input.LA(1);

                     
                    int index122_16 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred239_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index122_16);
                    if ( s >= 0 ) return s;
                    break;
                case 16 : 
                    int LA122_17 = input.LA(1);

                     
                    int index122_17 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred239_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index122_17);
                    if ( s >= 0 ) return s;
                    break;
                case 17 : 
                    int LA122_18 = input.LA(1);

                     
                    int index122_18 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred239_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index122_18);
                    if ( s >= 0 ) return s;
                    break;
                case 18 : 
                    int LA122_19 = input.LA(1);

                     
                    int index122_19 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred239_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index122_19);
                    if ( s >= 0 ) return s;
                    break;
                case 19 : 
                    int LA122_20 = input.LA(1);

                     
                    int index122_20 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred239_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index122_20);
                    if ( s >= 0 ) return s;
                    break;
                case 20 : 
                    int LA122_21 = input.LA(1);

                     
                    int index122_21 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred239_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index122_21);
                    if ( s >= 0 ) return s;
                    break;
                case 21 : 
                    int LA122_22 = input.LA(1);

                     
                    int index122_22 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred239_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index122_22);
                    if ( s >= 0 ) return s;
                    break;
                case 22 : 
                    int LA122_23 = input.LA(1);

                     
                    int index122_23 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred239_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index122_23);
                    if ( s >= 0 ) return s;
                    break;
                case 23 : 
                    int LA122_24 = input.LA(1);

                     
                    int index122_24 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred239_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index122_24);
                    if ( s >= 0 ) return s;
                    break;
                case 24 : 
                    int LA122_25 = input.LA(1);

                     
                    int index122_25 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred239_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index122_25);
                    if ( s >= 0 ) return s;
                    break;
                case 25 : 
                    int LA122_27 = input.LA(1);

                     
                    int index122_27 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred239_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 26; }

                     
                    input.Seek(index122_27);
                    if ( s >= 0 ) return s;
                    break;
        }
        if (state.backtracking > 0) {state.failed = true; return -1;}
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 122, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA123_eotS =
        "\x11\uffff";
    const string DFA123_eofS =
        "\x11\uffff";
    const string DFA123_minS =
        "\x01\x44\x07\uffff\x01\x44\x05\uffff\x01\x44\x02\uffff";
    const string DFA123_maxS =
        "\x01\x6a\x07\uffff\x01\x44\x05\uffff\x01\x5e\x02\uffff";
    const string DFA123_acceptS =
        "\x01\uffff\x01\x01\x01\x02\x01\x03\x01\x04\x01\x05\x01\x06\x01"+
        "\x07\x01\uffff\x01\x0a\x01\x0b\x01\x0c\x01\x0d\x01\x0e\x01\uffff"+
        "\x01\x08\x01\x09";
    const string DFA123_specialS =
        "\x11\uffff}>";
    static readonly string[] DFA123_transitionS = {
            "\x01\x08\x08\uffff\x01\x02\x10\uffff\x01\x01\x01\x03\x01\x04"+
            "\x01\x05\x01\x06\x01\x07\x02\uffff\x01\x0d\x01\x0c\x01\x09\x01"+
            "\x0a\x01\x0b",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "\x01\x0e",
            "",
            "",
            "",
            "",
            "",
            "\x01\x10\x19\uffff\x01\x0f",
            "",
            ""
    };

    static readonly short[] DFA123_eot = DFA.UnpackEncodedString(DFA123_eotS);
    static readonly short[] DFA123_eof = DFA.UnpackEncodedString(DFA123_eofS);
    static readonly char[] DFA123_min = DFA.UnpackEncodedStringToUnsignedChars(DFA123_minS);
    static readonly char[] DFA123_max = DFA.UnpackEncodedStringToUnsignedChars(DFA123_maxS);
    static readonly short[] DFA123_accept = DFA.UnpackEncodedString(DFA123_acceptS);
    static readonly short[] DFA123_special = DFA.UnpackEncodedString(DFA123_specialS);
    static readonly short[][] DFA123_transition = DFA.UnpackEncodedStringArray(DFA123_transitionS);

    protected class DFA123 : DFA
    {
        public DFA123(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 123;
            this.eot = DFA123_eot;
            this.eof = DFA123_eof;
            this.min = DFA123_min;
            this.max = DFA123_max;
            this.accept = DFA123_accept;
            this.special = DFA123_special;
            this.transition = DFA123_transition;

        }

        override public string Description
        {
            get { return "3052:1: assignmentOperator_int : ( ASSIGN | s= STAR a= ASSIGN | DIV_ASSIGN | MOD_ASSIGN | ADD_ASSIGN | SUB_ASSIGN | SHL_ASSIGN | ( ( '>' '>' '=' )=>t1= '>' t2= '>' t3= '=' {...}? -> SHR_ASSIGN ) | ( ( '>' '>' '>' '=' )=>t1= '>' t2= '>' t3= '>' t4= '=' {...}? -> SHU_ASSIGN ) | AND_ASSIGN | XOR_ASSIGN | OR_ASSIGN | LOR_ASSIGN | LAND_ASSIGN );"; }
        }

    }

    const string DFA148_eotS =
        "\x1e\uffff";
    const string DFA148_eofS =
        "\x1e\uffff";
    const string DFA148_minS =
        "\x01\x04\x18\uffff\x02\x00\x03\uffff";
    const string DFA148_maxS =
        "\x01\u0092\x18\uffff\x02\x00\x03\uffff";
    const string DFA148_acceptS =
        "\x01\uffff\x01\x01\x1a\uffff\x01\x03\x01\x02";
    const string DFA148_specialS =
        "\x19\uffff\x01\x00\x01\x01\x03\uffff}>";
    static readonly string[] DFA148_transitionS = {
            "\x08\x01\x01\x19\x1e\x01\x01\x19\x02\x01\x01\x19\x0b\x01\x01"+
            "\uffff\x01\x01\x01\uffff\x01\x01\x01\uffff\x01\x01\x03\uffff"+
            "\x01\x01\x07\uffff\x02\x1c\x01\x01\x02\uffff\x02\x1c\x06\uffff"+
            "\x02\x1a\x16\uffff\x02\x01\x0e\uffff\x02\x01\x02\uffff\x01\x01"+
            "\x04\uffff\x01\x01\x02\uffff\x01\x01\x01\uffff\x01\x01\x01\uffff"+
            "\x03\x01",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "",
            ""
    };

    static readonly short[] DFA148_eot = DFA.UnpackEncodedString(DFA148_eotS);
    static readonly short[] DFA148_eof = DFA.UnpackEncodedString(DFA148_eofS);
    static readonly char[] DFA148_min = DFA.UnpackEncodedStringToUnsignedChars(DFA148_minS);
    static readonly char[] DFA148_max = DFA.UnpackEncodedStringToUnsignedChars(DFA148_maxS);
    static readonly short[] DFA148_accept = DFA.UnpackEncodedString(DFA148_acceptS);
    static readonly short[] DFA148_special = DFA.UnpackEncodedString(DFA148_specialS);
    static readonly short[][] DFA148_transition = DFA.UnpackEncodedStringArray(DFA148_transitionS);

    protected class DFA148 : DFA
    {
        public DFA148(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 148;
            this.eot = DFA148_eot;
            this.eof = DFA148_eof;
            this.min = DFA148_min;
            this.max = DFA148_max;
            this.accept = DFA148_accept;
            this.special = DFA148_special;
            this.transition = DFA148_transition;

        }

        override public string Description
        {
            get { return "3335:1: unaryExpression : ( postfixExpression | op= ( NOT | INV ) unaryExpression | unaryOp postfixExpression );"; }
        }

    }


    protected internal int DFA148_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
            ITokenStream input = (ITokenStream)_input;
        int _s = s;
        switch ( s )
        {
                case 0 : 
                    int LA148_25 = input.LA(1);

                     
                    int index148_25 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred300_AS3_ex()) ) { s = 1; }

                    else if ( (true) ) { s = 28; }

                     
                    input.Seek(index148_25);
                    if ( s >= 0 ) return s;
                    break;
                case 1 : 
                    int LA148_26 = input.LA(1);

                     
                    int index148_26 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred302_AS3_ex()) ) { s = 29; }

                    else if ( (true) ) { s = 28; }

                     
                    input.Seek(index148_26);
                    if ( s >= 0 ) return s;
                    break;
        }
        if (state.backtracking > 0) {state.failed = true; return -1;}
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 148, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA152_eotS =
        "\x0d\uffff";
    const string DFA152_eofS =
        "\x01\x01\x0c\uffff";
    const string DFA152_minS =
        "\x01\x04\x01\uffff\x05\x00\x06\uffff";
    const string DFA152_maxS =
        "\x01\u0092\x01\uffff\x05\x00\x06\uffff";
    const string DFA152_acceptS =
        "\x01\uffff\x01\x07\x05\uffff\x01\x02\x01\x01\x01\x03\x01\x04\x01"+
        "\x05\x01\x06";
    const string DFA152_specialS =
        "\x02\uffff\x01\x00\x01\x04\x01\x01\x01\x02\x01\x03\x06\uffff}>";
    static readonly string[] DFA152_transitionS = {
            "\x39\x01\x01\x03\x01\x01\x01\x02\x01\x01\x01\x05\x04\x01\x01"+
            "\uffff\x0c\x01\x02\uffff\x0f\x01\x02\uffff\x05\x01\x01\uffff"+
            "\x01\x04\x02\uffff\x01\x06\x02\x01\x0e\uffff\x02\x01\x02\uffff"+
            "\x01\x01\x04\uffff\x01\x01\x02\uffff\x01\x01\x01\uffff\x01\x01"+
            "\x01\uffff\x03\x01",
            "",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            ""
    };

    static readonly short[] DFA152_eot = DFA.UnpackEncodedString(DFA152_eotS);
    static readonly short[] DFA152_eof = DFA.UnpackEncodedString(DFA152_eofS);
    static readonly char[] DFA152_min = DFA.UnpackEncodedStringToUnsignedChars(DFA152_minS);
    static readonly char[] DFA152_max = DFA.UnpackEncodedStringToUnsignedChars(DFA152_maxS);
    static readonly short[] DFA152_accept = DFA.UnpackEncodedString(DFA152_acceptS);
    static readonly short[] DFA152_special = DFA.UnpackEncodedString(DFA152_specialS);
    static readonly short[][] DFA152_transition = DFA.UnpackEncodedStringArray(DFA152_transitionS);

    protected class DFA152 : DFA
    {
        public DFA152(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 152;
            this.eot = DFA152_eot;
            this.eof = DFA152_eof;
            this.min = DFA152_min;
            this.max = DFA152_max;
            this.accept = DFA152_accept;
            this.special = DFA152_special;
            this.transition = DFA152_transition;

        }

        override public string Description
        {
            get { return "()* loopback of 3376:5: ( arguments | L= LBRACK expression R= RBRACK | E= XML_ELLIPSIS eitherIdentifier | D= DOT ( eitherIdentifier | parExpression ) | typePostfixSyntax | op= XML_NS_OP expression )*"; }
        }

    }


    protected internal int DFA152_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
            ITokenStream input = (ITokenStream)_input;
        int _s = s;
        switch ( s )
        {
                case 0 : 
                    int LA152_2 = input.LA(1);

                     
                    int index152_2 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred316_AS3_ex()) ) { s = 7; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index152_2);
                    if ( s >= 0 ) return s;
                    break;
                case 1 : 
                    int LA152_4 = input.LA(1);

                     
                    int index152_4 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred317_AS3_ex()) ) { s = 9; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index152_4);
                    if ( s >= 0 ) return s;
                    break;
                case 2 : 
                    int LA152_5 = input.LA(1);

                     
                    int index152_5 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred319_AS3_ex()) ) { s = 10; }

                    else if ( (synpred320_AS3_ex()) ) { s = 11; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index152_5);
                    if ( s >= 0 ) return s;
                    break;
                case 3 : 
                    int LA152_6 = input.LA(1);

                     
                    int index152_6 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred321_AS3_ex()) ) { s = 12; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index152_6);
                    if ( s >= 0 ) return s;
                    break;
                case 4 : 
                    int LA152_3 = input.LA(1);

                     
                    int index152_3 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred315_AS3_ex()) ) { s = 8; }

                    else if ( (true) ) { s = 1; }

                     
                    input.Seek(index152_3);
                    if ( s >= 0 ) return s;
                    break;
        }
        if (state.backtracking > 0) {state.failed = true; return -1;}
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 152, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA162_eotS =
        "\x1c\uffff";
    const string DFA162_eofS =
        "\x1c\uffff";
    const string DFA162_minS =
        "\x01\x04\x05\x00\x07\uffff\x02\x00\x06\uffff\x01\x00\x06\uffff";
    const string DFA162_maxS =
        "\x01\u0092\x05\x00\x07\uffff\x02\x00\x06\uffff\x01\x00\x06\uffff";
    const string DFA162_acceptS =
        "\x06\uffff\x01\x03\x04\uffff\x01\x04\x01\x05\x02\uffff\x01\x07"+
        "\x07\uffff\x01\x08\x01\x01\x01\x02\x01\x06\x01\x09";
    const string DFA162_specialS =
        "\x01\uffff\x01\x00\x01\x01\x01\x02\x01\x03\x01\x04\x07\uffff\x01"+
        "\x05\x01\x06\x06\uffff\x01\x07\x06\uffff}>";
    static readonly string[] DFA162_transitionS = {
            "\x0c\x0f\x01\x05\x0b\x0f\x01\x0e\x01\x0f\x01\x03\x05\x0f\x01"+
            "\x02\x01\x0f\x01\x01\x01\x0f\x01\x0e\x01\x04\x07\x0f\x04\x0e"+
            "\x01\x0f\x04\x0e\x01\uffff\x01\x0c\x01\uffff\x01\x17\x01\uffff"+
            "\x01\x0b\x03\uffff\x01\x15\x09\uffff\x01\x0f\x22\uffff\x02\x0f"+
            "\x0e\uffff\x02\x06\x02\uffff\x01\x06\x04\uffff\x01\x06\x02\uffff"+
            "\x01\x06\x01\uffff\x01\x0d\x01\uffff\x03\x0f",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            ""
    };

    static readonly short[] DFA162_eot = DFA.UnpackEncodedString(DFA162_eotS);
    static readonly short[] DFA162_eof = DFA.UnpackEncodedString(DFA162_eofS);
    static readonly char[] DFA162_min = DFA.UnpackEncodedStringToUnsignedChars(DFA162_minS);
    static readonly char[] DFA162_max = DFA.UnpackEncodedStringToUnsignedChars(DFA162_maxS);
    static readonly short[] DFA162_accept = DFA.UnpackEncodedString(DFA162_acceptS);
    static readonly short[] DFA162_special = DFA.UnpackEncodedString(DFA162_specialS);
    static readonly short[][] DFA162_transition = DFA.UnpackEncodedStringArray(DFA162_transitionS);

    protected class DFA162 : DFA
    {
        public DFA162(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 162;
            this.eot = DFA162_eot;
            this.eof = DFA162_eof;
            this.min = DFA162_min;
            this.max = DFA162_max;
            this.accept = DFA162_accept;
            this.special = DFA162_special;
            this.transition = DFA162_transition;

        }

        override public string Description
        {
            get { return "3521:1: primaryExpressionHelper : (T= THIS | S= SUPER | literal | arrayLiteral | objectLiteral | ( identifierLiteral x= XML_NS_OP )? identifierLiteral | xmlPrimaryExpression | parExpression | l= LT type g= GT ( arrayLiteral )? );"; }
        }

    }


    protected internal int DFA162_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
            ITokenStream input = (ITokenStream)_input;
        int _s = s;
        switch ( s )
        {
                case 0 : 
                    int LA162_1 = input.LA(1);

                     
                    int index162_1 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred385_AS3_ex()) ) { s = 24; }

                    else if ( (synpred392_AS3_ex()) ) { s = 15; }

                     
                    input.Seek(index162_1);
                    if ( s >= 0 ) return s;
                    break;
                case 1 : 
                    int LA162_2 = input.LA(1);

                     
                    int index162_2 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred386_AS3_ex()) ) { s = 25; }

                    else if ( (synpred392_AS3_ex()) ) { s = 15; }

                     
                    input.Seek(index162_2);
                    if ( s >= 0 ) return s;
                    break;
                case 2 : 
                    int LA162_3 = input.LA(1);

                     
                    int index162_3 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred387_AS3_ex()) ) { s = 6; }

                    else if ( (synpred392_AS3_ex()) ) { s = 15; }

                     
                    input.Seek(index162_3);
                    if ( s >= 0 ) return s;
                    break;
                case 3 : 
                    int LA162_4 = input.LA(1);

                     
                    int index162_4 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred387_AS3_ex()) ) { s = 6; }

                    else if ( (synpred392_AS3_ex()) ) { s = 15; }

                     
                    input.Seek(index162_4);
                    if ( s >= 0 ) return s;
                    break;
                case 4 : 
                    int LA162_5 = input.LA(1);

                     
                    int index162_5 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred387_AS3_ex()) ) { s = 6; }

                    else if ( (synpred392_AS3_ex()) ) { s = 15; }

                     
                    input.Seek(index162_5);
                    if ( s >= 0 ) return s;
                    break;
                case 5 : 
                    int LA162_13 = input.LA(1);

                     
                    int index162_13 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred391_AS3_ex()) ) { s = 26; }

                    else if ( (synpred392_AS3_ex()) ) { s = 15; }

                     
                    input.Seek(index162_13);
                    if ( s >= 0 ) return s;
                    break;
                case 6 : 
                    int LA162_14 = input.LA(1);

                     
                    int index162_14 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred391_AS3_ex()) ) { s = 26; }

                    else if ( (synpred392_AS3_ex()) ) { s = 15; }

                     
                    input.Seek(index162_14);
                    if ( s >= 0 ) return s;
                    break;
                case 7 : 
                    int LA162_21 = input.LA(1);

                     
                    int index162_21 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred392_AS3_ex()) ) { s = 15; }

                    else if ( (true) ) { s = 27; }

                     
                    input.Seek(index162_21);
                    if ( s >= 0 ) return s;
                    break;
        }
        if (state.backtracking > 0) {state.failed = true; return -1;}
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 162, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA161_eotS =
        "\x59\uffff";
    const string DFA161_eofS =
        "\x01\x02\x58\uffff";
    const string DFA161_minS =
        "\x01\x04\x01\x00\x57\uffff";
    const string DFA161_maxS =
        "\x01\u0092\x01\x00\x57\uffff";
    const string DFA161_acceptS =
        "\x02\uffff\x01\x02\x55\uffff\x01\x01";
    const string DFA161_specialS =
        "\x01\uffff\x01\x00\x57\uffff}>";
    static readonly string[] DFA161_transitionS = {
            "\x3b\x02\x01\x01\x06\x02\x01\uffff\x0c\x02\x02\uffff\x0f\x02"+
            "\x02\uffff\x05\x02\x01\uffff\x01\x02\x02\uffff\x03\x02\x0e\uffff"+
            "\x02\x02\x02\uffff\x01\x02\x04\uffff\x01\x02\x02\uffff\x01\x02"+
            "\x01\uffff\x01\x02\x01\uffff\x03\x02",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
    };

    static readonly short[] DFA161_eot = DFA.UnpackEncodedString(DFA161_eotS);
    static readonly short[] DFA161_eof = DFA.UnpackEncodedString(DFA161_eofS);
    static readonly char[] DFA161_min = DFA.UnpackEncodedStringToUnsignedChars(DFA161_minS);
    static readonly char[] DFA161_max = DFA.UnpackEncodedStringToUnsignedChars(DFA161_maxS);
    static readonly short[] DFA161_accept = DFA.UnpackEncodedString(DFA161_acceptS);
    static readonly short[] DFA161_special = DFA.UnpackEncodedString(DFA161_specialS);
    static readonly short[][] DFA161_transition = DFA.UnpackEncodedStringArray(DFA161_transitionS);

    protected class DFA161 : DFA
    {
        public DFA161(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 161;
            this.eot = DFA161_eot;
            this.eof = DFA161_eof;
            this.min = DFA161_min;
            this.max = DFA161_max;
            this.accept = DFA161_accept;
            this.special = DFA161_special;
            this.transition = DFA161_transition;

        }

        override public string Description
        {
            get { return "3530:48: ( arrayLiteral )?"; }
        }

    }


    protected internal int DFA161_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
            ITokenStream input = (ITokenStream)_input;
        int _s = s;
        switch ( s )
        {
                case 0 : 
                    int LA161_1 = input.LA(1);

                     
                    int index161_1 = input.Index();
                    input.Rewind();
                    s = -1;
                    if ( (synpred394_AS3_ex()) ) { s = 88; }

                    else if ( (true) ) { s = 2; }

                     
                    input.Seek(index161_1);
                    if ( s >= 0 ) return s;
                    break;
        }
        if (state.backtracking > 0) {state.failed = true; return -1;}
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 161, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
 

    public static readonly BitSet FOLLOW_TRUE_in_booleanLiteral3643 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_FALSE_in_booleanLiteral3651 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DEC_NUMBER_LITERAL_in_numericLiteral3685 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_HEX_NUMBER_LITERAL_in_numericLiteral3693 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_SINGLE_QUOTE_LITERAL_in_stringLiteral3728 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DOUBLE_QUOTE_LITERAL_in_stringLiteral3735 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_REGULAR_EXPR_LITERAL_in_regularExpresionLiteral3760 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_IDENTIFIER_in_identifierLiteral3793 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_notQuiteReservedWord_in_identifierLiteral3798 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_IDENTIFIER_in_xmlNameLiteral3833 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000020001002UL});
    public static readonly BitSet FOLLOW_allKeywords_in_xmlNameLiteral3838 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000020001002UL});
    public static readonly BitSet FOLLOW_SUB_in_xmlNameLiteral3849 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_DOT_in_xmlNameLiteral3857 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_COLON_in_xmlNameLiteral3865 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_IDENTIFIER_in_xmlNameLiteral3876 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000020001002UL});
    public static readonly BitSet FOLLOW_allKeywords_in_xmlNameLiteral3882 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000020001002UL});
    public static readonly BitSet FOLLOW_NULL_in_literal3935 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_booleanLiteral_in_literal3941 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_numericLiteral_in_literal3945 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_stringLiteral_in_literal3949 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_regularExpresionLiteral_in_literal3953 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlComment_in_xmlMarkup3989 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlCDATA_in_xmlMarkup3993 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlPI_in_xmlMarkup3997 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_XML_COMMENT_in_xmlComment4032 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_XML_CDATA_in_xmlCDATA4074 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_XML_PI_in_xmlPI4117 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LCURLY_in_xmlExprEval4155 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_expression_in_xmlExprEval4159 = new BitSet(new ulong[]{0x1000000000000000UL});
    public static readonly BitSet FOLLOW_RCURLY_in_xmlExprEval4163 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_allKeywords_in_xmlTextElement4181 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_set_in_xmlTextElement4194 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlTextElement_in_xmlText4909 = new BitSet(new ulong[]{0xF7FFFFFFFFFFFFF2UL,0x00019FCFFFE7FFB7UL,0x0000000000085203UL});
    public static readonly BitSet FOLLOW_xmlPropertyIdentifier_in_xmlPrimaryExpression4933 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlInitialiser_in_xmlPrimaryExpression4943 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlListInitialiser_in_xmlPrimaryExpression4953 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlAttributeIdentifier_in_xmlPropertyIdentifier5046 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlQualifiedIdentifier_in_xmlPropertyIdentifier5058 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_STAR_in_xmlPropertyIdentifier5072 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_XML_AT_in_xmlAttributeIdentifier5137 = new BitSet(new ulong[]{0x83FFFFFFFFFFFFF0UL,0x0000000000002000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_xmlQualifiedIdentifier_in_xmlAttributeIdentifier5163 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlPropertySelector_in_xmlAttributeIdentifier5178 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_indexSuffix_in_xmlAttributeIdentifier5193 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlNameLiteral_in_xmlPropertySelector5283 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_STAR_in_xmlPropertySelector5296 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlPropertySelector_in_xmlQualifiedIdentifier5317 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000800000000000UL});
    public static readonly BitSet FOLLOW_XML_NS_OP_in_xmlQualifiedIdentifier5322 = new BitSet(new ulong[]{0x83FFFFFFFFFFFFF0UL,0x0000000000002000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_xmlPropertySelector_in_xmlQualifiedIdentifier5357 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_indexSuffix_in_xmlQualifiedIdentifier5369 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlMarkup_in_xmlInitialiser5400 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlElement_in_xmlInitialiser5410 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LT_in_xmlElement5476 = new BitSet(new ulong[]{0x0BFFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_xmlTagName_in_xmlElement5482 = new BitSet(new ulong[]{0x0BFFFFFFFFFFFFF0UL,0x0000200000000010UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_xmlAttributes_in_xmlElement5484 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000200000000010UL});
    public static readonly BitSet FOLLOW_XML_TEND_in_xmlElement5504 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_GT_in_xmlElement5560 = new BitSet(new ulong[]{0xFFFFFFFFFFFFFFF0UL,0x0001DFCFFFE7FFBFUL,0x00000000000F5203UL});
    public static readonly BitSet FOLLOW_xmlElementContent_in_xmlElement5564 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000400000000000UL});
    public static readonly BitSet FOLLOW_XML_E_TEND_in_xmlElement5579 = new BitSet(new ulong[]{0x0BFFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_xmlTagName_in_xmlElement5594 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000010UL});
    public static readonly BitSet FOLLOW_GT_in_xmlElement5598 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlAttribute_in_xmlAttributes5637 = new BitSet(new ulong[]{0x0BFFFFFFFFFFFFF2UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_xmlExprEval_in_xmlTagName5667 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlNameLiteral_in_xmlTagName5672 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlTagName_in_xmlAttribute5695 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000040000000UL});
    public static readonly BitSet FOLLOW_ASSIGN_in_xmlAttribute5699 = new BitSet(new ulong[]{0x0800000000000000UL,0x0000000000000000UL,0x0000000000000003UL});
    public static readonly BitSet FOLLOW_xmlExprEval_in_xmlAttribute5718 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_stringLiteral_in_xmlAttribute5730 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlElementContentHelper_in_xmlElementContent5762 = new BitSet(new ulong[]{0xFFFFFFFFFFFFFFF2UL,0x00019FCFFFE7FFBFUL,0x00000000000F5203UL});
    public static readonly BitSet FOLLOW_xmlExprEval_in_xmlElementContentHelper5782 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlMarkup_in_xmlElementContentHelper5792 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlElement_in_xmlElementContentHelper5802 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlText_in_xmlElementContentHelper5813 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_XML_LS_STD_in_xmlListInitialiser5855 = new BitSet(new ulong[]{0xFFFFFFFFFFFFFFF0UL,0x00059FCFFFE7FFBFUL,0x00000000000F5203UL});
    public static readonly BitSet FOLLOW_xmlElementContent_in_xmlListInitialiser5870 = new BitSet(new ulong[]{0x0000000000000000UL,0x0004000000000000UL});
    public static readonly BitSet FOLLOW_XML_LS_END_in_xmlListInitialiser5883 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_SEMI_in_semic5921 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_EOF_in_semic5935 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_RCURLY_in_semic5949 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_packageDeclaration_in_fileContents5969 = new BitSet(new ulong[]{0xAFFFFFFFFFFFFFF2UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_packageElement_in_fileContents5972 = new BitSet(new ulong[]{0xAFFFFFFFFFFFFFF2UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_EOF_in_fileContents5978 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_PACKAGE_in_packageDeclaration5995 = new BitSet(new ulong[]{0x0BFFFFFFFFFFFFF0UL,0x0000000000002000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_type_in_packageDeclaration6002 = new BitSet(new ulong[]{0x0800000000000000UL});
    public static readonly BitSet FOLLOW_LCURLY_in_packageDeclaration6016 = new BitSet(new ulong[]{0xBFFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_packageElement_in_packageDeclaration6032 = new BitSet(new ulong[]{0xBFFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_RCURLY_in_packageDeclaration6058 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_conditionalCompilerOption_in_mxmlEmbedded6082 = new BitSet(new ulong[]{0x0800000000000000UL});
    public static readonly BitSet FOLLOW_LCURLY_in_mxmlEmbedded6090 = new BitSet(new ulong[]{0xBFFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_mxmlEmbedded_in_mxmlEmbedded6100 = new BitSet(new ulong[]{0x1000000000000000UL});
    public static readonly BitSet FOLLOW_RCURLY_in_mxmlEmbedded6109 = new BitSet(new ulong[]{0xAFFFFFFFFFFFFFF2UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_propertyDeclaration_in_mxmlEmbedded6122 = new BitSet(new ulong[]{0xAFFFFFFFFFFFFFF2UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_functionDeclaration_in_mxmlEmbedded6126 = new BitSet(new ulong[]{0xAFFFFFFFFFFFFFF2UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_statement_in_mxmlEmbedded6130 = new BitSet(new ulong[]{0xAFFFFFFFFFFFFFF2UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_directive_in_mxmlEmbedded6134 = new BitSet(new ulong[]{0xAFFFFFFFFFFFFFF2UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_interfaceFunctionDeclaration_in_mxmlEmbedded6138 = new BitSet(new ulong[]{0xAFFFFFFFFFFFFFF2UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_EOF_in_mxmlEmbedded6155 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_conditionalCompilerOption_in_packageElement6181 = new BitSet(new ulong[]{0x0800000000000000UL});
    public static readonly BitSet FOLLOW_LCURLY_in_packageElement6189 = new BitSet(new ulong[]{0xBFFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_packageElement_in_packageElement6199 = new BitSet(new ulong[]{0xBFFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_RCURLY_in_packageElement6214 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_classOrInterfaceDecl_in_packageElement6229 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_propertyDeclaration_in_packageElement6233 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_functionDeclaration_in_packageElement6237 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_interfaceFunctionDeclaration_in_packageElement6241 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_statement_in_packageElement6245 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_directive_in_packageElement6249 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_IMPORT_in_importDeclaration6274 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000002000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_type_in_importDeclaration6278 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DOT_in_importDeclaration6283 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000002000UL});
    public static readonly BitSet FOLLOW_STAR_in_importDeclaration6289 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_semic_in_importDeclaration6295 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_conditionalDirAndBindingDecls_in_classOrInterfaceDecl6312 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_memberModifiers_in_classOrInterfaceDecl6320 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_interfaceDeclaration_in_classOrInterfaceDecl6324 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_classDeclaration_in_classOrInterfaceDecl6328 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_bindingDecl_in_directive6345 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_includeDirective_in_directive6349 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_useNamespaceDirective_in_directive6353 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_importDeclaration_in_directive6357 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_defaultXMLNamespaceDirective_in_directive6363 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_conditionalCompilerOption_in_conditionalDirAndBindingDecls6389 = new BitSet(new ulong[]{0x8000000000000002UL});
    public static readonly BitSet FOLLOW_bindingDecl_in_conditionalDirAndBindingDecls6406 = new BitSet(new ulong[]{0x8000000000000002UL});
    public static readonly BitSet FOLLOW_IDENTIFIER_in_xmlKeyword6424 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_identifierLiteral_in_conditionalCompilerOption6440 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000800000000000UL});
    public static readonly BitSet FOLLOW_XML_NS_OP_in_conditionalCompilerOption6444 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_identifierLiteral_in_conditionalCompilerOption6448 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DEFAULT_in_defaultXMLNamespaceDirective6475 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_xmlKeyword_in_defaultXMLNamespaceDirective6479 = new BitSet(new ulong[]{0x0010000000000000UL});
    public static readonly BitSet FOLLOW_NAMESPACE_in_defaultXMLNamespaceDirective6487 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000040000000UL});
    public static readonly BitSet FOLLOW_ASSIGN_in_defaultXMLNamespaceDirective6495 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_defaultXMLNamespaceDirective6499 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_semic_in_defaultXMLNamespaceDirective6501 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LBRACK_in_bindingDecl6536 = new BitSet(new ulong[]{0x0000000000000000UL,0x0001000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_XML_AT_in_bindingDecl6547 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_IDENTIFIER_in_bindingDecl6553 = new BitSet(new ulong[]{0x2000000000000000UL,0x0000000000000001UL});
    public static readonly BitSet FOLLOW_LPAREN_in_bindingDecl6577 = new BitSet(new ulong[]{0x43FFFFFFFFFFFFF0UL,0x0001000000003800UL,0x0000000000005203UL});
    public static readonly BitSet FOLLOW_bindingDeclArg_in_bindingDecl6589 = new BitSet(new ulong[]{0x4000000000000000UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_COMMA_in_bindingDecl6594 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0001000000003800UL,0x0000000000005203UL});
    public static readonly BitSet FOLLOW_bindingDeclArg_in_bindingDecl6598 = new BitSet(new ulong[]{0x4000000000000000UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_RPAREN_in_bindingDecl6609 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000001UL});
    public static readonly BitSet FOLLOW_RBRACK_in_bindingDecl6630 = new BitSet(new ulong[]{0x0400000000000002UL});
    public static readonly BitSet FOLLOW_SEMI_in_bindingDecl6636 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_INCLUDE_in_includeDirective6666 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000000UL,0x0000000000000003UL});
    public static readonly BitSet FOLLOW_stringLiteral_in_includeDirective6669 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_semic_in_includeDirective6671 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_eitherIdentifier_in_bindingDeclArg6700 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000040000000UL});
    public static readonly BitSet FOLLOW_ASSIGN_in_bindingDeclArg6704 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0001000000003800UL,0x0000000000005203UL});
    public static readonly BitSet FOLLOW_stringLiteral_in_bindingDeclArg6717 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_PLUS_in_bindingDeclArg6724 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000000UL,0x0000000000001200UL});
    public static readonly BitSet FOLLOW_SUB_in_bindingDeclArg6732 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000000UL,0x0000000000001200UL});
    public static readonly BitSet FOLLOW_numericLiteral_in_bindingDeclArg6739 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_eitherIdentifier_in_bindingDeclArg6744 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DOT_in_bindingDeclArg6749 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0001000000002000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_eitherIdentifier_in_bindingDeclArg6753 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_INTERFACE_in_interfaceDeclaration6790 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000002000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_type_in_interfaceDeclaration6794 = new BitSet(new ulong[]{0x0800000000008000UL});
    public static readonly BitSet FOLLOW_EXTENDS_in_interfaceDeclaration6802 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000002000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_typeList_in_interfaceDeclaration6816 = new BitSet(new ulong[]{0x0800000000008000UL});
    public static readonly BitSet FOLLOW_interfaceBody_in_interfaceDeclaration6843 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LCURLY_in_interfaceBody6859 = new BitSet(new ulong[]{0xBFFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_interfaceElement_in_interfaceBody6875 = new BitSet(new ulong[]{0xBFFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_RCURLY_in_interfaceBody6901 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_CLASS_in_classDeclaration6928 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000002000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_type_in_classDeclaration6932 = new BitSet(new ulong[]{0x0800000000208000UL});
    public static readonly BitSet FOLLOW_EXTENDS_in_classDeclaration6941 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000002000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_type_in_classDeclaration6953 = new BitSet(new ulong[]{0x0800000000208000UL});
    public static readonly BitSet FOLLOW_IMPLEMENTS_in_classDeclaration6973 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000002000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_typeList_in_classDeclaration6987 = new BitSet(new ulong[]{0x0800000000208000UL});
    public static readonly BitSet FOLLOW_classBody_in_classDeclaration7013 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LCURLY_in_classBody7042 = new BitSet(new ulong[]{0xBFFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_classBodyElement_in_classBody7052 = new BitSet(new ulong[]{0xBFFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_RCURLY_in_classBody7069 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_conditionalCompilerOption_in_classBodyElement7108 = new BitSet(new ulong[]{0x0800000000000000UL});
    public static readonly BitSet FOLLOW_LCURLY_in_classBodyElement7116 = new BitSet(new ulong[]{0xBFFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_classBodyElement_in_classBodyElement7126 = new BitSet(new ulong[]{0xBFFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_RCURLY_in_classBodyElement7145 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_propertyDeclaration_in_classBodyElement7159 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_functionDeclaration_in_classBodyElement7163 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_statement_in_classBodyElement7167 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_directive_in_classBodyElement7171 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_conditionalCompilerOption_in_interfaceElement7203 = new BitSet(new ulong[]{0x0800000000000000UL});
    public static readonly BitSet FOLLOW_LCURLY_in_interfaceElement7211 = new BitSet(new ulong[]{0xBFFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_interfaceElement_in_interfaceElement7221 = new BitSet(new ulong[]{0xBFFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_RCURLY_in_interfaceElement7240 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_propertyDeclaration_in_interfaceElement7254 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_interfaceFunctionDeclaration_in_interfaceElement7258 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_statement_in_interfaceElement7262 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_directive_in_interfaceElement7265 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_conditionalDirAndBindingDecls_in_interfaceFunctionDeclaration7300 = new BitSet(new ulong[]{0x03C0000714080000UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_memberModifiers_in_interfaceFunctionDeclaration7306 = new BitSet(new ulong[]{0x0000000000080000UL});
    public static readonly BitSet FOLLOW_FUNCTION_in_interfaceFunctionDeclaration7311 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_SET_in_interfaceFunctionDeclaration7330 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_GET_in_interfaceFunctionDeclaration7337 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_IDENTIFIER_in_interfaceFunctionDeclaration7354 = new BitSet(new ulong[]{0x2000000000000000UL});
    public static readonly BitSet FOLLOW_notQuiteReservedWord_in_interfaceFunctionDeclaration7360 = new BitSet(new ulong[]{0x2000000000000000UL});
    public static readonly BitSet FOLLOW_formalParameterList_in_interfaceFunctionDeclaration7363 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000020000002UL});
    public static readonly BitSet FOLLOW_COLON_in_interfaceFunctionDeclaration7368 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000002000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_type_in_interfaceFunctionDeclaration7372 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_semic_in_interfaceFunctionDeclaration7376 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_conditionalDirAndBindingDecls_in_propertyDeclaration7406 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_memberModifiers_in_propertyDeclaration7413 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_variableStatement_in_propertyDeclaration7417 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_constantVarStatement_in_propertyDeclaration7421 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_namespaceDirective_in_propertyDeclaration7425 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_conditionalDirAndBindingDecls_in_functionDeclaration7459 = new BitSet(new ulong[]{0x03C0000714080000UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_memberModifiers_in_functionDeclaration7466 = new BitSet(new ulong[]{0x0000000000080000UL});
    public static readonly BitSet FOLLOW_FUNCTION_in_functionDeclaration7471 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_set_in_functionDeclaration7492 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_IDENTIFIER_in_functionDeclaration7513 = new BitSet(new ulong[]{0x2000000000000000UL});
    public static readonly BitSet FOLLOW_notQuiteReservedWord_in_functionDeclaration7519 = new BitSet(new ulong[]{0x2000000000000000UL});
    public static readonly BitSet FOLLOW_formalParameterList_in_functionDeclaration7522 = new BitSet(new ulong[]{0x0800000000000000UL,0x0000000020000000UL});
    public static readonly BitSet FOLLOW_COLON_in_functionDeclaration7527 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000002000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_type_in_functionDeclaration7531 = new BitSet(new ulong[]{0x0800000000000000UL,0x0000000020000000UL});
    public static readonly BitSet FOLLOW_functionBody_in_functionDeclaration7547 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_FUNCTION_in_functionExpression7582 = new BitSet(new ulong[]{0x2000000000000000UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_IDENTIFIER_in_functionExpression7589 = new BitSet(new ulong[]{0x2000000000000000UL});
    public static readonly BitSet FOLLOW_formalParameterList_in_functionExpression7594 = new BitSet(new ulong[]{0x0800000000000000UL,0x0000000020000000UL});
    public static readonly BitSet FOLLOW_COLON_in_functionExpression7599 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000002000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_type_in_functionExpression7603 = new BitSet(new ulong[]{0x0800000000000000UL,0x0000000020000000UL});
    public static readonly BitSet FOLLOW_functionBody_in_functionExpression7617 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LPAREN_in_formalParameterList7653 = new BitSet(new ulong[]{0x43FFFFFFFFFFFFF0UL,0x0000080000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_variableDeclaration_in_formalParameterList7674 = new BitSet(new ulong[]{0x4000000000000000UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_COMMA_in_formalParameterList7711 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_variableDeclaration_in_formalParameterList7746 = new BitSet(new ulong[]{0x4000000000000000UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_COMMA_in_formalParameterList7781 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000080000000000UL});
    public static readonly BitSet FOLLOW_formalEllipsisParameter_in_formalParameterList7786 = new BitSet(new ulong[]{0x4000000000000000UL});
    public static readonly BitSet FOLLOW_formalEllipsisParameter_in_formalParameterList7818 = new BitSet(new ulong[]{0x4000000000000000UL});
    public static readonly BitSet FOLLOW_RPAREN_in_formalParameterList7836 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ELLIPSIS_in_formalEllipsisParameter7883 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_variableIdentifierDecl_in_formalEllipsisParameter7888 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LCURLY_in_functionBody7917 = new BitSet(new ulong[]{0xBFFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_statement_in_functionBody7936 = new BitSet(new ulong[]{0xBFFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_functionDeclaration_in_functionBody7940 = new BitSet(new ulong[]{0xBFFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_RCURLY_in_functionBody7973 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_memberModifier_in_memberModifiers8001 = new BitSet(new ulong[]{0x03C0000714000002UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_set_in_memberModifier8028 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_blockStatement_in_statement8177 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_directive_in_statement8188 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_namespaceDirective_in_statement8199 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_constantVarStatement_in_statement8212 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_tryStatement_in_statement8225 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_switchStatement_in_statement8237 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_withStatement_in_statement8251 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_returnStatement_in_statement8265 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_breakStatement_in_statement8279 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_continueStatement_in_statement8293 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_forStatement_in_statement8310 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_forInStatement_in_statement8327 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_forEachInStatement_in_statement8344 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_doWhileStatement_in_statement8361 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_whileStatement_in_statement8378 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ifStatement_in_statement8393 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_variableStatement_in_statement8407 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_throwStatement_in_statement8422 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_labelledStatement_in_statement8438 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_expression_in_statement8470 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_semic_in_statement8472 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_emptyStatement_in_statement8487 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_conditionalCompilerOption_in_blockStatement8529 = new BitSet(new ulong[]{0x0800000000000000UL});
    public static readonly BitSet FOLLOW_LCURLY_in_blockStatement8535 = new BitSet(new ulong[]{0xBFFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_statement_in_blockStatement8552 = new BitSet(new ulong[]{0xBFFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_RCURLY_in_blockStatement8572 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_THROW_in_throwStatement8597 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_expression_in_throwStatement8608 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_semic_in_throwStatement8610 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_CONST_in_constantVarStatement8641 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_variableDeclarationList_in_constantVarStatement8646 = new BitSet(new ulong[]{0x0400000000000002UL});
    public static readonly BitSet FOLLOW_SEMI_in_constantVarStatement8651 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_USE_in_useNamespaceDirective8699 = new BitSet(new ulong[]{0x0010000000000000UL});
    public static readonly BitSet FOLLOW_NAMESPACE_in_useNamespaceDirective8708 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_qualifiedIdentifier_in_useNamespaceDirective8715 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000000000006UL});
    public static readonly BitSet FOLLOW_COMMA_in_useNamespaceDirective8720 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_qualifiedIdentifier_in_useNamespaceDirective8724 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000000000006UL});
    public static readonly BitSet FOLLOW_semic_in_useNamespaceDirective8728 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_NAMESPACE_in_namespaceDirective8767 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_qualifiedIdentifier_in_namespaceDirective8778 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000040000002UL});
    public static readonly BitSet FOLLOW_ASSIGN_in_namespaceDirective8784 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000000UL,0x0000000000000003UL});
    public static readonly BitSet FOLLOW_stringLiteral_in_namespaceDirective8789 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_semic_in_namespaceDirective8794 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_TRY_in_tryStatement8833 = new BitSet(new ulong[]{0x0BFFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_blockStatement_in_tryStatement8839 = new BitSet(new ulong[]{0x0000000000020080UL});
    public static readonly BitSet FOLLOW_catchClause_in_tryStatement8853 = new BitSet(new ulong[]{0x0000000000020080UL});
    public static readonly BitSet FOLLOW_finallyClause_in_tryStatement8856 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_catchClause_in_tryStatement8868 = new BitSet(new ulong[]{0x0000000000000082UL});
    public static readonly BitSet FOLLOW_finallyClause_in_tryStatement8881 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_CATCH_in_catchClause8910 = new BitSet(new ulong[]{0x2000000000000000UL});
    public static readonly BitSet FOLLOW_LPAREN_in_catchClause8917 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_variableIdentifierDecl_in_catchClause8921 = new BitSet(new ulong[]{0x4000000000000000UL});
    public static readonly BitSet FOLLOW_RPAREN_in_catchClause8925 = new BitSet(new ulong[]{0x0BFFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_blockStatement_in_catchClause8929 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_FINALLY_in_finallyClause8953 = new BitSet(new ulong[]{0x0BFFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_blockStatement_in_finallyClause8958 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_IDENTIFIER_in_labelledStatement8984 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000020000000UL});
    public static readonly BitSet FOLLOW_COLON_in_labelledStatement8997 = new BitSet(new ulong[]{0xAFFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_statement_in_labelledStatement9013 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_SWITCH_in_switchStatement9065 = new BitSet(new ulong[]{0x2000000000000000UL});
    public static readonly BitSet FOLLOW_parExpression_in_switchStatement9076 = new BitSet(new ulong[]{0x0800000000000000UL});
    public static readonly BitSet FOLLOW_LCURLY_in_switchStatement9088 = new BitSet(new ulong[]{0x1000000000000840UL});
    public static readonly BitSet FOLLOW_switchBlockStatementGroup_in_switchStatement9104 = new BitSet(new ulong[]{0x1000000000000840UL});
    public static readonly BitSet FOLLOW_RCURLY_in_switchStatement9124 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_switchLabel_in_switchBlockStatementGroup9162 = new BitSet(new ulong[]{0xAFFFFFFFFFFFFFF2UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_statement_in_switchBlockStatementGroup9179 = new BitSet(new ulong[]{0xAFFFFFFFFFFFFFF2UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_breakStatement_in_switchBlockStatementGroup9202 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_CASE_in_switchLabel9228 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_expression_in_switchLabel9234 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000020000000UL});
    public static readonly BitSet FOLLOW_COLON_in_switchLabel9238 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DEFAULT_in_switchLabel9259 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000020000000UL});
    public static readonly BitSet FOLLOW_COLON_in_switchLabel9265 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_WITH_in_withStatement9313 = new BitSet(new ulong[]{0x2000000000000000UL});
    public static readonly BitSet FOLLOW_LPAREN_in_withStatement9321 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_expression_in_withStatement9326 = new BitSet(new ulong[]{0x4000000000000000UL});
    public static readonly BitSet FOLLOW_RPAREN_in_withStatement9331 = new BitSet(new ulong[]{0xAFFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_statement_in_withStatement9352 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_RETURN_in_returnStatement9396 = new BitSet(new ulong[]{0xBFFFFFFFFFFFFFF0UL,0x000300000303380AUL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_expression_in_returnStatement9417 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_semic_in_returnStatement9421 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_BREAK_in_breakStatement9448 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000000000002UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_IDENTIFIER_in_breakStatement9471 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_semic_in_breakStatement9476 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_CONTINUE_in_continueStatement9502 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000000000002UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_IDENTIFIER_in_continueStatement9522 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_semic_in_continueStatement9527 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_FOR_in_forStatement9565 = new BitSet(new ulong[]{0x2000000000000000UL});
    public static readonly BitSet FOLLOW_LPAREN_in_forStatement9573 = new BitSet(new ulong[]{0xBFFFFFFFFFFFFFF0UL,0x000300000303380AUL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_forControl_in_forStatement9577 = new BitSet(new ulong[]{0x4000000000000000UL});
    public static readonly BitSet FOLLOW_RPAREN_in_forStatement9581 = new BitSet(new ulong[]{0xAFFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_statement_in_forStatement9600 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_FOR_in_forInStatement9656 = new BitSet(new ulong[]{0x2000000000000000UL});
    public static readonly BitSet FOLLOW_LPAREN_in_forInStatement9664 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000000002008UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_forInControl_in_forInStatement9668 = new BitSet(new ulong[]{0x4000000000000000UL});
    public static readonly BitSet FOLLOW_RPAREN_in_forInStatement9672 = new BitSet(new ulong[]{0xAFFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_statement_in_forInStatement9693 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_FOR_in_forEachInStatement9755 = new BitSet(new ulong[]{0x0002000000000000UL});
    public static readonly BitSet FOLLOW_EACH_in_forEachInStatement9773 = new BitSet(new ulong[]{0x2000000000000000UL});
    public static readonly BitSet FOLLOW_LPAREN_in_forEachInStatement9781 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000000002008UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_forInControl_in_forEachInStatement9785 = new BitSet(new ulong[]{0x4000000000000000UL});
    public static readonly BitSet FOLLOW_RPAREN_in_forEachInStatement9789 = new BitSet(new ulong[]{0xAFFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_statement_in_forEachInStatement9806 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_forInit_in_forControl9848 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_semic_in_forControl9853 = new BitSet(new ulong[]{0xBFFFFFFFFFFFFFF0UL,0x000300000303380AUL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_expression_in_forControl9858 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_semic_in_forControl9862 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF2UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_forUpdate_in_forControl9866 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_forInDecl_in_forInControl9894 = new BitSet(new ulong[]{0x0000000000800000UL});
    public static readonly BitSet FOLLOW_IN_in_forInControl9898 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_expression_in_forInControl9902 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_leftHandSideExpression_in_forInDecl9921 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_VAR_in_forInDecl9933 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_variableDeclarationNoIn_in_forInDecl9937 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_VAR_in_forInit9958 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_variableDeclarationNoInList_in_forInit9961 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_expressionNoIn_in_forInit9971 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_expression_in_forUpdate9990 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DO_in_doWhileStatement10032 = new BitSet(new ulong[]{0xAFFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_statement_in_doWhileStatement10052 = new BitSet(new ulong[]{0x0000800000000000UL});
    public static readonly BitSet FOLLOW_WHILE_in_doWhileStatement10091 = new BitSet(new ulong[]{0x2000000000000000UL});
    public static readonly BitSet FOLLOW_parExpression_in_doWhileStatement10095 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_semic_in_doWhileStatement10097 = new BitSet(new ulong[]{0x0400000000000002UL});
    public static readonly BitSet FOLLOW_SEMI_in_doWhileStatement10102 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_WHILE_in_whileStatement10151 = new BitSet(new ulong[]{0x2000000000000000UL});
    public static readonly BitSet FOLLOW_parExpression_in_whileStatement10156 = new BitSet(new ulong[]{0xAFFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_statement_in_whileStatement10176 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_IF_in_ifStatement10263 = new BitSet(new ulong[]{0x2000000000000000UL});
    public static readonly BitSet FOLLOW_parExpression_in_ifStatement10298 = new BitSet(new ulong[]{0xAFFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_statement_in_ifStatement10370 = new BitSet(new ulong[]{0x0000000000004002UL});
    public static readonly BitSet FOLLOW_ELSE_in_ifStatement10447 = new BitSet(new ulong[]{0xAFFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_statement_in_ifStatement10535 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_SEMI_in_emptyStatement10618 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_IDENTIFIER_in_variableStatement10665 = new BitSet(new ulong[]{0x0000200000000000UL});
    public static readonly BitSet FOLLOW_VAR_in_variableStatement10673 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_variableDeclaration_in_variableStatement10677 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000000000006UL});
    public static readonly BitSet FOLLOW_COMMA_in_variableStatement10685 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_variableDeclaration_in_variableStatement10689 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000000000006UL});
    public static readonly BitSet FOLLOW_semic_in_variableStatement10694 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_variableDeclaration_in_variableDeclarationList10743 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_COMMA_in_variableDeclarationList10750 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_variableDeclaration_in_variableDeclarationList10754 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_variableDeclarationNoIn_in_variableDeclarationNoInList10803 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_COMMA_in_variableDeclarationNoInList10809 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_variableDeclarationNoIn_in_variableDeclarationNoInList10813 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_variableIdentifierDecl_in_variableDeclaration10850 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000040000000UL});
    public static readonly BitSet FOLLOW_ASSIGN_in_variableDeclaration10856 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_variableDeclaration10872 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_variableIdentifierDecl_in_variableDeclarationNoIn10901 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000040000000UL});
    public static readonly BitSet FOLLOW_ASSIGN_in_variableDeclarationNoIn10907 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_assignmentExpressionNoIn_in_variableDeclarationNoIn10931 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_identifierLiteral_in_variableIdentifierDecl10956 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000020000000UL});
    public static readonly BitSet FOLLOW_COLON_in_variableIdentifierDecl10962 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000002000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_type_in_variableIdentifierDecl10966 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_qualifiedName_in_type10990 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_STAR_in_type10996 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_VOID_in_type11004 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_type_in_typeList11037 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_COMMA_in_typeList11042 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000002000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_type_in_typeList11046 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_typeSpecifier_in_standardQualifiedName11077 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DOT_in_standardQualifiedName11082 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_typeSpecifier_in_standardQualifiedName11086 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_standardQualifiedName_in_qualifiedName11115 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_typePostfixSyntax_in_qualifiedName11118 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DOT_in_typePostfixSyntax11140 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000008UL});
    public static readonly BitSet FOLLOW_LT_in_typePostfixSyntax11150 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000002000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_standardQualifiedName_in_typePostfixSyntax11155 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000012UL});
    public static readonly BitSet FOLLOW_STAR_in_typePostfixSyntax11161 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000012UL});
    public static readonly BitSet FOLLOW_typePostfixSyntax_in_typePostfixSyntax11167 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000010UL});
    public static readonly BitSet FOLLOW_GT_in_typePostfixSyntax11173 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_IDENTIFIER_in_qualifiedIdentifier11206 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LPAREN_in_parExpression11243 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_expression_in_parExpression11250 = new BitSet(new ulong[]{0x4000000000000000UL});
    public static readonly BitSet FOLLOW_RPAREN_in_parExpression11255 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_expression11302 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_COMMA_in_expression11309 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_expression11314 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_assignmentExpressionNoIn_in_expressionNoIn11358 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_COMMA_in_expressionNoIn11365 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_assignmentExpressionNoIn_in_expressionNoIn11370 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_leftHandSideExpression_in_assignmentExpression11438 = new BitSet(new ulong[]{0x0000000000000000UL,0x000007CFC0002010UL});
    public static readonly BitSet FOLLOW_assignmentOperator_in_assignmentExpression11441 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_assignmentExpression11444 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_conditionalExpression_in_assignmentExpression11453 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_leftHandSideExpression_in_assignmentExpressionNoIn11523 = new BitSet(new ulong[]{0x0000000000000000UL,0x000007CFC0002010UL});
    public static readonly BitSet FOLLOW_assignmentOperator_in_assignmentExpressionNoIn11526 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_assignmentExpressionNoIn_in_assignmentExpressionNoIn11529 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_conditionalExpressionNoIn_in_assignmentExpressionNoIn11538 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_assignmentOperator_int_in_assignmentOperator11575 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ASSIGN_in_assignmentOperator_int11601 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_STAR_in_assignmentOperator_int11610 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000040000000UL});
    public static readonly BitSet FOLLOW_ASSIGN_in_assignmentOperator_int11614 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DIV_ASSIGN_in_assignmentOperator_int11625 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_MOD_ASSIGN_in_assignmentOperator_int11634 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ADD_ASSIGN_in_assignmentOperator_int11643 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_SUB_ASSIGN_in_assignmentOperator_int11652 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_SHL_ASSIGN_in_assignmentOperator_int11660 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_GT_in_assignmentOperator_int11686 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000010UL});
    public static readonly BitSet FOLLOW_GT_in_assignmentOperator_int11690 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000040000000UL});
    public static readonly BitSet FOLLOW_ASSIGN_in_assignmentOperator_int11694 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_GT_in_assignmentOperator_int11740 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000010UL});
    public static readonly BitSet FOLLOW_GT_in_assignmentOperator_int11744 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000010UL});
    public static readonly BitSet FOLLOW_GT_in_assignmentOperator_int11748 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000040000000UL});
    public static readonly BitSet FOLLOW_ASSIGN_in_assignmentOperator_int11752 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_AND_ASSIGN_in_assignmentOperator_int11783 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_XOR_ASSIGN_in_assignmentOperator_int11792 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_OR_ASSIGN_in_assignmentOperator_int11801 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LOR_ASSIGN_in_assignmentOperator_int11809 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LAND_ASSIGN_in_assignmentOperator_int11817 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_logicalORExpression_in_conditionalExpression11852 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000010000000UL});
    public static readonly BitSet FOLLOW_QUE_in_conditionalExpression11858 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_conditionalExpression11863 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000020000000UL});
    public static readonly BitSet FOLLOW_COLON_in_conditionalExpression11870 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_conditionalExpression11875 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_logicalORExpressionNoIn_in_conditionalExpressionNoIn11927 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000010000000UL});
    public static readonly BitSet FOLLOW_QUE_in_conditionalExpressionNoIn11933 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_conditionalExpressionNoIn11937 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000020000000UL});
    public static readonly BitSet FOLLOW_COLON_in_conditionalExpressionNoIn11944 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_conditionalExpressionNoIn11949 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_logicalANDExpression_in_logicalORExpression12006 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000008000000UL});
    public static readonly BitSet FOLLOW_LOR_in_logicalORExpression12012 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_logicalANDExpression_in_logicalORExpression12016 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000008000000UL});
    public static readonly BitSet FOLLOW_logicalANDExpressionNoIn_in_logicalORExpressionNoIn12069 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000008000000UL});
    public static readonly BitSet FOLLOW_LOR_in_logicalORExpressionNoIn12075 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_logicalANDExpressionNoIn_in_logicalORExpressionNoIn12079 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000008000000UL});
    public static readonly BitSet FOLLOW_bitwiseORExpression_in_logicalANDExpression12136 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000004000000UL});
    public static readonly BitSet FOLLOW_LAND_in_logicalANDExpression12142 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_bitwiseORExpression_in_logicalANDExpression12146 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000004000000UL});
    public static readonly BitSet FOLLOW_bitwiseORExpressionNoIn_in_logicalANDExpressionNoIn12198 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000004000000UL});
    public static readonly BitSet FOLLOW_LAND_in_logicalANDExpressionNoIn12204 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_bitwiseORExpressionNoIn_in_logicalANDExpressionNoIn12208 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000004000000UL});
    public static readonly BitSet FOLLOW_bitwiseXORExpression_in_bitwiseORExpression12265 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000400000UL});
    public static readonly BitSet FOLLOW_OR_in_bitwiseORExpression12271 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_bitwiseXORExpression_in_bitwiseORExpression12275 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000400000UL});
    public static readonly BitSet FOLLOW_bitwiseXORExpressionNoIn_in_bitwiseORExpressionNoIn12327 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000400000UL});
    public static readonly BitSet FOLLOW_OR_in_bitwiseORExpressionNoIn12333 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_bitwiseXORExpressionNoIn_in_bitwiseORExpressionNoIn12337 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000400000UL});
    public static readonly BitSet FOLLOW_bitwiseANDExpression_in_bitwiseXORExpression12393 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000800000UL});
    public static readonly BitSet FOLLOW_XOR_in_bitwiseXORExpression12399 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_bitwiseANDExpression_in_bitwiseXORExpression12403 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000800000UL});
    public static readonly BitSet FOLLOW_bitwiseANDExpressionNoIn_in_bitwiseXORExpressionNoIn12455 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000800000UL});
    public static readonly BitSet FOLLOW_XOR_in_bitwiseXORExpressionNoIn12461 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_bitwiseANDExpressionNoIn_in_bitwiseXORExpressionNoIn12465 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000800000UL});
    public static readonly BitSet FOLLOW_equalityExpression_in_bitwiseANDExpression12517 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000200000UL});
    public static readonly BitSet FOLLOW_AND_in_bitwiseANDExpression12523 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_equalityExpression_in_bitwiseANDExpression12527 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000200000UL});
    public static readonly BitSet FOLLOW_equalityExpressionNoIn_in_bitwiseANDExpressionNoIn12579 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000200000UL});
    public static readonly BitSet FOLLOW_AND_in_bitwiseANDExpressionNoIn12585 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_equalityExpressionNoIn_in_bitwiseANDExpressionNoIn12589 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000200000UL});
    public static readonly BitSet FOLLOW_relationalExpression_in_equalityExpression12642 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000780UL});
    public static readonly BitSet FOLLOW_set_in_equalityExpression12648 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_relationalExpression_in_equalityExpression12660 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000780UL});
    public static readonly BitSet FOLLOW_relationalExpressionNoIn_in_equalityExpressionNoIn12712 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000780UL});
    public static readonly BitSet FOLLOW_set_in_equalityExpressionNoIn12718 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_relationalExpressionNoIn_in_equalityExpressionNoIn12731 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000780UL});
    public static readonly BitSet FOLLOW_shiftExpression_in_relationalExpression12784 = new BitSet(new ulong[]{0x0000000009800012UL,0x0000000000000038UL});
    public static readonly BitSet FOLLOW_GT_in_relationalExpression12804 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000043033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_ASSIGN_in_relationalExpression12809 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_set_in_relationalExpression12842 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_shiftExpression_in_relationalExpression12880 = new BitSet(new ulong[]{0x0000000009800012UL,0x0000000000000038UL});
    public static readonly BitSet FOLLOW_shiftExpression_in_relationalExpressionNoIn12941 = new BitSet(new ulong[]{0x0000000009000012UL,0x0000000000000038UL});
    public static readonly BitSet FOLLOW_GT_in_relationalExpressionNoIn12961 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000043033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_ASSIGN_in_relationalExpressionNoIn12966 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_set_in_relationalExpressionNoIn12999 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_shiftExpression_in_relationalExpressionNoIn13035 = new BitSet(new ulong[]{0x0000000009000012UL,0x0000000000000038UL});
    public static readonly BitSet FOLLOW_additiveExpression_in_shiftExpression13093 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000040010UL});
    public static readonly BitSet FOLLOW_SHL_in_shiftExpression13115 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_GT_in_shiftExpression13146 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000010UL});
    public static readonly BitSet FOLLOW_GT_in_shiftExpression13150 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_GT_in_shiftExpression13201 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000010UL});
    public static readonly BitSet FOLLOW_GT_in_shiftExpression13205 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000010UL});
    public static readonly BitSet FOLLOW_GT_in_shiftExpression13209 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_additiveExpression_in_shiftExpression13256 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000040010UL});
    public static readonly BitSet FOLLOW_multiplicativeExpression_in_additiveExpression13308 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000001800UL});
    public static readonly BitSet FOLLOW_set_in_additiveExpression13314 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_multiplicativeExpression_in_additiveExpression13322 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000001800UL});
    public static readonly BitSet FOLLOW_unaryExpression_in_multiplicativeExpression13371 = new BitSet(new ulong[]{0x0000000000000002UL,0x000000000000E000UL});
    public static readonly BitSet FOLLOW_set_in_multiplicativeExpression13377 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_unaryExpression_in_multiplicativeExpression13386 = new BitSet(new ulong[]{0x0000000000000002UL,0x000000000000E000UL});
    public static readonly BitSet FOLLOW_postfixExpression_in_unaryExpression13421 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_set_in_unaryExpression13432 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_unaryExpression_in_unaryExpression13442 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_unaryOp_in_unaryExpression13452 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000000002008UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_postfixExpression_in_unaryExpression13454 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_set_in_unaryOp13485 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_leftHandSideExpression_in_postfixExpression13542 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000030000UL});
    public static readonly BitSet FOLLOW_postfixOp_in_postfixExpression13544 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_set_in_postfixOp13570 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_primaryExpression_in_memberExpression13592 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_functionExpression_in_memberExpression13597 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_newExpression_in_memberExpression13602 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_NEW_in_newExpression13615 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000000002008UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_primaryExpression_in_newExpression13620 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_memberExpression_in_leftHandSideExpression13646 = new BitSet(new ulong[]{0xA000000000000002UL,0x0000900000000002UL});
    public static readonly BitSet FOLLOW_arguments_in_leftHandSideExpression13661 = new BitSet(new ulong[]{0xA000000000000002UL,0x0000900000000002UL});
    public static readonly BitSet FOLLOW_LBRACK_in_leftHandSideExpression13673 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_expression_in_leftHandSideExpression13677 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000001UL});
    public static readonly BitSet FOLLOW_RBRACK_in_leftHandSideExpression13681 = new BitSet(new ulong[]{0xA000000000000002UL,0x0000900000000002UL});
    public static readonly BitSet FOLLOW_XML_ELLIPSIS_in_leftHandSideExpression13697 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0001000000002000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_eitherIdentifier_in_leftHandSideExpression13700 = new BitSet(new ulong[]{0xA000000000000002UL,0x0000900000000002UL});
    public static readonly BitSet FOLLOW_DOT_in_leftHandSideExpression13714 = new BitSet(new ulong[]{0x23FFFFFFFFFFFFF0UL,0x0001000000002000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_eitherIdentifier_in_leftHandSideExpression13719 = new BitSet(new ulong[]{0xA000000000000002UL,0x0000900000000002UL});
    public static readonly BitSet FOLLOW_parExpression_in_leftHandSideExpression13725 = new BitSet(new ulong[]{0xA000000000000002UL,0x0000900000000002UL});
    public static readonly BitSet FOLLOW_typePostfixSyntax_in_leftHandSideExpression13738 = new BitSet(new ulong[]{0xA000000000000002UL,0x0000900000000002UL});
    public static readonly BitSet FOLLOW_XML_NS_OP_in_leftHandSideExpression13750 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_expression_in_leftHandSideExpression13754 = new BitSet(new ulong[]{0xA000000000000002UL,0x0000900000000002UL});
    public static readonly BitSet FOLLOW_IDENTIFIER_in_eitherIdentifier13791 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlPropertyIdentifier_in_eitherIdentifier13801 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_allKeywords_in_eitherIdentifier13807 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_IDENTIFIER_in_typeSpecifier13820 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_notQuiteReservedWord_in_typeSpecifier13826 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_INTERNAL_in_typeSpecifier13832 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DEFAULT_in_typeSpecifier13840 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_set_in_notQuiteReservedWord13858 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_reservedWord_in_allKeywords13911 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_notQuiteReservedWord_in_allKeywords13915 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_set_in_reservedWord13932 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LPAREN_in_arguments14494 = new BitSet(new ulong[]{0xEBFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_arguments14507 = new BitSet(new ulong[]{0x4000000000000000UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_COMMA_in_arguments14537 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_arguments14562 = new BitSet(new ulong[]{0x4000000000000000UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_RPAREN_in_arguments14588 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_indexSuffix_in_suffix14618 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_propertyReferenceSuffix_in_suffix14622 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LBRACK_in_indexSuffix14663 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_expression_in_indexSuffix14668 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000001UL});
    public static readonly BitSet FOLLOW_RBRACK_in_indexSuffix14673 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DOT_in_propertyReferenceSuffix14701 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_IDENTIFIER_in_propertyReferenceSuffix14708 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DOT_in_propertyReferenceSuffix14725 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0001000000002000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_xmlPropertyIdentifier_in_propertyReferenceSuffix14730 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DOT_in_propertyReferenceSuffix14745 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_primaryExpressionHelper_in_primaryExpression14775 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_THIS_in_primaryExpressionHelper14802 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_SUPER_in_primaryExpressionHelper14816 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_literal_in_primaryExpressionHelper14828 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_arrayLiteral_in_primaryExpressionHelper14840 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_objectLiteral_in_primaryExpressionHelper14851 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_identifierLiteral_in_primaryExpressionHelper14864 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000800000000000UL});
    public static readonly BitSet FOLLOW_XML_NS_OP_in_primaryExpressionHelper14868 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_identifierLiteral_in_primaryExpressionHelper14874 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlPrimaryExpression_in_primaryExpressionHelper14885 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_parExpression_in_primaryExpressionHelper14895 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LT_in_primaryExpressionHelper14908 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000002000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_type_in_primaryExpressionHelper14912 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000010UL});
    public static readonly BitSet FOLLOW_GT_in_primaryExpressionHelper14916 = new BitSet(new ulong[]{0x8000000000000002UL});
    public static readonly BitSet FOLLOW_arrayLiteral_in_primaryExpressionHelper14921 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LCURLY_in_objectLiteral14946 = new BitSet(new ulong[]{0x13FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000005203UL});
    public static readonly BitSet FOLLOW_propertyNameAndValueList_in_objectLiteral14950 = new BitSet(new ulong[]{0x1000000000000000UL});
    public static readonly BitSet FOLLOW_RCURLY_in_objectLiteral14955 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_propertyNameAndValue_in_propertyNameAndValueList14998 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_COMMA_in_propertyNameAndValueList15022 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000005203UL});
    public static readonly BitSet FOLLOW_propertyNameAndValue_in_propertyNameAndValueList15026 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_propertyName_in_propertyNameAndValue15056 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000020000000UL});
    public static readonly BitSet FOLLOW_COLON_in_propertyNameAndValue15060 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_propertyNameAndValue15078 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_identifierLiteral_in_propertyName15097 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_stringLiteral_in_propertyName15108 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_numericLiteral_in_propertyName15119 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LBRACK_in_arrayLiteral15142 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033809UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_elementList_in_arrayLiteral15146 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000001UL});
    public static readonly BitSet FOLLOW_RBRACK_in_arrayLiteral15151 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_elementList15199 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_COMMA_in_elementList15219 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_elementList15236 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_COMMA_in_elementList15249 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_SUB_in_synpred9_AS3_ex3849 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_DOT_in_synpred9_AS3_ex3857 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_COLON_in_synpred9_AS3_ex3865 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_IDENTIFIER_in_synpred9_AS3_ex3876 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_allKeywords_in_synpred9_AS3_ex3882 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlTextElement_in_synpred68_AS3_ex4909 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlQualifiedIdentifier_in_synpred72_AS3_ex5058 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlQualifiedIdentifier_in_synpred73_AS3_ex5163 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlPropertySelector_in_synpred74_AS3_ex5178 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_conditionalCompilerOption_in_synpred96_AS3_ex6082 = new BitSet(new ulong[]{0x0800000000000000UL});
    public static readonly BitSet FOLLOW_LCURLY_in_synpred96_AS3_ex6090 = new BitSet(new ulong[]{0xBFFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_mxmlEmbedded_in_synpred96_AS3_ex6100 = new BitSet(new ulong[]{0x1000000000000000UL});
    public static readonly BitSet FOLLOW_RCURLY_in_synpred96_AS3_ex6109 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_propertyDeclaration_in_synpred97_AS3_ex6122 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_functionDeclaration_in_synpred98_AS3_ex6126 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_statement_in_synpred99_AS3_ex6130 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_directive_in_synpred100_AS3_ex6134 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_interfaceFunctionDeclaration_in_synpred101_AS3_ex6138 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_conditionalCompilerOption_in_synpred104_AS3_ex6181 = new BitSet(new ulong[]{0x0800000000000000UL});
    public static readonly BitSet FOLLOW_LCURLY_in_synpred104_AS3_ex6189 = new BitSet(new ulong[]{0xBFFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_packageElement_in_synpred104_AS3_ex6199 = new BitSet(new ulong[]{0xBFFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_RCURLY_in_synpred104_AS3_ex6214 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_classOrInterfaceDecl_in_synpred105_AS3_ex6229 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_propertyDeclaration_in_synpred106_AS3_ex6233 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_functionDeclaration_in_synpred107_AS3_ex6237 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_interfaceFunctionDeclaration_in_synpred108_AS3_ex6241 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_statement_in_synpred109_AS3_ex6245 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_SEMI_in_synpred123_AS3_ex6636 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_eitherIdentifier_in_synpred124_AS3_ex6700 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000040000000UL});
    public static readonly BitSet FOLLOW_ASSIGN_in_synpred124_AS3_ex6704 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_conditionalCompilerOption_in_synpred135_AS3_ex7092 = new BitSet(new ulong[]{0x0800000000000000UL});
    public static readonly BitSet FOLLOW_LCURLY_in_synpred135_AS3_ex7094 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_propertyDeclaration_in_synpred137_AS3_ex7159 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_functionDeclaration_in_synpred138_AS3_ex7163 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_statement_in_synpred139_AS3_ex7167 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_conditionalCompilerOption_in_synpred140_AS3_ex7186 = new BitSet(new ulong[]{0x0800000000000000UL});
    public static readonly BitSet FOLLOW_LCURLY_in_synpred140_AS3_ex7188 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_propertyDeclaration_in_synpred142_AS3_ex7254 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_interfaceFunctionDeclaration_in_synpred143_AS3_ex7258 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_statement_in_synpred144_AS3_ex7262 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_memberModifiers_in_synpred152_AS3_ex7413 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_statement_in_synpred167_AS3_ex7936 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_memberModifier_in_synpred169_AS3_ex8001 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_blockStatement_in_synpred179_AS3_ex8177 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_directive_in_synpred180_AS3_ex8188 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_namespaceDirective_in_synpred181_AS3_ex8199 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_constantVarStatement_in_synpred182_AS3_ex8212 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_tryStatement_in_synpred183_AS3_ex8225 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_switchStatement_in_synpred184_AS3_ex8237 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_withStatement_in_synpred185_AS3_ex8251 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_returnStatement_in_synpred186_AS3_ex8265 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_breakStatement_in_synpred187_AS3_ex8279 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_continueStatement_in_synpred188_AS3_ex8293 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_forStatement_in_synpred189_AS3_ex8310 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_forInStatement_in_synpred190_AS3_ex8327 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_forEachInStatement_in_synpred191_AS3_ex8344 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_doWhileStatement_in_synpred192_AS3_ex8361 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_whileStatement_in_synpred193_AS3_ex8378 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ifStatement_in_synpred194_AS3_ex8393 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_variableStatement_in_synpred195_AS3_ex8407 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_throwStatement_in_synpred196_AS3_ex8422 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_labelledStatement_in_synpred197_AS3_ex8438 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_expression_in_synpred198_AS3_ex8470 = new BitSet(new ulong[]{0x1400000000000000UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_semic_in_synpred198_AS3_ex8472 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_SEMI_in_synpred201_AS3_ex8651 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_catchClause_in_synpred205_AS3_ex8853 = new BitSet(new ulong[]{0x0000000000020080UL});
    public static readonly BitSet FOLLOW_finallyClause_in_synpred205_AS3_ex8856 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_catchClause_in_synpred207_AS3_ex8868 = new BitSet(new ulong[]{0x0000000000000082UL});
    public static readonly BitSet FOLLOW_statement_in_synpred209_AS3_ex9179 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_SEMI_in_synpred220_AS3_ex10102 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ELSE_in_synpred221_AS3_ex10447 = new BitSet(new ulong[]{0xAFFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_statement_in_synpred221_AS3_ex10535 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_COMMA_in_synpred236_AS3_ex11309 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_synpred236_AS3_ex11314 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_leftHandSideExpression_in_synpred238_AS3_ex11431 = new BitSet(new ulong[]{0x0000000000000000UL,0x000007CFC0002010UL});
    public static readonly BitSet FOLLOW_assignmentOperator_in_synpred238_AS3_ex11434 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_leftHandSideExpression_in_synpred239_AS3_ex11515 = new BitSet(new ulong[]{0x0000000000000000UL,0x000007CFC0002010UL});
    public static readonly BitSet FOLLOW_assignmentOperator_in_synpred239_AS3_ex11518 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_QUE_in_synpred255_AS3_ex11858 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_synpred255_AS3_ex11863 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000020000000UL});
    public static readonly BitSet FOLLOW_COLON_in_synpred255_AS3_ex11870 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_synpred255_AS3_ex11875 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LOR_in_synpred257_AS3_ex12012 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_logicalANDExpression_in_synpred257_AS3_ex12016 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LAND_in_synpred259_AS3_ex12142 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_bitwiseORExpression_in_synpred259_AS3_ex12146 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_OR_in_synpred261_AS3_ex12271 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_bitwiseXORExpression_in_synpred261_AS3_ex12275 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_XOR_in_synpred263_AS3_ex12399 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_bitwiseANDExpression_in_synpred263_AS3_ex12403 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_AND_in_synpred265_AS3_ex12523 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_equalityExpression_in_synpred265_AS3_ex12527 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_set_in_synpred270_AS3_ex12648 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_relationalExpression_in_synpred270_AS3_ex12660 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_GT_in_synpred282_AS3_ex12804 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000043033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_ASSIGN_in_synpred282_AS3_ex12809 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_set_in_synpred282_AS3_ex12842 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_shiftExpression_in_synpred282_AS3_ex12880 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_GT_in_synpred293_AS3_ex13191 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000010UL});
    public static readonly BitSet FOLLOW_GT_in_synpred293_AS3_ex13193 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000010UL});
    public static readonly BitSet FOLLOW_GT_in_synpred293_AS3_ex13195 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_SHL_in_synpred294_AS3_ex13115 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_GT_in_synpred294_AS3_ex13146 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000010UL});
    public static readonly BitSet FOLLOW_GT_in_synpred294_AS3_ex13150 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_GT_in_synpred294_AS3_ex13201 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000010UL});
    public static readonly BitSet FOLLOW_GT_in_synpred294_AS3_ex13205 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000010UL});
    public static readonly BitSet FOLLOW_GT_in_synpred294_AS3_ex13209 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_additiveExpression_in_synpred294_AS3_ex13256 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_set_in_synpred296_AS3_ex13314 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_multiplicativeExpression_in_synpred296_AS3_ex13322 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_set_in_synpred299_AS3_ex13377 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_unaryExpression_in_synpred299_AS3_ex13386 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_postfixExpression_in_synpred300_AS3_ex13421 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_set_in_synpred302_AS3_ex13432 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_unaryExpression_in_synpred302_AS3_ex13442 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_postfixOp_in_synpred311_AS3_ex13544 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_arguments_in_synpred315_AS3_ex13661 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LBRACK_in_synpred316_AS3_ex13673 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_expression_in_synpred316_AS3_ex13677 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000001UL});
    public static readonly BitSet FOLLOW_RBRACK_in_synpred316_AS3_ex13681 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_XML_ELLIPSIS_in_synpred317_AS3_ex13697 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0001000000002000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_eitherIdentifier_in_synpred317_AS3_ex13700 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DOT_in_synpred319_AS3_ex13714 = new BitSet(new ulong[]{0x23FFFFFFFFFFFFF0UL,0x0001000000002000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_eitherIdentifier_in_synpred319_AS3_ex13719 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_parExpression_in_synpred319_AS3_ex13725 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_typePostfixSyntax_in_synpred320_AS3_ex13738 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_XML_NS_OP_in_synpred321_AS3_ex13750 = new BitSet(new ulong[]{0xABFFFFFFFFFFFFF0UL,0x0003000003033808UL,0x0000000000075213UL});
    public static readonly BitSet FOLLOW_expression_in_synpred321_AS3_ex13754 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_IDENTIFIER_in_synpred322_AS3_ex13791 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlPropertyIdentifier_in_synpred323_AS3_ex13801 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_THIS_in_synpred385_AS3_ex14802 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_SUPER_in_synpred386_AS3_ex14816 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_literal_in_synpred387_AS3_ex14828 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_identifierLiteral_in_synpred390_AS3_ex14864 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000800000000000UL});
    public static readonly BitSet FOLLOW_XML_NS_OP_in_synpred390_AS3_ex14868 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_identifierLiteral_in_synpred391_AS3_ex14864 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000800000000000UL});
    public static readonly BitSet FOLLOW_XML_NS_OP_in_synpred391_AS3_ex14868 = new BitSet(new ulong[]{0x03FFFFFFFFFFFFF0UL,0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_identifierLiteral_in_synpred391_AS3_ex14874 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlPrimaryExpression_in_synpred392_AS3_ex14885 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_arrayLiteral_in_synpred394_AS3_ex14921 = new BitSet(new ulong[]{0x0000000000000002UL});

}
